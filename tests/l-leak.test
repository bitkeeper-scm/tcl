# Test the L language.
# Copyright (c) 2007 BitMover, Inc.

#
# Tests in this file look for leaks in L core; they are only functional in
# builds with -DTCL_MEM_DEBUG (--enable-symbols=mem or all)
#


if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
    testConstraint exec [llength [info commands exec]]
}

set haveMem [llength [info commands memory]]
testConstraint memory $haveMem

if {$haveMem} {
    proc getbytes {} {
	set lines [split [memory info] "\n"]
	lindex $lines 3 3
    }
    set lam [list {} {set a 1}]
}

test leak-1.1 {leaks in a simple L-loop} -body {
#lang L
    leak() {
	int tmp, end, i, j;

	end = getbytes();
	for(i=0; i<5;i++) {
	    j=i;
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j));
    }
    leak();
} -constraints memory -output "0 4\n"

test leak-1.2 {leaks in L-func called in a loop} -body {
#lang L
    int foo (int v) {
	int k;
	k = v;
	return k;
    }
    leak() {
	int tmp, end, i, j;

	end = getbytes();
	for(i=0; i<5;i++) {
	    j=foo(i);
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j));
    }
    leak();
} -constraints memory -output "0 4\n"

test leak-1.3 {leaks in L-func called in a tcl-loop} -body {
#lang L
    int foo (int v) {
	int k;
	k = v;
	return k;
    }
#lang tcl
    set end [getbytes]
    for {set i 0} {$i < 5} {incr i} {
	set j [foo $i]
	set tmp $end
	set end [getbytes]
    }
    puts [list [expr {$end - $tmp}] $j]
} -constraints memory -output "0 4\n"

test leak-2.0 {leaks in array reading} -body {
#lang L
    leak() {
	int tmp, end, i, j[2], k, l;
	j[0]=1;
	j[1]=2;

	end = getbytes();
	for(i=0; i<5;i++) {
	    k = j[0];
	    l = j[1];
            tmp=end;
	    end = getbytes();
	}
	puts(end-tmp);
    }
    leak();
} -constraints memory -output "0\n"

test leak-2.1 {leaks in array initializers} -body {
#lang L
    leak() {
	int tmp, end, i, k[2];

	end = getbytes();
	for(i=0; i<5;i++) {
	    int j[2];
            k = j;
            tmp=end;
	    end = getbytes();
	}
	puts(end-tmp);
    }
    leak();
} -constraints memory -output "0\n"

test leak-2.2 {leaks in arrays} -body {
#lang L
    leak() {
	int tmp, end, i, j[2];

	end = getbytes();
	for(i=0; i<5;i++) {
	    j[0]=i;
	    j[1]=2*j[0]+i;
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j));
    }
    leak();
} -constraints memory -output "0 {4 12}\n"

test leak-2.3 {leaks in arrays} -body {
#lang L
    int foo (int v) {
	int k[2];
	k[0] = v;
	k[1] = 2*k[0]+v;
	return k[1];
    }
    leak() {
	int tmp, end, i, j;

	end = getbytes();
	for(i=0; i<5;i++) {
	    j=foo(i);
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j));
    }
    leak();
} -constraints memory -output "0 12\n"

test leak-3.1 {leaks in hashes} -body {
#lang L
    leak() {
	int tmp, end, i;
	hash j;

	end = getbytes();
	for(i=0; i<5;i++) {
	    j{"0"}=i;
	    j{"1"}=2*(int)j{"0"}+i;
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j{"1"}));
    }
    leak();
} -constraints memory -output "0 12\n"

test leak-3.2 {leaks in hashes} -body {
#lang L
    hash foo (int v) {
	hash k;
	k{"0"} = v;
	k{"1"} = 2*(int)k{"0"}+v;
	return k;
    }
    leak() {
	int tmp, end, i;
        hash j;

	end = getbytes();
	for(i=0; i<5;i++) {
	    j=foo(i);
            tmp=end;
	    end = getbytes();
	}
	puts(list(end-tmp, j{"1"}));
    }
    leak();
} -constraints memory -output "0 12\n"




# cleanup
::tcltest::cleanupTests
return
