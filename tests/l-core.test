# Test the L language.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
    testConstraint exec [llength [info commands exec]]
}

test lfile-1.0 {Test autowrapping of empty .l file} -setup {
	set fname [makeFile {} lfile-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.0.l
} -result {}

test lfile-1.1 {Test autowrapping of .l works} -setup {
	set fname [makeFile {
		main() {
			printf("hi mom\n");
		}
	} lfile-1.1.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.1.l
} -result {hi mom}

# main shouldn't be automatically called if within an .l file we find
# the #lang L directive... right?
test lfile-1.2 {Test autowrapping doesn't wrap twice} -setup {
	set fname [makeFile {#lang L -nowarn
		main(int ac, string av[]) {
			printf("hi dad\n");
		}
	} lfile-1.2.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.2.l
} -result {}

test parse-1.0 {Test parsing an empty L script} -body {
#lang L
}

test parse-1.1 {Test parsing an L script that's just white space} -body {
#lang L
	


}

test parse-1.2 {Test parsing an empty L file} -setup {
	set fName [makeFile {} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.3 {Test parsing an L file that just has whitespace} -setup {
	set fName [makeFile {



	} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.3 {parse an L function named by a pattern} -body {
#lang L
poly Pattern_*(int a, ...rest)
{
	puts("${$1}${a}${rest}");
}
#lang tcl
} -result {}

test proc-1.0 {Test L function definition.} -body {
#lang L
main(void) {
        puts("foo");
}
#lang tcl
main  
} -output "foo\n"


test proc-1.1 {Test L function returns.} -body {
#lang L
f1() {
        puts("whiz");
}
f2() {
        puts("bang");
        return "foo";
        return "bar";
}
f3() {
        return;
}
main(void) {
        puts(f1());
        puts(f2());
        puts(f3());
}
#lang tcl
main  
} -output "whiz\n\nbang\nfoo\n\n"

test proc-1.2 {Test L function parameters.} -body {
#lang L
proc_1_2(string arg1, string arg2) {
        puts(arg1);
        puts(arg2);
} 
#lang tcl
proc_1_2 "val1" "val2" 
} -output "val1\nval2\n"

test proc-1.3 {Test variable arity functions} -body {
#lang L
proc_1_3() {
	foo("a", "b", "c", "d");
	foo();
	bar(1, 2, 3, 4);
	bar(1);
}
string foo(...stuff) {
	int i;
	for (i=0; defined(stuff[i]); i++) {
		printf("%s ", stuff[i]);
	}
	printf("\n");
}
string bar(int a, ...stuff) {
	puts(a);
	puts((tcl)stuff);
}
#lang tcl
proc_1_3
} -output "a b c d \n\n1\n2 3 4\n1\n\n"

test proc-1.4 {Ensure rest parameter comes last} -body {
#lang L -nowarn
proc_1_4(int a, ...b, int c) {
	puts("oops");
}
#lang tcl
proc_1_4
} -returnCodes {error} -result "L Error: Rest parameter must be last on line 1\n"


test var-1.0 {Test L variable assignment and reference} -body {
#lang L
var_1_0(void)
{
	string s;
        s = "Hello";
	puts(s);
}
#lang tcl
var_1_0
} -output "Hello\n"

test var-1.1 {L global variables} -body {
#lang L
int lglobal1_1 = 1;
var_1_1(void)
{
        puts(lglobal1_1);
}
#lang tcl
var_1_1
} -output "1\n"


test var-1.2 {L global variables, harder} -body {
#lang L
int lglobal1_2 = 3;
var_1_2(void)
{
        puts(lglobal1_2);
        lglobal1_2 = 4;
        var_1_2_aux();
        puts(lglobal1_2);
}

var_1_2_aux()
{
        puts(lglobal1_2);
        lglobal1_2 = 5;
}
#lang tcl
var_1_2
} -output "3\n4\n5\n"

test var-1.4 {Variable function names} -body {
#lang L
var_1_4() {
  string printfvar = "printf";
  printfvar("Earth calling printf\n");
}
#lang tcl
var_1_4
} -output "Earth calling printf\n"


test var-1.3 {A global array of structs} -body {
#lang L

struct var_1_3_point { int x, y; };
struct var_1_3_point lglobal1_3[5];

var_1_3(void)
{
        int i = 0;

        puts((tcl)lglobal1_3);
        while (i < 5) {
          lglobal1_3[i].x = i * 10;
          lglobal1_3[i].y = i * 20;
          i++;
        }
        puts((tcl)lglobal1_3);
        var_1_3_aux(3);
        puts((tcl)lglobal1_3);
}

var_1_3_aux(int i)
{
        lglobal1_3[i].x = i * 35;
        lglobal1_3[i].y = i * 45;
}
#lang tcl
var_1_3
} -output "{0 0} {0 0} {0 0} {0 0} {0 0}
{0 0} {10 20} {20 40} {30 60} {40 80}
{0 0} {10 20} {20 40} {105 135} {40 80}
"

test var-1.4 {Test extern variables} -body {
set tclvar "this is an extern variable"
#lang L
var_1_4()
{
	extern string tclvar;
	puts(tclvar);
}
#lang tcl
var_1_4
} -output "this is an extern variable\n"

test lang-1.0 {Test lang parsing} -body {
# These are some Tcl Comments
#lang L
main(void)
{
	puts("worked");
}

#lang tcl
# More comments
main
} -output "worked\n"

test lang-2.0 {Test failure path in lang parsing} -body {
#lang(foo)
main(void)
{
	puts("worked");
}

#lang tcl
main
} -returnCodes {error} -result {malformed pragma}

# no output because we're not calling any functions
test lang-3.0 {Test not switching back to Tcl} -body {
#lang L
main(void)
{
	puts("worked");
}
}

test decl-1.0 {Variable and parameter declaration syntax} -body {
#lang L -nowarn
fun1() { }
fun2(void) { }
void fun3() { }
int fun4() { }
fun5(int foo) { }
hash fun6(hash foo, hash bar[], hash baz[23]) { }
void fun7(int foo, float bar, hash baz, string quux, poly quuux, var quuuux) { }
void fun8() {
        int foo, bar[], baz[84][42][1];
        string foo1[19], mani[], padmi = "hum";
        hash whee;
        if (0) {
                int bleh = 5;
        } else {
                if (1) {
                        poly padmi1 = "om";
                        puts(padmi1);
                }
        }
}
#lang tcl
fun8
} -output "om\n";

test decl-1.1 {Hairy literal hash syntax in initializers} -body {
#lang L -nowarn
initmewoo() {
        hash h = { "key" => "val", "key2" => "val" };
}
#lang tcl
}

test decl-1.2 {Undeclared variable error} -body {
#lang L
undecl() {
        foo = "bar";
        puts(cheese);
}
#lang tcl
undecl
} -returnCodes error -result {L Error: Undeclared variable: foo on line 2
L Error: Undeclared variable: cheese on line 3
}


test decl-1.3 {Variable shadowing} -body {
#lang L
shadow() {
        int foo = 1;
        if (1) {
                int foo = 2;
                puts(foo);
        } 
        puts(foo);
}
#lang tcl
shadow
} -returnCodes error -result {L Error: Illegal redeclaration of local variable foo on line 4
}

test decl-1.4 {Single dimensional initializers actually initialize} -body {
#lang L
decl_1_4 () {
  int foo[] = {4, 5, 6};
  hash bar = {"foo" => 4, "bar" => 5, "baz" => 6};
  struct { int x; int y; } point = { 1024, 768 };

  printf("%s\n", (tcl)foo);
  printf("%s\n", (tcl)bar);
  printf("%s\n", point);
}
#lang tcl
decl_1_4
} -output "4 5 6\nfoo 4 bar 5 baz 6\n1024 768\n"

test if-1.0 {If statements} -body {
#lang L
if_1_0() {
        if (1) puts("0 working");
        if (0) {
                puts("1 broken");
        } 
        puts("between");
        if (1) {
                puts("1 working");
        } 
}
#lang tcl
if_1_0
} -output "0 working\nbetween\n1 working\n"


test if-1.1 {If statements with else clauses and multistatement bodies} -body {
#lang L
if_1_1() {
        if (1) {
                puts("1 working");
                puts(".");
        } else {
                puts("1 broken");
                puts(".");
        }
        
        if (0) {
                puts("2 broken");
                puts(".");
                puts(".");
        } else {
                puts("2 working");
                puts(".");
                puts(".");
        }
}
#lang tcl
if_1_1
} -output "1 working\n.\n2 working\n.\n.\n"


test if-1.2 {"else if" clauses} -body {
#lang L
if_1_2() {
        if (0) {
                puts("1 broken");
        } else if (1) {
                puts("1 working");
        }

        puts("between");

        if (0) {
                puts("2 broken");
        } else if (0) {
                puts("2.2 broken");
        } else {
                puts("2 working");
        }
}
#lang tcl
if_1_2
} -output "1 working\nbetween\n2 working\n"

test if-1.3 {nested if statements} -body {
#lang L
if_1_3() {
        if (1) {
                puts("1 before");
                if (0) {
                        puts("1 broken");
                } else {
                        puts("1 working");
                }
                puts("1 after");
        } else {
                puts("1.1 broken");
        }
        puts("1 done");
}
#lang tcl
if_1_3
} -output "1 before\n1 working\n1 after\n1 done\n"


test if-1.4 {else is only allowed with curly braces} -body {
#lang L
main(void)
{
	if (0) puts("1 broken"); else puts("1 even more broken");
}
#lang tcl
} -returnCodes error -match glob -result "L Error: *line 3\n"


test unless-1.0 {unless statements} -body {
#lang L
unless_1_0() {
        unless(0) puts("0 working");
        unless(0) {
                puts("1 working");
        }
        unless(1) {
                puts("2 broken");
        } else {
                puts("2 working");
        }
        unless(1) {
                puts("3 broken");
        } else unless (1) {
                puts("3.1 broken");
        } else {
                puts("3 working");
        }
} 
#lang tcl
unless_1_0
} -output "0 working\n1 working\n2 working\n3 working\n"

test unless-1.1 {unless and if statements mixed} -body {
#lang L
unless_1_1() {
        unless(1) {
                puts("1 broken");
        } else if (0) {
                puts("1.1 broken");
        } else unless(0) {
                puts("1 working");
        }
        puts("done");
} 
#lang tcl
unless_1_1
} -output "1 working\ndone\n"

test syntax-1.0 {single-line comments a la C++} -body {
#lang L
syntax_1_0() {
        // single-line comments are 
        puts("working"); //see?
        //////cruftilioucious 
}
#lang tcl
syntax_1_0
} -output "working\n" 


test syntax-1.1 {structure syntax} -body {
#lang L -nowarn

struct syntax_1_1_point {
        int x, y;
        string label;
        float froboz[128];
        struct { int m, n; } sub_struct;
};

syntax_1_1() {
        struct { string firstname; string lastname; } him;
        struct { string firstname; string lastname; } me = {"john", "doe"};
        struct syntax_1_1_point p1, p2 = {1, 2} , p3;
        puts("didn't crash");
}

#lang tcl
syntax_1_1
} -output "didn't crash\n"

test syntax-1.2 {interpolated strings} -body {
#lang L

syntax_1_2() {
        int i = 1, j = 2;
        string m = "ASDF";

        puts("syntax_${ i + j - 2 }_${j}.");
        puts("foo ${"bar ${m} baz"} zot");
}

#lang tcl
syntax_1_2
} -output "syntax_1_2.\nfoo bar ASDF baz zot\n"

test syntax-1.3 {keywords} -body {
#lang L
syntax_1_3() {
	printf("%s, %s, %s\n", foo : "bar", baz:);
}
#lang tcl
syntax_1_3
} -output "-foo, bar, -baz\n"

test syntax-1.4 {string appendation} -body {
#lang L
syntax_1_4() {
	printf("these" "strings"
	    "stick" "together.\n");
}
#lang tcl
syntax_1_4
} -output "thesestringssticktogether.\n"

test op-1.0 {increment and decrement operators} -body {
#lang L
op_1_0() {
        int i = 1;

        puts("pre:");
        puts(i);
        ++i;
        puts(i);
        puts(++i);
        --i;
        puts(i);
        puts(--i);

        puts("post:");
        puts(i);
        i++;
        puts(i);
        puts(i++);
        puts(i);
        i--;
        puts(i);
        puts(i--);
        puts(i);
}
#lang tcl
op_1_0
} -output "pre:\n1\n2\n3\n2\n1\npost:\n1\n2\n2\n3\n2\n2\n1\n"

test op-1.1 {plus, minus, multiply, divide, and modulus operators} -body {
#lang L
op_1_1() {
        int i = 2;
        puts(i + 5);
        puts(i - 50);
        puts(i * 500);
        puts(i / 2);
        puts(i / 4.0);
        puts((i + 5) % 3);
        // precedence
        puts(i + i / i - i * i % i);
}
#lang tcl
op_1_1
} -output "7\n-48\n1000\n1\n0.5\n1\n3\n"

test op-1.2 {unary plus and minus} -body {
#lang L
op_1_2() {
        int i = -2;
        int j = +2;

        puts(i);
        i = i + -100;
        puts(i);
        puts(i * -3);
        puts(-8 - -2);

        puts(j);
        j = j + +100;
        puts(j);
        puts(j * +3);
        puts(+8 - +2);
}
#lang tcl
op_1_2
} -output "-2\n-102\n306\n-6\n2\n102\n306\n6\n"

test op-1.3 {numeric comparison operators} -body {
#lang L
op_1_3() {
        if (-1 < 1) { puts("1okay"); } else { puts("1broken"); }
        if (1 > -1) { puts("2okay"); } else { puts("2broken"); }
        if (1 == 1) { puts("3okay"); } else { puts("3broken"); }
        if (1 <= 1) { puts("4okay"); } else { puts("4broken"); }
        if (-1 <= 1) { puts("5okay"); } else { puts("5broken"); }
        if (1 >= -1) { puts("6okay"); } else { puts("6broken"); }
        if (1 >= 0) { puts("7okay"); } else { puts("7broken"); }
        if (0 != 1) { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if (1 < 1) { puts("1broken"); } else { puts("1okay"); }
        if (1 > 1) { puts("2broken"); } else { puts("2okay"); }
        if (1 == 0) { puts("3broken"); } else { puts("3okay"); }
        if (1 != 1) { puts("4broken"); } else { puts("4okay"); }
        if (1 <= -1) { puts("5broken"); } else { puts("5okay"); }
        if (-1 >= 1) { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_3
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"

test op-1.4 {lexicographic comparison operators} -body {
#lang L
op_1_4() {
        if ("aa" lt "ab") { puts("1okay"); } else { puts("1broken"); }
        if ("ab" gt "aa") { puts("2okay"); } else { puts("2broken"); }
        if ("aa" eq "aa") { puts("3okay"); } else { puts("3broken"); }
        if ("aa" le "aa") { puts("4okay"); } else { puts("4broken"); }
        if ("aa" le "ab") { puts("5okay"); } else { puts("5broken"); }
        if ("aa" ge "aa") { puts("6okay"); } else { puts("6broken"); }
        if ("ab" ge "aa") { puts("7okay"); } else { puts("7broken"); }
        if ("aa" ne "ab") { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if ("aa" lt "aa") { puts("1broken"); } else { puts("1okay"); }
        if ("aa" gt "aa") { puts("2broken"); } else { puts("2okay"); }
        if ("ab" eq "aa") { puts("3broken"); } else { puts("3okay"); }
        if ("aa" ne "aa") { puts("4broken"); } else { puts("4okay"); }
        if ("ab" le "aa") { puts("5broken"); } else { puts("5okay"); }
        if ("aa" ge "ab") { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_4
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"


test op-1.5 {boolean operators} -body {
#lang L
op_1_5() {
        int true = 1, false = 0;
        if (true && true)       { puts("1okay"); } else { puts("1broken"); }
        if (!false)             { puts("2okay"); } else { puts("2broken"); }
        if (false || true)      { puts("3okay"); } else { puts("3broken"); }
        if (true && !false)     { puts("4okay"); } else { puts("4broken"); }
        // && has higher precedence than ||
        if (false && false || true) { puts("5okay"); } else { puts("5broken"); }
        // now from the other side
        puts("--");
        if (true && !true)      { puts("1broken"); } else { puts("1okay"); }
        if (false || false)     { puts("2broken"); } else { puts("2okay"); }
        if (!true)              { puts("3broken"); } else { puts("3okay"); }

}
#lang tcl
op_1_5
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n--\n1okay\n2okay\n3okay\n"


test op-1.6 {bitwise operators} -body {
#lang L
op_1_6(){
        int bits = 715827882;

        puts(bits << 1);
        puts(bits >> 1);
        puts(bits >> 29);
        puts(-1 << 10);
        puts(-1024 >> 9);
        puts(~bits);
        puts(bits & ~bits);
        puts(bits | ~bits);
        puts(bits ^ (bits + 1));

}
#lang tcl
op_1_6
} -output "1431655764\n357913941\n1\n-1024\n-2\n-715827883\n0\n-1\n1\n"


test op-1.7 {logical operator short-circuiting} -body {
#lang L
puts_int(string str) {
        puts(str);
        return 9;
}
op_1_7(){
        puts(0 && puts_int("1"));
        puts(1 && puts_int("2"));
        puts(0 || puts_int("3"));
        puts(1 || puts_int("4"));
}
#lang tcl
op_1_7
} -output "0\n2\n9\n3\n9\n1\n"

test op-1.8 {compound assignment operators, simple lvalues} -body {
#lang L
op_1_8() {
  int foo;

  puts(foo += 2);
  puts(foo);
  puts(foo -= 3);
  puts(foo);
  puts(foo *= 4);
  puts(foo);
  puts(foo /= -2);
  puts(foo);
  foo = 17;
  puts(foo %= 7);
  puts(foo);
  puts(foo |= 9);
  puts(foo);
  puts(foo &= 8);
  puts(foo);
  puts(foo ^= 9);
  puts(foo);
  puts(foo <<= 3);
  puts(foo);
  puts(foo >>= 2);
  puts(foo);
}
#lang tcl
op_1_8
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n"

test op-1.9 {compound assignment operators, array lvalues} -body {
#lang L
op_1_9() {
  int foo[4];

  puts(foo[2] += 2);
  puts(foo[2]);
  puts(foo[2] -= 3);
  puts(foo[2]);
  puts(foo[2] *= 4);
  puts(foo[2]);
  puts(foo[2] /= -2);
  puts(foo[2]);
  foo[2] = 17;
  puts(foo[2] %= 7);
  puts(foo[2]);
  puts(foo[2] |= 9);
  puts(foo[2]);
  puts(foo[2] &= 8);
  puts(foo[2]);
  puts(foo[2] ^= 9);
  puts(foo[2]);
  puts(foo[2] <<= 3);
  puts(foo[2]);
  puts(foo[2] >>= 2);
  puts(foo[2]);
  puts((tcl)foo);
}
#lang tcl
op_1_9
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n0 0 2 0\n"

test cast-1.0 { Casts to integer and float } -body {
#lang L
cast_1_0() {
    printf("%d\n", (int)1.9);
    printf("%f\n", (float)5);
}
#lang tcl
cast_1_0
} -output "1\n5.000000\n"

test cast-1.1 { Invalid cast from string to int } -body {
#lang L
cast_1_1() {
    printf("%d\n", (int)"asdf");
}
#lang tcl
cast_1_1
} -returnCodes {error} -result {expected number but got "asdf"}

test cast-1.2 { Invalid cast from string to float } -body {
#lang L
cast_1_2() {
    printf("%f\n", (float)"asdf");
}
#lang tcl
cast_1_2
} -returnCodes {error} -result {expected floating-point number but got "asdf"}

test array-1.0 { Single-dimensional array creation and indexing } -body {
#lang L
array_1_0() {
    int array[3];

    array[0] = 1;
    array[1] = 2;
    array[2] = 3;
    puts(array[2]);
}
#lang tcl
array_1_0
} -output "3\n"

test array-1.1 { Multi-dimensional array creation and indexing } -body {
#lang L
array_1_0() {
    int array[4][3][2];

    puts((tcl)array);
    array[0][0][0] = 1;
    array[1][1][1] = 2;
    array[2][2][0] = 3;
    array[3][0][1] = 4;
    puts((tcl)array);
}
#lang tcl
array_1_0
} -output "{{0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0}}
{{1 0} {0 0} {0 0}} {{0 0} {0 2} {0 0}} {{0 0} {0 0} {3 0}} {{0 4} {0 0} {0 0}}\n"


test array-1.2 {increment and decrement on array elements} -body {
#lang L
array_1_2() {
  int foo[5];

  foo[3] = 0;
  for (foo[3]=0; foo[3]<5; foo[3]++);
  puts((tcl)foo);

  puts("pre:");
  puts(foo[3]);
  ++foo[3];
  puts(foo[3]);
  puts(++foo[3]);
  --foo[3];
  puts(foo[3]);
  puts(--foo[3]);

  puts("post:");
  puts(foo[3]);
  foo[3]++;
  puts(foo[3]);
  puts(foo[3]++);
  puts(foo[3]);
  foo[3]--;
  puts(foo[3]);
  puts(foo[3]--);
  puts(foo[3]);
  puts((tcl)foo);
}
#lang tcl
array_1_2
} -output "0 0 0 5 0\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n0 0 0 5 0\n"

test array_1_3 {1d arrays with no length auto-extend by one at a time} -body {
#lang L
array_1_3() {
  int foo[];

  foo[0] = 4;
  foo[1] = 5;
  foo[2] = 6;
  puts((tcl)foo);
}
#lang tcl
array_1_3
} -output "4 5 6\n"

test array_1_4 {extend arrays using push and pop} -body {
#lang L
array_1_4() {
  int foo[];

  push(foo, 1);
  push(foo, 2);
  push(foo, 3);
  puts((tcl)foo);
  puts(pop(foo));
  puts((tcl)foo);
  puts(pop(foo));
  puts((tcl)foo);
  puts(pop(foo));
  puts((tcl)foo);
  puts(pop(foo));
  puts((tcl)foo);
} 
#lang tcl
array_1_4
} -output "1 2 3\n3\n1 2\n2\n1\n1\n\n\n\n"


test array_1_3 {1d arrays with no length auto-extend by one at a time} -body {
#lang L
array_1_3() {
  int foo[];

  foo[0] = 4;
  foo[1] = 5;
  foo[2] = 6;
  puts((tcl)foo);
}
#lang tcl
array_1_3
} -output "4 5 6\n"


test loop-1.0 {while loops} -body {
#lang L
loop_1_0() {
        int i = 0;
        while (i++ < 5) puts (i);
        while (i) {
                int j = i--;
                puts(j);
        }
}
#lang tcl
loop_1_0
} -output "1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\n"
test loop-1.1 {for loops} -body {
#lang L
loop_1_1() {
        int i;
        for (i=1; i<7; i++) {
                puts(i);
        }
        puts("-*-");
        for ( ; i; i--) {
                puts(i);
        }
}
#lang tcl
loop_1_1
} -output "1\n2\n3\n4\n5\n6\n-*-\n7\n6\n5\n4\n3\n2\n1\n"

test loop-1.2 {foreach loops} -body {
#lang L
loop_1_2() {
	hash h, empty;
	string k, v;

	h{"a"} = 1;
	h{"b"} = 2;
	h{"c"} = 3;
	foreach (h as k => v) {
		printf("key is %s, value is %s\n", k, v);
	}
	foreach (empty as k => v) {
		printf("key is %s, value is %s\n", k, v);
	}
	foreach (k in h) {
		printf("key is %s\n", k);
	}
	foreach (k in empty) {
		printf("key is %s\n", k);
	}
}
#lang tcl
loop_1_2
} -output "key is a, value is 1
key is b, value is 2
key is c, value is 3
key is a
key is b
key is c
"

test loop-1.3 {continue statements} -body {
#lang L
loop_1_3() {
  loop_1_3_for_continue();
  loop_1_3_foreach_continue();
}

loop_1_3_for_continue() {
  int i;

  for (i=0; i<5; i++) {
    if (i == 2) {
      continue;
    }
    puts(i);
  }
}

loop_1_3_foreach_continue() {
  hash h;
  string k, v;

  h{"a"} = "x";
  h{"b"} = "y";
  h{"c"} = "z";
  foreach (h as k => v) {
    if (k == "b") {
      continue;
    }
    printf("%s => %s\n", k, v);
  }
}
#lang tcl
loop_1_3
} -output {0
1
3
4
a => x
c => z
}

test loop-1.4 {break statements} -body {
#lang L
loop_1_4() {
  loop_1_4_foreach_break();
  loop_1_4_for_break();
}

loop_1_4_foreach_break() {
  hash h;
  string k, v, l;

  h{"a"} = "x";
  h{"b"} = "y";
  h{"c"} = "z";
  foreach (l in h) {
    foreach (h as k => v) {
      if (k == "b") {
        break;
      }
    }
  }
  printf("loop's over, k is %s, v is %s\n", k, v);
}

loop_1_4_for_break() {
  int i;

  for (i=0; i<10; i++) {
    puts(i);
    if (i == 5) {
      puts("attempting to break");
      break;
    }
  }
  printf("at the end of the day, i is %d\n", i);
}
#lang tcl
loop_1_4
} -output {loop's over, k is b, v is y
0
1
2
3
4
5
attempting to break
at the end of the day, i is 5
}



test struct-1.0 {structs} -body {
#lang L
struct struct_1_0_point {
        int x, y;
        string label;
};

struct_1_0() {
        struct struct_1_0_point p1, p2;

        p1.x = 1;
        p1.y = 2;
        p1.label = "this is a label";
        puts("p1 is:");
        puts(p1);
        puts(format("p1.x is %d, p1.y is %d, and p1.label is %s", p1.x, p1.y, p1.label));
        p2 = p1;
        p2.label = "this is another label";
        puts("p1 is:");
        puts(p1);
        puts("p2 is:");
        puts(p2);
}
#lang tcl
struct_1_0
} -output "p1 is:
1 2 {this is a label}
p1.x is 1, p1.y is 2, and p1.label is this is a label
p1 is:
1 2 {this is a label}
p2 is:
1 2 {this is another label}
"

test struct-1.1 {struct allocation and arrays of structs} -body {
#lang L
struct struct_1_1_point {
        int x, y;
        string label;
};

struct_1_1() {
   int i = 0;
   struct struct_1_1_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_1
} -output "42 0 {10 cows}
43 1 {9 cows}
44 2 {8 cows}
45 3 {7 cows}
46 4 {6 cows}
47 5 {5 cows}
48 6 {4 cows}
49 7 {3 cows}
50 8 {2 cows}
51 9 {1 cows}
"

test struct-1.2 {arrays of structs containing arrays} -body {
#lang L
struct struct_1_2_point {
        int x, y;
        string label;
  int z[4];
};

struct_1_2() {
   int i = 0;
   struct struct_1_2_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      s[i].z[i%4] = i;
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_2
} -output "42 0 {10 cows} {0 0 0 0}
43 1 {9 cows} {0 1 0 0}
44 2 {8 cows} {0 0 2 0}
45 3 {7 cows} {0 0 0 3}
46 4 {6 cows} {4 0 0 0}
47 5 {5 cows} {0 5 0 0}
48 6 {4 cows} {0 0 6 0}
49 7 {3 cows} {0 0 0 7}
50 8 {2 cows} {8 0 0 0}
51 9 {1 cows} {0 9 0 0}
"

test struct-1.3 {increment and decrement on struct fields} -body {
#lang L
struct foo {
  int i;
};

struct_1_3() {
  struct foo v;

  v.i = 0;
  for (v.i=0; v.i<5; v.i++);
  puts(v);

  puts("pre:");
  puts(v.i);
  ++v.i;
  puts(v.i);
  puts(++v.i);
  --v.i;
  puts(v.i);
  puts(--v.i);

  puts("post:");
  puts(v.i);
  v.i++;
  puts(v.i);
  puts(v.i++);
  puts(v.i);
  v.i--;
  puts(v.i);
  puts(v.i--);
  puts(v.i);
}
#lang tcl
struct_1_3
} -output "5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n"


test hash-1.0 {basic hashtable support} -body {
#lang L
void hash_1_0() {
  hash foo;
  foo{"key"} = "value";
  puts(foo{"key"});
}
#lang tcl
hash_1_0
} -output "value\n"

test hash-1.1 {array of hashtables} -body {
#lang L
void hash_1_1() {
  hash foo[10];
  foo[5]{"key"} = "value";
  foo[4]{"key"} = "";
  puts(foo[5]{"key"});
  puts(foo[4]{"key"});
}
#lang tcl
hash_1_1
} -output "value\n\n"

test hash-1.2 {increment and decrement on hash elements} -body {
#lang L -poly
hash_1_2() {
  hash foo;

  foo{"three"} = 0;
  for (foo{"three"}=0; foo{"three"}<5; foo{"three"}++);
  puts((tcl)foo);

  puts("pre:");
  puts(foo{"three"});
  ++foo{"three"};
  puts(foo{"three"});
  puts(++foo{"three"});
  --foo{"three"};
  puts(foo{"three"});
  puts(--foo{"three"});

  puts("post:");
  puts(foo{"three"});
  foo{"three"}++;
  puts(foo{"three"});
  puts(foo{"three"}++);
  puts(foo{"three"});
  foo{"three"}--;
  puts(foo{"three"});
  puts(foo{"three"}--);
  puts(foo{"three"});
  puts((tcl)foo);
}
#lang tcl
hash_1_2
} -output "three 5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\nthree 5\n"

test hash-1.3 {a hash inside of an array inside a struct} -body {
#lang L -poly
hash_1_3() {
	struct { int foo; hash bar[4][5]; } baz;

  	baz.foo = 2;
	baz.bar[3][4]{"asdf"} = 9;
	baz.bar[3][4]{"asdf"} *= 2;
	puts(baz.bar[3][4]{"asdf"}--);
	puts(baz);
}
#lang tcl
hash_1_3
} -output "18\n2 {{{} {} {} {} {}} {{} {} {} {} {}} {{} {} {} {} {}} {{} {} {} {} {asdf 17}}}\n"


test regexp-1.0 {regular expression support} -body {
#lang L
void regexp_1_0() {
        string s = "string";
        puts(s =~ /ring/);
        puts(s =~ /bob/);
}
#lang tcl
regexp_1_0
} -output "1\n0\n"

test regexp-1.1 {magic submatch variables ($1, $2, ...)} -body {
#lang L
void regexp_1_1() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";

        if (s =~ /((Go).*(elves)).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_1
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"


test regexp-1.2 {magic submatch variables with interpolation} -body {
#lang L
void regexp_1_2() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";
        string interp = "elves";

        if (s =~ /((Go).*(${interp})).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_2
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"

test regexp-1.3 {regexp substitution} -body {
#lang L -poly
regexp_1_3() {
        string s = "string";
	string s1[] = {"a", "b", "coochie"};
	hash h[2];

        puts(s =~ m/ring/);
        puts(s =~ m|bob|);
	puts("--------");
	puts(s =~ s/ring/ling/);
	puts(s);
	puts("--------");
	puts(s1[2] =~ s/c/f/);
	puts((tcl)s1);
	puts("--------");
	h[0]{"a"} = "string";
	h[1]{"m"} = "not a string";
	puts((tcl)h);
	h[1]{"m"} =~ s/not a/probably a/;
	puts((tcl)h);
}
#lang tcl
regexp_1_3
} -output "1\n0\n--------\n1\nstling\n--------\n1\na b foochie\n--------\n{a string} {m {not a string}}\n{a string} {m {probably a string}}\n"

test regexp-1.4 {regexp modifiers i and g} -body {
#lang L -poly
regexp_1_4() {
	string foo = "aaa";
	foo =~ s/a/b/;
	puts(foo);
	foo =~ s/a/b/g;
	puts(foo);
	foo =~ s/B/a/;
	puts(foo);
	foo =~ s/B/a/i;
	puts(foo);
	foo =~ s/B/a/ig;
	puts(foo);
	if (foo =~ /A/) {
		puts("busted");
	}
	if (foo =~ /A/i) {
		puts("works");
	}
}
#lang tcl
regexp_1_4
} -output "baa\nbbb\nbbb\nabb\naaa\nworks\n"

test reference-1.0 {L references} -body {
#lang L -nowarn
reference_1_0() {
  string foo = "this is a string";
  printf("so far, so good: %s\n", foo);
  reference_1_0_aux("bleh", &foo);
  printf("%s\n", foo);
}

reference_1_0_aux(string dummy, string &bob) {
  printf("foot: %s\n", bob);
  bob = "This was a string.";
}
#lang tcl
reference_1_0
} -output "so far, so good: this is a string
foot: this is a string
This was a string.
"

test reference-1.1 {L references} -body {
#lang L
struct reference_1_1_point { int x, y; };

reference_1_1() {
  struct reference_1_1_point a;
  puts(a);
  reference_1_1_tweak(&a);
  puts(a);
}

reference_1_1_tweak(struct reference_1_1_point &foo) {
  foo.x = 2;
}
#lang tcl
reference_1_1
} -output "0 0
2 0
"
test reference-1.2 {widget pointer thingys} -body {
#lang L
int
reference_1_2()
{
	int	a;

	a = 5;
	printf("%s %s\n", variable: &a);
	eval("puts [set ::Lptr::[list 1 a]]");
}
#lang tcl
reference_1_2
} -output "-variable ::Lptr::1 a\n5\n"

test reference-1.3 {widget pointers via the Lptr namespace} -body {
#lang L
reference_1_3()
{
  int reference_1_3_foo = 0;
  printf("%s, %s\n", variable: &reference_1_3_foo);
  eval("set {::Lptr::1 reference_1_3_foo} 93");
  puts(reference_1_3_foo);
}
#lang tcl
reference_1_3
} -output "-variable, ::Lptr::1 reference_1_3_foo\n93\n"

test typedef-1.0 {basic typedef support} -body {
#lang L
typedef int typedef_1_0_foot[5];
typedef string typedef_1_0_nike;
typedef struct typedef_1_0_point {
  int x;
  int y;
} typedef_1_0_point;

typedef_1_0() {
  puts(typedef_1_0_aux());
}

typedef_1_0_nike typedef_1_0_aux() {
  typedef_1_0_foot cheese;
  typedef_1_0_nike shoe = "pegasus";
  typedef_1_0_point p;

  p.x = 1;
  p.y = 2;
  puts(p);
  cheese[2] = 1;
  cheese[3] = 2;
  cheese[4] = 3;
  puts(cheese[3]);
  puts(shoe);
  return shoe;
}
#lang tcl
typedef_1_0
} -output "1 2\n2\npegasus\npegasus\n"

test defined-1.0 {interesting defined form support} -body {
#lang L
defined_1_0() {
  int arr[5][2], i, j;
  for (i = 0; defined(arr[i]); i++) {
    for (j = 0; defined(arr[i][j]); j++) {
      puts(format("%d, %d", i, j));
    }
  }
  puts("-*-");
  puts(defined(arr[3]));
  puts(defined(arr[-1]));
}
#lang tcl
defined_1_0
} -output "0, 0
0, 1
1, 0
1, 1
2, 0
2, 1
3, 0
3, 1
4, 0
4, 1
-*-
1
0
"

test defined-1.1 {defined works on hashes} -body {
#lang L
defined_1_1() {
	hash foo[5];

	foo[2]{"a"} = 1;
	foo[3]{"b"} = 2;
	
	if (defined(foo[2]{"a"})) {
		puts("defined works");
	}
	if (!defined(foo[2]{"b"})) {
		puts("defined works even better");
	}
}
#lang tcl
defined_1_1
} -output "defined works\ndefined works even better\n"

test main-1.0 {test that main gets called} -setup {
	set fname [makeFile {
		main() {
			printf("main got called\n");
		}
	} test-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile test-1.0.l
} -result {main got called}


test lib-1.0 {L library functions -- setenv, getenv, and unsetenv} -body {
#lang L
lib_1_0() {
	puts("don't overwrite");
	setenv("PATH", "nil", 0);
	if (getenv("PATH") != "nil") {
		puts("worked");
	}
	puts("overwrite");
	setenv("PATH", "nil", 1);
	if (getenv("PATH") == "nil") {
		puts("worked");
	}
	puts("unset");
	unsetenv("PATH");
	if (!getenv("PATH")) {
		puts("worked");
	}
}
#lang tcl
lib_1_0
} -output {don't overwrite
worked
overwrite
worked
unset
worked
}

test toplevel-1.0 {Toplevel code in L} -body {
#lang L
int toplevel_1_0_i = 2;
printf("at the toplevel, i is: %d\n", toplevel_1_0_i);

toplevel_1_0(void) {
  printf("in toplevel_1_0, i is: %d\n", toplevel_1_0_i);
}
#lang tcl
toplevel_1_0
} -output {at the toplevel, i is: 2
in toplevel_1_0, i is: 2
}

test toplevel-1.1 {Toplevel code via the L command, sharing variables} -body {
L { puts("Accent on helpful side of your nature.  Drain the moat."); }
proc toplevel_1_1 {} {
    set v 2
    L {
        string v = "Sphenic numbers always have exactly eight divisors.";
    }
    puts $v
}
toplevel_1_1
} -output {Accent on helpful side of your nature.  Drain the moat.
Sphenic numbers always have exactly eight divisors.
}

test typecheck-1.0 {L typechecking} -body {
#lang L
typecheck_1_0() {
	puts(typecheck_1_0_foo() + 22);
}

string typecheck_1_0_foo() {
	return "string";
}
#lang tcl
typecheck_1_0
} -returnCodes {error} \
-result "L Error: type error, want L_TYPE_NUMBER, got L_TYPE_STRING on line 2\n"

test typecheck-1.1 {arity check} -body {
#lang L -nowarn
typecheck_1_1() {
	foo(1, 2, 3);
	bar();
}
foo() {}
bar(int a, int b) {}
#lang tcl
} -returnCodes {error} \
-result "L Error: Not enough arguments for function bar on line 3
L Error: Too many arguments for function foo on line 2\n"

test backtrace-1.0 {backtracing in L} -setup {
	set fname [makeFile {
foo()
{
	puts("foo", "bar");
}

bar()
{
	foo();
}

int
main(int ac, string av[])
{
	bar();
}

	} backtrace-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.0.l
} -returnCodes {error} -match regexp -result {.*line 4.*line 9.*line 15}

test pattern-1.0 {L pattern functions} -body {
#lang L
poly Pattern_foo(int a, int b)
{
	puts("Pattern_foo special case ${a} ${b}");
}
poly Pattern_*(int a, int b)
{
	puts("Pattern_* ${$1} ${a} ${b}");
}
Pattern_foo(1, 2);
Pattern_bar(3, 4);
Pattern_baz(5, 6);
#lang tcl
} -output "Pattern_foo special case 1 2\nPattern_* bar 3 4\nPattern_* baz 5 6\n"


# cleanup
::tcltest::cleanupTests
return
