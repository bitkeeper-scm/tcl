# Test the L language.
# Copyright (c) 2007-2009 BitMover, Inc.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
    testConstraint exec [llength [info commands exec]]
}

test lfile-1.0 {Test autowrapping of empty .l file} -setup {
	set fname [makeFile {} lfile-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.0.l
} -result {}

test lfile-1.1 {Test autowrapping of .l works} -setup {
	set fname [makeFile {
		void main() {
			printf("hi mom\n");
		}
	} lfile-1.1.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.1.l
} -result {hi mom}

# main shouldn't be automatically called if within an .l file we find
# the #lang L directive... right?
test lfile-1.2 {Test autowrapping doesn't wrap twice} -setup {
	set fname [makeFile {#lang L -nowarn
		void main() {
			printf("hi dad\n");
		}
	} lfile-1.2.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.2.l
} -result {}

test lfile-1.3 {Test .l mapping via source command} -setup {
	set fname [makeFile {printf("hello there");} lfile-1.3.l]
} -body {
	source $fname
} -cleanup {
	removeFile lfile-1.3.l
} -output {hello there}

test parse-1.0 {Test parsing an empty L script} -body {
#lang L
}

test parse-1.1 {Test parsing an L script that's just white space} -body {
#lang L
	


}

test opts-1 {test command options 1} -body {
#lang L -nowarn
void opts_1()
{
	int	not_used;  // not used warning should be suppressed
	printf("good");
}
opts_1();
} -output {good}

test opts-2 {test command options 2} -body {
#lang L --nowarn
void opts_2()
{
	int	not_used;  // not used warning should be suppressed
	printf("good");
}
opts_2();
} -output {good}

test opts-3 {test command options 3} -body {
#lang L -n
void opts_3()
{
	int	not_used;  // not used warning should be suppressed
	printf("good");
}
opts_3();
} -output {good}

test opts-4 {test command options 4} -body {
#lang L -poly
void opts_4()
{
	string	s = "3";
	printf("%d", s+1);  // would be an err w/o the -poly
}
opts_4();
} -output {4}

test opts-5 {test command options 5} -body {
#lang L --poly
void opts_5()
{
	string	s = "3";
	printf("%d", s+1);  // would be an err w/o the --poly
}
opts_5();
} -output {4}

test opts-6 {test command options 6} -body {
#lang L -P
void opts_6()
{
	string	s = "3";
	printf("%d", s+1);  // would be an err w/o the -P
}
opts_6();
} -output {4}

test opts-7 {test -nowarn command-line option} -setup {
	set file [makeFile {
			private void f() {
				int not_used;
				puts("good");
			}
			f();
		  } opts7.l .]
} -constraints {
	exec
} -body {
	# The script created above should not compile and run unless
	# the command-line options are handled correctly.
	set s1 [exec [interpreter] -nowarn $file]
	set s2 [exec [interpreter] --nowarn $file]
	set s3 [exec [interpreter] -n $file]
	puts $s1
	puts $s2
	puts $s3
} -cleanup {
	removeFile $file
} -output "good\ngood\ngood\n"

test opts-8 {test -poly command-line option} -setup {
	set file [makeFile {
			private void f() {
				string s = "3";
				printf("%d\n", s+1);
			}
			f();
		  } opts8.l .]
} -constraints {
	exec
} -body {
	# The script created above should not compile and run unless
	# the command-line options are handled correctly.
	set s1 [exec [interpreter] -poly $file]
	set s2 [exec [interpreter] --poly $file]
	set s3 [exec [interpreter] -P $file]
	puts $s1
	puts $s2
	puts $s3
} -cleanup {
	removeFile $file
} -output "4\n4\n4\n"

test opts-9 {test multiple command-line options} -setup {
	set file [makeFile {
			private void f() {
				int	not_used;
				string	s = "3";
				printf("%d\n", s+1);
			}
			f();
		  } opts9.l .]
} -constraints {
	exec
} -body {
	# The script created above should not compile and run unless
	# the command-line options are handled correctly.
	set s1 [exec [interpreter] -poly -nowarn $file]
	set s2 [exec [interpreter] --poly --nowarn $file]
	set s3 [exec [interpreter] -P -n $file]
	puts $s1
	puts $s2
	puts $s3
} -cleanup {
	removeFile $file
} -output "4\n4\n4\n"

test opts-10 {test multiple command-line options with app args} -setup {
	set file [makeFile {
			void main(int ac, string av[]) {
				int	i;
				string	s;
				for (i = 1; i < ac; ++i) s .= av[i];
				puts(s);
			}
		  } opts10.l .]
} -constraints {
	exec
} -body {
	# Check the application arguments are correctly passed to the L
	# main() even in the presence of tclsh command-line args.
	set s1 [exec [interpreter] $file]
	set s2 [exec [interpreter] $file arg1]
	set s3 [exec [interpreter] $file arg1 arg2]
	set s4 [exec [interpreter] -nowarn $file]
	set s5 [exec [interpreter] -nowarn $file arg1]
	set s6 [exec [interpreter] -nowarn $file arg1 arg2]
	set s7 [exec [interpreter] -nowarn -poly $file]
	set s8 [exec [interpreter] -nowarn -poly $file arg1]
	set s9 [exec [interpreter] -nowarn -poly $file arg1 arg2]
	puts $s1
	puts $s2
	puts $s3
	puts $s4
	puts $s5
	puts $s6
	puts $s7
	puts $s8
	puts $s9
} -cleanup {
	removeFile $file
} -output "\narg1\narg1arg2\n\narg1\narg1arg2\n\narg1\narg1arg2\n"

test parse-1.2 {Test parsing an empty L file} -setup {
	set fName [makeFile {} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.3 {Test parsing an L file that just has whitespace} -setup {
	set fName [makeFile {



	} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.4 {parse an L function named by a pattern} -body {
#lang L
poly Parse14Pattern_*(int a, ...rest)
{
	puts("${$1}${a}${rest}");
}
#lang tcl
} -result {}

test parse-1.5 {test handling of illegal character} -body {
#lang L
@
} -returnCodes error -match regexp -result {.*1: L Error: illegal character '\@'
}

test scan-1.1 {test detection of run-away string 1} -body {
#lang L
void scan_1_1()
{
	string	s = "This is bad
	and should be an error";
	puts(s);
}
} -returnCodes {error} -match regexp -result {.*missing string terminator \"\n}

test scan-1.2 {test detection of run-away string 2} -body {
#lang L
void scan_1_2()
{
	string	s = "This is bad
}
#"
} -returnCodes {error} -match regexp -result {.*missing string terminator \"\n}

test scan-1.3 {test detection of run-away string 3} -body {
#lang L
void scan_1_3()
{
	string	s = 'This is bad
	and should be an error';
	puts(s);
}
} -returnCodes {error} -match regexp -result {.*missing string terminator \'\n}

test scan-1.4 {test detection of run-away string 4} -body {
#lang L
void scan_1_4()
{
	string	s = 'This is bad
}
#'
} -returnCodes {error} -match regexp -result {.*missing string terminator \'\n}

test scan-1.4.2 {test detection of run-away string 5} -body {
#lang L
void scan_1_4_2()
{
	string	s = `echo this is bad
}
} -returnCodes {error} -match regexp -result {.*missing string terminator `\n}

test scan-1.4.3 {test detection of run-away string 5} -body {
#lang L
void scan_1_4_3()
{
	string	s = `echo this is bad
>foo`;
}
} -returnCodes {error} -match regexp -result {.*missing string terminator `\n}

test scan-1.5 {check escapes in single-quoted strings} -body {
#lang L
void scan_1_5()
{
	string	s;

	s = '\a\t\n\001';
	unless (length(s) == 10) puts("bad 1.0");
	unless ((s[0] eq "\\") && (s[1] eq "a")) puts("bad 1.1");
	unless ((s[2] eq "\\") && (s[3] eq "t")) puts("bad 1.2");
	unless ((s[4] eq "\\") && (s[5] eq "n")) puts("bad 1.3");
	unless ((s[6] eq "\\") && (s[7] eq "0")) puts("bad 1.4");
	unless ((s[8] eq "0")  && (s[9] eq "1")) puts("bad 1.5");

	s = '\\\'';
	unless (length(s) == 2) puts("bad 2.0");
	unless ((s[0] eq "\\") && (s[1] eq "'")) puts("bad 2.1");

	/*
	 * The following test doesn't work unless run from the
	 * command line.  Perhaps tcltest is munging the string.  ?
	s = 'line\
break';
	unless (s eq "line\nbreak") puts("bad 3.1");
	*/
}
scan_1_5();
} -output {}

test scan-1.6 {check escapes in double-quoted strings} -body {
#lang L
void scan_1_6()
{
	string	s;

	s = "\a\t\n\r\\\"";
	unless (length(s) == 6) puts("bad 1.0");
	unless ((s[0] eq "a")  && (s[1] eq "\t")) puts("bad 1.1");
	unless ((s[2] eq "\n") && (s[3] eq "\r")) puts("bad 1.2");
	unless ((s[4] eq "\\") && (s[5] eq "\"")) puts("bad 1.3");

	/*
	 * The following test doesn't work unless run from the
	 * command line.  Perhaps tcltest is munging the string.  ?
	s = "line\
break";
	unless (s eq "line\nbreak") puts("bad 2.1");
	*/
}
scan_1_6();
} -output {}

test scan-1.7 {test here documents 1} -body {
#lang L
void scan_1_7()
{
	/* Vary the whitespace. */

	string	s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11;

	s1 = <<'E'
str1
E
	unless (s1 eq "str1\n") puts("bad 1");

	s2 = <<'EN'
str2
EN
	unless (s2 eq "str2\n") puts("bad 2");

	s3 = <<'END'
str3
END
	unless (s3 eq "str3\n") puts("bad 3");

	s4 =<<'END'
str4
END
	unless (s4 eq "str4\n") puts("bad 4");

	s5 =  <<'END'
str5
END
	unless (s5 eq "str5\n") puts("bad 5");

	s6 =	<<'END'
str6
END
	unless (s6 eq "str6\n") puts("bad 6");

	s7 =	 <<'END'
str7
END
	unless (s7 eq "str7\n") puts("bad 7");

	s8 =
<<'END'
str8
END
	unless (s8 eq "str8\n") puts("bad 8");

	s9 =
 <<'END'
str9
END
	unless (s9 eq "str9\n") puts("bad 9");

	/*
	 * These test the patterns in the scanner that check for a ;
	 * after the end delim.  Note that there are spaces after
	 * some of the ; below.
	 */

	s10 = <<'END'
NOTEND;
NOTEND ;
NOTEND; 
NOTEND ; 
END
	unless (s10 eq "NOTEND;\nNOTEND ;\nNOTEND; \nNOTEND ; \n") {
		puts("bad 10");
	}

	s11 = <<END
NOTEND;
NOTEND ;
NOTEND; 
NOTEND ; 
END
	unless (s11 eq "NOTEND;\nNOTEND ;\nNOTEND; \nNOTEND ; \n") {
		puts("bad 11");
	}
}
scan_1_7();
} -output {}

test scan-1.8 {test here documents 2} -body {
#lang L
void scan_1_8()
{
	string	s;
	string	foo = "foo";

	/* Check string interpolation. */

	s = <<END
interpolated string ${foo}
END
	unless (s eq "interpolated string foo\n") puts("bad 1");

	s = <<'END'
uninterpolated string ${foo}
END
	unless (s eq "uninterpolated string \${foo}\n") puts("bad 2");

	/*
	 * The scanner handles an ID inside a here document
	 * differently than a non-ID, so try both.
	 */

	s = <<END
${foo}
aword
two words
END
	unless (s eq "foo\naword\ntwo words\n") puts("bad 3");

	s = <<'END'
${foo}
aword
two words
END
	unless (s eq "\${foo}\naword\ntwo words\n") puts("bad 4");

	/*
	 * Ensure delimeter isn't found mistakenly.  It isn't
	 * allowed to have leading or trailing whitespace or
	 * anything else.
	 */

	s = <<END
EN
EN D
END 
 END
ENDEND
END
	unless (s eq "EN\nEN D\nEND \n END\nENDEND\n") puts("bad 5");

	s = <<'END'
EN
EN D
END 
 END
ENDEND
END
	unless (s eq "EN\nEN D\nEND \n END\nENDEND\n") puts("bad 6");

	/* Check escapes. */

	s = <<END
a\tb\nc\\d\x
END
	unless (s eq "a\tb\nc\\dx\n") puts("bad 9");

	s = <<'END'
a\tb\nc\\d\x\\\'
END
	unless (s eq "a\\tb\\nc\\d\\x\\'\n") puts("bad 10");
}
scan_1_8();
} -output {}

test scan-1.9 {test here document error 1} -body {
#lang L
void
scan_1_9()
{
	/*
	 * Error, since nothing is allowed after the END except
	 * a newline.
	 */
	string s1 = <<'END'err
END
}
scan_1_9();
} -returnCodes {error} -match regexp -result ".*syntax error.*"

test scan-1.10 {test here document error 2} -body {
#lang L
void
scan_1_10()
{
	/*
	 * Error, since nothing is allowed after the END except
	 * a newline.
	 */
	string s1 = <<END err
END
}
scan_1_10();
} -returnCodes {error} -match regexp -result ".*syntax error.*"

test scan-1.11 {test nested here documents error} -body {
#lang L
void
scan_1_11()
{
	string s1, s2 = <<END
${s1=<<BAD
should be error
BAD
}
END
}
scan_1_11();
} -returnCodes {error} -match regexp -result ".*nested here documents illegal.*"

test scan-1.12 {test here documents semicolon error 1} -body {
#lang L
void
scan_1_12()
{
	string s = <<END
should be error
END;
}
scan_1_12();
} -returnCodes {error} -match regexp -result ".*illegal ; after here document."

test scan-1.13 {test here documents semicolon error 2} -body {
#lang L
void
scan_1_13()
{
	string s = <<'END'
should be error
END;
}
scan_1_13();
} -returnCodes {error} -match regexp -result ".*illegal ; after here document."

test scan-1.14 {test here documents semicolon error 3} -body {
#lang L
void
scan_1_14()
{
	string s = <<END
should be error
END ;
}
scan_1_14();
} -returnCodes {error} -match regexp -result ".*illegal ; after here document."

test scan-1.15 {test here documents semicolon error 4} -body {
#lang L
void
scan_1_15()
{
	string s = <<'END'
should be error
END ;
}
scan_1_15();
} -returnCodes {error} -match regexp -result ".*illegal ; after here document."

test scan-1.16 {check auto string concatenation} -body {
#lang L
void scan_1_16()
{
	string	s;

	s = "a"
"b"
"c";
	unless (s eq "abc") puts("bad 1");

	s = "d"
	    "e"
	    "f";
	unless (s eq "def") puts("bad 2");

	s = 'a'
'b'
'c';
	unless (s eq "abc") puts("bad 3");

	s = 'd'
	    'e'
	    'f';
	unless (s eq "def") puts("bad 4");
}
scan_1_16();
} -output {}

test cmdsubst-1 {test command substitution} -body {
#lang L
void cmdsubst_1()
{
	string	cmd, s1, s2;

	if (platform() eq "windows") {
		cmd = "sh echo";
	} else {
		cmd = "echo";
	}

	`${cmd} testing1 >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "testing1") puts("bad 1.1");
	`rm -f foo.txt`;

	s1 = "testing2";
	`${cmd} ${s1} >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "testing2") puts("bad 2.1");
	`rm -f foo.txt`;

	s1 = "testing3";
	s2 = "xyz";
	`${cmd} ${s1}${s2} >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "testing3xyz") puts("bad 3.1");
	`rm -f foo.txt`;

	s1 = "testing4";
	s2 = "pdq";
	`${cmd} ${s1}-${s2} >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "testing4-pdq") puts("bad 4.1");
	`rm -f foo.txt`;

	s1 = "testing";
	s2 = "xyz";
	`${cmd} ${s1}${5}${s2} ${"zyx"} >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "testing5xyz zyx") puts("bad 5.1");
	`rm -f foo.txt`;

	/*
	 * Check escapes.  The \r\n\t should get expanded but then
	 * ignored when the compiler splits the command string.
	 */

	`${cmd} \r\n\t\a$x >foo.txt`;
	s1 = `cat foo.txt`;
	unless (s1 eq "a$x") puts("bad 10.1");
	`rm -f foo.txt`;
}
cmdsubst_1();
} -output {}

test proc-1.0 {Test L function definition.} -body {
#lang L
void proc_1_0(void) {
        puts("foo");
}
#lang tcl
proc_1_0
} -output "foo\n"


test proc-1.1 {Test L function returns.} -body {
#lang L
void proc_1_1_f1() {
        puts("whiz");
}
string proc_1_1_f2() {
        puts("bang");
        return "foo";
        return "bar";
}
void proc_1_1_f3() {
        return;
}
void proc_1_1(void) {
        puts(proc_1_1_f1());
        puts(proc_1_1_f2());
        puts(proc_1_1_f3());
}
#lang tcl
proc_1_1
} -output "whiz\n\nbang\nfoo\n\n"

test proc-1.2 {Test L function parameters.} -body {
#lang L
void proc_1_2(string arg1, string arg2) {
        puts(arg1);
        puts(arg2);
} 
#lang tcl
proc_1_2 "val1" "val2" 
} -output "val1\nval2\n"

test proc-1.3 {Test variable arity functions} -body {
#lang L
string proc_1_3_foo(...stuff) {
	int i;
	for (i=0; defined(stuff[i]); i++) {
		printf("%s ", stuff[i]);
	}
	printf("\n");
}
string proc_1_3_bar(int a, ...stuff) {
	puts(a);
	puts(stuff);
}
void proc_1_3() {
	proc_1_3_foo("a", "b", "c", "d");
	proc_1_3_foo();
	proc_1_3_bar(1, 2, 3, 4);
	proc_1_3_bar(1);
}
#lang tcl
proc_1_3
} -output "a b c d \n\n1\n2 3 4\n1\n\n"

test proc-1.4 {Ensure rest parameter comes last} -body {
#lang L -nowarn
void proc_1_4(int a, ...b, int c) {
	puts("oops");
}
#lang tcl
proc_1_4
} -returnCodes {error} -match glob -result "*:1: L Error: Rest parameter must be last\n"

test proc-1.5 {test parameter multiple declaration} -body {
#lang L -nowarn
void proc_1_5_1(int a, int a) {}
void proc_1_5_2(int a, int a, int a) {}
} -returnCodes error -match regexp -result {.*1: L Error: multiple declaration of local a
.*2: L Error: multiple declaration of local a
.*2: L Error: multiple declaration of local a
}

test proc-1.6 {check ignored function return value} -body {
#lang L
int proc_1_6_foo() { return (1); }
void proc_1_6()
{
	/*
	 * This test checks that an ignored function's return value is
	 * properly popped off the run-time stack.  If it's not, the
	 * unbalanced stack will cause a Tcl panic in a debug build.
	 */

	int	i;
	int	n = 100;

	for (i = 0; i < n; ++i) {
		proc_1_6_foo();
	}
}
proc_1_6();
} -output {}

test proc-1.7 {check extern functions} -setup {
	proc proc_1_7 {} { puts "good" }
} -body {
#lang L
	extern void proc_1_7();
	proc_1_7();
} -output {good
}

test proc-1.8 {test (expand)} -body {
#lang L
string proc_1_8_concat(...args)
{
	poly	p;
	string	s;

	foreach (p in args) s = sprintf("%s%s", s, p);
	return (s);
}
int proc_1_8_sum(int a, int b, int c)
{
	return (a + b + c);
}
/* Return a string array of n elements, starting at "1" and counting up. */
string[] proc_1_8_arr(int n)
{
	int	i;
	string	s[];

	for (i = 1; i <= n; ++i) push(&s, (string)i);
	return (s);
}
void proc_1_8()
{
	int	i1[] = { 10 };
	int	i2[] = { 20, 30 };
	int	i3[] = { 40, 50, 60 };
	string	sa[] = { "a", "b", "c" };
	string	sb[] = { "d", "e" };
	poly	p = { "a", "b", "c" };

	unless (proc_1_8_concat((expand){}) eq "") puts("bad 0.1");

	unless (proc_1_8_concat((expand)sa) eq "abc") puts("bad 1.1");
	unless (proc_1_8_concat((expand all)sa) eq "abc") puts("bad 1.2");
	unless (proc_1_8_concat("x", (expand)sa) eq "xabc") puts("bad 2.1");
	unless (proc_1_8_concat("x", (expand all)sa) eq "xabc") puts("bad 2.2");
	unless (proc_1_8_concat((expand)sa, "y") eq "abcy") puts("bad 3.1");
	unless (proc_1_8_concat((expand all)sa, "y") eq "abcy") puts("bad 3.2");
	unless (proc_1_8_concat("x", (expand)sa, "y") eq "xabcy") {
		puts("bad 4.1");
	}
	unless (proc_1_8_concat("x", (expand all)sa, "y") eq "xabcy") {
		puts("bad 4.2");
	}
	unless (proc_1_8_concat("x", (expand)sa, (expand)sb, "y") eq "xabcdey") {
		puts("bad 5.1");
	}
	unless (proc_1_8_concat("x", (expand all)sa, (expand all)sb, "y")
			eq "xabcdey") {
		puts("bad 5.2");
	}
	unless (proc_1_8_concat((expand)sa, (expand)sa, (expand)sa)
			eq "abcabcabc") {
		puts("bad 6.1");
	}
	unless (proc_1_8_concat((expand all)sa, (expand all)sa, (expand all)sa)
			eq "abcabcabc") {
		puts("bad 6.2");
	}

	unless (proc_1_8_sum((expand)i1, 2, 3) == 15) puts("bad 10.1");
	unless (proc_1_8_sum((expand all)i1, 2, 3) == 15) puts("bad 10.2");
	unless (proc_1_8_sum((expand)i2, 2) == 52) puts("bad 11.1");
	unless (proc_1_8_sum((expand all)i2, 2) == 52) puts("bad 11.2");
	unless (proc_1_8_sum((expand)i3) == 150) puts("bad 12.1");
	unless (proc_1_8_sum((expand all)i3) == 150) puts("bad 12.2");

	unless (proc_1_8_concat((expand)p) eq "abc") puts("bad 20.1");
	unless (proc_1_8_concat((expand all)p) eq "abc") puts("bad 20.2");

	unless (proc_1_8_concat((expand)proc_1_8_arr(1)) eq "1") {
		puts("bad 30.1");
	}
	unless (proc_1_8_concat((expand all)proc_1_8_arr(1)) eq "1") {
		puts("bad 30.2");
	}
	unless (proc_1_8_concat((expand)proc_1_8_arr(2)) eq "12") {
		puts("bad 31.1");
	}
	unless (proc_1_8_concat((expand all)proc_1_8_arr(2)) eq "12") {
		puts("bad 31.2");
	}
	unless (proc_1_8_concat((expand)proc_1_8_arr(3)) eq "123") {
		puts("bad 32.1");
	}
	unless (proc_1_8_concat((expand all)proc_1_8_arr(3)) eq "123") {
		puts("bad 32.2");
	}

	/* These test expand inside of a list {}. */

	unless (proc_1_8_concat((expand){(expand){1}}) eq "1") {
		puts("bad 40.1");
	}
	unless (proc_1_8_concat((expand all){(expand all){1}}) eq "1") {
		puts("bad 40.2");
	}
	unless (proc_1_8_concat((expand){(expand){1,2}}) eq "12") {
		puts("bad 40.3");
	}
	unless (proc_1_8_concat((expand all){(expand all){1,2}}) eq "12") {
		puts("bad 40.4");
	}
	unless (proc_1_8_concat((expand){(expand){1,2,3}}) eq "123") {
		puts("bad 40.5");
	}
	unless (proc_1_8_concat((expand all){(expand all){1,2,3}}) eq "123") {
		puts("bad 40.6");
	}

	sa = { (expand){"1","2"}, "3", (expand){"4"}, "5", (expand){"6","7","8"} };
	unless (length(sa) == 8) puts("bad 41.1");
	unless (proc_1_8_concat((expand)sa) eq "12345678") puts("bad 41.2");

	sa = { (expand)"1" };
	unless ((length(sa) == 1) && (sa[0] eq "1")) puts("bad 42.1");
	sa = { (expand)"1", (expand)"2" };
	unless ((length(sa) == 2) && (sa[0] eq "1") && (sa[1] eq "2")) {
		puts("bad 42.2");
	}
}
proc_1_8();
} -output {}

test proc-1.9 {test (expand all)} -body {
#lang L
string proc_1_9_concat(...args)
{
	poly	p;
	string	s;

	foreach (p in args) s = sprintf("%s%s", s, p);
	return (s);
}
int proc_1_9_sum(int a, int b, int c, int d, int e, int f, int g, int h)
{
	return (a + b + c + d + e + f + g + h);
}
/* Return a string array of n elements, starting at "1" and counting up. */
string[] proc_1_9_arr(int n)
{
	int	i;
	string	s[];

	for (i = 1; i <= n; ++i) push(&s, (string)i);
	return (s);
}
void proc_1_9()
{
	int	ia0[] = {1};
	int	ia1[][] = { {1}, {1}, {1,1} };
	int	ia2[][][] = { { {1}, {1} }, {{1}}, { {1,1,1}, {1,1} } };
	string	sa[];
	string	saa[][] = { {"00","01"}, {"10"}, {"20"}, {"30","31","32"} };
	string	sh{string} = { "k1"=>"v1", "k2"=>"v2" };
	struct {
		int	i, j;
		string	sa[];
		string	s;
	} st = { 11, 22, { "s1","s2" }, "str" };

	unless (proc_1_9_concat((expand all){}) eq "") puts("bad 0.1");

	unless (proc_1_9_sum((expand all)ia0,1,1,1,1,1,1,1) == 8) {
		puts("bad 0.2");
	}
	unless (proc_1_9_sum((expand all)ia1,3,3,3,3) == 16) {
		puts("bad 0.3");
	}
	unless (proc_1_9_sum((expand all)ia2) == 8) {
		puts("bad 0.4");
	}

	unless (proc_1_9_concat((expand all)saa) eq "00011020303132") {
		puts("bad 1.1");
	}

	unless (proc_1_9_concat((expand all){1,2,{3,{4,5},6}}) eq "123456") {
		puts("bad 2");
	}

	unless (proc_1_9_concat((expand all){{{{{{{{1}}}}}}}}) eq "1") {
		puts("bad 3");
	}

	unless (proc_1_9_concat((expand all)sh) eq "k1v1k2v2") puts("bad 4");
	unless (proc_1_9_concat((expand all)st) eq "1122s1s2str") puts("bad 5");

	/* Try some nested lists with expands. */
	sa = { (expand){"1","2","3"}, (expand all){"4", (expand){"5","6"}} };
	unless (length(sa) == 6) puts("bad 10.1");
	unless (proc_1_9_concat((expand)sa) eq "123456") puts("bad 10.2");
	sa = { (expand){"1","2","3"}, (expand){"4", (expand){"5","6"}} };
	unless (length(sa) == 6) puts("bad 10.3");
	unless (proc_1_9_concat((expand)sa) eq "123456") puts("bad 10.4");
}
proc_1_9();
} -output {}

test proc-1.10 {check expand errors} -body {
#lang L
void proc_1_10()
{
	(expand bad){1,2,3};
}
} -returnCodes error -match regexp -result {.*3: L Error: only \(expand\) and \(expand all\) are legal
}

test var-1.0 {Test L variable assignment and reference} -body {
#lang L
void var_1_0(void)
{
	string s;
        s = "Hello";
	puts(s);
}
#lang tcl
var_1_0
} -output "Hello\n"

test var-1.1 {L global variables} -body {
#lang L
int lglobal1_1 = 1;
void var_1_1(void)
{
        puts(lglobal1_1);
}
#lang tcl
var_1_1
} -output "1\n"


test var-1.2 {L global variables, harder} -body {
#lang L
int lglobal1_2 = 3;
void var_1_2(void)
{
        puts(lglobal1_2);
        lglobal1_2 = 4;
        var_1_2_aux();
        puts(lglobal1_2);
}

void var_1_2_aux()
{
        puts(lglobal1_2);
        lglobal1_2 = 5;
}
#lang tcl
var_1_2
} -output "3\n4\n5\n"

test var-1.2.2 {L global variable access from inside function} -body {
#lang L
private int g = 123;
void var_1_2_2()
{
	/*
	 * This tests a past compiler bug where the upvars for the
	 * global shadows were emitted at the point of variable use,
	 * which doesn't work if the use doesn't get executed, like
	 * the first reference to "g" below.
	 */
	for (; 0; g);
	unless (g == 123) puts("bad 1");
}
var_1_2_2();
} -output {}

test var-1.2.3 {L global variable access from inside class} -body {
#lang L
/*
 * Like the above test (var-1.2.2) but with class variables as well.
 */
private int g = 321;
class class_var_1_2_3a
{
	public int l1 = g;    // should see the global "g"
	public int g  = 654;  // shadows the global
	public int l2 = g;    // should see the local "g"
}
class class_var_1_2_3b
{
	public int l1 = g;    // should see the global "g"
	public int g  = 456;  // shadows the global
	public int l2 = g;    // should see the local "g"
}
void var_1_2_3()
{
	unless (g == 321) puts("bad 1");
	unless (class_var_1_2_3a->l1 == 321) puts("bad 2");
	unless (class_var_1_2_3a->g  == 654) puts("bad 3");
	unless (class_var_1_2_3a->l2 == 654) puts("bad 4");
	unless (class_var_1_2_3b->l1 == 321) puts("bad 5");
	unless (class_var_1_2_3b->g  == 456) puts("bad 6");
	unless (class_var_1_2_3b->l2 == 456) puts("bad 7");
	if (1) {
		int	g = 987;
		unless (g == 987) puts("bad 10");
	}
	unless (g == 321) puts("bad 20");
}
var_1_2_3();
} -output {}

test var-1.3 {A global array of structs} -body {
#lang L

struct var_1_3_point { int x, y; };
struct var_1_3_point lglobal1_3[5];

void var_1_3(void)
{
        int i = 0;

        puts(lglobal1_3);
        while (i < 5) {
          lglobal1_3[i].x = i * 10;
          lglobal1_3[i].y = i * 20;
          i++;
        }
        puts(lglobal1_3);
        var_1_3_aux(3);
        puts(lglobal1_3);
}

void var_1_3_aux(int i)
{
        lglobal1_3[i].x = i * 35;
        lglobal1_3[i].y = i * 45;
}
#lang tcl
var_1_3
} -output {
{0 0} {10 20} {20 40} {30 60} {40 80}
{0 0} {10 20} {20 40} {105 135} {40 80}
}

test var-1.4 {Test extern variables} -body {
set tclvar "this is an extern variable"
#lang L
extern string tclvar;
void var_1_4()
{
	puts(tclvar);
}
#lang tcl
var_1_4
} -output "this is an extern variable\n"

test var-1.5 {Variable function names} -body {
#lang L
void var_1_5() {
  /*
   * This used to be supported but is no longer (2/24/09).
   * This is now an error.
   */
  string printfvar = "printf";
  printfvar("Earth calling printf\n");
}
#lang tcl
var_1_5
} -returnCodes error -match regexp -result {.*7: L Error: 'printfvar' is declared but not as a function
}

test lang-1.0 {Test lang parsing} -body {
# These are some Tcl Comments
#lang L
void lang_1_0(void)
{
	puts("worked");
}

#lang tcl
# More comments
lang_1_0
} -output "worked\n"

test lang-2.0 {Test failure path in lang parsing} -body {
#lang(foo)
void lang_2_0(void)
{
	puts("worked");
}

#lang tcl
lang_2_0
} -returnCodes {error} -result {malformed pragma}

# no output because we're not calling any functions
test lang-3.0 {Test not switching back to Tcl} -body {
#lang L
void lang_3_0(void)
{
	puts("worked");
}
}

test decl-1.0 {Variable and parameter declaration syntax} -body {
#lang L -nowarn
void decl_1_0_fun1() { }
void decl_1_0_fun2(void) { }
void decl_1_0_fun3() { }
int fdecl_1_0_un4() { }
void decl_1_0_fun5(int foo) { }
hash decl_1_0_fun6(hash foo, hash bar[], hash baz[23]) { }
void decl_1_0_fun7(int foo, float bar, hash baz, string quux, poly quuux) { }
void decl_1_0_fun8() {
        int foo, bar[], baz[84][42][1];
        string foo1[19], mani[], padmi = "hum";
        hash whee;
        if (0) {
                int bleh = 5;
        } else {
                if (1) {
                        poly padmi1 = "om";
                        puts(padmi1);
                }
        }
}
#lang tcl
decl_1_0_fun8
} -output "om\n";

test decl-1.1 {Hairy literal hash syntax in initializers} -body {
#lang L -nowarn
void initmewoo() {
        hash h = { "key" => "val", "key2" => "val" };
}
#lang tcl
}

test decl-1.2 {Undeclared variable error} -body {
#lang L
void decl_1_2_undecl() {
        foo = "bar";
        puts(cheese);
}
#lang tcl
decl_1_2_undecl
} -returnCodes error -match glob -result {*L Error: undeclared variable: foo
*L Error: undeclared variable: cheese
}

test decl-1.3 {Variable shadowing} -body {
#lang L
void decl_1_3_shadow() {
        int foo = 1;
        if (1) {
                int foo = 2;
                puts(foo);
        } 
        puts(foo);
}
#lang tcl
decl_1_3_shadow
} -returnCodes error -match glob -result {*L Error: multiple declaration of local foo
}

test decl-1.4 {Single dimensional initializers actually initialize} -body {
#lang L
void decl_1_4 () {
  int foo[] = {4, 5, 6};
  hash bar = {"foo" => 4, "bar" => 5, "baz" => 6};
  struct { int x; int y; } point = { 1024, 768 };

  printf("%s\n", foo);
  printf("%s\n", bar);
  printf("%s\n", point);
}
#lang tcl
decl_1_4
} -output "4 5 6\nfoo 4 bar 5 baz 6\n1024 768\n"

# Test decl-1.5 removed.

test decl-1.6 {Check scoping rule errors for globals and externs} -body {
#lang L -nowarn
/*
 * The L scoping rules are as follows:
 *
 * - A name multiply declared at the global scope is illegal.
 * - A name multiply declared in a local scope or any enclosing scopes
 *   is illegal.
 * - A local name hides a global of the same name.
 * - A name is not visible outside the scope in which it is declared.
 * - A name is not visible in a scope before it is declared.
 *
 * This test checks the error cases.
 */
int decl_1_6_g1 = decl_1_6_g2;  // error -- g2 used before being declared
int decl_1_6_g2;
void foo_decl_1_6()
{
	decl_1_6_g3 = 1;  // error -- g3 used before being declared
}
int decl_1_6_g3;
void decl_1_6()
{
	int	l;
	int	l;  // error -- name already declared locally
	puts(decl_1_6_extern);  // error -- extern not yet declared
	if (1) {
		if (1) {
			int decl_1_6_extern;
			decl_1_6_extern = 3;
		}
	}
	if (1) {
		int	l2;
		int	l;  // error -- name already declared locally
		if (1) {
			int	l2;  // error -- name already declared locally
		}
	}
}
extern int decl_1_6_extern;
extern int decl_1_6_extern;  // error -- multiply declared at global scope
int decl_1_6_g2;  // error -- multiply declared at global scope
void decl_1_6_bad()
{
	extern int decl_1_6_g;  // error -- externs illegal in local scopes
}
} -returnCodes error -match regexp -result {.*13: L Error: undeclared variable: decl_1_6_g2
.*17: L Error: undeclared variable: decl_1_6_g3
.*23: L Error: multiple declaration of local l
.*24: L Error: undeclared variable: decl_1_6_extern
.*33: L Error: multiple declaration of local l
.*35: L Error: multiple declaration of local l2
.*40: L Error: multiple declaration of global decl_1_6_extern
.*41: L Error: multiple declaration of global decl_1_6_g2
.*44: L Error: externs legal only at global scope
}

test decl-1.7 {Check scoping rules for globals and externs} -body {
#lang L
/*
 * This test checks the non-error cases of the scoping rules described
 * above.
 */
extern string decl_1_7_extern;
string decl_1_7_g1;
string decl_1_7_g2 = "g2";
string decl_1_7_g3;
void decl_1_7()
{
	string	s = decl_1_7_g2;  // read the global
	string	decl_1_7_g2 = "g2local"; // now shadow the global

	unless (s eq "g2") puts("bad 1");
	unless (decl_1_7_g2 eq "g2local") puts("bad 2");

	decl_1_7_extern = "ex";
	unless (decl_1_7_extern eq "ex") puts("bad 3");

	decl_1_7_g1 = "g1";
	unless (decl_1_7_g1 eq "g1") puts("bad 4");

	if (1) {
		string	decl_1_7_g1;  // shadow a global, already referenced
		string	decl_1_7_g3;  // shadow a global, not yet referenced
		decl_1_7_g1 = "local1";   // sets the local
		decl_1_7_g3 = "local3";   // sets the local
		unless (decl_1_7_g1 eq "local1") puts("bad 5");
		unless (decl_1_7_g3 eq "local3") puts("bad 6");
	}
	unless (decl_1_7_g1 eq "g1") puts("bad 7");
}
#lang tcl
decl_1_7
} -output ""

test decl-1.8 {Check illegal variable names} -body {
#lang L -nowarn
void _decl_1_8()  // err -- function names cannot begin with _
{
	int	_bad;  // err -- locals cannot begin with _
}
} -returnCodes error -match regexp -result {.*1: L Error: function names cannot begin with _
.*3: L Error: local variable names cannot begin with _
}

test decl-1.9 {Check mixing types on single decl line} -body {
#lang L
void decl_1_9() {
	/*
	 * This is a regression test.  L used to get the types wrong.
	 * This just checks that the compiler issues no type errors.
	 */
	string	h1{int}, s1;
	string	s2;
	string	h2{int};

	s1 = s2;
	h1 = h2;
	s1 = "s1";
	s2 = "s2";
	h1{1} = "one";
	h2{1} = "one";
}
#lang tcl
decl_1_9
} -output {}

test decl-1.10 {multiple declaration of main in same script disallowed} -body {
#lang L
void main()
{
}
void main()
{
}
void main()
{
}
} -returnCodes error -match regexp -result {.*4: L Error: redeclaration of main
.*7: L Error: redeclaration of main
}

test decl-1.11.1 {private globals 1} -body {
#lang L
private string priv_global = "test 1";
private void priv_global_test_fn()
{
	puts(priv_global);
}
void decl_1_11_1()
{
	unless (priv_global eq "test 1") puts("bad decl_1_11_1");
}
priv_global_test_fn();
decl_1_11_1();
} -output "test 1\n"

test decl-1.11.2 {private globals 2} -body {
#lang L
/*
 * This test declares the same (private) names as the previous test.
 * They should not clash.
 */
private string priv_global = "test 2";
private void priv_global_test_fn()
{
	puts(priv_global);
}
priv_global_test_fn();
/*
 * Call the previous test's function.  It should see the value of its
 * own private global, not ours.
 */
decl_1_11_1();
} -output "test 2\n"

test decl-1.11.3 {test public/private global declaration errors} -body {
#lang L -nowarn
private int decl_1_11_3_priv_first;
int decl_1_11_3_priv_first;

int decl_1_11_3_publ_first;
private int decl_1_11_3_publ_first;

private int two_privates;
private int two_privates;

private void decl_1_11_1() {}  // already declared in earlier test

private string stdin;  // already declared in libl

void decl_1_11_3()
{
	public	string bad1;
	private	string bad2;
}
} -returnCodes {error} -match regexp -result {.*2: L Error: multiple declaration of global decl_1_11_3_priv_first
.*5: L Error: multiple declaration of global decl_1_11_3_publ_first
.*8: L Error: multiple declaration of global two_privates
.*10: L Error: function decl_1_11_1 already declared
.*12: L Error: multiple declaration of global stdin
.*16: L Error: public/private qualifiers illegal for locals
.*17: L Error: public/private qualifiers illegal for locals
}

test decl-1.12.1 {public globals 1} -body {
#lang L
/*
 * This simply tests that the "public" qualifier on a global
 * declaration acts like a no-op.
 */
public string decl_1_12_s = "public decl test";
public void decl_1_12_1()
{
	puts(decl_1_12_s);
}
decl_1_12_1();
} -output "public decl test\n"

test decl-1.12.1 {public globals 2} -body {
#lang L
/* This is the second half of the test above. */
public void decl_1_12_2()
{
	puts(decl_1_12_s);  // print global defined in the previous test
}
decl_1_12_2();
} -output "public decl test\n"

test if-1.0 {If statements} -body {
#lang L
void if_1_0() {
        if (1) puts("0 working");
        if (0) {
                puts("1 broken");
        } 
        puts("between");
        if (1) {
                puts("1 working");
        } 
}
#lang tcl
if_1_0
} -output "0 working\nbetween\n1 working\n"


test if-1.1 {If statements with else clauses and multistatement bodies} -body {
#lang L
void if_1_1() {
        if (1) {
                puts("1 working");
                puts(".");
        } else {
                puts("1 broken");
                puts(".");
        }
        
        if (0) {
                puts("2 broken");
                puts(".");
                puts(".");
        } else {
                puts("2 working");
                puts(".");
                puts(".");
        }
}
#lang tcl
if_1_1
} -output "1 working\n.\n2 working\n.\n.\n"


test if-1.2 {"else if" clauses} -body {
#lang L
void if_1_2() {
        if (0) {
                puts("1 broken");
        } else if (1) {
                puts("1 working");
        }

        puts("between");

        if (0) {
                puts("2 broken");
        } else if (0) {
                puts("2.2 broken");
        } else {
                puts("2 working");
        }
}
#lang tcl
if_1_2
} -output "1 working\nbetween\n2 working\n"

test if-1.3 {nested if statements} -body {
#lang L
void if_1_3() {
        if (1) {
                puts("1 before");
                if (0) {
                        puts("1 broken");
                } else {
                        puts("1 working");
                }
                puts("1 after");
        } else {
                puts("1.1 broken");
        }
        puts("1 done");
}
#lang tcl
if_1_3
} -output "1 before\n1 working\n1 after\n1 done\n"


test if-1.4 {else is only allowed with curly braces} -body {
#lang L
void if_1_4(void)
{
	if (0) puts("1 broken"); else puts("1 even more broken");
}
#lang tcl
} -returnCodes error -match glob -result "*3: L Error: syntax error, unexpected else\n"


test unless-1.0 {unless statements} -body {
#lang L
void unless_1_0() {
        unless(0) puts("0 working");
        unless(0) {
                puts("1 working");
        }
        unless(1) {
                puts("2 broken");
        } else {
                puts("2 working");
        }
        unless(1) {
                puts("3 broken");
        } else unless (1) {
                puts("3.1 broken");
        } else {
                puts("3 working");
        }
} 
#lang tcl
unless_1_0
} -output "0 working\n1 working\n2 working\n3 working\n"

test unless-1.1 {unless and if statements mixed} -body {
#lang L
void unless_1_1() {
        unless(1) {
                puts("1 broken");
        } else if (0) {
                puts("1.1 broken");
        } else unless(0) {
                puts("1 working");
        }
        puts("done");
} 
#lang tcl
unless_1_1
} -output "1 working\ndone\n"

test return-1.1 {return from void function allowed} -body {
#lang L
void return_1_1() { return; }
} -returnCodes normal

test return-1.2 {returning int from void function disallowed} -body {
#lang L
void return_1_2() { return 0; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.3 {returning string from void function disallowed} -body {
#lang L
void return_1_3() { return "str"; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.4 {returning float from void function disallowed} -body {
#lang L
void return_1_4() { return 2.99792458; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.5 {returning array from void function disallowed} -body {
#lang L
void return_1_5() {
	int	a[3];
	return a;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.6 {returning hash from void function disallowed} -body {
#lang L
void return_1_6() {
	hash	h;
	return h;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.7 {returning struct from void function disallowed} -body {
#lang L
void return_1_7() {
	struct { int x,y; } s;
	return s;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.8 {returning poly from void function disallowed} -body {
#lang L
void return_1_8() {
	poly	p;
	return p;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.9.1 {return from global scope 1} -body {
#lang L
return;
} -output {}

test return-1.9.2 {return from global scope 2} -body {
#lang L
return(1);
} -result {1} -output {}

test return-1.9.3 {return from global scope 3} -body {
#lang L
return("ret");
} -result {ret} -output {}

test return-2.1 {int return value from int function allowed} -body {
#lang L
int return_2_1_f() { return 123; }
unless (return_2_1_f() == 123) printf("BAD\n");
} -output ""

test return-2.2 {float return value from float function allowed} -body {
#lang L
float return_2_2_f() { return 123.456; }
unless (return_2_2_f() == 123.456) printf("BAD\n");
} -output ""

test return-2.3 {string return value from string function allowed} -body {
#lang L
string return_2_3_f() { return "str"; }
unless (return_2_3_f() eq "str") printf("BAD\n");
} -output ""

test return-2.4 {array return value from array function allowed} -body {
#lang L
int[] return_2_4_f()
{
	int	a[3] = {2,3,5};
	return a;
}
void return_2_4()
{
	int res[] = return_2_4_f();
	unless ((res[0] == 2) && (res[1] == 3) && (res[2] == 5)) {
		printf("BAD\n");
	}
}
#lang tcl
return_2_4
} -output ""

test return-2.5 {hash return value from hash function allowed} -body {
#lang L
hash return_2_5_f()
{
	hash	h;
	h{"one"} = 1;
	h{"two"} = 2;
	h{"ten"} = 10;
	return h;
}
void return_2_5()
{
	hash res = return_2_5_f();
	unless ((res{"one"} == 1) && (res{"two"} == 2) && (res{"ten"} == 10)) {
		printf("BAD\n");
	}
}
#lang tcl
return_2_5
} -output ""

test return-2.6 {struct return value from struct function allowed} -body {
#lang L
struct return_2_6_s {
	int x, y, z;
};
struct return_2_6_s return_2_6_f()
{
	struct return_2_6_s s;
	s.x = 1;
	s.y = 2;
	s.z = 3;
	return s;
}
void return_2_6()
{
	struct return_2_6_s res = return_2_6_f();
	unless ((res.x == 1) && (res.y == 2) && (res.z == 3)) printf("BAD\n");
}
#lang tcl
return_2_6
} -output ""

# Spot-check some of the type-checking cases to ensure that return-value
# type checking is being done.  Do not check all possible permutations.

test return-3.1 {int return value from string function disallowed} -body {
#lang L
string return_3_1() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.2 {float return value from string function disallowed} -body {
#lang L
string return_3_2() { return 1.2; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.3 {int return value from hash function disallowed} -body {
#lang L
hash return_3_3() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.4 {array return value from hash function disallowed} -body {
#lang L
hash return_3_4() { int a[3]; return a; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.5 {int return value from struct function disallowed} -body {
#lang L
struct s35 {
	int x, y;
};
struct s35 return_3_5() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.6 {hash return value from struct function disallowed} -body {
#lang L
struct s36 {
	int x, y;
};
struct s36 return_3_6() { hash h; return h; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.7 {int return value from array function disallowed} -body {
#lang L
int[] return_3_7() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.8 {struct return value from array function disallowed} -body {
#lang L
struct s38 {
	int x, y;
};
int[] return_3_8() { struct s38 s; return s; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.9 {hash return value from array function disallowed} -body {
#lang L
int[] return_3_9() { hash h; return h; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test syntax-1.0 {single-line comments a la C++} -body {
#lang L
void syntax_1_0() {
        // single-line comments are 
        puts("working"); //see?
        //////cruftilioucious 
	# this too
# and this
}
# and this

#lang tcl
syntax_1_0
} -output "working\n" 


test syntax-1.1 {structure syntax} -body {
#lang L -nowarn

struct syntax_1_1_point {
        int x, y;
        string label;
        float froboz[128];
        struct { int m, n; } sub_struct;
};

void syntax_1_1() {
        struct { string firstname; string lastname; } him;
        struct { string firstname; string lastname; } me = {"john", "doe"};
        struct syntax_1_1_point p1, p2 = {
	       1, 2, "label", {1.0}, {1,2} } , p3;
        puts("didn't crash");
}

#lang tcl
syntax_1_1
} -output "didn't crash\n"

test syntax-1.2 {interpolated strings} -body {
#lang L

void syntax_1_2() {
        int i = 1, j = 2;
        string m = "ASDF";

        puts("syntax_${ i + j - 2 }_${j}.");
        puts("foo ${"bar ${m} baz"} zot");
}

#lang tcl
syntax_1_2
} -output "syntax_1_2.\nfoo bar ASDF baz zot\n"

test syntax-1.3 {keywords} -body {
#lang L
void syntax_1_3() {
	printf("%s, %s, %s\n", foo: "bar", baz:);
}
#lang tcl
syntax_1_3
} -output "-foo, bar, -baz\n"

test syntax-1.4 {string appendation} -body {
#lang L
void syntax_1_4() {
	printf("these" "strings"
	    "stick" "together.\n");
}
#lang tcl
syntax_1_4
} -output "thesestringssticktogether.\n"

test op-1.0 {increment and decrement operators} -body {
#lang L
void op_1_0() {
        int i = 1;

        puts("pre:");
        puts(i);
        ++i;
        puts(i);
        puts(++i);
        --i;
        puts(i);
        puts(--i);

        puts("post:");
        puts(i);
        i++;
        puts(i);
        puts(i++);
        puts(i);
        i--;
        puts(i);
        puts(i--);
        puts(i);
}
#lang tcl
op_1_0
} -output "pre:\n1\n2\n3\n2\n1\npost:\n1\n2\n2\n3\n2\n2\n1\n"

test op-1.0.1 {increment and decrement operator side effects} -body {
#lang L
class op_1_0_1_cls
{
	instance { public int n; }
}
void op_1_0_1()
{
	/*
	 * This test checks that the argument to ++ or -- is evaluated
	 * exactly once.
	 */

	int	i;
	int	a[];
	op_1_0_1_cls o[] = { op_1_0_1_cls_new(), op_1_0_1_cls_new() };

	i = 0;
	a[0] = 13;
	++(a[i++]);
	unless ((i == 1) && (a[0] == 14)) puts("bad 1");

	i = 0;
	a[0] = 13;
	(a[i++])++;
	unless ((i == 1) && (a[0] == 14)) puts("bad 2");

	i = 0;
	o[0]->n = 13;
	o[1]->n = 13;
	++(o[i++]->n);
	unless ((i == 1) && (o[0]->n == 14)) puts("bad 3");
	unless (o[1]->n == 13) puts("bad 3.1");

	i = 0;
	o[0]->n = 13;
	o[1]->n = 13;
	(o[i++]->n)++;
	unless ((i == 1) && (o[0]->n == 14)) puts("bad 4");
	unless (o[1]->n == 13) puts("bad 4.1");
}
op_1_0_1();
} -output {}

test op-1.1 {plus, minus, multiply, divide, and modulus operators} -body {
#lang L
void op_1_1() {
        int i = 2;
        puts(i + 5);
        puts(i - 50);
        puts(i * 500);
        puts(i / 2);
        puts(i / 4.0);
        puts((i + 5) % 3);
        // precedence
        puts(i + i / i - i * i % i);
}
#lang tcl
op_1_1
} -output "7\n-48\n1000\n1\n0.5\n1\n3\n"

test op-1.2 {unary plus and minus} -body {
#lang L
void op_1_2() {
        int i = -2;
        int j = +2;

        puts(i);
        i = i + -100;
        puts(i);
        puts(i * -3);
        puts(-8 - -2);

        puts(j);
        j = j + +100;
        puts(j);
        puts(j * +3);
        puts(+8 - +2);
}
#lang tcl
op_1_2
} -output "-2\n-102\n306\n-6\n2\n102\n306\n6\n"

test op-1.3 {numeric comparison operators} -body {
#lang L
void op_1_3() {
        if (-1 < 1) { puts("1okay"); } else { puts("1broken"); }
        if (1 > -1) { puts("2okay"); } else { puts("2broken"); }
        if (1 == 1) { puts("3okay"); } else { puts("3broken"); }
        if (1 <= 1) { puts("4okay"); } else { puts("4broken"); }
        if (-1 <= 1) { puts("5okay"); } else { puts("5broken"); }
        if (1 >= -1) { puts("6okay"); } else { puts("6broken"); }
        if (1 >= 0) { puts("7okay"); } else { puts("7broken"); }
        if (0 != 1) { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if (1 < 1) { puts("1broken"); } else { puts("1okay"); }
        if (1 > 1) { puts("2broken"); } else { puts("2okay"); }
        if (1 == 0) { puts("3broken"); } else { puts("3okay"); }
        if (1 != 1) { puts("4broken"); } else { puts("4okay"); }
        if (1 <= -1) { puts("5broken"); } else { puts("5okay"); }
        if (-1 >= 1) { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_3
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"

test op-1.4 {lexicographic comparison operators} -body {
#lang L
void op_1_4() {
        if ("aa" lt "ab") { puts("1okay"); } else { puts("1broken"); }
        if ("ab" gt "aa") { puts("2okay"); } else { puts("2broken"); }
        if ("aa" eq "aa") { puts("3okay"); } else { puts("3broken"); }
        if ("aa" le "aa") { puts("4okay"); } else { puts("4broken"); }
        if ("aa" le "ab") { puts("5okay"); } else { puts("5broken"); }
        if ("aa" ge "aa") { puts("6okay"); } else { puts("6broken"); }
        if ("ab" ge "aa") { puts("7okay"); } else { puts("7broken"); }
        if ("aa" ne "ab") { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if ("aa" lt "aa") { puts("1broken"); } else { puts("1okay"); }
        if ("aa" gt "aa") { puts("2broken"); } else { puts("2okay"); }
        if ("ab" eq "aa") { puts("3broken"); } else { puts("3okay"); }
        if ("aa" ne "aa") { puts("4broken"); } else { puts("4okay"); }
        if ("ab" le "aa") { puts("5broken"); } else { puts("5okay"); }
        if ("aa" ge "ab") { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_4
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"


test op-1.5 {boolean operators} -body {
#lang L
void op_1_5() {
        int true = 1, false = 0;
        if (true && true)       { puts("1okay"); } else { puts("1broken"); }
        if (!false)             { puts("2okay"); } else { puts("2broken"); }
        if (false || true)      { puts("3okay"); } else { puts("3broken"); }
        if (true && !false)     { puts("4okay"); } else { puts("4broken"); }
        // && has higher precedence than ||
        if (false && false || true) { puts("5okay"); } else { puts("5broken"); }
        // now from the other side
        puts("--");
        if (true && !true)      { puts("1broken"); } else { puts("1okay"); }
        if (false || false)     { puts("2broken"); } else { puts("2okay"); }
        if (!true)              { puts("3broken"); } else { puts("3okay"); }

}
#lang tcl
op_1_5
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n--\n1okay\n2okay\n3okay\n"


test op-1.6 {bitwise operators} -body {
#lang L
void op_1_6(){
        int bits = 715827882;

        puts(bits << 1);
        puts(bits >> 1);
        puts(bits >> 29);
        puts(-1 << 10);
        puts(-1024 >> 9);
        puts(~bits);
        puts(bits & ~bits);
        puts(bits | ~bits);
        puts(bits ^ (bits + 1));

}
#lang tcl
op_1_6
} -output "1431655764\n357913941\n1\n-1024\n-2\n-715827883\n0\n-1\n1\n"


test op-1.7 {logical operator short-circuiting} -body {
#lang L
int
puts_int(string str) {
        puts(str);
        return 9;
}
void op_1_7(){
        puts(0 && puts_int("1"));
        puts(1 && puts_int("2"));
        puts(0 || puts_int("3"));
        puts(1 || puts_int("4"));
}
#lang tcl
op_1_7
} -output "0\n2\n9\n3\n9\n1\n"

test op-1.8 {compound assignment operators, simple lvalues} -body {
#lang L
void op_1_8() {
  int foo = 0;

  puts(foo += 2);
  puts(foo);
  puts(foo -= 3);
  puts(foo);
  puts(foo *= 4);
  puts(foo);
  puts(foo /= -2);
  puts(foo);
  foo = 17;
  puts(foo %= 7);
  puts(foo);
  puts(foo |= 9);
  puts(foo);
  puts(foo &= 8);
  puts(foo);
  puts(foo ^= 9);
  puts(foo);
  puts(foo <<= 3);
  puts(foo);
  puts(foo >>= 2);
  puts(foo);
}
#lang tcl
op_1_8
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n"

test op-1.9 {compound assignment operators, array lvalues} -body {
#lang L
void op_1_9() {
  int foo[4] = {0,0,0,0};

  puts(foo[2] += 2);
  puts(foo[2]);
  puts(foo[2] -= 3);
  puts(foo[2]);
  puts(foo[2] *= 4);
  puts(foo[2]);
  puts(foo[2] /= -2);
  puts(foo[2]);
  foo[2] = 17;
  puts(foo[2] %= 7);
  puts(foo[2]);
  puts(foo[2] |= 9);
  puts(foo[2]);
  puts(foo[2] &= 8);
  puts(foo[2]);
  puts(foo[2] ^= 9);
  puts(foo[2]);
  puts(foo[2] <<= 3);
  puts(foo[2]);
  puts(foo[2] >>= 2);
  puts(foo[2]);
  puts(foo);
}
#lang tcl
op_1_9
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n0 0 2 0\n"

test op-1.10 {short-circuit conditionals} -body {
#lang L
void op_1_10()
{
	/*
	 * Ensure that conditionals of type string are tested properly
	 * in the short-circuited operators (i.e., tested against "0").
	 */

	int	i = 0, j;

	if ("0" && ++i) j = 1;
	unless (i == 0) puts("bad 1");

	if ("0" || ++i) j = 1;
	unless (i == 1) puts("bad 2");
}
#lang tcl
op_1_10
} -output {}

test op-1.11 {comma operator} -body {
#lang L -nowarn
int op_1_11_f(int a, int b, int c) { return (b); }
string op_1_11_s(string a, string b, string c, string d)
{
	return ((string)concat(a,b,c,d));
}
void op_1_11()
{
	/*
	 * Check precedence and associativity of comma operator.
	 * Should be the lowest and left associative, and not get
	 * confused with comma as an arg seperator.  Also check that
	 * the value of a,b is b.
	 */

	int	i;
	int	j = 2, k = 0;  // declares j & k; is not a comma op
	int	l = (1,2), m = (1,2,3,4,5);
	string	s;

	unless ((j == 2) && (k == 0)) puts("bad d1");
	unless (l == 2) puts("bad d2");
	unless (m == 5) puts("bad d3");

	i = 1,2;
	unless (i == 1) puts("bad 1");
	unless ((i = 1,2) == 2) puts("bad 2");
	unless (op_1_11_f(1, 2, 3) == 2) puts("bad 3");
	unless (op_1_11_f(1, (2,3), 4) == 3) puts("bad 4");
	unless (op_1_11_s("a", "b", kw:"d") eq "a b -kw d") puts("bad 5");
	unless (op_1_11_s("a", kw:"b", "c") eq "a -kw b c") puts("bad 6");
	unless (op_1_11_s(kw:"a", "b", "c") eq "-kw a b c") puts("bad 7");
	unless (op_1_11_s("a", ("b","c"), kw: "d") eq "a c -kw d") {
		puts("bad 8");
	}

	i = (1,2,3);
	unless (i == 3) puts("bad 10");
	i = (1,2,3,4);
	unless (i == 4) puts("bad 11");
	i = (1,2),(3,4);
	unless (i == 2) puts("bad 12");
	i = ((1,2),(3,4));
	unless (i == 4) puts("bad 13");

	/*
	 * Check that the type of a,b is the type of b.
	 */
	i = ("s", 11);
	unless (i == 11) puts("bad t1");
	s = (1, "s");
	unless (s eq "s") puts("bad t2");

	/*
	 * For loops should just automatically get the use of comma op.
	 */
	i = j = -1;
	for (i=0,j=10; i < 10; ++i,j+=10) ;
	unless ((i == 10) && (j == 110)) puts("bad f1");

	/*
	 * Check that the grammar's special switching of the scanner
	 * to/from a regexp for the split built-in, which happens just
	 * before the comma after the first arg is scanned, works when
	 * the comma operator is present.
	 */
	unless (split("a b c", / /)[1] eq "b") puts("bad s1");
	unless (split("a b c")[1] eq "b") puts("bad s2");
	unless (split(("x y z","a b c"), / /)[1] eq "b") puts("bad s3");
	unless (split(("x y z","a b c"))[1] eq "b") puts("bad s4");
}
#lang tcl
op_1_11
} -output {}

test op-1.12 {test string concat operator} -body {
#lang L
void op_1_12()
{
	string	a, b, c;
	string	as[];
	string	hs{string};
	poly	p;
	struct {
		string	a, b, c;
	} st;

	unless ("a" . "b" eq "ab") puts("bad 1.1");
	unless ("ab" . "cd" eq "abcd") puts("bad 1.2");
	unless ("ab" . "cd" . "ef" eq "abcdef") puts("bad 1.3");
	unless ("ab" . "cd" . "ef" . "gh" eq "abcdefgh") puts("bad 1.4");
	unless ("" . "a" eq "a") puts("bad 1.5");
	unless ("a" . "" eq "a") puts("bad 1.6");
	unless ("" . "a" . "" eq "a") puts("bad 1.7");
	unless ("" . "" . """" . "a" . "" eq "a") puts("bad 1.8");
	unless ("" . "" eq "") puts("bad 1.9");
	unless ("" . "" . "" eq "") puts("bad 1.10");

	a = "a";
	b = "b";
	c = "c";
	unless (a . b . c eq "abc") puts("bad 2.1");

	p = "a";
	unless (p . "b" eq "ab") puts("bad 3.1");

	/* Test precedence. "." should be lower than [], {}, and -> */

	as[0] = "a";
	as[1] = "b";
	as[2] = "c";
	unless (as[0] . as[1] . as[2] eq "abc") puts("bad 10.1");
	hs{"a"} = "a";
	hs{"b"} = "b";
	hs{"c"} = "c";
	unless (hs{"a"} . hs{"b"} . hs{"c"} eq "abc") puts("bad 10.2");
	st.a = "a";
	st.b = "b";
	st.c = "c";
	unless (st.a . st.b . st.c eq "abc") puts("bad 10.3");

	/* Check varying whitespace around the "." */

	unless ("a"  . "b" eq "ab") puts("bad 20.1");
	unless ("a" .  "b" eq "ab") puts("bad 20.2");
	unless ("a"  .  "b" eq "ab") puts("bad 20.3");
	unless ("a"	. "b" eq "ab") puts("bad 20.4");  // tab
	unless ("a" .	"b" eq "ab") puts("bad 20.5");  // tab
	unless ("a" .
		"b" eq "ab") puts("bad 20.6");
	unless ("a"
		. "b" eq "ab") puts("bad 20.7");
	unless ("a" .
		"b" .
		"c" eq "abc") puts("bad 20.8");

	/* Check .= */

	a = "a";
	a .= "bcd";
	unless (a eq "abcd") puts("bad 30.1");
	b = "e";
	unless ((a.=b) eq "abcde") puts("bad 30.2");

	as[0] = "0";
	as[0] .= "123";
	unless (as[0] eq "0123") puts("bad 31.1");

	a = "0234";
	a[0] .= "1";
	unless (a eq "01234") puts("bad 32.1");
}
op_1_12();
} -output {}

test op-1.13 {test string concat type errors} -body {
#lang L
void op_1_13()
{
	int	i, j;
	string	s;
	float	f;
	int	h{string};

	i . j;
	i . f;
	h{"bad"} . i;
	i . "s";
	"s" . f;
	h{"bad"} . "s";

	i .= "s";
	i .= j;
	s .= i;
}
} -returnCodes {error} -match regexp -result {.*8: L Error: expected type string.*
.*9: L Error: expected type string.*
.*10: L Error: expected type string.*
.*11: L Error: expected type string.*
.*12: L Error: expected type string.*
.*13: L Error: expected type string.*
.*15: L Error: expected type string.*
.*16: L Error: expected type string.*
.*17: L Error: assignment of incompatible types
}

test op-1.14 {test "." and "->" as struct selection operators} -body {
#lang L
struct op14 {
       int	i, j;
};
void op_1_14_ref(struct op14 &st)
{
	st->i = 7;
}
void op_1_14_val(struct op14 st)
{
	st.i = 8;
}
void op_1_14()
{
	struct op14 st = { 5, 6 };

	unless (st.i  == 5) puts("bad 1.1");
	unless (st.j  == 6) puts("bad 1.2");

	op_1_14_ref(&st);
	unless (st.i == 7) puts("bad 2.1");

	op_1_14_val(st);
	unless (st.i == 7) puts("bad 3.1");
}
op_1_14();
} -output {}

test op-1.15 {check "." and "->" usage errors} -body {
#lang L
struct op15 {
       int	i, j;
};
void op_1_15_ref(struct op14 &st)
{
	st.i = 7;  // err
}
void op_1_15_val(struct op14 st)
{
	st->i = 8; // err
}
void op_1_15()
{
	struct op14 st;

	st->i = st.j;  // st->i is an err
}
} -returnCodes {error} -match regexp -result {.*6: L Error: \. illegal on call-by-reference parms; use -> instead
.*10: L Error: -> illegal except on call-by-reference parms; use \. instead
.*16: L Error: -> illegal except on call-by-reference parms; use \. instead
}

test op-1.16 {check ? : operator} -body {
#lang L
string op_1_16_f(...args) { return (join("", args)); }
void op_1_16()
{
	int	i;
	float	f;
	string	s;

	/* Check spacing variations. */

	s = "bad";
	0 ? puts("bad 1.1") : (s = "good");
	unless (s eq "good") puts("bad 1.2");

	s = "bad";
	0? puts("bad 2.1") : (s = "good");
	unless (s eq "good") puts("bad 2.2");

	s = "bad";
	0?puts("bad 3.1") : (s = "good");
	unless (s eq "good") puts("bad 3.2");

	s = "bad";
	0?puts("bad 4.1"): (s = "good");
	unless (s eq "good") puts("bad 4.2");

	s = "bad";
	0?puts("bad 5.1"):(s = "good");
	unless (s eq "good") puts("bad 5.2");

	s = "bad";
	1 ? (s = "good") : puts("bad 6.1");
	unless (s eq "good") puts("bad 6.2");

	/* Exactly one of the expressions must ever be executed. */

	i = 0;
	0 ? ++i : ++i;
	unless (i == 1) puts("bad 7.1");
	i = 0;
	1 ? ++i : ++i;
	unless (i == 1) puts("bad 7.2");

	/* Check value. */

	s = 0 ? "bad" : "good";
	unless (s eq "good") puts("bad 10.1");

	s = 1 ? "good" : "bad";
	unless (s eq "good") puts("bad 11.1");

	/*
	 * Check typing.  If either expr is a float and the other is compatible
	 * with that, we get a float.  If either is a poly, we get a poly.
	 */

	f = 0 ? 0 : 3.14;
	unless (f == 3.14) puts("bad 12.1");
	f = 1 ? 6.28 : 0;
	unless (f == 6.28) puts("bad 12.2");
	f = 1 ? 1.11 : 0.0;
	unless (f == 1.11) puts("bad 12.3");
	f = 1 ? 12 : -1;
	unless (f == 12) puts("bad 12.4");

	s = "bad";
	s = 0 ? "bad" : (poly)13;
	unless (s eq "13") puts("bad 12.5");
	s = "bad";
	s = 1 ? (poly)13 : "bad";
	unless (s eq "13") puts("bad 12.6");

	/*
	 * Check precedence -- ? : should be between = and || in the
	 * precedence hierarchy.
	 */
	i = 1 ? 1 || puts("bad 20.1") : 1 || puts("bad 20.2");

	/* Should have no confusion with the opt: argument syntax. */
	s = op_1_16_f(o1: 0 ? "bad": "good", o2: "3");
	unless (s eq "-o1good-o23") puts("bad 20.3");

	/*
	 * This checks that the run-time stack is kept balanced when
	 * the value of the ternary expression is ignored (if it's
	 * not, we'll probably crash).
	 */
	for (i = 0; i < 10000; ++i) {
		0 ? 1 : 2;
		(0 ? 1 : 2) , (0 ? 1 : 2);
	}

	/* Try some nested ?: */
	i = 0 ? 1 ? 11:12 : 13;
	unless(i == 13) puts("bad 30.1");
	i = 1 ? 1 ? 11:12 : 13;
	unless(i == 11) puts("bad 30.2");
	i = 1 ? 0 ? 11:12 : 13;
	unless(i == 12) puts("bad 30.3");
}
op_1_16();
} -output {}

test op-1.17 {check type errors in ? : operator} -body {
#lang L
void op_1_17()
{
	int	i;
	float	f;
	string	s;

	s = 0 ? 1 : 2;
	i = 0 ? "a" : "b";
	f = 0 ? "a" : "b";

	/* The type of these ?: is float. */
	i = 0 ? f : i;
	i = 0 ? i : f;
	i = 0 ? f : f;

	/* These have exprs with incompatible types. */
	s = 0 ? 1 : "2";
	s = 0 ? "1" : 2;
}
} -returnCodes {error} -match regexp -result {.*7: L Error: assignment of incompatible types
.*8: L Error: assignment of incompatible types
.*9: L Error: assignment of incompatible types
.*12: L Error: assignment of incompatible types
.*13: L Error: assignment of incompatible types
.*14: L Error: assignment of incompatible types
.*17: L Error: incompatible types in \? : expressions
.*18: L Error: incompatible types in \? : expressions
}

test cast-1.0 { Casts to integer and float } -body {
#lang L
void cast_1_0() {
    printf("%d\n", (int)1.9);
    printf("%f\n", (float)5);
}
#lang tcl
cast_1_0
} -output "1\n5.000000\n"

test cast-1.1 { Invalid cast from string to int } -body {
#lang L
void cast_1_1() {
    printf("%d\n", (int)"asdf");
}
#lang tcl
cast_1_1
} -returnCodes {error} -result {expected number but got "asdf"}

test cast-1.2 { Invalid cast from string to float } -body {
#lang L
void cast_1_2() {
    printf("%f\n", (float)"asdf");
}
#lang tcl
cast_1_2
} -returnCodes {error} -result {expected floating-point number but got "asdf"}

test cast-1.3 { Cast to string } -body {
#lang L
void cast_1_3()
{
	string	s;
	poly	p = "p";
	int	a[] = { 1, 2 };
	int	h{string} = { "a"=>1, "b"=>2 };
	struct { int i,j; } st = { 5, 6 };

	/* This checks not only cast functionality but also type checking. */

	s = (string)1;
	unless (s eq "1") puts("bad 1");

	s = (string)3.14159;
	unless (s =~ /3.14159/) puts("bad 2");

	s = (string)"ok";
	unless (s eq "ok") puts("bad 3");

	s = (string)a;
	unless (s eq "1 2") puts("bad 5");

	s = (string)h;
	unless (s eq "a 1 b 2") puts("bad 6");

	s = (string)st;
	unless (s eq "5 6") puts("bad 7");

	s = (string)p;
	unless (s eq "p") puts("bad 8");
}
#lang tcl
cast_1_3
} -output {}

test cast-1.4 { Invalid cast from function } -body {
#lang L
void cast_1_4()
{
	int	i;
	float	f;
	string	s;
	int	h{string};

	i = (int)cast_1_4;
	f = (float)cast_1_4;
	s = (string)cast_1_4;
	s = (tcl)cast_1_4;
	h = (hash)cast_1_4;
}
#lang tcl
cast_1_4
} -returnCodes {error} -match regexp -result {.*8: L Error: type function illegal
.*9: L Error: type function illegal
.*10: L Error: type function illegal
.*11: L Error: type function illegal
.*12: L Error: type function illegal
}

test cast-1.5 {cast to hash} -body {
#lang L
void cast_1_5()
{
	int	n = 0;
	string	k;
	string	a[] = { "k1","v1", "k2","v2", "k3","v3" };
	poly	h{poly};

	h = (hash)a;
	unless (h{"k1"} eq "v1") puts("bad 1");
	unless (h{"k2"} eq "v2") puts("bad 2");
	unless (h{"k3"} eq "v3") puts("bad 3");
	foreach (k in h) ++n;
	unless (n == 3) puts("bad 4");
}
#lang tcl
cast_1_5
} -output {}

test cast-1.6 {cast to various structured types} -body {
#lang L
struct s {
	int	i;
	string	s;
	struct {
		string	h{int};
		int	i;
	} st;
};
void cast_1_6()
{
	struct s	st;
	int		a[], i, n;
	string		h{int};

	/* Cast a string to a struct s. */
	st = (struct s)"1 str { { 1 one 2 two } 33 }";
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 1");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 2");
	unless (st.st.i == 33) puts("bad 3");

	/* Same as above except casting from a composite constant. */
	st = (struct s) {
			  1,
			  "str",
			  {
				  { 1=>"one", 2=>"two" },
				  33
			  }
	};
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 4");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 5");
	unless (st.st.i == 33) puts("bad 6");

	/* Cast a string to a struct s but spell out the entire struct type. */
	st = (struct { int i; string s; struct { string h{int}; int i; } st; })
		"1 str { { 1 one 2 two } 33 }";
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 7");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 8");
	unless (st.st.i == 33) puts("bad 9");

	/* Same as above except casting from a composite constant. */
	st = (struct { int i; string s; struct { string h{int}; int i; } st; })
		{
			  1,
			  "str",
			  {
				  { 1=>"one", 2=>"two" },
				  33
			  }
		};
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 10");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 11");
	unless (st.st.i == 33) puts("bad 12");

	a = (int[])"1 2 3";
	n = 0;
	foreach (i in a) {
		unless (i == (n+1)) puts("bad 10");
		++n;
	}
	if (n != 3) puts("bad 11");

	h = (string{int})"1 one 2 two 3 three";
	unless ((h{1} eq "one") && (h{2} eq "two") && (h{3} eq "three")) {
		puts("bad 20");
	}
	n = 0;
	foreach (i in h) ++n;
	unless (n == 3) puts("bad 21");
}
#lang tcl
cast_1_6
} -output {}

test array-1.0 { Single-dimensional array creation and indexing } -body {
#lang L
void array_1_0() {
    int array[3];

    array[0] = 1;
    array[1] = 2;
    array[2] = 3;
    puts(array[2]);
}
#lang tcl
array_1_0
} -output "3\n"

test array-1.1 { Multi-dimensional array creation and indexing } -body {
#lang L
void array_1_1() {
    int array[4][3][2];

    puts(array);
    array[0][0][0] = 1;
    array[1][1][1] = 2;
    array[2][2][0] = 3;
    array[3][0][1] = 4;
    puts(array);
}
#lang tcl
array_1_1
} -output "
1 {{} {{} 2}} {{} {} 3} {{{} 4}}\n"


test array-1.2 {increment and decrement on array elements} -body {
#lang L
void array_1_2() {
  int foo[5] = {0,0,0,0,0};

  foo[3] = 0;
  for (foo[3]=0; foo[3]<5; foo[3]++);
  puts(foo);

  puts("pre:");
  puts(foo[3]);
  ++foo[3];
  puts(foo[3]);
  puts(++foo[3]);
  --foo[3];
  puts(foo[3]);
  puts(--foo[3]);

  puts("post:");
  puts(foo[3]);
  foo[3]++;
  puts(foo[3]);
  puts(foo[3]++);
  puts(foo[3]);
  foo[3]--;
  puts(foo[3]);
  puts(foo[3]--);
  puts(foo[3]);
  puts(foo);
}
#lang tcl
array_1_2
} -output "0 0 0 5 0\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n0 0 0 5 0\n"

test array-1.3 {1d arrays with no length auto-extend by one at a time} -body {
#lang L
void array_1_3() {
  int foo[];

  foo[0] = 4;
  foo[1] = 5;
  foo[2] = 6;
  puts(foo);
}
#lang tcl
array_1_3
} -output "4 5 6\n"

test array-1.4 {extend arrays using push and pop} -body {
#lang L
void array_1_4() {
  int foo[];

  push(&foo, 1);
  push(&foo, 2);
  push(&foo, 3);
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
}
#lang tcl
array_1_4
} -output "1 2 3\n3\n1 2\n2\n1\n1\n\n\n\n"

test strindex-1 {string indexing} -body {
#lang L
void strindex_1()
{
	int	i;
	string	s, s2;
	struct {
		string	s;
	} st;
	string	sa[];
	string	sh{string};

	s = "abcd";
	s[0] = "x";
	unless (s eq "xbcd") puts("bad 1.1");
	s[1] = "y";
	unless (s eq "xycd") puts("bad 1.2");
	s[2] = "z";
	unless (s eq "xyzd") puts("bad 1.3");
	s[3] = "q";
	unless (s eq "xyzq") puts("bad 1.4");
	s[3] = "";
	unless (s eq "xyz") puts("bad 1.5");
	s[0] = "";
	unless (s eq "yz") puts("bad 1.6");
	s[0] = "";
	unless (s eq "z") puts("bad 1.7");
	s[0] = "";
	unless (s eq "") puts("bad 1.8");
	s = "abcd";
	if (defined(s[4])) puts("bad 1.9");

	st.s = "abcd";
	st.s[0] = "x";
	unless (st.s eq "xbcd") puts("bad 2.1");
	st.s[1] = "y";
	unless (st.s eq "xycd") puts("bad 2.2");
	st.s[2] = "z";
	unless (st.s eq "xyzd") puts("bad 2.3");
	st.s[3] = "q";
	unless (st.s eq "xyzq") puts("bad 2.4");
	st.s[3] = "";
	unless (st.s eq "xyz") puts("bad 2.5");
	st.s[0] = "";
	unless (st.s eq "yz") puts("bad 2.6");
	st.s[0] = "";
	unless (st.s eq "z") puts("bad 2.7");
	st.s[0] = "";
	unless (st.s eq "") puts("bad 2.8");
	st.s = "abcd";
	if (defined(st.s[4])) puts("bad 2.9");

	sa[0] = "abcd";
	sa[0][0] = "x";
	unless (sa[0] eq "xbcd") puts("bad 3.1");
	sa[0][1] = "y";
	unless (sa[0] eq "xycd") puts("bad 3.2");
	sa[0][2] = "z";
	unless (sa[0] eq "xyzd") puts("bad 3.3");
	sa[0][3] = "q";
	unless (sa[0] eq "xyzq") puts("bad 3.4");
	sa[0][3] = "";
	unless (sa[0] eq "xyz") puts("bad 3.5");
	sa[0][0] = "";
	unless (sa[0] eq "yz") puts("bad 3.6");
	sa[0][0] = "";
	unless (sa[0] eq "z") puts("bad 3.7");
	sa[0][0] = "";
	unless (sa[0] eq "") puts("bad 3.8");
	sa[0] = "abcd";
	if (defined(sa[0][4])) puts("bad 3.9");

	sh{"zero"} = "abcd";
	sh{"zero"}[0] = "x";
	unless (sh{"zero"} eq "xbcd") puts("bad 4.1");
	sh{"zero"}[1] = "y";
	unless (sh{"zero"} eq "xycd") puts("bad 4.2");
	sh{"zero"}[2] = "z";
	unless (sh{"zero"} eq "xyzd") puts("bad 4.3");
	sh{"zero"}[3] = "q";
	unless (sh{"zero"} eq "xyzq") puts("bad 4.4");
	sh{"zero"}[3] = "";
	unless (sh{"zero"} eq "xyz") puts("bad 4.5");
	sh{"zero"}[0] = "";
	unless (sh{"zero"} eq "yz") puts("bad 4.6");
	sh{"zero"}[0] = "";
	unless (sh{"zero"} eq "z") puts("bad 4.7");
	sh{"zero"}[0] = "";
	unless (sh{"zero"} eq "") puts("bad 4.8");
	sh{"zero"} = "abcd";
	if (defined(sh{"zero"}[4])) puts("bad 4.9");

	s = "abcd";
	s[1] =~ s/n/nochange/;
	unless (s eq "abcd") puts("bad 5.1");
	s[0] =~ s/n/nochange/;
	unless (s eq "abcd") puts("bad 5.2");
	s[3] =~ s/n/nochange/;
	unless (s eq "abcd") puts("bad 5.3");
	s[0] =~ s/a/was-a/;
	unless (s eq "was-abcd") puts("bad 5.4");
	s[5] =~ s/b/was-b/;
	unless (s eq "was-awas-bcd") puts("bad 5.5");
	s[11] =~ s/d/was-d/;
	unless (s eq "was-awas-bcwas-d") puts("bad 5.6");
	s[0] =~ s/w//;
	unless (s eq "as-awas-bcwas-d") puts("bad 5.7");
	s[0] =~ s/a//;
	unless (s eq "s-awas-bcwas-d") puts("bad 5.8");
	s[1] =~ s/-//;
	unless (s eq "sawas-bcwas-d") puts("bad 5.9");
	s[12] =~ s/d//;
	unless (s eq "sawas-bcwas-") puts("bad 5.10");

	s = "0123456789";
	for (i = 0; i < 10; ++i) {
		s[i] =~ s/${i}/${i+1}/;
	}
	unless (s eq "12345678910") puts("bad 6.1");

	/*
	 * Ensure that an un-shared copy of the string is made.
	 */
	s = "xyzzy";
	s2 = s;  // s2 and s now share the same Tcl_Obj
	s[1] = "x";
	unless (s eq "xxzzy") puts("bad 7.1");
	unless (s2 eq "xyzzy") puts("bad 7.2");
}
strindex_1();
} -output {}

test strindex-2 {string indexing errors 1} -body {
#lang L
void strindex_2()
{
	string	s = "bad";
	s[-1] = "x";  // run-time error
}
strindex_2();
} -returnCodes error -result {negative string index illegal}

test strindex-3 {string indexing errors 2} -body {
#lang L
void strindex_3()
{
	string	s = "bad";
	puts (s[-1]);  // run-time error
}
strindex_3();
} -returnCodes error -result {negative string index illegal}

test strindex-4 {string indexing errors 3} -body {
#lang L
void strindex_4()
{
	string	s = "bad";
	s[-1] =~ s/b/bad/;  // run-time error
}
strindex_4();
} -returnCodes error -result {negative string index illegal}

test strindex-5 {string indexing index using comma expression} -body {
#lang L
void strindex_5()
{
	/*
	 * This checks an obscure case to ensure that a string index
	 * whose value is discarded -- the first expression in a comma
	 * expression -- is compiled properly.
	 */

	string	s = "abcde";

	/* The value of "fgh"[0] is discarded in the "s" index expression. */
	unless (s[ "fgh"[0], 2 ] eq "c") puts("bad 1");
}
strindex_5();
} -output {}

test strindex-6 {writing to a string index beyond end of string} -body {
#lang L
void strindex_6()
{
	string	s = "good";
	s[END+2] = "bad";  // run-time error
}
strindex_6();
} -returnCodes error -result {index is more than one past end of string}

test slice-1 {string slicing} -body {
#lang L
string slice_1_f(string s) { return (s); }
void slice_1()
{
	int	i, j;
	string	s;

	s = "";
	unless (s[0..0] eq "") puts("bad 1.1");

	s = "a";
	unless (s[0..0] eq "a") puts("bad 2.1");

	s = "abcdefg";
	unless (s[0..0] eq "a") puts("bad 3.1");
	unless (s[0..1] eq "ab") puts("bad 3.2");
	unless (s[0..2] eq "abc") puts("bad 3.3");
	unless (s[0..3] eq "abcd") puts("bad 3.4");
	unless (s[0..4] eq "abcde") puts("bad 3.5");
	unless (s[1..1] eq "b") puts("bad 3.6");
	unless (s[1..2] eq "bc") puts("bad 3.7");
	unless (s[1..3] eq "bcd") puts("bad 3.8");
	unless (s[1..4] eq "bcde") puts("bad 3.9");
	unless (s[2..2] eq "c") puts("bad 3.10");
	unless (s[2..3] eq "cd") puts("bad 3.11");
	unless (s[2..4] eq "cde") puts("bad 3.12");
	unless (s[3..3] eq "d") puts("bad 3.13");
	unless (s[3..4] eq "de") puts("bad 3.14");
	unless (s[4..4] eq "e") puts("bad 3.15");
	unless (s[0..10] eq "abcdefg") puts("bad 3.20");
	unless (s[-1..0] eq "a") puts("bad 3.21");
	unless (s[-1..1] eq "ab") puts("bad 3.22");
	unless (s[-1..10] eq "abcdefg") puts("bad 3.23");
	unless (s[2..1] eq "") puts("bad 3.24");

	s = "0123456789";
	unless (s[2..4][0..0] eq "2") puts("bad 4.1");
	unless (s[2..4][1..1] eq "3") puts("bad 4.2");
	unless (s[1..8][1..6][1..4][1..2] eq "45") puts("bad 4.3");

	s = "0123456789";
	unless (slice_1_f(s)[2..4][0..0] eq "2") puts("bad 5.1");
	unless (slice_1_f(s)[2..4][1..1] eq "3") puts("bad 5.2");
	unless (slice_1_f(s)[1..8][1..6][1..4][1..2] eq "45") puts("bad 5.3");

	s = "0123456789";
	i = 2;
	j = 4;
	unless (s[i..j] eq "234") puts("bad 6.1");
	unless (s[i-1..j] eq "1234") puts("bad 6.2");
	unless (s[i-1..j+1] eq "12345") puts("bad 6.3");
}
slice_1();
} -output {}

test slice-2 {array slicing} -body {
#lang L
string slice_2_tostr(int a[])
{
	int	i;
	string	ret = "";

	foreach (i in a) ret = sprintf("%s<%i>", ret, i);
	return (ret);
}
void slice_2()
{
	int	ai[];
	string	s;

	ai = { 0, 1, 2, 3, 4 };
	unless (slice_2_tostr(ai[0..0]) eq "<0>") puts("bad 1.1");
	unless (slice_2_tostr(ai[0..1]) eq "<0><1>") puts("bad 1.2");
	unless (slice_2_tostr(ai[0..2]) eq "<0><1><2>") puts("bad 1.3");
	unless (slice_2_tostr(ai[0..3]) eq "<0><1><2><3>") puts("bad 1.4");
	unless (slice_2_tostr(ai[0..4]) eq "<0><1><2><3><4>") puts("bad 1.5");
	unless (slice_2_tostr(ai[1..1]) eq "<1>") puts("bad 1.6");
	unless (slice_2_tostr(ai[1..2]) eq "<1><2>") puts("bad 1.7");
	unless (slice_2_tostr(ai[1..3]) eq "<1><2><3>") puts("bad 1.8");
	unless (slice_2_tostr(ai[1..4]) eq "<1><2><3><4>") puts("bad 1.9");
	unless (slice_2_tostr(ai[2..2]) eq "<2>") puts("bad 1.10");
	unless (slice_2_tostr(ai[2..3]) eq "<2><3>") puts("bad 1.11");
	unless (slice_2_tostr(ai[2..4]) eq "<2><3><4>") puts("bad 1.12");
	unless (slice_2_tostr(ai[3..3]) eq "<3>") puts("bad 1.13");
	unless (slice_2_tostr(ai[3..4]) eq "<3><4>") puts("bad 1.14");
	unless (slice_2_tostr(ai[4..4]) eq "<4>") puts("bad 1.15");

	s = slice_2_tostr(ai[0..3][0..2]);
	unless (s eq "<0><1><2>") puts("bad 2.1");
	s = slice_2_tostr(ai[0..3][0..2][0..1]);
	unless (s eq "<0><1>") puts("bad 2.2");
	s = slice_2_tostr(ai[0..3][0..2][0..1][0..0]);
	unless (s eq "<0>") puts("bad 2.3");

	s = slice_2_tostr(ai[1..3][0..2]);
	unless (s eq "<1><2><3>") puts("bad 3.1");
	s = slice_2_tostr(ai[1..3][0..1]);
	unless (s eq "<1><2>") puts("bad 3.2");
	s = slice_2_tostr(ai[1..3][0..2][0..2][0..2][0..2]);
	unless (s eq "<1><2><3>") puts("bad 3.3");

	/* Check expressions as slice indices. */
	s = slice_2_tostr(ai[1-1..2+1][0*10..2]);
	unless (s eq "<0><1><2>") puts("bad 4.1");
	s = slice_2_tostr(ai[1-1..ai[2..2][0]+1][0*10..ai[2]]);
	unless (s eq "<0><1><2>") puts("bad 4.2");

	/* Check slices of lists. */
	s = slice_2_tostr({0,1,2,3,4}[1..3]);
	unless (s eq "<1><2><3>") puts("bad 5.1");
}
slice_2();
} -output {}

test slice-2.1 {array slicing 2} -body {
#lang L
void slice_2_1()
{
	/*
	 * Althgouh probably not recommended style, these should work.
	 */

	struct s1 {
		int	i1, i2, i3, i4;
	} st1;
	struct s2 {
		int	i1, i2;
	} st2;

	st2 = (struct s2){1,2,3,4}[1..2];
	unless ((st2.i1 == 2) && (st2.i2 == 3)) puts("bad 1");

	st1 = { 5, 6, 7, 8 };
	st2 = (struct s2) ((int[])st1)[1..2];
	unless ((st2.i1 == 6) && (st2.i2 == 7)) puts("bad 2");
}
slice_2_1();
} -output {}

test slice-3 {array slice errors} -body {
#lang L
void slice_3()
{
	int	i;
	float	f;
	struct {
		int	i, j;
	} st;
	int	h{int};

	i = i[0..1];
	f = f[0..1];
	i = st[0..1];
	i = h[0..1];
}
} -returnCodes error -match regexp -result {.*10: L Error: illegal type for slice
.*11: L Error: illegal type for slice
.*12: L Error: illegal type for slice
.*13: L Error: illegal type for slice
}

test slice-4 {array slice index errors} -body {
#lang L
void slice_4()
{
	int	a[], i;
	float	f;

	i = a[0.0..1];
	i = a[0..1.0];
	i = a[0.0..1.0];
	i = a[f..1];
	i = a[0..f];
	i = a[f..f];
	i = a[a..a];

	a[0..1] = { 0, 1 };  // invalid l-value
}
} -returnCodes error -match regexp -result {.*6: L Error: first slice index not an int
.*7: L Error: second slice index not an int
.*8: L Error: first slice index not an int
.*8: L Error: second slice index not an int
.*9: L Error: first slice index not an int
.*10: L Error: second slice index not an int
.*11: L Error: first slice index not an int
.*11: L Error: second slice index not an int
.*12: L Error: first slice index not an int
.*12: L Error: second slice index not an int
.*14: L Error: invalid l-value in assignment
}

test end-1 {test END keyword for string indices} -body {
#lang L
int end_1_f(int end) {
	unless ("abc"[END] eq "c") puts("bad f.1");
	return (end);
}
void end_1()
{
	int	e1, e2, e3;
	string	s, s1, s2, s3;
	string	as[];

	/* Ensure END works and can be used in a full-blown expression. */
	s = "abcde";
	as[0] = "123";
	as[1] = "456";
	as[2] = "789";
	unless (s[END] eq "e") puts("bad 1.1");
	unless (s[END-1] eq "d") puts("bad 1.2");
	unless (s[END-2] eq "c") puts("bad 1.3");
	unless (s[END/2+2] eq "e") puts("bad 1.4");
	unless (s[end_1_f(END)/2+2] eq "e") puts("bad 1.5");
	unless (s[END-END+END-END+END*0+END] eq "e") puts("bad 1.6");
	unless ("xyz123"[END] eq "3") puts("bad 1.7");

	/*
	 * These check END for something that is represented on the
	 * run-time stack as an L deep-ptr (as[0]).
	 */
	unless (as[0][END] eq "3") puts("bad 1.8");
	unless (as[1][END] eq "6") puts("bad 1.9");
	unless (as[2][END] eq "9") puts("bad 1.10");

	/* Grab the value of END and verify it. */
	e1 = -1;
	s = "abcde";
	unless (s[0,e1=END] eq "e") puts("bad 2.1");
	unless (e1 == 4) puts("bad 2.2");
	e1 = -1;
	unless (s[e1=END,0] eq "a") puts("bad 2.3");
	unless (e1 == 4) puts("bad 2.4");

	/* Check nested ENDs. */
	e1 = e2 = -1;
	s1 = "abcde"[ s2="fgh"[e2=END], e1=END ];
	unless ((s1 eq "e") && (s2 eq "h")) puts("bad 3.1");
	unless ((e1 == 4) && (e2 == 2)) puts("bad 3.2");
	e1 = e2 = -1;
	s1 = "abcde"[ s2="fgh"[ s3="pqrstuvwxyz"[e3=END], e2=END ], e1=END ];
	unless ((s1 eq "e") && (s2 eq "h") && (s3 eq "z")) puts("bad 3.3");
	unless ((e1 == 4) && (e2 == 2) && (e3 == 10)) puts("bad 3.4");
}
end_1();
} -output {}

test end-2 {test END keyword for arrays} -body {
#lang L
int end_2_f(int end) {
	unless ({7,8,9}[END] == 9) puts("bad f.1");
	return (end);
}
void end_2()
{
	int	e1, e2, e3, i1, i2, i3;
	int	a[], aa[][];

	/* Ensure END works and can be used in a full-blown expression. */
	a = {1,2,3};
	unless (a[END] == 3) puts("bad 1.1");
	unless (a[END-1] == 2) puts("bad 1.2");
	unless (a[END-2] == 1) puts("bad 1.3");
	unless (a[END/2] == 2) puts("bad 1.4");
	unless (a[END/2+END/2] == 3) puts("bad 1.5");
	unless (a[END-END-END-END+END+END] == 1) puts("bad 1.6");
	unless (a[end_1_f(END)/2+1] == 3) puts("bad 1.7");
	unless ({1,2,3}[END] == 3) puts("bad 1.8");
	unless ({1,2,3}[END-1] == 2) puts("bad 1.9");
	unless ({1,2,3}[END-2] == 1) puts("bad 1.10");

	/*
	 * These check END for something that is represented on the
	 * run-time stack as an L deep-ptr (aa[0]).
	 */
	aa[0] = {4,5,6};
	aa[1] = {7,8,9};
	aa[2] = {10,11,12};
	unless (aa[0][END] == 6) puts("bad 2.1");
	unless (aa[1][END] == 9) puts("bad 2.2");
	unless (aa[2][END] == 12) puts("bad 2.3");

	/* Grab the value of END and verify it. */
	e1 = -1;
	a = {1,2,3};
	unless (a[0,e1=END] == 3) puts("bad 3.1");
	unless (e1 == 2) puts("bad 3.2");
	e1 = -1;
	unless (a[e1=END,0] == 1) puts("bad 3.3");
	unless (e1 == 2) puts("bad 3.4");
	e1 = -1;
	if (defined({}[e1=END])) puts("bad 3.5");
	unless (e1 == -1) puts("bad 3.6");

	/* Check nested ENDs. */
	e1 = e2 = e3 = -1;
	i1 = {1,2,3}[ i2={4,5,6,7}[e2=END], e1=END ];
	unless ((i1 == 3) && (i2 == 7)) puts("bad 4.1");
	unless ((e1 == 2) && (e2 == 3)) puts("bad 4.2");
	e1 = e2 = e3 = -1;
	i1 = {1,2,3}[ i2={4,5,6,7}[ i3={8,9}[e3=END], e2=END ], e1=END ];
	unless ((i1 == 3) && (i2 == 7) && (i3 == 9)) puts("bad 4.3");
	unless ((e1 == 2) && (e2 == 3) && (e3 == 1)) puts("bad 4.4");

	/* Some multiple ENDs. */
	aa = { {1,2,3}, {4,5,6}, {7,8,9}, {10,11,12} };
	e1 = e2 = -1;
	unless (aa[e1=END][e2=END] == 12) puts("bad 5.1");
	unless ((e1 == 3) && (e2 == 2)) puts("bad 5.2");
}
end_2();
} -output {}

test end-3 {test END usage for string append} -body {
#lang L
void end_3()
{
	int	i;
	string	s;
	string	atoz="abcdefghijklmnopqrstuvwxyz";

	s = "";
	for (i = 0; i < 26; ++i) {
		s[END+1] = atoz[i];
	}
	for (i = 0; i < 26; ++i) {
		unless (s[i] eq atoz[i]) printf("bad 1.1 i=%d", i);
	}
	if (defined(s[i])) puts("bad 1.2");
	unless (s eq "abcdefghijklmnopqrstuvwxyz") puts("bad 1.3");
}
end_3();
} -output {}

test end-4 {test END usage for array append} -body {
#lang L
void end_4()
{
	int	e1, e2, i;
	int	a[], aa[][];

	a = {};
	for (i = 0; i < 100; ++i) {
		a[END+1] = i;
	}
	for (i = 0; i < 100; ++i) {
		unless (a[i] == i) printf("bad 1.1 i=%d\n", i);
	}
	if (defined(a[i])) puts("bad 1.2");

	aa = {};
	e1 = e2 = -2;
	aa[(e1=END)+1][(e2=END)+1] = 100;
	unless ((e1 == -1) && (e2 == -1)) puts("bad 2.1");
	unless (aa[e1=END][e2=END] == 100) puts("bad 2.2");
	unless ((e1 == 0) && (e2 == 0)) puts("bad 2.3");

	aa = {};
	for (i = 0; i < 10; ++i) {
		aa[END+1][END+1] = i;
		aa[END][END+1]   = 10*i;
	}
	for (i = 0; i < 10; ++i) {
		unless (aa[i][0] == i) puts("bad 3.1");
		unless (aa[i][1] == 10*i) puts("bad 3.2");
		if (defined(aa[i][2])) puts("bad 3.3");
	}
	if (defined(aa[i][0])) puts("bad 3.4");
}
end_4();
} -output {}

test end-5 {test END with recursion} -body {
#lang L
int end_5_f(int lim, int n)
{
	int	a[], e, i;

	/* Put n things into a[]. */
	for (i = 0; i < n; ++i) a[END+1] = i;

	if (n < lim) {
		/* e should get END+1; i.e., the # of things in a[] */
		a[e = (END+end_5_f(lim,n+1)+END)/2 + 1];
		unless (e == n) printf("bad n=%d, e=%d\n", n, e);
	}
	return (0);
}
void end_5()
{
	/*
	 * This test makes sure we can have lots of different ENDs all
	 * stacked up at once.
	 */
	end_5_f(100, 0);
}
end_5();
} -output {}

test end-6 {test END errors} -body {
#lang L
int END;  // err -- cannot declare global w/name "END"
void END() {}  // err -- cannot declare function w/name "END"
void end_6()
{
	int	END, i;  // err -- cannot declare variable w/name "END"

	i = END;  // err -- cannot use END outside of an array or string index
}
} -returnCodes error -match regexp -result {.*1: L Error: cannot use END.*
.*2: L Error: cannot use END.*
.*5: L Error: cannot use END.*
.*7: L Error: END illegal.*
}

test end-7 {test END in string slices} -body {
#lang L
void end_7()
{
	string	s;

	s = "123456789";
	unless (s[0..END] eq "123456789") puts("bad 1.0");
	unless (s[0..END] eq s) puts("bad 1.1");
	unless (s[1..END] eq "23456789") puts("bad 1.2");
	unless (s[2..END] eq "3456789") puts("bad 1.3");
	unless (s[2..END-1] eq "345678") puts("bad 1.4");
	unless (s[2..END-2] eq "34567") puts("bad 1.5");
	unless (s[END-1..END] eq "89") puts("bad 1.6");
	unless (s[END-1..END-1] eq "8") puts("bad 1.7");
}
end_7();
} -output {}

test end-8 {test END in array slices} -body {
#lang L
void end_8()
{
	string	a[];

	a = { "1", "2", "3", "4", "5", "6" };
	unless (join(" ", a[0..END]) eq "1 2 3 4 5 6") puts("bad 1.1");
	unless (join(" ", a[1..END]) eq "2 3 4 5 6") puts("bad 1.2");
	unless (join(" ", a[2..END]) eq "3 4 5 6") puts("bad 1.3");
	unless (join(" ", a[2..END-1]) eq "3 4 5") puts("bad 1.4");
	unless (join(" ", a[2..END-2]) eq "3 4") puts("bad 1.5");
	unless (join(" ", a[END-1..END]) eq "5 6") puts("bad 1.6");
	unless (join(" ", a[END-1..END-1]) eq "5") puts("bad 1.7");
}
end_8();
} -output {}

test end-10 {check END ignored in comma expression} -body {
#lang L
void end_10()
{
	int	i;
	int	a[] = {1,2,3};

	/*
	 * This tests that an ignored END does not leave anything on
	 * the run-time stack (which would case a crash).
	 */
	for (i = 0; i < 100; ++i) a[END,0];
}
end_10();
} -output {}

test loop-1.0 {while loops} -body {
#lang L
void loop_1_0() {
        int i = 0;
        while (i++ < 5) puts (i);
        while (i) {
                int j = i--;
                puts(j);
        }
}
#lang tcl
loop_1_0
} -output "1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\n"
test loop-1.1 {for loops} -body {
#lang L
void loop_1_1() {
        int i;
        for (i=1; i<7; i++) {
                puts(i);
        }
        puts("-*-");
        for ( ; i; i--) {
                puts(i);
        }
}
#lang tcl
loop_1_1
} -output "1\n2\n3\n4\n5\n6\n-*-\n7\n6\n5\n4\n3\n2\n1\n"

test loop-1.2 {do loops} -body {
#lang L
void loop_1_2()
{
	int	i;

	/* Do loops must iterate at least once. */
	i = 0;
	do {
		++i;
	} while (0);
	unless (i == 1) puts("bad 1");

	i = 0;
	do {
		++i;
		puts(i);
	} while (i < 4);
}
#lang tcl
loop_1_2
} -output "1\n2\n3\n4\n"

test loop-1.2.0 {simple foreach loops} -body {
#lang L
struct sl120 {
	int	i;
	int	j;
	string	s;
};
void
loop_1_2_0()
{
	int	k, vi;
	string	vs;
	float	vf;
	hash	h0 = { };
	hash	h1 = { 0=>1 };
	hash	h2 = { 0=>1, 1=>2 };
	hash	h3 = { 0=>1, 1=>2, 2=>3 };
	int	ai0[];
	int	ai1[1] = { 11 };
	int	ai2[2] = { 22, 23 };
	int	ai3[3] = { 33, 34, 35 };
	string	as0[0];
	string	as1[1] = { "a" };
	string	as2[2] = { "b", "c" };
	string	as3[3] = { "d", "e", "f" };
	float	af0[0];
	float	af1[1] = { 1.1 };
	float	af2[2] = { 2.1, 2.2 };
	float	af3[3] = { 3.1, 3.2, 3.3 };
	struct sl120	vc;
	struct sl120	ac[3];

	printf("start\n");
	foreach (k in h0) {
		printf("h0 has %d\n", k);
	}
	foreach (k in h1) {
		printf("h1 has %d\n", k);
	}
	foreach (k in h2) {
		printf("h2 has %d\n", k);
	}
	foreach (k in h3) {
		printf("h3 has %d\n", k);
	}
	foreach (k=>vi in h0) {
		printf("h0 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h1) {
		printf("h1 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h2) {
		printf("h2 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h3) {
		printf("h3 has %d=>%d\n", k, vi);
	}
	foreach (vi in ai0) {
		printf("ai0 has %d\n", vi);
	}
	foreach (vi in ai1) {
		printf("ai1 has %d\n", vi);
	}
	foreach (vi in ai2) {
		printf("ai2 has %d\n", vi);
	}
	foreach (vi in ai3) {
		printf("ai3 has %d\n", vi);
	}
	foreach (vs in as0) {
		printf("as0 has %s\n", vs);
	}
	foreach (vs in as1) {
		printf("as1 has %s\n", vs);
	}
	foreach (vs in as2) {
		printf("as2 has %s\n", vs);
	}
	foreach (vs in as3) {
		printf("as3 has %s\n", vs);
	}
	foreach (vf in af0) {
		printf("af0 has %1.1f\n", vf);
	}
	foreach (vf in af1) {
		printf("af1 has %1.1f\n", vf);
	}
	foreach (vf in af2) {
		printf("af2 has %1.1f\n", vf);
	}
	foreach (vf in af3) {
		printf("af3 has %1.1f\n", vf);
	}
	foreach (vf in ai0) {
		printf("ai0 has %1.1f\n", vf);
	}
	foreach (vf in ai1) {
		printf("ai1 has %1.1f\n", vf);
	}
	foreach (vf in ai2) {
		printf("ai2 has %1.1f\n", vf);
	}
	foreach (vf in ai3) {
		printf("ai3 has %1.1f\n", vf);
	}
	ac[0].i = 1;
	ac[0].j = 2;
	ac[0].s = "a";
	ac[1].i = 11;
	ac[1].j = 22;
	ac[1].s = "aa";
	ac[2].i = 111;
	ac[2].j = 222;
	ac[2].s = "aaa";
	foreach (vc in ac) {
		printf("ac has %d,%d,%s\n", vc.i, vc.j, vc.s);
	}
	printf("end\n");
}
#lang tcl
loop_1_2_0
} -output "start
h1 has 0
h2 has 0
h2 has 1
h3 has 0
h3 has 1
h3 has 2
h1 has 0=>1
h2 has 0=>1
h2 has 1=>2
h3 has 0=>1
h3 has 1=>2
h3 has 2=>3
ai1 has 11
ai2 has 22
ai2 has 23
ai3 has 33
ai3 has 34
ai3 has 35
as1 has a
as2 has b
as2 has c
as3 has d
as3 has e
as3 has f
af1 has 1.1
af2 has 2.1
af2 has 2.2
af3 has 3.1
af3 has 3.2
af3 has 3.3
ai1 has 11.0
ai2 has 22.0
ai2 has 23.0
ai3 has 33.0
ai3 has 34.0
ai3 has 35.0
ac has 1,2,a
ac has 11,22,aa
ac has 111,222,aaa
end
"

test loop-1.2.1 {foreach loops over arrays of arrays} -body {
#lang L
void
loop_121_fill2(int d1, int d2, int &a[][])
{
	int	i, j;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			a[i][j] = i*10 + j;
		}
	}
}

void
loop_121_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = i*100 + j*10 + k;
			}
		}
	}
}

void
loop_1_2_1()
{
	int	vi;
	int	ai[3];
	int	aii[4][3];
	int	aiii[5][4][3];

	loop_121_fill2(4, 3, &aii);
	loop_121_fill3(5, 4, 3, &aiii);

	printf("test 1\n");
	foreach (ai in aii) {
		foreach (vi in ai) {
			printf("aii has %d\n", vi);
		}
	}

	printf("test 2\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}

	printf("end\n");
}
loop_1_2_1();
} -output "test 1
aii has 0
aii has 1
aii has 2
aii has 10
aii has 11
aii has 12
aii has 20
aii has 21
aii has 22
aii has 30
aii has 31
aii has 32
test 2
aiii has 0
aiii has 1
aiii has 2
aiii has 10
aiii has 11
aiii has 12
aiii has 20
aiii has 21
aiii has 22
aiii has 30
aiii has 31
aiii has 32
aiii has 100
aiii has 101
aiii has 102
aiii has 110
aiii has 111
aiii has 112
aiii has 120
aiii has 121
aiii has 122
aiii has 130
aiii has 131
aiii has 132
aiii has 200
aiii has 201
aiii has 202
aiii has 210
aiii has 211
aiii has 212
aiii has 220
aiii has 221
aiii has 222
aiii has 230
aiii has 231
aiii has 232
aiii has 300
aiii has 301
aiii has 302
aiii has 310
aiii has 311
aiii has 312
aiii has 320
aiii has 321
aiii has 322
aiii has 330
aiii has 331
aiii has 332
aiii has 400
aiii has 401
aiii has 402
aiii has 410
aiii has 411
aiii has 412
aiii has 420
aiii has 421
aiii has 422
aiii has 430
aiii has 431
aiii has 432
end
"

test loop-1.2.2 {foreach with int variable lists} -body {
#lang L
void
loop_1_2_2()
{
	int	i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12;
	int	a[12] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

	printf("test 1\n");
	foreach (i1 in a) {
		printf("a has %d\n", i1);
	}
	printf("test 2\n");
	foreach (i1,i2 in a) {
		printf("a has %d,%d\n", i1, i2);
	}
	printf("test 3\n");
	foreach (i1,i2,i3 in a) {
		printf("a has %d,%d,%d\n", i1, i2, i3);
	}
	printf("test 4\n");
	foreach (i1,i2,i3,i4 in a) {
		printf("a has %d,%d,%d,%d\n", i1, i2, i3, i4);
	}
	printf("test 5\n");
	foreach (i1,i2,i3,i4,i5,i6 in a) {
		printf("a has %d,%d,%d,%d,%d,%d\n", i1, i2, i3, i4, i5, i6);
	}
	printf("test 6\n");
	foreach (i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12 in a) {
		printf("a has %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
		       i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
	}
	printf("end\n");
}
loop_1_2_2();
} -output "test 1
a has 1
a has 2
a has 3
a has 4
a has 5
a has 6
a has 7
a has 8
a has 9
a has 10
a has 11
a has 12
test 2
a has 1,2
a has 3,4
a has 5,6
a has 7,8
a has 9,10
a has 11,12
test 3
a has 1,2,3
a has 4,5,6
a has 7,8,9
a has 10,11,12
test 4
a has 1,2,3,4
a has 5,6,7,8
a has 9,10,11,12
test 5
a has 1,2,3,4,5,6
a has 7,8,9,10,11,12
test 6
a has 1,2,3,4,5,6,7,8,9,10,11,12
end
"

test loop-1.2.3 {foreach with string variable lists} -body {
#lang L
void
loop_1_2_3()
{
	string	s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14;
	string	a[12] = { "a","b","c","d","e","f","g","h","i","j","k","l" };

	printf("test 1\n");
	foreach (s1 in a) {
		printf("a has %s\n", s1);
	}
	printf("test 2\n");
	foreach (s1,s2 in a) {
		printf("a has %s,%s\n", s1, s2);
	}
	printf("test 3\n");
	foreach (s1,s2,s3 in a) {
		printf("a has %s,%s,%s\n", s1, s2, s3);
	}
	printf("test 4\n");
	foreach (s1,s2,s3,s4 in a) {
		printf("a has %s,%s,%s,%s\n", s1, s2, s3, s4);
	}
	printf("test 5\n");
	foreach (s1,s2,s3,s4,s5,s6 in a) {
		printf("a has %s,%s,%s,%s,%s,%s\n", s1, s2, s3, s4, s5, s6);
	}
	printf("test 6\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
	}

	/*
	 * The current semantics is that extra vars get "", so test that.
	 * This may eventually be changed to be a run-time error.
	 */

	printf("test 7\n");
	foreach (s1,s2,s3,s4,s5 in a) {
		printf("a has %s,%s,%s,%s,%s\n", s1, s2, s3, s4, s5);
	}

	printf("test 8\n");
	foreach (s1,s2,s3,s4,s5,s6,s7 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7);
	}

	printf("test 9\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8);
	}

	printf("test 10\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9);
	}

	printf("test 11\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10);
	}

	printf("test 12\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11);
	}

	printf("test 13\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13);
	}

	printf("test 14\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,
		       s14);
	}

	printf("end\n");
}
loop_1_2_3();
} -output "test 1
a has a
a has b
a has c
a has d
a has e
a has f
a has g
a has h
a has i
a has j
a has k
a has l
test 2
a has a,b
a has c,d
a has e,f
a has g,h
a has i,j
a has k,l
test 3
a has a,b,c
a has d,e,f
a has g,h,i
a has j,k,l
test 4
a has a,b,c,d
a has e,f,g,h
a has i,j,k,l
test 5
a has a,b,c,d,e,f
a has g,h,i,j,k,l
test 6
a has a,b,c,d,e,f,g,h,i,j,k,l
test 7
a has a,b,c,d,e
a has f,g,h,i,j
a has k,l,,,
test 8
a has a,b,c,d,e,f,g
a has h,i,j,k,l,,
test 9
a has a,b,c,d,e,f,g,h
a has i,j,k,l,,,,
test 10
a has a,b,c,d,e,f,g,h,i
a has j,k,l,,,,,,
test 11
a has a,b,c,d,e,f,g,h,i,j
a has k,l,,,,,,,,
test 12
a has a,b,c,d,e,f,g,h,i,j,k
a has l,,,,,,,,,,
test 13
a has a,b,c,d,e,f,g,h,i,j,k,l,
test 14
a has a,b,c,d,e,f,g,h,i,j,k,l,,
end
"

test loop-1.2.4 {foreach loops with large loop body (>127 bytes of bytecode)} -body {
#lang L
void
loop_1_2_4()
{
	int	i, k, v;
	int	a[3] = { 1,2,3 };
	hash	h = { 1=>2, 2=>3, 3=>4 };

	printf("start\n");
	foreach (i in a) {
		/* Just do whatever to rack up bytecodes. */
		int	x = 1, y = 1, z = 1;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		printf("a has %d\n", i);
	}
	foreach (k=>v in h) {
		/* Just do whatever to rack up bytecodes. */
		int	x = 1, y = 1, z = 1;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		printf("h has %d=>%d\n", k, v);
	}
	printf("end\n");
}
loop_1_2_4();
} -output "start
a has 1
a has 2
a has 3
h has 1=>2
h has 2=>3
h has 3=>4
end
"

test loop-1.2.5 {check hash foreach type checking} -body {
#lang L
void loop_1_2_5()
{
	int	i1, i2;
	string	s1, s2;
	string	h{int};

	foreach (s1=>s2 in h) ;
	foreach (s1=>i2 in h) ;
	foreach (i1=>i2 in h) ;
}
#lang tcl
} -returnCodes error -match regexp -result {.*7: L Error: loop index key type incompatible.*
.*8: L Error: loop index value type incompatible.*
.*8: L Error: loop index key type incompatible.*
.*9: L Error: loop index value type incompatible.*
}

test loop-1.2.6 {test foreach over string} -body {
#lang L
void loop_1_2_6()
{
	int	i;
	string	a, b, c, d;
	string	as[];
	poly	p;

	a = "x";
	foreach (a in "") puts("bad 1.1");
	unless (a eq "x") puts("bad 1.2");

	/* as[0] has the value undef */
	a = "x";
	if (defined(as[0])) puts("bad 2.0");
	foreach(a in as[0]) puts("bad 2.1");
	unless (a eq "x") puts("bad 2.2");

	i = 0;
	foreach(a in "0123456789") {
		unless (a eq (string)i++) printf("bad 2.1 i=%d\n", i);
	}
	i = 0;
	foreach(p in "0123456789") {
		unless (p eq (string)i++) printf("bad 2.2 i=%d\n", i);
	}
	i = 0;
	foreach(a,b in "0123456789") {
		unless (a eq (string)i++) printf("bad 3.1 i=%d\n", i);
		unless (b eq (string)i++) printf("bad 3.2 i=%d\n", i);
	}
	i = 0;
	foreach(a,b,c in "0123456789") {
		unless (a eq (string)i++) printf("bad 4.1 i=%d\n", i);
		if (i == 10) {
			if (defined(b)) puts("bad 4.2 b undef");
			if (defined(c)) puts("bad 4.2 c undef");
		} else {
			unless (b eq (string)i++) printf("bad 4.3 i=%d\n", i);
			unless (c eq (string)i++) printf("bad 4.4 i=%d\n", i);
		}
	}
	i = 0;
	foreach(a,b,c,d in "0123456789") {
		unless (a eq (string)i++) printf("bad 5.1 i=%d\n", i);
		unless (b eq (string)i++) printf("bad 5.2 i=%d\n", i);
		if (i == 10) {
			if (defined(c)) puts("bad 5.2 b undef");
			if (defined(d)) puts("bad 5.2 c undef");
		} else {
			unless (c eq (string)i++) printf("bad 5.3 i=%d\n", i);
			unless (d eq (string)i++) printf("bad 5.4 i=%d\n", i);
		}
	}
}
loop_1_2_6();
} -output {}

test loop-1.2.7 {test foreach over string type errors} -body {
#lang L
class loop_1_2_7_class {}
void loop_1_2_7()
{
	int	i;
	float	f;
	int	a[];
	int	h{int};
	loop_1_2_7_class o;
	struct { int i,j; } st;

	foreach(i in "string") {}
	foreach(f in "string") {}
	foreach(h in "string") {}
	foreach(a in "string") {}
	foreach(o in "string") {}
	foreach(st in "string") {}
}
} -returnCodes error -match regexp -result {.*11: L Error: loop index not of string type
.*12: L Error: loop index not of string type
.*13: L Error: loop index not of string type
.*14: L Error: loop index not of string type
.*15: L Error: loop index not of string type
.*16: L Error: loop index not of string type
}

test loop-1.2.8 {test foreach type errors} -body {
#lang L -nowarn
void loop_1_2_8()
{
	string	s;
	poly	p;
	struct { int i,j; } st;

	foreach(s in p) ;
	foreach(s in st) ;
	foreach(s in {"a","b"}) ;
}
} -returnCodes error -match regexp -result {.*7: L Error: foreach expression must be array, hash, or string
.*8: L Error: foreach expression must be array, hash, or string
.*9: L Error: foreach expression must be array, hash, or string
}

test loop-1.2.9 {test foreach syntax errors} -body {
#lang L
void loop_1_2_9()
{
	string	k, v;
	string	h{string};

	/*
	 * This test was added after un-reserving the keyword "in",
	 * used in foreach loops.  In the grammar, "in" was replaced
	 * with an id.  Verify that using anything other than "in" is
	 * a syntax error.
	 */

	foreach (k=>v bad h) ;
}
} -returnCodes error -match regexp -result {.*13: L Error: syntax error.*
}

test loop-1.2.10 {test foreach syntax errors} -body {
#lang L
void loop_1_2_10()
{
	string	k, v;
	string	h{string};

	/*
	 * Second part of above test (we can test only one syntax
	 * error at a time).
	 */

	foreach (k bad "xyz") ;
}
} -returnCodes error -match regexp -result {.*11: L Error: syntax error.*
}

test loop-1.2.11 {test that "in" is not reserved} -body {
#lang L
void loop_1_2_11()
{
	/*
	 * Verify that "in" is no longer a reserved word.
	 */

	int	in = 123;
	unless (in == 123) puts("bad");
}
loop_1_2_11();
} -output {}

test loop-1.3 {continue statements} -body {
#lang L
void loop_1_3_for_continue()
{
	int	i;

	for (i = 0; i < 5; i++) {
		if (i == 2) continue;
		puts(i);
	}
}

void loop_1_3_foreach_continue()
{
	string	k, l, v;
	string	as[] = { "1", "2", "3", "4", "5" };
	hash	h;

	h{"a"} = "x";
	h{"b"} = "y";
	h{"c"} = "z";

	printf("foreach test 1\n");
	foreach (k => v in h) {
		if (k eq "b") continue;
		printf("%s => %s\n", k, v);
	}

	printf("foreach test 2\n");
	foreach (l in h) {
		if (l eq "c") continue;
		foreach (k => v in h) {
			if (k eq "b") continue;
			printf("%s: %s => %s\n", l, k, v);
		}
	}

	printf("foreach test 3\n");
	foreach (v in as) {
		if ((v ge "2") && (v le "4")) continue;
		printf("%s\n", v);
	}

	printf("foreach test 4\n");
	foreach (l in "abcdefg") {
		if ((l ge "d") && (l le "f")) continue;
		printf("%s\n", l);
	}
}

void loop_1_3_do_while_continue()
{
	int	i;

	printf("do while test\n");
	i = -1;
	do {
		++i;
		if ((i == 1) || (i == 2)) continue;
		puts(i);
	} while (i < 5);
}

void loop_1_3_while_continue()
{
	int	i;

	printf("while test\n");
	i = -1;
	while (i < 5) {
		++i;
		if ((i == 1) || (i == 2)) continue;
		puts(i);
	};
}

void loop_1_3()
{
	loop_1_3_for_continue();
	loop_1_3_foreach_continue();
	loop_1_3_do_while_continue();
	loop_1_3_while_continue();
}
#lang tcl
loop_1_3
} -output {0
1
3
4
foreach test 1
a => x
c => z
foreach test 2
a: a => x
a: c => z
b: a => x
b: c => z
foreach test 3
1
5
foreach test 4
a
b
c
g
do while test
0
3
4
5
while test
0
3
4
5
}

test loop-1.4 {break statements} -body {
#lang L
void loop_1_4_foreach_break()
{
	string	k, l, v;
	string	as[] = { "1", "2", "3", "4", "5" };
	hash	h;

	h{"a"} = "x";
	h{"b"} = "y";
	h{"c"} = "z";
	foreach (l in h) {
		foreach (k => v in h) {
			if (k eq "b") break;
		}
	}
	printf("loops over, k is %s, v is %s\n", k, v);

	foreach (l in as) {
		if (l eq "3") break;
	}
	printf("l is %s\n", l);

	foreach (l in "abcdefg") {
		if (l eq "c") break;
	}
	printf("l is %s\n", l);
}

void loop_1_4_for_break()
{
	int	i;

	for (i = 0; i < 10; i++) {
		puts(i);
		if (i == 5) {
			puts("attempting to break");
			break;
		}
	}
	printf("at the end of the day, i is %d\n", i);
}

void loop_1_4_do_while_break()
{
	int	i;

	i = 0;
	do {
		++i;
		if (i == 3) break;
	} while (i < 5);
	printf("do while i = %d\n", i);
}

void loop_1_4_while_break()
{
	int	i;

	i = 0;
	while (i < 5) {
		++i;
		if (i == 3) break;
	}
	printf("while i = %d\n", i);
}

void loop_1_4()
{
	loop_1_4_foreach_break();
	loop_1_4_for_break();
	loop_1_4_do_while_break();
	loop_1_4_while_break();
}

#lang tcl
loop_1_4
} -output {loops over, k is b, v is y
l is 3
l is c
0
1
2
3
4
5
attempting to break
at the end of the day, i is 5
do while i = 3
while i = 3
}

test loop-1.5 {continues in nested foreach loops} -body {
#lang L
void
loop_1_5_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = (i+1)*100 + (j+1)*10 + k+1;
			}
		}
	}
}

void
loop_1_5()
{
	int	d1, d2, vi;
	int	ai[3];
	int	aii[3][3];
	int	aiii[3][3][3];

	loop_1_5_fill3(3, 3, 3, &aiii);

	printf("test 1\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				// Omit all even numbers.
				if ((vi%2) == 0) continue;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 2\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		foreach (ai in aii) {
			++d2;
			// Omit 11x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 3\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 4\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			// Omit 21x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 5\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			// Omit 21x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				// Omit 3xx.
				if (vi >= 300) continue;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("end\n");
}

loop_1_5();
} -output "test 1
aiii has 111
aiii has 113
aiii has 121
aiii has 123
aiii has 131
aiii has 133
aiii has 211
aiii has 213
aiii has 221
aiii has 223
aiii has 231
aiii has 233
aiii has 311
aiii has 313
aiii has 321
aiii has 323
aiii has 331
aiii has 333
test 2
aiii has 121
aiii has 122
aiii has 123
aiii has 131
aiii has 132
aiii has 133
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 3
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 4
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 5
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
end
"

test loop-1.6 {breaks in nested foreach loops} -body {
#lang L
void
loop_1_6_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = (i+1)*100 + (j+1)*10 + k+1;
			}
		}
	}
}

void
loop_1_6()
{
	int	d1, d2, vi;
	int	ai[3];
	int	aii[3][3];
	int	aiii[3][3][3];

	loop_1_6_fill3(3, 3, 3, &aiii);

	printf("test 1\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				// Should have no output.
				break;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 2\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		foreach (ai in aii) {
			++d2;
			// Omit 13x.
			if (d2 == 3) break;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 3\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit [23]xx.
		if (d1 == 2) break;
		foreach (ai in aii) {
			++d2;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("end\n");
}

loop_1_6();
} -output "test 1
test 2
aiii has 111
aiii has 112
aiii has 113
aiii has 121
aiii has 122
aiii has 123
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 3
aiii has 111
aiii has 112
aiii has 113
aiii has 121
aiii has 122
aiii has 123
aiii has 131
aiii has 132
aiii has 133
end
"

test loop-1.7 {test loop condition with regexp captures} -body {
#lang L
void loop_1_7()
{
	/*
	 * This checks for an earlier compiler bug where the loop
	 * condition was sometimes compiled before the loop body,
	 * causing any regexp capture variable references to possibly
	 * become undeclared-variable references.
	 */

	int	it;

	it = 0;
	while ("abc" =~ /(a)(b)/) {
		++it;
		unless (($1 eq "a") && ($2 eq "b")) {
			puts("bad 1.1");
		}
		break;
	}
	unless (it == 1) puts("bad 1.2");

	/* Use more captures than last time. */
	for (it = 0; "abcd" =~ /(a)(b)(c)(d)/; ) {
		++it;
		unless (($1 eq "a") && ($2 eq "b") && ($3 eq "c") &&
			($4 eq "d")) {
			puts("bad 2.1");
		}
		break;
	}
	unless (it == 1) puts("bad 2.2");
}
loop_1_7();
} -output {}

test struct-1.0 {structs} -body {
#lang L
struct struct_1_0_point {
        int x, y;
        string label;
};

void struct_1_0() {
        struct struct_1_0_point p1, p2;

        p1.x = 1;
        p1.y = 2;
        p1.label = "this is a label";
        puts("p1 is:");
        puts(p1);
        puts(format("p1.x is %d, p1.y is %d, and p1.label is %s", p1.x, p1.y, p1.label));
        p2 = p1;
        p2.label = "this is another label";
        puts("p1 is:");
        puts(p1);
        puts("p2 is:");
        puts(p2);
}
#lang tcl
struct_1_0
} -output "p1 is:
1 2 {this is a label}
p1.x is 1, p1.y is 2, and p1.label is this is a label
p1 is:
1 2 {this is a label}
p2 is:
1 2 {this is another label}
"

test struct-1.1 {struct allocation and arrays of structs} -body {
#lang L
struct struct_1_1_point {
        int x, y;
        string label;
};

void struct_1_1() {
   int i = 0;
   struct struct_1_1_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_1
} -output "42 0 {10 cows}
43 1 {9 cows}
44 2 {8 cows}
45 3 {7 cows}
46 4 {6 cows}
47 5 {5 cows}
48 6 {4 cows}
49 7 {3 cows}
50 8 {2 cows}
51 9 {1 cows}
"

test struct-1.2 {arrays of structs containing arrays} -body {
#lang L
struct struct_1_2_point {
        int x, y;
        string label;
  int z[4];
};

void struct_1_2() {
   int i = 0;
   struct struct_1_2_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      s[i].z[i%4] = i;
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_2
} -output "42 0 {10 cows} 0
43 1 {9 cows} {{} 1}
44 2 {8 cows} {{} {} 2}
45 3 {7 cows} {{} {} {} 3}
46 4 {6 cows} 4
47 5 {5 cows} {{} 5}
48 6 {4 cows} {{} {} 6}
49 7 {3 cows} {{} {} {} 7}
50 8 {2 cows} 8
51 9 {1 cows} {{} 9}
"

test struct-1.3 {increment and decrement on struct fields} -body {
#lang L
struct foo {
  int i;
};

void struct_1_3() {
  struct foo v;

  v.i = 0;
  for (v.i=0; v.i<5; v.i++);
  puts(v);

  puts("pre:");
  puts(v.i);
  ++v.i;
  puts(v.i);
  puts(++v.i);
  --v.i;
  puts(v.i);
  puts(--v.i);

  puts("post:");
  puts(v.i);
  v.i++;
  puts(v.i);
  puts(v.i++);
  puts(v.i);
  v.i--;
  puts(v.i);
  puts(v.i--);
  puts(v.i);
}
#lang tcl
struct_1_3
} -output "5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n"

test struct-1.4 {check struct type declarations} -body {
#lang L
struct struct_1_4_1 {
	int	i;
	int	j;
};
struct struct_1_4_2;
struct struct_1_4_3 {
	int	i;
	int	j;
	struct struct_1_4_2 st;
};
struct struct_1_4_2 {
	string	s;
};
void struct_1_4()
{
	struct struct_1_4_1 st1 = { 2, 3 };
	struct struct_1_4_2 st2 = { "s2" };
	struct struct_1_4_3 st3 = { 4, 5, { "s3" } };
	/* This redeclaration hides the global one. */
	struct struct_1_4_2 { int k,l; } st4 = { 6, 7 };

	unless ((st1.i == 2) && (st1.j == 3)) puts("bad 1");
	unless (st2.s eq "s2") puts("bad 2");
	unless ((st3.i == 4) && (st3.j == 5) && (st3.st.s eq "s3")) {
	       puts("bad 3");
	}
	unless ((st4.k == 6) && (st4.l == 7)) puts("bad 4");

	if (1) {
		/* This redeclaration hides the global one in this scope. */
		struct struct_1_4_1 { string t,u; } st5 = { "t", "u" };
		unless ((st5.t eq "t") && (st5.u eq "u")) puts("bad 5");
	}
	if (1) {
		/* This should reference the global one. */
		struct struct_1_4_1 st6 = { 8, 9 };
		unless ((st6.i == 8) && (st6.j == 9)) puts("bad 7");
	}
}
#lang tcl
struct_1_4
} -output {}

test struct-1.5 {check multiple struct type declarations} -body {
#lang L
struct struct_1_5_1 { int i,j; };
struct struct_1_5_1 { int i,j; };
struct struct_1_5_2 { int i,j; };
void struct_1_5_1()
{
	struct struct_1_5_2 { string s; } st1;
	struct struct_1_5_2 { string s; } st2;
}
} -returnCodes error -match regexp -result {.*2: L Error: multiple declaration of struct struct_1_5_1.*7: L Error: multiple declaration of struct struct_1_5_2
}

test struct-1.6 {check struct member errors} -body {
#lang L
void struct_1_6()
{
	struct struct_1_6 { string s; } st;
	st.x = 1;  // err -- x is not a member
}
} -returnCodes error -match regexp -result {.*4: L Error: struct field x not found
}

test hash-1.0 {basic hashtable support} -body {
#lang L
void hash_1_0() {
  hash foo;
  foo{"key"} = "value";
  puts(foo{"key"});
}
#lang tcl
hash_1_0
} -output "value\n"

test hash-1.1 {array of hashtables} -body {
#lang L
void hash_1_1() {
  hash foo[10];
  foo[5]{"key"} = "value";
  foo[4]{"key"} = "";
  puts(foo[5]{"key"});
  puts(foo[4]{"key"});
}
#lang tcl
hash_1_1
} -output "value\n\n"

test hash-1.2 {increment and decrement on hash elements} -body {
#lang L -poly
void hash_1_2() {
  hash foo;

  foo{"three"} = 0;
  for (foo{"three"}=0; foo{"three"}<5; foo{"three"}++);
  puts(foo);

  puts("pre:");
  puts(foo{"three"});
  ++foo{"three"};
  puts(foo{"three"});
  puts(++foo{"three"});
  --foo{"three"};
  puts(foo{"three"});
  puts(--foo{"three"});

  puts("post:");
  puts(foo{"three"});
  foo{"three"}++;
  puts(foo{"three"});
  puts(foo{"three"}++);
  puts(foo{"three"});
  foo{"three"}--;
  puts(foo{"three"});
  puts(foo{"three"}--);
  puts(foo{"three"});
  puts(foo);
}
#lang tcl
hash_1_2
} -output "three 5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\nthree 5\n"

# test hash-1.3 removed

test hash-1.4 {basic hash element types} -body {
#lang L
struct sh14 {
	int	x;
	int	y;
};
void
hash_1_4()
{
	int		ki, vi;
	string		ks, vs;
	float		kf, vf;
	poly		kp, vp;
	struct sh14	vst;
	int		ihi{int};
	int		ihs{string};
	int		ihf{float};
	int		ihp{poly};
	string		shi{int};
	string		shs{string};
	string		shf{float};
	string		shp{poly};
	float		fhi{int};
	float		fhs{string};
	float		fhf{float};
	float		fhp{poly};
	poly		phi{int};
	poly		phs{string};
	poly		phf{float};
	poly		php{poly};
	struct sh14	sthi{int};
	struct sh14	sths{string};
	struct sh14	sthf{float};
	struct sh14	sthp{poly};

	printf("start\n");

	ihi{0} = 100;
	ihi{1} = 101;
	ihi{2} = 102;
	foreach (ki=>vi in ihi) {
		printf("ihi has %d=>%d\n", ki, vi);
	}

	ihs{"zero"} = 100;
	ihs{"one"}  = 101;
	ihs{"two"}  = 102;
	foreach (ks=>vi in ihs) {
		printf("ihs has %s=>%d\n", ks, vi);
	}

	ihf{1.1} = 100;
	ihf{2.2} = 101;
	ihf{3.3} = 102;
	foreach (kf=>vi in ihf) {
		printf("ihf has %3.1f=>%d\n", kf, vi);
	}

	ihp{0}     = 100;
	ihp{"two"} = 101;
	ihp{3.3}   = 102;
	foreach (kp=>vi in ihp) {
		printf("ihp has %s=>%d\n", kp, vi);
	}

	shi{0} = "zero";
	shi{1} = "one";
	shi{2} = "two";
	foreach (ki=>vs in shi) {
		printf("shi has %d=>%s\n", ki, vs);
	}

	shs{"zero"} = "zero0";
	shs{"one"}  = "one1";
	shs{"two"}  = "two2";
	foreach (ks=>vs in shs) {
		printf("shs has %s=>%s\n", ks, vs);
	}

	shf{1.1} = "one.one";
	shf{2.2} = "two.two";
	shf{3.3} = "three.three";
	foreach (kf=>vs in shf) {
		printf("shf has %3.1f=>%s\n", kf, vs);
	}

	shp{0}     = "zero";
	shp{1.1}   = "one.one";
	shp{"two"} = "two2";
	foreach (kp=>vs in shp) {
		printf("shp has %s=>%s\n", kp, vs);
	}

	fhi{0} = 1.1;
	fhi{1} = 2.2;
	fhi{2} = 3.3;
	foreach (ki=>vf in fhi) {
		printf("fhi has %d=>%3.1f\n", ki, vf);
	}

	fhs{"zero"} = 1.1;
	fhs{"one"}  = 2.2;
	fhs{"two"}  = 3.3;
	foreach (ks=>vf in fhs) {
		printf("fhs has %s=>%3.1f\n", ks, vf);
	}

	fhf{1.1} = 11.1;
	fhf{2.2} = 22.2;
	fhf{3.3} = 33.3;
	foreach (kf=>vf in fhf) {
		printf("fhf has %3.1f=>%3.1f\n", kf, vf);
	}

	fhp{0}     = 1.1;
	fhp{1.1}   = 2.2;
	fhp{"two"} = 3.3;
	foreach (kp=>vf in fhp) {
		printf("fhp has %s=>%3.1f\n", kp, vf);
	}

	phi{0} = 1;
	phi{1} = "two";
	phi{2} = 3.3;
	foreach (ki=>vp in phi) {
		printf("phi has %d=>%s\n", ki, vp);
	}

	phs{"zero"} = 1;
	phs{"one"}  = "two";
	phs{"two"}  = 3.3;
	foreach (ks=>vp in phs) {
		printf("phs has %s=>%s\n", ks, vp);
	}

	phf{1.1} = 1;
	phf{2.2} = "two";
	phf{3.3} = 33.33;
	foreach (kf=>vp in phf) {
		printf("phf has %3.1f=>%s\n", kf, vp);
	}

	php{"one"} = 1;
	php{1.1}   = "two";
	php{2}     = 3.3;
	foreach (kp=>vp in php) {
		printf("php has %s=>%s\n", kp, vp);
	}

	sthi{0}.x = 100;
	sthi{0}.y = 101;
	sthi{1}.x = 200;
	sthi{1}.y = 201;
	sthi{2}.x = 300;
	sthi{2}.y = 301;
	foreach (ki=>vst in sthi) {
		printf("sthi has %d=>(%d,%d)\n", ki, vst.x, vst.y);
	}

	sths{"zero"}.x = 100;
	sths{"zero"}.y = 101;
	sths{"one"}.x  = 200;
	sths{"one"}.y  = 201;
	sths{"two"}.x  = 300;
	sths{"two"}.y  = 301;
	foreach (ks=>vst in sths) {
		printf("sths has %s=>(%d,%d)\n", ks, vst.x, vst.y);
	}

	sthf{1.1}.x = 100;
	sthf{1.1}.y = 101;
	sthf{2.2}.x = 200;
	sthf{2.2}.y = 201;
	sthf{3.3}.x = 300;
	sthf{3.3}.y = 301;
	foreach (kf=>vst in sthf) {
		printf("sthf has %3.1f=>(%d,%d)\n", kf, vst.x, vst.y);
	}

	sthp{0}.x     = 100;
	sthp{0}.y     = 101;
	sthp{1.1}.x   = 200;
	sthp{1.1}.y   = 201;
	sthp{"two"}.x = 300;
	sthp{"two"}.y = 301;
	foreach (kp=>vst in sthp) {
		printf("sthp has %s=>(%d,%d)\n", kp, vst.x, vst.y);
	}

	printf("end\n");
}
#lang tcl
hash_1_4
} -output "start
ihi has 0=>100
ihi has 1=>101
ihi has 2=>102
ihs has zero=>100
ihs has one=>101
ihs has two=>102
ihf has 1.1=>100
ihf has 2.2=>101
ihf has 3.3=>102
ihp has 0=>100
ihp has two=>101
ihp has 3.300000=>102
shi has 0=>zero
shi has 1=>one
shi has 2=>two
shs has zero=>zero0
shs has one=>one1
shs has two=>two2
shf has 1.1=>one.one
shf has 2.2=>two.two
shf has 3.3=>three.three
shp has 0=>zero
shp has 1.100000=>one.one
shp has two=>two2
fhi has 0=>1.1
fhi has 1=>2.2
fhi has 2=>3.3
fhs has zero=>1.1
fhs has one=>2.2
fhs has two=>3.3
fhf has 1.1=>11.1
fhf has 2.2=>22.2
fhf has 3.3=>33.3
fhp has 0=>1.1
fhp has 1.100000=>2.2
fhp has two=>3.3
phi has 0=>1
phi has 1=>two
phi has 2=>3.300000
phs has zero=>1
phs has one=>two
phs has two=>3.300000
phf has 1.1=>1
phf has 2.2=>two
phf has 3.3=>33.330000
php has one=>1
php has 1.100000=>two
php has 2=>3.300000
sthi has 0=>(100,101)
sthi has 1=>(200,201)
sthi has 2=>(300,301)
sths has zero=>(100,101)
sths has one=>(200,201)
sths has two=>(300,301)
sthf has 1.1=>(100,101)
sthf has 2.2=>(200,201)
sthf has 3.3=>(300,301)
sthp has 0=>(100,101)
sthp has 1.100000=>(200,201)
sthp has two=>(300,301)
end
"

test hash-1.5 {hashes of hashes and arrays} -body {
#lang L
void
hash_1_5()
{
	int	k1, k2;
	string	vs;
	string	hai[3]{int};
	string	hia{int}[3];
	string	hii{int}{int};
	string	hi{int};

	printf("start\n");

	// Array of hashes.
	hai[0]{1} = "01";
	hai[0]{6} = "06";
	hai[0]{5} = "05";
	hai[1]{2} = "12";
	hai[1]{3} = "13";
	hai[1]{0} = "10";
	hai[2]{0} = "20";
	hai[2]{1} = "21";
	hai[2]{2} = "22";
	foreach (hi in hai) {
		foreach (k1 in sort(keys(hi))) {
			printf("hai has %d=>%s\n", k1, hi{k1});
		}
	}

	// Hash of arrays.
	hia{1}[0] = "10";
	hia{1}[1] = "11";
	hia{1}[2] = "12";
	hia{0}[0] = "00";
	hia{0}[1] = "01";
	hia{0}[2] = "02";
	hia{2}[0] = "20";
	hia{2}[1] = "21";
	hia{2}[2] = "22";
	foreach (k1 in sort(keys(hia))) {
		foreach (vs in hia{k1}) {
			printf("hia{%d} has %s\n", k1, vs);
		}
	}

	// Hash of hashes.
	hii{0}{2} = "02";
	hii{1}{0} = "10";
	hii{0}{0} = "00";
	hii{2}{1} = "21";
	hii{1}{2} = "12";
	hii{1}{1} = "11";
	hii{0}{1} = "01";
	hii{2}{0} = "20";
	hii{2}{2} = "22";
	foreach (k1 in sort(keys(hii))) {
		foreach (k2 in sort(keys(hii{k1}))) {
			printf("hii{%d}{%d} has %s\n", k1, k2, hii{k1}{k2});
		}
	}

	printf("end\n");
}
#lang tcl
hash_1_5
} -output "start
hai has 1=>01
hai has 5=>05
hai has 6=>06
hai has 0=>10
hai has 2=>12
hai has 3=>13
hai has 0=>20
hai has 1=>21
hai has 2=>22
hia{0} has 00
hia{0} has 01
hia{0} has 02
hia{1} has 10
hia{1} has 11
hia{1} has 12
hia{2} has 20
hia{2} has 21
hia{2} has 22
hii{0}{0} has 00
hii{0}{1} has 01
hii{0}{2} has 02
hii{1}{0} has 10
hii{1}{1} has 11
hii{1}{2} has 12
hii{2}{0} has 20
hii{2}{1} has 21
hii{2}{2} has 22
end
"

test deep-1.1 {deep dive 1} -body {
#lang L
struct xy {
	string		x;
	string		y;
};
struct sd11 {
	string		a;
	string		b;
	struct xy	h{int};
};

void
deep_1_1()
{
	int		k1, k2;
	struct sd11	s;
	struct xy	xy;
	struct sd11	h{int};

	printf("start\n");

	/*
	 * Test a hash that has a struct that has another hash.
	 */

	h{0}.a = "h{0}.a";
	h{0}.b = "h{0}.b";
	h{0}.h{0}.x = "h{0}.h{0}.x";
	h{0}.h{0}.y = "h{0}.h{0}.y";
	h{1}.a = "h{1}.a";
	h{1}.b = "h{1}.b";
	h{1}.h{0}.x = "h{1}.h{0}.x";
	h{1}.h{0}.y = "h{1}.h{0}.y";
	h{1}.h{2}.x = "h{1}.h{2}.x";
	h{1}.h{2}.y = "h{1}.h{2}.y";

	foreach (k1=>s in h) {
		printf("h{%d}.a = %s\n", k1, s.a);
		printf("h{%d}.b = %s\n", k1, s.b);
		foreach (k2=>xy in s.h) {
			printf("h{%d}.h{%d}.x = %s\n", k1, k2, xy.x);
			printf("h{%d}.h{%d}.y = %s\n", k1, k2, xy.y);
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_1
} -output "start
h{0}.a = h{0}.a
h{0}.b = h{0}.b
h{0}.h{0}.x = h{0}.h{0}.x
h{0}.h{0}.y = h{0}.h{0}.y
h{1}.a = h{1}.a
h{1}.b = h{1}.b
h{1}.h{0}.x = h{1}.h{0}.x
h{1}.h{0}.y = h{1}.h{0}.y
h{1}.h{2}.x = h{1}.h{2}.x
h{1}.h{2}.y = h{1}.h{2}.y
end
"

test deep-1.2 {deep dive with consecutive hash indices} -body {
#lang L
void
deep_1_2()
{
	int	k1, k2, k3, k4;
	string	v;
	string	h{int};
	string	hh{int}{int};
	string	hhh{int}{int}{int};
	string	hhhh{int}{int}{int}{int};

	printf("start\n");

	/*
	 * Test various cases with consecutive hash indices.
	 */

	hh{0}{0} = "00";
	hh{0}{1} = "01";
	hh{1}{0} = "10";
	foreach (k1=>h in hh) {
		foreach (k2=>v in h) {
			unless (hh{k1}{k2} eq h{k2}) {
				printf("bad 1\n");
			}
			printf("hh{%d}{%d} has %s\n", k1, k2, hh{k1}{k2});
		}
	}

	hhh{0}{0}{0} = "000";
	hhh{0}{0}{1} = "001";
	hhh{0}{1}{0} = "010";
	hhh{1}{0}{0} = "100";
	foreach (k1=>hh in hhh) {
		foreach (k2=>h in hh) {
			foreach (k3=>v in h) {
				unless (hhh{k1}{k2}{k3} eq hh{k2}{k3}) {
					printf("bad 2\n");
				}
				unless (hh{k2}{k3} eq h{k3}) {
					printf("bad 3\n");
				}
				printf("hhh{%d}{%d}{%d} has %s\n", k1, k2, k3,
				       hhh{k1}{k2}{k3});
			}
		}
	}

	hhhh{0}{0}{0}{0} = "0000";
	hhhh{0}{0}{0}{1} = "0001";
	hhhh{0}{0}{1}{0} = "0010";
	hhhh{0}{1}{0}{0} = "0100";
	hhhh{1}{0}{0}{0} = "1000";
	foreach (k1=>hhh in hhhh) {
		foreach (k2=>hh in hhh) {
			foreach (k3=>h in hh) {
				foreach (k4=>v in h) {
					unless (hhhh{k1}{k2}{k3}{k4} eq
						hhh{k2}{k3}{k4}) {
						printf("bad 4\n");
					}
					unless (hhh{k2}{k3}{k4} eq hh{k3}{k4}) {
						printf("bad 5\n");
					}
					unless (hh{k3}{k4} eq h{k4}) {
						printf("bad 6\n");
					}
					printf("hhhh{%d}{%d}{%d}{%d} has %s\n",
					       k1, k2, k3, k4,
					       hhhh{k1}{k2}{k3}{k4});
				}
			}
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_2
} -output "start
hh{0}{0} has 00
hh{0}{1} has 01
hh{1}{0} has 10
hhh{0}{0}{0} has 000
hhh{0}{0}{1} has 001
hhh{0}{1}{0} has 010
hhh{1}{0}{0} has 100
hhhh{0}{0}{0}{0} has 0000
hhhh{0}{0}{0}{1} has 0001
hhhh{0}{0}{1}{0} has 0010
hhhh{0}{1}{0}{0} has 0100
hhhh{1}{0}{0}{0} has 1000
end
"

test deep-1.3 {deep dive with consecutive array indices} -body {
#lang L
void
deep_1_3()
{
	string	v;
	string	a[3];
	string	aa[2][2];
	string	aaa[2][2][2];
	string	aaaa[2][2][2][2];

	printf("start\n");

	/*
	 * Test various cases with consecutive array indices.
	 */

	a[0] = "0";
	a[1] = "1";
	a[2] = "2";
	foreach (v in a) {
		printf("a has '%s'\n", v);
	}

	aa[0][0] = "00";
	aa[0][1] = "01";
	aa[0][2] = "02";
	aa[1][0] = "10";
	foreach (a in aa) {
		foreach (v in a) {
			printf("aa has '%s'\n", v);
		}
	}

	aaa[0][0][0] = "000";
	aaa[0][0][1] = "001";
	aaa[0][1][0] = "010";
	aaa[0][1][1] = "011";
	aaa[1][0][0] = "100";
	foreach (aa in aaa) {
		foreach (a in aa) {
			foreach (v in a) {
				printf("aaa has '%s'\n", v);
			}
		}
	}

	aaaa[0][0][0][0] = "0000";
	aaaa[0][0][0][1] = "0001";
	aaaa[0][0][1][0] = "0010";
	aaaa[0][1][0][0] = "0100";
	aaaa[1][0][0][0] = "1000";
	foreach (aaa in aaaa) {
		foreach (aa in aaa) {
			foreach (a in aa) {
				foreach (v in a) {
					printf("aaaa has '%s'\n", v);
				}
			}
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_3
} -output "start
a has '0'
a has '1'
a has '2'
aa has '00'
aa has '01'
aa has '02'
aa has '10'
aaa has '000'
aaa has '001'
aaa has '010'
aaa has '011'
aaa has '100'
aaaa has '0000'
aaaa has '0001'
aaaa has '0010'
aaaa has '0100'
aaaa has '1000'
end
"

test deep-1.4 {deep dive with alternating hash and array indices} -body {
#lang L
void
deep_1_4()
{
	/*
	 * Note that, because of the array auto-extend semantics, if
	 * you write to a[i] but there are values before index i not
	 * yet written, those get automatically set to an undefined
	 * value, which the foreach's will iterate through.  When used
	 * as a string, the undefined value shows up as "".  (Tcl
	 * doesn't let you use it as an integer, which is why the
	 * hashes are string hashes in these tests.)
	 */

	int	i, j, ki, k1, k2;
	string	vs;
	string	a[3];
	string	aa[3][3];
	string	h{int};
	string	hh{int}{int};
	string	ah[3]{int};
	string	ha{int}[3];
	string	aah[3][3]{int};
	string	aha[3]{int}[3];
	string	ahh[3]{int}{int};
	string	haa{int}[3][3];
	string	hah{int}[3]{int};
	string	hha{int}{int}[3];

	printf("start\n");

	ah[0]{0} = "ah[0]{0}";
	ah[2]{0} = "ah[2]{0}";
	ah[2]{1} = "ah[2]{1}";
	i = 0;
	foreach (h in ah) {
		foreach (ki=>vs in h) {
			unless (ah[i]{ki} eq vs) printf("bad 1\n");
			printf("ah[%d]{%d} = '%s'\n", i, ki, vs);
		}
		++i;
	}

	ha{0}[0] = "ha{0}[0]";
	ha{0}[1] = "ha{0}[1]";
	ha{1}[1] = "ha{1}[1]";
	foreach (ki=>a in ha) {
		i = 0;
		foreach (vs in a) {
			unless (ha{ki}[i] eq vs) printf("bad 2\n");
			printf("ha{%d}[%d] = '%s'\n", ki, i, vs);
			++i;
		}
	}

	aah[0][0]{0} = "aah[0][0]{0}";
	aah[0][1]{1} = "aah[0][1]{1}";
	aah[1][0]{2} = "aah[1][0]{2}";
	aah[1][0]{3} = "aah[1][0]{3}";
	i = 0;
	foreach (ah in aah) {
		j = 0;
		foreach (h in ah) {
			foreach (ki=>vs in h) {
				unless (aah[i][j]{ki} eq vs) printf("bad 3\n");
				unless (ah[j]{ki} eq vs) printf("bad 4\n");
				unless (h{ki} eq vs) printf("bad 5\n");
				printf("aah[%d][%d]{%d} = '%s'\n", i, j, ki,
				       aah[i][j]{ki});
			}
			++j;
		}
		++i;
	}

	aha[0]{0}[0] = "aha[0]{0}[0]";
	aha[0]{1}[1] = "aha[0]{1}[1]";
	aha[1]{2}[0] = "aha[1]{2}[0]";
	aha[0]{3}[2] = "aha[0]{3}[2]";
	i = 0;
	foreach (ha in aha) {
		foreach (ki=>a in ha) {
			j = 0;
			foreach (vs in a) {
				unless (aha[i]{ki}[j] eq vs) printf("bad 6\n");
				unless (ha{ki}[j] eq vs) printf("bad 7\n");
				unless (a[j] eq vs) printf("bad 7\n");
				printf("aha[%d]{%d}[%d] = '%s'\n", i, ki, j,
				       aha[i]{ki}[j]);
				++j;
			}
		}
		++i;
	}

	ahh[0]{0}{1} = "ahh[0]{0}{1}";
	ahh[0]{2}{3} = "ahh[0]{2}{3}";
	ahh[1]{4}{5} = "ahh[1]{4}{5}";
	ahh[2]{6}{7} = "ahh[2]{6}{7}";
	i = 0;
	foreach (hh in ahh) {
		foreach (k1=>h in hh) {
			foreach (k2=>vs in h) {
				unless (ahh[i]{k1}{k2} eq vs) printf("bad 7\n");
				unless (hh{k1}{k2} eq vs) printf("bad 8\n");
				unless (h{k2} eq vs) printf("bad 9\n");
			printf("ahh[%d]{%d}{%d} = '%s'\n", i, k1, k2,
			       ahh[i]{k1}{k2});
			}
		}
		++i;
	}

	haa{0}[0][0] = "haa{0}[0][0]";
	haa{0}[1][0] = "haa{0}[1][0]";
	haa{1}[0][0] = "haa{1}[0][0]";
	haa{2}[0][1] = "haa{2}[0][1]";
	foreach (ki=>aa in haa) {
		i = 0;
		foreach (a in aa) {
			j = 0;
			foreach (vs in a) {
				unless (haa{ki}[i][j] eq vs) printf("bad 10\n");
				unless (aa[i][j] eq vs) printf("bad 11\n");
				unless (a[j] eq vs) printf("bad 12\n");
				printf("haa{%d}[%d][%d] = '%s'\n", ki, i, j,
				       haa{ki}[i][j]);
				++j;
			}
			++i;
		}
	}

	hha{0}{1}[0] = "hha{0}{1}[0]";
	hha{2}{3}[0] = "hha{2}{3}[0]";
	hha{4}{5}[1] = "hha{4}{5}[1]";
	hha{6}{7}[2] = "hha{6}{7}[2]";
	foreach (k1=>ha in hha) {
		foreach (k2=>a in ha) {
			i = 0;
			foreach (vs in a) {
				unless (hha{k1}{k2}[i] eq vs) printf("bad13\n");
				unless (ha{k2}[i] eq vs) printf("bad 14n");
				unless (a[i] eq vs) printf("bad 15\n");
				printf("hha{%d}{%d}[%d] = '%s'\n", k1, k2, i,
				       hha{k1}{k2}[i]);
				++i;
			}
		}
	}

	hah{0}[0]{0} = "hah{0}[0]{0}";
	hah{1}[0]{2} = "hah{1}[0]{2}";
	hah{3}[1]{4} = "hah{3}[1]{4}";
	hah{5}[2]{6} = "hah{5}[2]{6}";
	foreach (k1=>ah in hah) {
		i = 0;
		foreach (h in ah) {
			foreach (k2=>vs in h) {
				unless (hah{k1}[i]{k2} eq vs) printf("bad16\n");
				unless (ah[i]{k2} eq vs) printf("bad 17\n");
				unless (h{k2} eq vs) printf("bad 18\n");
				printf("hah{%d}[%d]{%d} = '%s'\n", k1, i, k2,
				       hah{k1}[i]{k2});
			}
			++i;
		}
	}

	printf("end\n");
}

#lang tcl
deep_1_4
} -output {start
ah[0]{0} = 'ah[0]{0}'
ah[2]{0} = 'ah[2]{0}'
ah[2]{1} = 'ah[2]{1}'
ha{0}[0] = 'ha{0}[0]'
ha{0}[1] = 'ha{0}[1]'
ha{1}[0] = ''
ha{1}[1] = 'ha{1}[1]'
aah[0][0]{0} = 'aah[0][0]{0}'
aah[0][1]{1} = 'aah[0][1]{1}'
aah[1][0]{2} = 'aah[1][0]{2}'
aah[1][0]{3} = 'aah[1][0]{3}'
aha[0]{0}[0] = 'aha[0]{0}[0]'
aha[0]{1}[0] = ''
aha[0]{1}[1] = 'aha[0]{1}[1]'
aha[0]{3}[0] = ''
aha[0]{3}[1] = ''
aha[0]{3}[2] = 'aha[0]{3}[2]'
aha[1]{2}[0] = 'aha[1]{2}[0]'
ahh[0]{0}{1} = 'ahh[0]{0}{1}'
ahh[0]{2}{3} = 'ahh[0]{2}{3}'
ahh[1]{4}{5} = 'ahh[1]{4}{5}'
ahh[2]{6}{7} = 'ahh[2]{6}{7}'
haa{0}[0][0] = 'haa{0}[0][0]'
haa{0}[1][0] = 'haa{0}[1][0]'
haa{1}[0][0] = 'haa{1}[0][0]'
haa{2}[0][0] = ''
haa{2}[0][1] = 'haa{2}[0][1]'
hha{0}{1}[0] = 'hha{0}{1}[0]'
hha{2}{3}[0] = 'hha{2}{3}[0]'
hha{4}{5}[0] = ''
hha{4}{5}[1] = 'hha{4}{5}[1]'
hha{6}{7}[0] = ''
hha{6}{7}[1] = ''
hha{6}{7}[2] = 'hha{6}{7}[2]'
hah{0}[0]{0} = 'hah{0}[0]{0}'
hah{1}[0]{2} = 'hah{1}[0]{2}'
hah{3}[1]{4} = 'hah{3}[1]{4}'
hah{5}[2]{6} = 'hah{5}[2]{6}'
end
}

test deep-2.1 {deep dive array auto-extend} -body {
#lang L
void
deep_2_1()
{
	int	i, j;
	int	a1[];
	int	a2[];
	int	aa1[][];
	int	aa2[][];

	/*
	 * Test that arrays auto-extend properly.
	 */

	a1[0] = 0;
	a1[1] = 1;
	a1[2] = 2;
	unless ((a1[0] == 0) && (a1[1] == 1) && (a1[2] == 2)) {
		puts("a1 bad 1");
	}
	if (defined(a1[3])) puts("a1 bad 2");

	a2[1]  = 1;
	a2[3]  = 3;
	a2[6]  = 6;
	a2[10] = 10;
	unless ((a2[1] == 1) && (a2[3] == 3) && (a2[6] == 6) && (a2[10] == 10)) {
		puts("a2 bad 1");
	}
	if (defined(a2[0])) puts("a2 bad 2");
	if (defined(a2[2])) puts("a2 bad 3");
	if (defined(a2[4])) puts("a2 bad 4");
	if (defined(a2[5])) puts("a2 bad 5");
	if (defined(a2[7])) puts("a2 bad 6");
	if (defined(a2[8])) puts("a2 bad 7");
	if (defined(a2[9])) puts("a2 bad 8");
	if (defined(a2[11])) puts("a2 bad 9");

	/* Now check that the pad elements can be written and used. */
	a2[0] = 0;
	a2[2] = 2;
	a2[4] = 4;
	a2[5] = 5;
	unless ((a2[0] == 0) && (a2[2] == 2)) puts("a2 bad 10");
	unless ((a2[4] == 4) && (a2[5] == 5)) puts("a2 bad 11");
	if (defined(a2[7])) puts("a2 bad 12");
	if (defined(a2[8])) puts("a2 bad 13");
	if (defined(a2[9])) puts("a2 bad 14");
	if (defined(a2[11])) puts("a2 bad 15");

	aa1[0][0] = 100;
	aa1[0][1] = 101;
	aa1[0][2] = 102;
	aa1[1][0] = 110;
	aa1[1][1] = 111;
	aa1[2][0] = 120;
	unless ((aa1[0][0] == 100) && (aa1[0][1] == 101) && (aa1[0][2] == 102) &&
		(aa1[1][0] == 110) && (aa1[1][1] == 111) && (aa1[2][0] == 120)) {
		puts("aa1 bad 1");
	}
	if (defined(aa1[0][3])) puts("aa1 bad 2");
	if (defined(aa1[1][3])) puts("aa1 bad 3");
	if (defined(aa1[2][1])) puts("aa1 bad 4");

	aa2[1][1]   = 111;
	aa2[3][3]   = 133;
	aa2[6][6]   = 166;
	aa2[10][10] = 1010;
	unless ((aa2[1][1] == 111) && (aa2[3][3] == 133) && (aa2[6][6] == 166) &&
		(aa2[10][10] == 1010)) {
		puts("aa2 bad 2");
	}
	for (i = 0; i <= 10; ++i) {
		for (j = 0; j <= i; ++j) {
			if ((i == 1)  && (j == 1))  continue;
			if ((i == 3)  && (j == 3))  continue;
			if ((i == 6)  && (j == 6))  continue;
			if ((i == 10) && (j == 10)) continue;
			if (defined(aa2[i][j])) printf("aa2[%d][%d] defined\n",
						       i, j);
		}
	}
}
#lang tcl
deep_2_1
} -output ""

test deep-2.2 {check that a negative array index is an error} -body {
#lang L
void
deep_2_2()
{
	int	a[3];
	a[-1] = 0;
}
#lang tcl
deep_2_2
} -returnCodes error -match regexp -result {cannot write to negative array index}

test deep-2.3 {check deep-dive element create/read} -body {
#lang L
void
deep_2_3()
{
	/*
	 * This checks that an op= works on an undefined deep-dive
	 * element.  A string substitute is the only one we can test;
	 * because undef isn't a valid integer, ++a[0] would cause a
	 * run-time error that you can't use "" in a + operation.
	 */

	string	a[];
	string	h{string};

	h{"undefined"} =~ s//ShouldWork/;
	unless (h{"undefined"} eq "ShouldWork") puts("bad 1");

	a[0] =~ s//ShouldWork/;
	unless (a[0] eq "ShouldWork") puts("bad 2");
}
#lang tcl
deep_2_3
} -output {}

test deep-3.1 {check reading an undefined array index} -body {
#lang L
void
deep_3_1()
{
	int	a[] = {};

	/*
	 * Reading an array element with an undefined index is legal
	 * and should return undef.
	 */

	if (defined(a[undef])) puts("bad 1");
}
deep_3_1();
} -output {}

test deep-3.2 {check writing an undefined array index} -body {
#lang L
void
deep_3_2()
{
	int	a[] = {};

	/*
	 * Writing an array element with an undefined index is
	 * illegal.
	 */

	a[undef] = 0;  // run-time error
}
deep_3_2();
} -returnCodes error -match regexp -result {cannot write to undefined array index}

test deep-3.3 {check reading an undefined string index} -body {
#lang L
void
deep_3_3()
{
	string	s = "";

	/*
	 * Reading a string element with an undefined index is legal
	 * and should return undef.
	 */

	if (defined(s[undef])) puts("bad 1");
}
deep_3_3();
} -output {}

test deep-3.4 {check writing an undefined array index} -body {
#lang L
void
deep_3_4()
{
	string	s = "";

	/*
	 * Writing a string element with an undefined index is
	 * illegal.
	 */

	s[undef] = "bad";  // run-time error
}
deep_3_4();
} -returnCodes error -match regexp -result {cannot write to undefined string index}

test regexp-1.0 {regular expression support} -body {
#lang L
void regexp_1_0() {
        string s = "string";
        puts(s =~ /ring/);
        puts(s =~ /bob/);
}
#lang tcl
regexp_1_0
} -output "1\n0\n"

test regexp-1.1 {magic submatch variables ($1, $2, ...)} -body {
#lang L
void regexp_1_1() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";

        if (s =~ /((Go).*(elves)).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_1
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"


test regexp-1.2 {magic submatch variables with interpolation} -body {
#lang L
void regexp_1_2() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";
        string interp = "elves";

        if (s =~ /((Go).*(${interp})).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_2
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"

test regexp-1.3 {regexp substitution} -body {
#lang L -poly
void regexp_1_3() {
        string s = "string";
	string s1[] = {"a", "b", "coochie"};
	hash h[2];

        puts(s =~ m/ring/);
        puts(s =~ m|bob|);
	puts("--------");
	puts(s =~ s/ring/ling/);
	puts(s);
	puts("--------");
	puts(s1[2] =~ s/c/f/);
	puts(s1);
	puts("--------");
	h[0]{"a"} = "string";
	h[1]{"m"} = "not a string";
	puts(h);
	h[1]{"m"} =~ s/not a/probably a/;
	puts(h);
}
#lang tcl
regexp_1_3
} -output "1\n0\n--------\n1\nstling\n--------\n1\na b foochie\n--------\n{a string} {m {not a string}}\n{a string} {m {probably a string}}\n"

test regexp-1.4 {regexp modifiers i and g} -body {
#lang L -poly
void regexp_1_4() {
	string foo = "aaa";
	foo =~ s/a/b/;
	puts(foo);
	foo =~ s/a/b/g;
	puts(foo);
	foo =~ s/B/a/;
	puts(foo);
	foo =~ s/B/a/i;
	puts(foo);
	foo =~ s/B/a/ig;
	puts(foo);
	if (foo =~ /A/) {
		puts("busted");
	}
	if (foo =~ /A/i) {
		puts("works");
	}
}
#lang tcl
regexp_1_4
} -output "baa\nbbb\nbbb\nabb\naaa\nworks\n"

test regexp-1.5 {regexp quoting} -body {
#lang L
void
regexp_1_5()
{
	string	r, s;

	s = "a b c d";
	s =~ s/\s//;
	unless (s eq "ab c d") puts("bad 1");

	s = "a  b    c     d";
	s =~ s/\s+//g;
	unless (s eq "abcd") puts("bad 2");

	r = "\\s+";
	s = "a  b    c     d";
	s =~ s/${r}//g;
	unless (s eq "abcd") puts("bad 3");

	r = "\\s+";
	s = "a  b    c     d";
	s =~ s/\${r}//g;
	unless (s eq "a  b    c     d") puts("bad 4");

	s = "$a$b";
	s =~ s/\$//g;  // should match a dollar sign
	unless (s eq "ab") puts("bad 5");

 	r = "\\s+";
	s = '${r} ${r}';
	s =~ s/\${r}//g;  // should match '${r}' literally
	unless (s eq " ") puts("bad 6");

	s = "(in parens)";
	s =~ s/\(//;
	unless (s eq "in parens)") puts("bad 7");
	s =~ s/(in)//;
	unless (s eq " parens)") puts("bad 8");
}
#lang tcl
regexp_1_5
} -output ""

test reference-1.0 {L references} -body {
#lang L -nowarn
void reference_1_0() {
  string foo = "this is a string";
  printf("so far, so good: %s\n", foo);
  reference_1_0_aux("bleh", &foo);
  printf("%s\n", foo);
}

void reference_1_0_aux(string dummy, string &bob) {
  printf("foot: %s\n", bob);
  bob = "This was a string.";
}
#lang tcl
reference_1_0
} -output "so far, so good: this is a string
foot: this is a string
This was a string.
"

test reference-1.1 {L references} -body {
#lang L
struct reference_1_1_point { int x, y; };

void reference_1_1() {
  struct reference_1_1_point a = { 0, 0 };
  unless ((a.x == 0) && (a.y == 0)) puts("bad 1");
  reference_1_1_tweak(&a);
  unless ((a.x == 2) && (a.y == 0)) puts("bad 2");
}

void reference_1_1_tweak(struct reference_1_1_point &foo) {
  foo->x = 2;
}
reference_1_1();
} -output {}

test reference-1.4 {test multiple reference arguments} -body {
#lang L
void reference_1_4_foo1(string &s1, string &s2)
{
	s1 = s2;
}
void reference_1_4_foo2(string &s1, string s2)
{
	s1 = s2;
	s2 = "bad";
}
void reference_1_4_foo3(string &s1, string s2, string &s3)
{
	s1 = sprintf("%s%s", s2, s3);
	s2 = "bad";
}
void reference_1_4_foo4(string &s1, string s2, string &s3)
{
	s1 = sprintf("%s%s", s2, s3);
	s3 = s2;
	s2 = "bad";
}
void reference_1_4_foo5(string &s1, string &s2, string &s3)
{
	s1 = sprintf("%s%s", s2, s3);
	s2 = s3;
	s3 = "x";
}
void reference_1_4_foo6(string &s1, string s2, string &s3, string s4)
{
	s1 = sprintf("%s%s", s2, s3);
	s3 = sprintf("%s%s", s3, s4);
	s2 = s4 = "bad";
}
void reference_1_4_foo7(string s1, string &s2, string s3, string s4, string &s5)
{
	s2 = sprintf("%s%s%s", s1, s2, s3);
	s5 = sprintf("%s%s%s", s3, s4, s5);
	s1 = s3 = s4 = "bad";
}
void reference_1_4()
{
	string	s1, s2, s3;

	s1 = "";
	s2 = "foo1";
	reference_1_4_foo1(&s1, &s2);
	unless (s1 eq "foo1") puts("bad 1.1");
	unless (s2 eq "foo1") puts("bad 1.2");

	s1 = "";
	reference_1_4_foo2(&s1, "foo2");
	unless (s1 eq "foo2") puts("bad 2.1");

	s1 = "";
	s2 = "xxx";
	reference_1_4_foo3(&s1, "foo3", &s2);
	unless (s1 eq "foo3xxx") puts("bad 3.1");
	unless (s2 eq "xxx") puts("bad 3.2");

	s1 = "xx";
	s2 = "yy";
	reference_1_4_foo4(&s1, "foo4", &s2);
	unless (s1 eq "foo4yy") puts("bad 4.1");
	unless (s2 eq "foo4") puts("bad 4.2");

	s1 = "zz";
	s2 = "xx";
	s3 = "yy";
	reference_1_4_foo5(&s1, &s2, &s3);
	unless (s1 eq "xxyy") puts("bad 4.1");
	unless (s2 eq "yy") puts("bad 4.2");
	unless (s3 eq "x") puts("bad 4.3");

	s1 = "x";
	s2 = "y";
	reference_1_4_foo6(&s1, "foo61", &s2, "foo62");
	unless (s1 eq "foo61y") puts("bad 5.1");
	unless (s2 eq "yfoo62") puts("bad 5.2");

	s1 = "a";
	s2 = "b";
	reference_1_4_foo7("foo71", &s1, "foo72", "foo73", &s2);
	unless (s1 eq "foo71afoo72") puts("bad 6.1");
	unless (s2 eq "foo72foo73b") puts("bad 6.2");
}
reference_1_4();
} -output {}

test reference-1.5 {test parameter multiple declaration errs with references} -body {
#lang L -nowarn
void reference_1_5_1(string &arg1, string arg1)  {}
void reference_1_5_2(string &arg2, string &arg2) {}
void reference_1_5_3(string arg3,  string &arg3) {}
void reference_1_5_4(string &arg4, string &arg4, string arg4)  {}
void reference_1_5_5(string &arg5, string arg5,  string &arg5) {}
} -returnCodes error -match regexp -result {.*1: L Error: multiple declaration of local arg1
.*2: L Error: multiple declaration of local &arg2
.*3: L Error: multiple declaration of local arg3
.*4: L Error: multiple declaration of local &arg4
.*4: L Error: multiple declaration of local arg4
.*5: L Error: multiple declaration of local &arg5
.*5: L Error: multiple declaration of local arg5
.*5: L Error: multiple declaration of local arg5
}

test pointer-1 {check L pointers} -body {
#lang L
string pointer_1_g;
private string g;
private string ga[];
class pointer_1_cls {
	public	string s;
	public	string sa[];
	instance {
		public	string si;
		public	string sia[];
	}
}
private pointer_1_cls g_obj;
private int getobj_count = 0;
private pointer_1_cls get_obj()
{
	unless (defined(g_obj)) g_obj = pointer_1_cls_new();
	++getobj_count;
	return (g_obj);
}
private void chk(_unused string opt, poly var, string want, string new)
{
	string  have;

	unless (var =~ /::Lptr::/) puts("bad chk.1");
	eval("set have [set $var]");
	unless (have eq want) puts("bad chk.2");
	eval("set $var $new");
	eval("set have [set $var]");
	unless (have eq new) puts("bad chk.3");
}
void pointer_1()
{
	string  s;
	string	sa[];
	struct {
		string	s1;
		string	s2;
	} st;
	pointer_1_cls obj = pointer_1_cls_new();

	/*
	 * These check that the L variable or array/struct member and
	 * the anonymous variable whose name gets passed to chk() are
	 * linked in both directions.  A change in one should cause an
	 * identical change in the other.
	 *
	 * Locals, public globals, private globals, etc all are tested
	 * to ensure that pointers work with all the various kinds of
	 * Tcl variable name mangling that L does.
	 */

	s = "testing";
	chk(textvariable: &s, s, "new");
	unless (s eq "new") puts("bad 1.1");
	s = "testing2";
	chk(textvariable: &s, s, "new2");
	unless (s eq "new2") puts("bad 1.2");

	sa[3] = "testing";
	chk(textvariable: &sa[3], sa[3], "new");
	unless (sa[3] eq "new") puts("bad 2.1");
	sa[3] = "testing2";
	chk(textvariable: &sa[3], sa[3], "new2");
	unless (sa[3] eq "new2") puts("bad 2.2");

	pointer_1_g = "testing";
	chk(textvariable: &pointer_1_g, pointer_1_g, "new");
	unless (pointer_1_g eq "new") puts("bad 3.1");
	pointer_1_g = "testing2";
	chk(textvariable: &pointer_1_g, pointer_1_g, "new2");
	unless (pointer_1_g eq "new2") puts("bad 3.2");

	g = "testing";
	chk(textvariable: &g, g, "new");
	unless (g eq "new") puts("bad 4.1");
	g = "testing2";
	chk(textvariable: &g, g, "new2");
	unless (g eq "new2") puts("bad 4.2");

	ga[3] = "testing";
	chk(textvariable: &ga[3], ga[3], "new");
	unless (ga[3] eq "new") puts("bad 5.1");
	ga[3] = "testing2";
	chk(textvariable: &ga[3], ga[3], "new2");
	unless (ga[3] eq "new2") puts("bad 5.2");

	st.s1 = "testing";
	chk(textvariable: &st.s1, st.s1, "new");
	unless (st.s1 eq "new") puts("bad 10.1");
	st.s1 = "testing2";
	chk(textvariable: &st.s1, st.s1, "new2");
	unless (st.s1 eq "new2") puts("bad 10.2");

	st.s2 = "testing";
	chk(textvariable: &st.s2, st.s2, "new");
	unless (st.s2 eq "new") puts("bad 11.1");
	st.s2 = "testing2";
	chk(textvariable: &st.s2, st.s2, "new2");
	unless (st.s2 eq "new2") puts("bad 11.2");

	pointer_1_cls->s = "testing";
	chk(textvariable: &pointer_1_cls->s, pointer_1_cls->s, "new");
	unless (pointer_1_cls->s eq "new") puts("bad 20.1");
	pointer_1_cls->s = "testing2";
	chk(textvariable: &pointer_1_cls->s, pointer_1_cls->s, "new2");
	unless (pointer_1_cls->s eq "new2") puts("bad 20.2");

	pointer_1_cls->sa[3] = "testing";
	chk(textvariable: &pointer_1_cls->sa[3], pointer_1_cls->sa[3], "new");
	unless (pointer_1_cls->sa[3] eq "new") puts("bad 21.1");
	pointer_1_cls->sa[3] = "testing2";
	chk(textvariable: &pointer_1_cls->sa[3], pointer_1_cls->sa[3], "new2");
	unless (pointer_1_cls->sa[3] eq "new2") puts("bad 21.2");

	obj->si = "testing";
	chk(textvariable: &obj->si, obj->si, "new");
	unless (obj->si eq "new") puts("bad 22.1");
	obj->si = "testing2";
	chk(textvariable: &obj->si, obj->si, "new2");
	unless (obj->si eq "new2") puts("bad 22.2");

	obj->sia[3] = "testing";
	chk(textvariable: &obj->sia[3], obj->sia[3], "new");
	unless (obj->sia[3] eq "new") puts("bad 22.1");
	obj->sia[3] = "testing2";
	chk(textvariable: &obj->sia[3], obj->sia[3], "new2");
	unless (obj->sia[3] eq "new2") puts("bad 22.2");

	/*
	 * The getobj_count counts how many times get_obj() was called,
	 * to verify that &fn()->var evaluates fn exactly once.
	 */
	get_obj()->si = "testing";
	unless (getobj_count == 1) puts("bad 23.1");
	chk(textvariable: &get_obj()->si, get_obj()->si, "new");
	unless (getobj_count == 3) puts("bad 23.2");
	unless (get_obj()->si eq "new") puts("bad 23.3");
	get_obj()->si = "testing2";
	unless (getobj_count == 5) puts("bad 23.4");
	chk(textvariable: &get_obj()->si, get_obj()->si, "new2");
	unless (getobj_count == 7) puts("bad 23.5");
	unless (get_obj()->si eq "new2") puts("bad 23.6");
}
pointer_1();
} -output {}

test pointer-2 {check L pointer identification} -body {
#lang L
private void chk(_unused string opt, poly arg, string varname)
{
	unless (arg =~ /${varname}/) puts("bad chk.1");
}
void pointer_2()
{
	string	s;

	/* These are L pointers. */
	chk(textvariable: &s, "::Lptr::");
	chk(tvariable: &s, "::Lptr::");
	chk(variable: &s, "::Lptr::");

	/* These are reference parameters, not pointers. */
	chk(ariable: &s, "s");
	chk(o: &s, "s");
}
pointer_2();
} -output {}

test pointer-3 {check L pointer errors} -body {
#lang L -nowarn
class pointer_3_cls {}
private void chk(_unused string opt, _unused poly arg) {}
void pointer_3()
{
	string	saa[][];
	string	h{string};

	/*
	 * These should all issue errors, not crash the compiler.
	 */
	chk(textvariable: &undeclared1);
	chk(textvariable: &undeclared2[2]);
	chk(textvariable: &undeclared3.s);
	chk(textvariable: &undeclared4->s);
	chk(textvariable: &pointer_3_cls->undeclared1);
	chk(textvariable: &pointer_3_cls->undeclared2[3]);
	chk(textvariable: &saa[1][2]);
	chk(textvariable: &h{"bad"});
	chk(textvariable: &chk);
}
} -returnCodes error -match regexp -result {.*11: L Error: undeclared variable: undeclared1
.*12: L Error: undeclared variable: undeclared2
.*13: L Error: undeclared variable: undeclared3
.*14: L Error: undeclared variable: undeclared4
.*15: L Error: undeclared1 is not a member of class pointer_3_cls
.*16: L Error: undeclared2 is not a member of class pointer_3_cls
.*17: L Error: multiple indices not supported with &
.*18: L Error: illegal operand to &
.*19: L Error: illegal operand to &
}

test typedef-1.0 {basic typedef support} -body {
#lang L
typedef int typedef_1_0_foot[5];
typedef string typedef_1_0_nike;
typedef struct typedef_1_0_point {
  int x;
  int y;
} typedef_1_0_point;

void typedef_1_0() {
  puts(typedef_1_0_aux());
}

typedef_1_0_nike typedef_1_0_aux() {
  typedef_1_0_foot cheese;
  typedef_1_0_nike shoe = "pegasus";
  typedef_1_0_point p;

  p.x = 1;
  p.y = 2;
  puts(p);
  cheese[2] = 1;
  cheese[3] = 2;
  cheese[4] = 3;
  puts(cheese[3]);
  puts(shoe);
  return shoe;
}
#lang tcl
typedef_1_0
} -output "1 2\n2\npegasus\npegasus\n"

test typedef-1.1 {test redefining identical typedefs} -body {
#lang L
typedef int t1;
typedef int t1;
typedef int t1;

typedef float t2;
typedef float t2;
typedef float t2;

typedef string t3;
typedef string t3;
typedef string t3;

typedef poly t5;
typedef poly t5;
typedef poly t5;

typedef int a11_1[];
typedef int a11_1[];
typedef int a11_1[];

typedef int a11_2[2];
typedef int a11_2[2];
typedef int a11_2[2];

typedef int a11_3{int};
typedef int a11_3{int};
typedef int a11_3{int};

typedef int a11_4[2][3];
typedef int a11_4a[3];
typedef a11_4a a11_4[2];

typedef struct { int x,y; } s11_1;
typedef struct { int x,y; } s11_1;
typedef struct { int x,y; } s11_1;

typedef int int_typedef;

typedef int h11_1{int};
typedef int h11_1{int_typedef};
typedef int_typedef h11_1{int};
typedef int_typedef h11_1{int_typedef};

typedef int h11_2{int}{int};
typedef int h11_2a{int};
typedef h11_2a h11_2{int};
} -output ""

test typedef-1.2 {test redefining different typedefs} -body {
#lang L
typedef int t12;
typedef float t12;
typedef string t12;
typedef poly t12;     // not an error, but perhaps should be
typedef int t12[];
typedef int t12[2];
typedef int t12{int};
typedef struct { int i; } t12;

typedef int a12_1[];  // not an error -- array size is ignored
typedef int a12_1[2];

typedef int a12_2[2]; // not an error -- array size is ignored
typedef int a12_2[];

typedef int a12_3[2];
typedef string a12_3[2];

typedef int h12_1{int};
typedef int h12_1{string};

typedef int h12_2{int};
typedef string h12_2{int};

typedef int h12_3{int};
typedef string h12_3{string};

typedef struct { int x; } s12_1;
typedef struct { string x; } s12_1;

typedef struct { int x; } s12_2;
typedef struct { int x,y; } s12_2;

typedef struct { int x,y; } s12_3;
typedef struct { int x; } s12_3;

typedef struct s1 { int x; } s12_4;
typedef struct s2 { string x; } s12_4;

typedef struct s3 { int x; } s12_5;
typedef struct s4 { int x,y; } s12_5;

typedef struct s5 { int x,y; } s12_6;
typedef struct s6 { int x; } s12_6;
} -returnCodes error -match regexp -result {.*2: L Error: Cannot redefine type t12
.*3: L Error: Cannot redefine type t12
.*5: L Error: Cannot redefine type t12
.*6: L Error: Cannot redefine type t12
.*7: L Error: Cannot redefine type t12
.*8: L Error: Cannot redefine type t12
.*17: L Error: Cannot redefine type a12_3
.*20: L Error: Cannot redefine type h12_1
.*23: L Error: Cannot redefine type h12_2
.*26: L Error: Cannot redefine type h12_3
.*29: L Error: Cannot redefine type s12_1
.*32: L Error: Cannot redefine type s12_2
.*35: L Error: Cannot redefine type s12_3
.*38: L Error: Cannot redefine type s12_4
.*41: L Error: Cannot redefine type s12_5
.*44: L Error: Cannot redefine type s12_6
}

test typedef-1.3 {test some typedef cases} -body {
#lang L
/*
 * This is really a regression test.  These have caused errors in the past.
 */
typedef int	int_t;
typedef int	h1_t{int_t};
typedef int_t	h2_t{int};
typedef int_t	h3_t{int_t};
void typedef_1_3()
{
	int	k, n;
	h1_t	h1 = { 1=>2 };
	h2_t	h2 = { 3=>4, 5=>6 };
	h3_t	h3 = { 7=>8, 9=>10, 11=>12 };

	unless (h1{1} == 2) puts("bad 1");
	n = 0;
	foreach (k in h1) ++n;
	unless (n == 1) puts("bad 2");

	unless ((h2{3} == 4) && (h2{5} == 6)) puts("bad 3");
	n = 0;
	foreach (k in h2) ++n;
	unless (n == 2) puts("bad 4");

	unless ((h3{7} == 8) && (h3{9} == 10) && (h3{11} == 12)) puts("bad 4");
	n = 0;
	foreach (k in h3) ++n;
	unless (n == 3) puts("bad 5");
}
#lang tcl
typedef_1_3
} -output {}

test typedef-1.4 {test another typedef case} -body {
#lang L
/* Another regression test.  This used to fail. */
typedef struct {
	int x;
	int y;
} typedef_1_4_t;

typedef_1_4_t typedef_1_4_bars{string};

void typedef_1_4_foo(typedef_1_4_t f)
{
	typedef_1_4_bars{"FOO"} = f;
	puts("X = ${f.x}");
}

void typedef_1_4()
{
	typedef_1_4_t	f = { 1, 2 };
	typedef_1_4_foo(f);
}
#lang tcl
typedef_1_4
} -output {X = 1
}


test defined-1.0 {interesting defined form support} -body {
#lang L
void defined_1_0() {
  int arr[5][2], i, j;
  for (i = 0; defined(arr[i]); i++) {
    for (j = 0; defined(arr[i][j]); j++) {
      puts(format("%d, %d", i, j));
    }
  }
  puts("-*-");
  puts(defined(arr[3]));
  puts(defined(arr[-1]));
}
#lang tcl
defined_1_0
} -output "-*-
0
0
"

test defined-1.1 {defined works on hashes} -body {
#lang L
void defined_1_1() {
	hash foo[5];

	foo[2]{"a"} = 1;
	foo[3]{"b"} = 2;
	
	if (defined(foo[2]{"a"})) {
		puts("defined works");
	}
	if (!defined(foo[2]{"b"})) {
		puts("defined works even better");
	}
}
#lang tcl
defined_1_1
} -output "defined works\ndefined works even better\n"

test main-1.0 {test that main gets called} -setup {
	set fname [makeFile {
		void main() {
			printf("main got called\n");
		}
	} test-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile test-1.0.l
} -result {main got called}

test defined-1.2 {defined operator on scalars} -body {
#lang L
int d12_fint() { return 0; }
float d12_ffloat() { return 0.0; }
string d12_fstring() { return "0"; }
void
defined_1_2()
{
	int	i;
	int	ii = 0;
	string	s;
	string	ss = "";
	float	f;
	float	ff = 3.14159;

	if (defined(i))  puts("err 1");
	unless (defined(ii)) puts("err 2");
	if (defined(s))  puts("err 3");
	unless (defined(ss)) puts("err 4");
	if (defined(f))  puts("err 5");
	unless (defined(ff)) puts("err 6");
	unless (defined(0))  puts("err 7");
	unless (defined(1))  puts("err 7");
	unless (defined("")) puts("err 8");
	unless (defined("x")) puts("err 9");
	unless (defined(0.0)) puts("err 10");
	unless (defined(1.0)) puts("err 11");
	unless (defined(d12_fint()))    puts("err 12");
	unless (defined(d12_ffloat()))  puts("err 13");
	unless (defined(d12_fstring())) puts("err 14");
	unless (defined(1-0))     puts("err 16");
	unless (defined(1+2+3+4)) puts("err 17");
}
#lang tcl
defined_1_2
} -output ""

test defined-1.3 {defined operator on auto-extended arrays} -body {
#lang L
void
defined_1_3()
{
	int	i;
	int	a[];
	int	a3[3] = {0, 0, 0};
	string	s[];
	string	s3[3] = {"", "", ""};
	float	f[];
	float	f3[3] = {0.0, 0.0, 0.0};
	string	h{int}[];

	a[3] = 3;
	a[5] = 5;
	a[6] = 6;
	a[8] = 8;
	if (defined(a[0]))     puts("err 1.1");
	if (defined(a[1]))     puts("err 1.2");
	if (defined(a[2]))     puts("err 1.3");
	unless (defined(a[3])) puts("err 1.4");
	if (defined(a[4]))     puts("err 1.5");
	unless (defined(a[5])) puts("err 1.6");
	unless (defined(a[6])) puts("err 1.7");
	if (defined(a[7]))     puts("err 1.8");
	unless (defined(a[8])) puts("err 1.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(a[i])) printf("err 1.10 i=%d\n", i);
	}

	unless (defined(a3[0])) puts("err 2.1");
	unless (defined(a3[1])) puts("err 2.2");
	unless (defined(a3[2])) puts("err 2.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(a3[i])) printf("err 2.4 i=%d\n", i);
	}

	s[3] = "3";
	s[5] = "5";
	s[6] = "6";
	s[8] = "8";
	if (defined(s[0]))     puts("err 3.1");
	if (defined(s[1]))     puts("err 3.2");
	if (defined(s[2]))     puts("err 3.3");
	unless (defined(s[3])) puts("err 3.4");
	if (defined(s[4]))     puts("err 3.5");
	unless (defined(s[5])) puts("err 3.6");
	unless (defined(s[6])) puts("err 3.7");
	if (defined(s[7]))     puts("err 3.8");
	unless (defined(s[8])) puts("err 3.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(s[i])) printf("err 3.10 i=%d\n", i);
	}

	unless (defined(s3[0])) puts("err 4.1");
	unless (defined(s3[1])) puts("err 4.2");
	unless (defined(s3[2])) puts("err 4.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(s3[i])) printf("err 4.4 i=%d\n", i);
	}

	f[3] = 3.0;
	f[5] = 5.0;
	f[6] = 6.0;
	f[8] = 8.0;
	if (defined(f[0]))     puts("err 5.1");
	if (defined(f[1]))     puts("err 5.2");
	if (defined(f[2]))     puts("err 5.3");
	unless (defined(f[3])) puts("err 5.4");
	if (defined(f[4]))     puts("err 5.5");
	unless (defined(f[5])) puts("err 5.6");
	unless (defined(f[6])) puts("err 5.7");
	if (defined(f[7]))     puts("err 5.8");
	unless (defined(f[8])) puts("err 5.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(f[i])) printf("err 5.10 i=%d\n", i);
	}

	unless (defined(f3[0])) puts("err 5.1");
	unless (defined(f3[1])) puts("err 5.2");
	unless (defined(f3[2])) puts("err 5.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(f3[i])) printf("err 5.4 i=%d\n", i);
	}

	h{0}[2] = "2";
	if (defined(h{0}[0]))     puts("err 6.1");
	if (defined(h{0}[1]))     puts("err 6.2");
	unless (defined(h{0}[2])) puts("err 6.3");
	if (defined(h{0}[3]))     puts("err 6.4");
}
#lang tcl
defined_1_3
} -output ""

test defined-1.4 {check propagation of undefined values} -body {
#lang L
int
d14(int i)
{
	return (i);
}
void
defined_1_4()
{
	int	i, j;
	int	a[];

	a[1] = 1;  // a[0] is now undefined
	i = a[0];  // i is now undefined
	j = d14(i);  // j is now undefined

	if (defined(a[0])) puts("err 1");
	if (defined(i)) puts("err 2");
	if (defined(j)) puts("err 3");
	if (defined(d14(i))) puts("err 4");
	if (defined(d14(j))) puts("err 5");
	if (defined(d14(d14(j)))) puts("err 6");
	if (defined(d14(d14(d14(j))))) puts("err 7");
}
#lang tcl
defined_1_4
} -output ""

test defined-1.5 {check that tcl shimmering does not make undef defined} -body {
#lang L
void defined_1_5()
{
	/*
	 * This tests that the use of the undefined "s" in the printf,
	 * or the undefined ah[0] in the foreach, does not shimmer the
	 * shared undef object to something that is defined.  This was
	 * a bug in an earlier implementation of undef.
	 */

	string	a[], s;
	int	ah[]{int}, k, v;

	s = a[0];  // s is now undef

	if (defined(s)) puts("bad 1.1");
	printf("s = '%s'\n", s);
	if (defined(s)) puts("bad 1.2");
	printf("s = '%s'\n", s);

	if (defined(ah[0])) puts("bad 2.1");
	foreach (k=>v in ah[0]) {}
	if (defined(ah[0])) puts("bad 2.2");
	if (defined(s)) puts("bad 1.3");
}
defined_1_5();
} -output {s = ''
s = ''
}

test defined-1.6 {check undef constant} -body {
#lang L
string defined_1_6_foo(string arg)
{
	if (arg) {
		return (arg);
	} else {
		return (undef);
	}
}
void defined_1_6()
{
	int	i;

	if (defined(undef)) puts("bad 0.1");

	i = undef;
	if (defined(i)) puts("bad 1.1");
	printf("i = '%s'\n", i);
	if (defined(i)) puts("bad 1.2");

	i = 0;
	unless (defined(i)) puts("bad 2.1");
	printf("i = '%s'\n", i);
	unless (defined(i)) puts("bad 2.2");

	i = undef;
	if (defined(i)) puts("bad 3.1");
	printf("i = '%s'\n", i);
	if (defined(i)) puts("bad 3.2");

	unless (defined(defined_1_6_foo("1"))) puts("bad 4.1");
	if (defined(defined_1_6_foo("0"))) puts("bad 4.2");
	if (defined(defined_1_6_foo(undef))) puts("bad 4.3");
}
defined_1_6();
} -output {i = ''
i = '0'
i = ''
}

test defined-1.7 {check attempted assignment to undef} -body {
#lang L
void defined_1_7()
{
	undef = 1;
	undef += 1;
	++undef;
	undef--;
	undef =~ s/a/b/;
}
} -returnCodes error -match regexp -result {.*3: L Error: invalid l-value in assignment
.*4: L Error: invalid l-value in assignment
.*5: L Error: invalid l-value in inc/dec
.*6: L Error: invalid l-value in inc/dec
.*7: L Error: invalid l-value in =~
}

test defined-1.8 {check attempted declaration of undef} -body {
#lang L
void undef() {}
int undef;
void defined_1_8()
{
	int	undef;
}
} -returnCodes error -match regexp -result {.*1: L Error: cannot use undef for function name
.*2: L Error: cannot use undef for variable name
.*5: L Error: cannot use undef for variable name
}

test defined-1.9 {check that undef has type poly} -body {
#lang L
class defined_1_9_cls {}
void defined_1_9()
{
	int	i;
	float	f;
	string	s;
	int	a[], aa[][];
	int	h{int}, hh{int}{int};
	struct { int i,j; } st;
	defined_1_9_cls o;

	/* None of these should be type errors. */

	i = undef;
	if (defined(i)) puts("bad 1");
	f = undef;
	if (defined(f)) puts("bad 2");
	s = undef;
	if (defined(s)) puts("bad 3");
	a = undef;
	if (defined(a)) puts("bad 4");
	aa = undef;
	if (defined(aa)) puts("bad 5");
	h = undef;
	if (defined(h)) puts("bad 6");
	hh = undef;
	if (defined(hh)) puts("bad 7");
	st = undef;
	if (defined(st)) puts("bad 8");
	o = undef;
	if (defined(o)) puts("bad 9");
}
defined_1_9();
} -output {}

test defined-1.10 {check undef as a reference parameter} -body {
#lang L
void defined_1_10_foo(int &arg) { arg = 0; }
void defined_1_10()
{
	defined_1_10_foo(&undef);  // err
}
defined_1_10();
} -returnCodes error -match regexp -result {.*4: L Error: illegal operand to &
}

test defined-1.11 {check that assignment to part of an obj makes it defined} -body {
#lang L
void defined_1_11()
{
	string	s;
	string	a[];
	string	aa[][];
	string	h{string};
	string	hh{string}{string};

	if (defined(s)) puts("bad 1.1");
	s[0] = "x";
	unless (defined(s)) puts("bad 1.2");

	if (defined(a)) puts("bad 2.1");
	a[0] = "x";
	unless (defined(a)) puts("bad 2.2");

	if (defined(aa)) puts("bad 3.1");
	a[0][0] = "x";
	unless (defined(a)) puts("bad 3.2");
	unless (defined(a[0])) puts("bad 3.3");

	if (defined(h)) puts("bad 4.1");
	h{"k"} = "v";
	unless (defined(h)) puts("bad 4.2");

	if (defined(hh)) puts("bad 5.1");
	hh{"k1"}{"k2"} = "v";
	unless (defined(hh)) puts("bad 5.2");
	unless (defined(hh{"k1"})) puts("bad 5.3");
}
defined_1_11();
} -output {}

test toplevel-1.0 {Toplevel code in L} -body {
#lang L
int toplevel_1_0_i = 2;
printf("at the toplevel, i is: %d\n", toplevel_1_0_i);

void toplevel_1_0(void) {
  printf("in toplevel_1_0, i is: %d\n", toplevel_1_0_i);
}
#lang tcl
toplevel_1_0
} -output {at the toplevel, i is: 2
in toplevel_1_0, i is: 2
}

test toplevel-1.1 {Toplevel code via the L command, sharing variables} -body {
L { puts("Accent on helpful side of your nature.  Drain the moat."); }
proc toplevel_1_1 {} {
    set v 2
    L {
        string v = "Sphenic numbers always have exactly eight divisors.";
    }
    puts $v
}
toplevel_1_1
} -output {Accent on helpful side of your nature.  Drain the moat.
Sphenic numbers always have exactly eight divisors.
}

test typecheck-1.0 {L typechecking} -body {
#lang L
string typecheck_1_0_foo() {
	return "string";
}

void typecheck_1_0() {
	puts(typecheck_1_0_foo() + 22);
}
#lang tcl
typecheck_1_0
} -returnCodes {error} -match glob \
-result "*:6: L Error: expected type int or float but got string*\n"

test typecheck-1.1 {arity check} -body {
#lang L -nowarn
void typecheck_1_1_foo() {}
void typecheck_1_1_bar(int a, int b) {}
void typecheck_1_1() {
	typecheck_1_1_foo(1, 2, 3);
	typecheck_1_1_bar();
}
#lang tcl
} -returnCodes {error} -match glob \
-result "*:4: L Error: too many arguments for function typecheck_1_1_foo
*:5: L Error: not enough arguments for function typecheck_1_1_bar\n"

test typecheck-1.2 {check functions returning int arrays of arrays} -body {
#lang L
int[]
typecheck_1_2_int()
{
	int	i, a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = i;
	}
	return a;
}
int[][]
typecheck_1_2_int_int()
{
	int	i, j, a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = 10*i + j;
		}
	}
	return a;
}
int[][][]
typecheck_1_2_int_int_int()
{
	int	i, j, k, a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = 100*i + 10*j + k;
			}
		}
	}
	return a;
}
void
typecheck_1_2()
{
	int	i, j, k;
	int	one[3];
	int	two[3][4];
	int	three[3][4][5];

	one   = typecheck_1_2_int();
	two   = typecheck_1_2_int_int();
	three = typecheck_1_2_int_int_int();

	for (i = 0; i < 3; ++i) {
		unless (one[i] == i) {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] == (10*i + j)) {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] == (100*i + 10*j + k)) {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_2();
} -output {}

test typecheck-1.3 {check functions returning float arrays of arrays} -body {
#lang L
float[]
typecheck_1_3_float()
{
	int	i;
	float	a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = i;
	}
	return a;
}
float[][]
typecheck_1_3_float_float()
{
	int	i, j;
	float	a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = 10.0*i + j;
		}
	}
	return a;
}
float[][][]
typecheck_1_3_float_float_float()
{
	int	i, j, k;
	float	a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = 100.0*i + 10.0*j + k;
			}
		}
	}
	return a;
}
void
typecheck_1_3()
{
	int	i, j, k;
	float	one[3];
	float	two[3][4];
	float	three[3][4][5];

	one   = typecheck_1_3_float();
	two   = typecheck_1_3_float_float();
	three = typecheck_1_3_float_float_float();

	/*
	 * Although testing equality of floats is usually unwise,
	 * there should be sufficient precision in this case to make
	 * the comparisons true when they should be.
	 */
	for (i = 0; i < 3; ++i) {
		unless (one[i] == i) {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] == (10.0*i + j)) {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] == (100.0*i+10.0*j+k)) {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_3();
} -output {}

test typecheck-1.4 {check functions returning string arrays of arrays} -body {
#lang L
string[]
typecheck_1_4_string()
{
	int	i;
	string	a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = "${i}";
	}
	return a;
}
string[][]
typecheck_1_4_string_string()
{
	int	i, j;
	string	a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = "${i}:${j}";
		}
	}
	return a;
}
string[][][]
typecheck_1_4_string_string_string()
{
	int	i, j, k;
	string	a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = "${i}:${j}:${k}";
			}
		}
	}
	return a;
}
void
typecheck_1_4()
{
	int	i, j, k;
	string	one[3];
	string	two[3][4];
	string	three[3][4][5];

	one   = typecheck_1_4_string();
	two   = typecheck_1_4_string_string();
	three = typecheck_1_4_string_string_string();

	for (i = 0; i < 3; ++i) {
		unless (one[i] eq "${i}") {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] eq "${i}:${j}") {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] eq "${i}:${j}:${k}") {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_4();
} -output {}

test typecheck-1.5 {check functions returning void arrays are illegal} -body {
#lang L
void[] typecheck_1_5() { return; }
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal.*
}

test typecheck-2.1 {check int-to-float casts and coercions} -body {
#lang L
float
typecheck_2_1_return_float(float f)
{
	return f;
}

float
typecheck_2_1_sum_three_floats(float f1, float f2, float f3)
{
	return f1 + f2 + f3;
}

void
typecheck_2_1()
{
	/*
	 * Exact comparisons with floats must be done with care.  Keep
	 * the precision of the numbers low so there is sufficient
	 * precision for the variable comparisons to be true when
	 * intended.
	 */

	/* Test initializers and all comparison ops that allow floats. */

	int	i1 = 1964;
	int	i2 = 0;
	float	f1 = i1;
	float	f2 = 0.0;

	unless (f1 == 1964)        puts("BAD 1.1.1");
	unless (1964 == f1)        puts("BAD 1.1.2");
	unless (f1 == 1964.0)      puts("BAD 1.1.3");
	unless (1964.0 == f1)      puts("BAD 1.1.4");
	unless (f1 == (float)1964) puts("BAD 1.1.5");
	unless ((float)1964 == f1) puts("BAD 1.1.6");
	unless (f1 == (float)i1)   puts("BAD 1.1.7");
	unless ((float)i1 == f1)   puts("BAD 1.1.8");
	unless (f1 == i1)          puts("BAD 1.1.9");
	unless (i1 == f1)          puts("BAD 1.1.10");

	unless (f1 >= 1964)        puts("BAD 1.2.1");
	unless (1964 >= f1)        puts("BAD 1.2.2");
	unless (f1 >= 1964.0)      puts("BAD 1.2.3");
	unless (1964.0 >= f1)      puts("BAD 1.2.4");
	unless (f1 >= (float)1964) puts("BAD 1.2.5");
	unless ((float)1964 >= f1) puts("BAD 1.2.6");
	unless (f1 >= (float)i1)   puts("BAD 1.2.7");
	unless ((float)i1 >= f1)   puts("BAD 1.2.8");
	unless (f1 >= i1)          puts("BAD 1.2.9");
	unless (i1 >= f1)          puts("BAD 1.2.10");

	unless (f1 <= 1964)        puts("BAD 1.3.1");
	unless (1964 <= f1)        puts("BAD 1.3.2");
	unless (f1 <= 1964.0)      puts("BAD 1.3.3");
	unless (1964.0 <= f1)      puts("BAD 1.3.4");
	unless (f1 <= (float)1964) puts("BAD 1.3.5");
	unless ((float)1964 <= f1) puts("BAD 1.3.6");
	unless (f1 <= (float)i1)   puts("BAD 1.3.7");
	unless ((float)i1 <= f1)   puts("BAD 1.3.8");
	unless (f1 <= i1)          puts("BAD 1.3.9");
	unless (i1 <= f1)          puts("BAD 1.3.10");

	unless (f1 != 1999)        puts("BAD 1.4.1");
	unless (1999 != f1)        puts("BAD 1.4.2");
	unless (f1 != 1999.0)      puts("BAD 1.4.3");
	unless (1999.0 != f1)      puts("BAD 1.4.4");
	unless (f1 != (float)1999) puts("BAD 1.4.5");
	unless ((float)1999 != f1) puts("BAD 1.4.6");
	unless (f1 != (float)i2)   puts("BAD 1.4.7");
	unless ((float)i2 != f1)   puts("BAD 1.4.8");
	unless (f1 != i2)          puts("BAD 1.4.9");
	unless (i2 != f1)          puts("BAD 1.4.10");

	/* Test assignments and all binary ops that allow floats. */

	i2 = 1965;
	f2 = i2;
	unless (f2 == 1965.0) puts("BAD 2.1");

	f2 = f2 + 1;
	unless (f2 == 1966.0) puts("BAD 2.2");

	f2 = f2 - 2;
	unless (f2 == 1964.0) puts("BAD 2.3");

	f2 = f2 / 2;
	unless (f2 == 982.0)  puts("BAD 2.4");

	f2 = f2 * 2;
	unless (f2 == 1964.0) puts("BAD 2.5");

	f2 = i2;
	f2 = 1 + f2;
	unless (f2 == 1966.0) puts("BAD 3.1");

	f2 = -2 + f2;
	unless (f2 == 1964.0) puts("BAD 3.2");

	f2 = f2 / 2;
	unless (f2 == 982.0)  puts("BAD 3.3");

	f2 = 2;
	f2 = 2 / f2;
	unless (f2 == 1.0)    puts("BAD 3.4");

	i2 = 1965;
	f2 = i2;
	f2 += 1;
	unless (f2 == 1966.0) puts("BAD 4.1");

	f2 -= 2;
	unless (f2 == 1964.0) puts("BAD 4.2");

	f2 /= 2;
	unless (f2 == 982.0)  puts("BAD 4.3");

	f2 *= 2;
	unless (f2 == 1964.0) puts("BAD 4.4");

	/* Test that int actuals coerce to a float when the formal is a float. */

	f2 = typecheck_2_1_return_float(1);
	unless (f2 == 1.0)    puts("BAD 5.1");

	i2 = 3;
	f2 = typecheck_2_1_return_float(i2);
	unless (f2 == 3.0)    puts("BAD 5.2");

	f2 = typecheck_2_1_sum_three_floats(1, 2, 3);
	unless (f2 = 6.0)     puts("BAD 5.3");

	i1 = 1;
	i2 = 3;
	f2 = typecheck_2_1_sum_three_floats(i1, i2, 3);
	unless (f2 = 6.0)     puts("BAD 5.4");
}
typecheck_2_1();
} -output ""

test typecheck-3.1 {void illegal in if-stmt conditional} -body {
#lang L
void typecheck_3_1_v() { return; }
void
typecheck_3_1()
{
	if (typecheck_3_1_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.2 {void illegal in unless-stmt conditional} -body {
#lang L
void typecheck_3_2_v() { return; }
void
typecheck_3_2()
{
	unless (typecheck_3_2_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.3 {void illegal in while-loop conditional} -body {
#lang L
void typecheck_3_3_v() { return; }
void
typecheck_3_3()
{
	while (typecheck_3_3_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.4 {void illegal in do-loop conditional} -body {
#lang L
void typecheck_3_4_v() { return; }
void
typecheck_3_4()
{
	do {
		return;
	} while(typecheck_3_4_v());
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.5 {void illegal in for-loop conditional} -body {
#lang L
void typecheck_3_5_v() { return; }
void
typecheck_3_5()
{
	for (1; typecheck_3_5_v(); 1) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.6 {void illegal in abbreviated-for-loop conditional} -body {
#lang L
void typecheck_3_6_v() { return; }
void
typecheck_3_6()
{
	for (1; typecheck_3_6_v();) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.10 {void illegal in binary operators} -body {
#lang L
void t310v() { return; }
void
typecheck_3_10()
{
	int	i;

	if (t310v() && 0) return;
	if (0 && t310v()) return;
	if (t310v() || 0) return;
	if (0 || t310v()) return;
	if (t310v() =~ /bad/) return;
	if (t310v() eq "") return;
	if ("" eq t310v()) return;
	if (t310v() ne "") return;
	if ("" ne t310v()) return;
	if (t310v() gt "") return;
	if ("" gt t310v()) return;
	if (t310v() ge "") return;
	if ("" ge t310v()) return;
	if (t310v() lt "") return;
	if ("" lt t310v()) return;
	if (t310v() le "") return;
	if ("" le t310v()) return;
	if (t310v() == 0)  return;
	if (0 == t310v())  return;
	if (t310v() != 0)  return;
	if (0 != t310v())  return;
	if (t310v() > 0)   return;
	if (0 > t310v())   return;
	if (t310v() >= 0)  return;
	if (0 >= t310v())  return;
	if (t310v() < 0)   return;
	if (0 < t310v())   return;
	if (t310v() <= 0)  return;
	if (0 <= t310v())  return;
	i = t310v() + 1;
	i = 1 + t310v();
	i = t310v() - 1;
	i = 1 - t310v();
	i = t310v() * 1;
	i = 1 * t310v();
	i = t310v() / 1;
	i = 1 / t310v();
	i = t310v() % 1;
	i = 1 % t310v();
	i = t310v() & 1;
	i = 1 & t310v();
	i = t310v() | 1;
	i = 1 | t310v();
	i = t310v() ^ 1;
	i = 1 ^ t310v();
	i = t310v() << 1;
	i = 1 << t310v();
	i = t310v() >> 1;
	i = 1 >> t310v();
}
} -returnCodes error -match regexp -result {.*7: L Error: void type illegal in predicate
.*8: L Error: void type illegal in predicate
.*9: L Error: void type illegal in predicate
.*10: L Error: void type illegal in predicate
.*11: L Error: expected type.*but got void in =~
.*12: L Error: expected type.*but got void in string comparison
.*13: L Error: expected type.*but got void in string comparison
.*14: L Error: expected type.*but got void in string comparison
.*15: L Error: expected type.*but got void in string comparison
.*16: L Error: expected type.*but got void in string comparison
.*17: L Error: expected type.*but got void in string comparison
.*18: L Error: expected type.*but got void in string comparison
.*19: L Error: expected type.*but got void in string comparison
.*20: L Error: expected type.*but got void in string comparison
.*21: L Error: expected type.*but got void in string comparison
.*22: L Error: expected type.*but got void in string comparison
.*23: L Error: expected type.*but got void in string comparison
.*24: L Error: expected type.*but got void in arithmetic operator
.*25: L Error: expected type.*but got void in arithmetic operator
.*26: L Error: expected type.*but got void in arithmetic operator
.*27: L Error: expected type.*but got void in arithmetic operator
.*28: L Error: expected type.*but got void in arithmetic operator
.*29: L Error: expected type.*but got void in arithmetic operator
.*30: L Error: expected type.*but got void in arithmetic operator
.*31: L Error: expected type.*but got void in arithmetic operator
.*32: L Error: expected type.*but got void in arithmetic operator
.*33: L Error: expected type.*but got void in arithmetic operator
.*34: L Error: expected type.*but got void in arithmetic operator
.*35: L Error: expected type.*but got void in arithmetic operator
.*36: L Error: expected type.*but got void in arithmetic operator
.*37: L Error: expected type.*but got void in arithmetic operator
.*38: L Error: expected type.*but got void in arithmetic operator
.*39: L Error: expected type.*but got void in arithmetic operator
.*40: L Error: expected type.*but got void in arithmetic operator
.*41: L Error: expected type.*but got void in arithmetic operator
.*42: L Error: expected type.*but got void in arithmetic operator
.*43: L Error: expected type.*but got void in arithmetic operator
.*44: L Error: expected type.*but got void in arithmetic operator
.*45: L Error: expected type.*but got void in arithmetic operator
.*46: L Error: expected type.*but got void in arithmetic operator
.*47: L Error: expected type.*but got void in arithmetic operator
.*48: L Error: expected type.*but got void in arithmetic operator
.*49: L Error: expected type.*but got void in arithmetic operator
.*50: L Error: expected type.*but got void in arithmetic operator
.*51: L Error: expected type.*but got void in arithmetic operator
.*52: L Error: expected type.*but got void in arithmetic operator
.*53: L Error: expected type.*but got void in arithmetic operator
.*54: L Error: expected type.*but got void in arithmetic operator
.*55: L Error: expected type.*but got void in arithmetic operator
}

test typecheck-3.11 {void illegal in casts and unary operators} -body {
#lang L
void t311v() { return; }
void
typecheck_3_11()
{
	int	i;
	float	f;
	string	s;
	hash	h;

	i = (int)t311v();
	f = (float)t311v();
	s = (string)t311v();
	h = (hash)t311v();
	i = !t311v();
	i = ~t311v();
	i = +t311v();
	i = -t311v();
}
} -returnCodes error -match regexp -result {.*10: L Error: type void illegal
.*11: L Error: type void illegal
.*12: L Error: type void illegal
.*13: L Error: type void illegal
.*14: L Error: expected type int.*
.*15: L Error: expected type int.*
.*16: L Error: expected type int or float.*
.*17: L Error: expected type int or float.*
}

test typecheck-3.12 {void illegal in assignments} -body {
#lang L
void t312v() { return; }
int takes_int(int i) { return i; }
void
typecheck_3_12()
{
	int	i;

	i = t312v();
	i += t312v();
	i -= t312v();
	i /= t312v();
	i *= t312v();
	i %= t312v();
	i &= t312v();
	i |= t312v();
	i ^= t312v();
	i >>= t312v();
	i <<= t312v();
	takes_int(t312v());
}
} -returnCodes error -match regexp -result {.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal
.*11: L Error: type void illegal
.*12: L Error: type void illegal
.*13: L Error: type void illegal
.*14: L Error: type void illegal
.*15: L Error: type void illegal
.*16: L Error: type void illegal
.*17: L Error: type void illegal
.*18: L Error: type void illegal
.*19: L Error: parameter 1 has incompatible type
}

test typecheck-3.13 {void illegal as foreach expr} -body {
#lang L -nowarn
void t313v() { return; }
void
typecheck_3_13()
{
	int	k;

	foreach (k in t313v()) { }
}
} -returnCodes error -match regexp -result {.*foreach expression must be array, hash, or string}

test typecheck-4.1 {type errors in foreach} -body {
#lang L
void
typecheck_4_1()
{
	int	vi;
	float	vf;
	string	vs;
	int	ai[2] = { 22, 23 };
	string	as[2] = { "b", "c" };
	float	af[2] = { 2.1, 2.2 };
	hash	h = { 1=>2, 2=>3 };

	foreach (vi in as) {}
	foreach (vi in af) {}
	foreach (vs in ai) {}
	foreach (vs in af) {}
	foreach (vf in as) {}
	foreach (vi,vi in h) {}
}
} -returnCodes error -match regexp -result {.*12: L Error: loop index type incompatible with array element type
.*13: L Error: loop index type incompatible with array element type
.*14: L Error: loop index type incompatible with array element type
.*15: L Error: loop index type incompatible with array element type
.*16: L Error: loop index type incompatible with array element type
.*17: L Error: multiple variables illegal in foreach over hash
}

test typecheck-4.2 {type errors in foreach with multiple variables} -body {
#lang L
void
typecheck_4_2()
{
	int	i1,i2,i3;
	float	f1,f2,f3;
	string	s1,s2,s3;
	int	ai[3] = { 22, 23, 24 };
	string	as[3] = { "b", "c", "d" };
	float	af[3] = { 2.1, 2.2, 2.3 };

	foreach (i1,s2,s3 in as) {}
	foreach (s1,i2,s3 in as) {}
	foreach (s1,s2,i3 in as) {}
	foreach (s1,i2,i3 in ai) {}
	foreach (i1,s2,i3 in ai) {}
	foreach (i1,i2,s3 in ai) {}
	foreach (s1,f2,f3 in af) {}
	foreach (f1,s2,f3 in af) {}
	foreach (f1,f2,s3 in af) {}

	/* Make sure that multiple type errors get caught. */
	foreach (i1,i2,s3 in as) {}
	foreach (i1,i2,i3 in as) {}
}
} -returnCodes error -match regexp -result {.*11: L Error: loop index type incompatible with array element type
.*12: L Error: loop index type incompatible with array element type
.*13: L Error: loop index type incompatible with array element type
.*14: L Error: loop index type incompatible with array element type
.*15: L Error: loop index type incompatible with array element type
.*16: L Error: loop index type incompatible with array element type
.*17: L Error: loop index type incompatible with array element type
.*18: L Error: loop index type incompatible with array element type
.*19: L Error: loop index type incompatible with array element type
.*22: L Error: loop index type incompatible with array element type
.*22: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
}

test typecheck-4.3 {type errors in conditional expressions} -body {
#lang L
void
typecheck_4_3()
{
	/* Conditional expressions must be of scalar type. */

	int	a[];
	int	h{int};
	struct { int i,j; } st;

	if (a) puts("bad");
	if (h) puts("bad");
	if (st) puts("bad");
}
#lang tcl
} -returnCodes error -match regexp -result {.*10: L Error: predicate must be scalar
.*11: L Error: predicate must be scalar
.*12: L Error: predicate must be scalar
}

test typehceck-4.4 {scalars as condition expressions} -body {
#lang L
void
typecheck_4_4()
{
	/* These are all legal. */

	int	i = 0;
	float	f = 0.0;
	string	s1 = "0", s2 = "1";
	poly	p = "0";

	if (i) puts("bad 1");
	if (f) puts("bad 2");  // Exact comparisons w/floats don't always work

	/* Strings as conditionals get compared against "0". */
	if (s1) puts("bad 3");
	unless (s2) puts("bad 4");

	if (p) puts("bad 6");
}
typecheck_4_4();
} -output {}

test typecheck-5.1 {type errors in hash elements} -body {
#lang L
struct st51 {
	int	x;
	int	y;
};
void
typecheck_5_1()
{
	int		a[3], i;
	string		s;
	float		f;
	poly		p;
	struct st51	st = {0,0};

	int		ihi{int};
	int		ihs{string};
	int		ihf{float};

	string		shi{int};
	string		shs{string};
	string		shf{float};

	float		fhi{int};
	float		fhs{string};
	float		fhf{float};

	poly		phi{int};
	poly		phs{string};
	poly		phf{float};

	ihi{1.1} = 0;	// These want an index of type int.
	ihi{"s"} = 0;
	ihi{st}  = 0;
	ihi{a}   = 0;
	ihi{shi} = 0;
	shi{1.1} = "s";
	shi{"s"} = "s";
	shi{st}  = "s";
	shi{a}   = "s";
	shi{shi} = "s";
	fhi{1.1} = 0.0;
	fhi{"s"} = 0.0;
	fhi{st}  = 0.0;
	fhi{a}   = 0.0;
	fhi{shi} = 0.0;
	phi{1.1} = 0.0;
	phi{"s"} = 0.0;
	phi{st}  = 0.0;
	phi{a}   = 0.0;
	phi{shi} = 0.0;
	i = ihi{1.1};
	i = ihi{"s"};
	i = ihi{st};
	i = ihi{a};
	i = ihi{shi};
	s = shi{1.1};
	s = shi{"s"};
	s = shi{st};
	s = shi{a};
	s = shi{shi};
	f = fhi{1.1};
	f = fhi{"s"};
	f = fhi{st};
	f = fhi{a};
	f = fhi{shi};
	p = phi{1.1};
	p = phi{"s"};
	p = phi{st};
	p = phi{a};
	p = phi{shi};
	ihs{1.1} = 0;	// These want an index of type string.
	ihs{0}   = 0;
	ihs{st}  = 0;
	ihs{a}   = 0;
	ihs{shi} = 0;
	shs{1.1} = "s";
	shs{0}   = "s";
	shs{st}  = "s";
	shs{a}   = "s";
	shs{shi} = "s";
	fhs{1.1} = 0.0;
	fhs{0}   = 0.0;
	fhs{st}  = 0.0;
	fhs{a}   = 0.0;
	fhs{shi} = 0.0;
	phs{1.1} = 0.0;
	phs{0}   = 0.0;
	phs{st}  = 0.0;
	phs{a}   = 0.0;
	phs{shi} = 0.0;
	i = ihs{1.1};
	i = ihs{0};
	i = ihs{st};
	i = ihs{a};
	i = ihs{shi};
	s = shs{1.1};
	s = shs{0};
	s = shs{st};
	s = shs{a};
	s = shs{shi};
	f = fhs{1.1};
	f = fhs{0};
	f = fhs{st};
	f = fhs{a};
	f = fhs{shi};
	p = phs{1.1};
	p = phs{0};
	p = phs{st};
	p = phs{a};
	p = phs{shi};
	ihf{"s"} = 0;	// These want an index of type float (but int is OK).
	ihf{st}  = 0;
	ihf{a}   = 0;
	ihf{shi} = 0;
	shf{"s"} = "s";
	shf{st}  = "s";
	shf{a}   = "s";
	shf{shi} = "s";
	fhf{"s"} = 0.0;
	fhf{st}  = 0.0;
	fhf{a}   = 0.0;
	fhf{shi} = 0.0;
	phf{"s"} = 0.0;
	phf{st}  = 0.0;
	phf{a}   = 0.0;
	phf{shi} = 0.0;
	i = ihf{"s"};
	i = ihf{st};
	i = ihf{a};
	i = ihf{shi};
	s = shf{"s"};
	s = shf{st};
	s = shf{a};
	s = shf{shi};
	f = fhf{"s"};
	f = fhf{st};
	f = fhf{a};
	f = fhf{shi};
	p = phf{"s"};
	p = phf{st};
	p = phf{a};
	p = phf{shi};
}
#lang tcl
typecheck_5_1
} -returnCodes error -match regexp -result {.*30: L Error: expected type int but got float in hash index
.*31: L Error: expected type int but got string in hash index
.*32: L Error: expected type int but got struct in hash index
.*33: L Error: expected type int but got array in hash index
.*34: L Error: expected type int but got hash in hash index
.*35: L Error: expected type int but got float in hash index
.*36: L Error: expected type int but got string in hash index
.*37: L Error: expected type int but got struct in hash index
.*38: L Error: expected type int but got array in hash index
.*39: L Error: expected type int but got hash in hash index
.*40: L Error: expected type int but got float in hash index
.*41: L Error: expected type int but got string in hash index
.*42: L Error: expected type int but got struct in hash index
.*43: L Error: expected type int but got array in hash index
.*44: L Error: expected type int but got hash in hash index
.*45: L Error: expected type int but got float in hash index
.*46: L Error: expected type int but got string in hash index
.*47: L Error: expected type int but got struct in hash index
.*48: L Error: expected type int but got array in hash index
.*49: L Error: expected type int but got hash in hash index
.*50: L Error: expected type int but got float in hash index
.*51: L Error: expected type int but got string in hash index
.*52: L Error: expected type int but got struct in hash index
.*53: L Error: expected type int but got array in hash index
.*54: L Error: expected type int but got hash in hash index
.*55: L Error: expected type int but got float in hash index
.*56: L Error: expected type int but got string in hash index
.*57: L Error: expected type int but got struct in hash index
.*58: L Error: expected type int but got array in hash index
.*59: L Error: expected type int but got hash in hash index
.*60: L Error: expected type int but got float in hash index
.*61: L Error: expected type int but got string in hash index
.*62: L Error: expected type int but got struct in hash index
.*63: L Error: expected type int but got array in hash index
.*64: L Error: expected type int but got hash in hash index
.*65: L Error: expected type int but got float in hash index
.*66: L Error: expected type int but got string in hash index
.*67: L Error: expected type int but got struct in hash index
.*68: L Error: expected type int but got array in hash index
.*69: L Error: expected type int but got hash in hash index
.*70: L Error: expected type string but got float in hash index
.*71: L Error: expected type string but got int in hash index
.*72: L Error: expected type string but got struct in hash index
.*73: L Error: expected type string but got array in hash index
.*74: L Error: expected type string but got hash in hash index
.*75: L Error: expected type string but got float in hash index
.*76: L Error: expected type string but got int in hash index
.*77: L Error: expected type string but got struct in hash index
.*78: L Error: expected type string but got array in hash index
.*79: L Error: expected type string but got hash in hash index
.*80: L Error: expected type string but got float in hash index
.*81: L Error: expected type string but got int in hash index
.*82: L Error: expected type string but got struct in hash index
.*83: L Error: expected type string but got array in hash index
.*84: L Error: expected type string but got hash in hash index
.*85: L Error: expected type string but got float in hash index
.*86: L Error: expected type string but got int in hash index
.*87: L Error: expected type string but got struct in hash index
.*88: L Error: expected type string but got array in hash index
.*89: L Error: expected type string but got hash in hash index
.*90: L Error: expected type string but got float in hash index
.*91: L Error: expected type string but got int in hash index
.*92: L Error: expected type string but got struct in hash index
.*93: L Error: expected type string but got array in hash index
.*94: L Error: expected type string but got hash in hash index
.*95: L Error: expected type string but got float in hash index
.*96: L Error: expected type string but got int in hash index
.*97: L Error: expected type string but got struct in hash index
.*98: L Error: expected type string but got array in hash index
.*99: L Error: expected type string but got hash in hash index
.*100: L Error: expected type string but got float in hash index
.*101: L Error: expected type string but got int in hash index
.*102: L Error: expected type string but got struct in hash index
.*103: L Error: expected type string but got array in hash index
.*104: L Error: expected type string but got hash in hash index
.*105: L Error: expected type string but got float in hash index
.*106: L Error: expected type string but got int in hash index
.*107: L Error: expected type string but got struct in hash index
.*108: L Error: expected type string but got array in hash index
.*109: L Error: expected type string but got hash in hash index
.*110: L Error: expected type float but got string in hash index
.*111: L Error: expected type float but got struct in hash index
.*112: L Error: expected type float but got array in hash index
.*113: L Error: expected type float but got hash in hash index
.*114: L Error: expected type float but got string in hash index
.*115: L Error: expected type float but got struct in hash index
.*116: L Error: expected type float but got array in hash index
.*117: L Error: expected type float but got hash in hash index
.*118: L Error: expected type float but got string in hash index
.*119: L Error: expected type float but got struct in hash index
.*120: L Error: expected type float but got array in hash index
.*121: L Error: expected type float but got hash in hash index
.*122: L Error: expected type float but got string in hash index
.*123: L Error: expected type float but got struct in hash index
.*124: L Error: expected type float but got array in hash index
.*125: L Error: expected type float but got hash in hash index
.*126: L Error: expected type float but got string in hash index
.*127: L Error: expected type float but got struct in hash index
.*128: L Error: expected type float but got array in hash index
.*129: L Error: expected type float but got hash in hash index
.*130: L Error: expected type float but got string in hash index
.*131: L Error: expected type float but got struct in hash index
.*132: L Error: expected type float but got array in hash index
.*133: L Error: expected type float but got hash in hash index
.*134: L Error: expected type float but got string in hash index
.*135: L Error: expected type float but got struct in hash index
.*136: L Error: expected type float but got array in hash index
.*137: L Error: expected type float but got hash in hash index
.*138: L Error: expected type float but got string in hash index
.*139: L Error: expected type float but got struct in hash index
.*140: L Error: expected type float but got array in hash index
.*141: L Error: expected type float but got hash in hash index
}

test typecheck-6.1 {type check errors with push built-in} -body {
#lang L -nowarn
class typecheck_6_1_cls {}
void
typecheck_6_1()
{
	int	a[], aa[][], i, j;
	int	h{int};
	float	f;
	string	s;
	struct { int i,j; } st;
	poly	p;
	typecheck_6_1_cls o;

	/* Errors -- first arg not a reference (&). */
	push(a, i);
	push(i, i);
	push(h, i);
	push(f, i);
	push(s, i);
	push(st, i);
	push(p, i);

	/* Error -- too many arguments. */
	push(a, i, j);
	push(a, i, j, j);

	/* Error -- too few arguments. */
	push(&a);
	push();

	/* Error -- first arg not an array reference. */
	push(&i, i);
	push(&h, i);
	push(&f, i);
	push(&s, i);
	push(&st, i);
	push(&1, i);
	push(&3.14159, i);
	push(&o, i);
}
#lang tcl
typecheck_6_1
} -returnCodes {error} -match regexp -result {.*:14: L Error: first arg to push not an array reference.*
.*:15: L Error: first arg to push not an array reference.*
.*:16: L Error: first arg to push not an array reference.*
.*:17: L Error: first arg to push not an array reference.*
.*:18: L Error: first arg to push not an array reference.*
.*:19: L Error: first arg to push not an array reference.*
.*:20: L Error: first arg to push not an array reference.*
.*:23: L Error: incorrect # arguments to push
.*:24: L Error: incorrect # arguments to push
.*:27: L Error: incorrect # arguments to push
.*:28: L Error: incorrect # arguments to push
.*:31: L Error: first arg to push not an array reference.*
.*:32: L Error: first arg to push not an array reference.*
.*:33: L Error: first arg to push not an array reference.*
.*:34: L Error: first arg to push not an array reference.*
.*:35: L Error: first arg to push not an array reference.*
.*:36: L Error: first arg to push not an array reference.*
.*:37: L Error: first arg to push not an array reference.*
.*:38: L Error: first arg to push not an array reference.*
}

test typecheck-6.2 {type check errors with push built-in 2} -body {
#lang L
void typecheck_6_2_v() { }
void
typecheck_6_2()
{
	int	ai[];
	string	as[], s;
	float	af[], f;
	int	aa[][], a[];		// array of array, and an array
	int	ah[]{int}, h{int};	// array of hash, and a hash
	struct { int i,j; } ast[], st;	// array of struct, and a struct

	/*
	 * Check pushing incompatible type onto the array.  Just check
	 * for an array of int, since we check the full type-checker
	 * elsewhere.
	 */

	push(&ai, typecheck_6_2_v());  // pushing a void

	push(&ai, f);
	push(&ai, s);
	push(&ai, a);
	push(&ai, aa);
	push(&ai, as);
	push(&ai, af);
	push(&ai, h);
	push(&ai, ah);
	push(&ai, st);
	push(&ai, ast);
}
#lang tcl
typecheck_6_2
} -returnCodes {error} -match regexp -result {.*:18: L Error: pushing incompatible type onto array
.*:20: L Error: pushing incompatible type onto array
.*:21: L Error: pushing incompatible type onto array
.*:22: L Error: pushing incompatible type onto array
.*:23: L Error: pushing incompatible type onto array
.*:24: L Error: pushing incompatible type onto array
.*:25: L Error: pushing incompatible type onto array
.*:26: L Error: pushing incompatible type onto array
.*:27: L Error: pushing incompatible type onto array
.*:28: L Error: pushing incompatible type onto array
.*:29: L Error: pushing incompatible type onto array
}

test typecheck-6.3 {type check push built-in} -body {
#lang L
void
typecheck_6_3()
{
	int	ai[], i;
	string	as[], s;
	float	af[], f;
	poly	ap[], p;
	int	aa[][], a[];		// array of array, and an array
	int	ah[]{int}, h{int};	// array of hash, and a hash
	struct { int i,j; } ast[], st;	// array of struct, and a struct

	/* All legal. */

	push(&ai, 0);
	push(&ai, i);

	push(&as, "s");
	push(&as, s);

	push(&af, 3.14);
	push(&af, f);
	push(&af, 0);  // legal to push ints onto a float array
	push(&af, i);

	push(&ap, 0);
	push(&ap, 3.14);
	push(&ap, "s");
	push(&ap, i);
	push(&ap, s);
	push(&ap, f);
	push(&ap, p);
	push(&ap, ai);
	push(&ap, as);
	push(&ap, af);
	push(&ap, ap);
	push(&ap, ast);
	push(&ap, h);
	push(&ap, st);

	push(&ah, h);

	push(&aa, a);

	push(&ast, st);
}
#lang tcl
typecheck_6_3
} -output {}

test typecheck-7.1 {test type checking of reference parameters} -body {
#lang L -nowarn
void typecheck_7_1_foo(int &a) {}
void typecheck_7_1()
{
	int	a;

	typecheck_7_1_foo(a);  // incorrect arg type
}
typecheck_7_1();
} -returnCodes error -match regexp -result {.*6: L Error: parameter 1 has incompatible type
}

test typecheck-9.1 {illegal types in function prototype declarations} -body {
#lang L
void typecheck_9_1_1(void, void);
void typecheck_9_1_2(void, void, void);
void typecheck_9_1_3(int, void);
void typecheck_9_1_4(void, int);
void typecheck_9_1_5(void[]);
void typecheck_9_1_6(void[][]);
void typecheck_9_1_7(void{int});
void typecheck_9_1_8(void{int}[]);
void typecheck_9_1_9(void[]{int});
void typecheck_9_1_10(void &bad);
void typecheck_9_1_11(int{void});
void{int} typecheck_9_1_12();
void[] typecheck_9_1_13();
int{void} typecheck_9_1_14();
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal
.*1: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*3: L Error: type void illegal
.*4: L Error: type void illegal
.*5: L Error: type void illegal
.*6: L Error: type void illegal
.*7: L Error: type void illegal
.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal in declaration of 'bad'
.*11: L Error: type void illegal
.*12: L Error: type void illegal in declaration of 'typecheck_9_1_12'
.*13: L Error: type void illegal in declaration of 'typecheck_9_1_13'
.*14: L Error: type void illegal in declaration of 'typecheck_9_1_14'
}

test typecheck-9.2 {illegal types in function pointer args} -body {
#lang L
void typecheck_9_2_1(void &bad(void, void));
void typecheck_9_2_2(void &bad(void, void, void));
void typecheck_9_2_3(void &bad(int, void));
void typecheck_9_2_4(void &bad(void, int));
void typecheck_9_2_5(void &bad(void[]));
void typecheck_9_2_6(void &bad(void[][]));
void typecheck_9_2_7(void &bad(void{int}));
void typecheck_9_2_8(void &bad(void{int}[]));
void typecheck_9_2_9(void &bad(void[]{int}));
void typecheck_9_2_10(void &bad(void &bad));
void typecheck_9_2_11(void &bad(int{void}));
void typecheck_9_2_12(void{int} &bad());
void typecheck_9_2_13(void[] &bad());
void typecheck_9_2_14(int{void} &bad());
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal
.*1: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*3: L Error: type void illegal
.*4: L Error: type void illegal
.*5: L Error: type void illegal
.*6: L Error: type void illegal
.*7: L Error: type void illegal
.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal in declaration of 'bad'
.*11: L Error: type void illegal
.*12: L Error: type void illegal in declaration of 'bad'
.*13: L Error: type void illegal in declaration of 'bad'
.*14: L Error: type void illegal in declaration of 'bad'
}

test typecheck-9.3 {illegal types in variable declarations 1} -body {
#lang L
void typecheck_9_3()
{
	void	bad1;
	void	bad2[];
	void	bad3[][];
	void	bad4{int};
	void	bad5{int}{int};
	void	bad6[]{int};
	void	bad7{int}[];
	int	bad8{void};
	int	bad9[]{void}{int};
	int	&bad10;
	int	&bad11[];
	int	&bad12{int};
	int	&bad13(void);
	int	&bad14(int);
	int	&bad15(int arg);
}
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*4: L Error:.*bad2.*
.*5: L Error:.*bad3.*
.*6: L Error:.*bad4.*
.*7: L Error:.*bad5.*
.*8: L Error:.*bad6.*
.*9: L Error:.*bad7.*
.*10: L Error:.*bad8.*
.*11: L Error:.*bad9.*
.*12: L Error:.*bad10.*
.*13: L Error:.*bad11.*
.*14: L Error:.*bad12.*
.*15: L Error:.*bad13.*
.*16: L Error:.*bad14.*
.*17: L Error:.*bad15.*
}

test typecheck-9.3.1 {illegal types in variable declarations 2} -body {
#lang L
void typecheck_9_3_1()
{
	void	bad1, bad2[], bad3[][],	bad4{int}, bad5{int}{int};
	void	bad6[]{int}, bad7{int}[], bad8{void}, bad9[]{void}{int};
	int	&bad10, &bad11[], &bad12{int}, &bad13(void);
	int	&bad14(int), &bad15(int arg);
}
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*3: L Error:.*bad2.*
.*3: L Error:.*bad3.*
.*3: L Error:.*bad4.*
.*3: L Error:.*bad5.*
.*4: L Error:.*bad6.*
.*4: L Error:.*bad7.*
.*4: L Error:.*bad8.*
.*4: L Error:.*bad9.*
.*5: L Error:.*bad10.*
.*5: L Error:.*bad11.*
.*5: L Error:.*bad12.*
.*5: L Error:.*bad13.*
.*6: L Error:.*bad14.*
.*6: L Error:.*bad15.*
}

test typecheck-9.3.2 {illegal types in variable declarations 3} -body {
#lang L
typedef void &t932();
void typecheck_9_3_2()
{
	t932	bad1;
	t932	bad2[];
	t932	bad3[][];
	t932	bad4{int};
	t932	bad5{int}{int};
	t932	bad6[]{int};
	t932	bad7{int}[];
	t932	bad8{void};
	t932	bad9[]{void}{int};
	t932	&bad10;
	t932	&bad11[];
	t932	&bad12{int};
	t932	&bad13(void);
	t932	&bad14(int);
	t932	&bad15(int arg);
}
} -returnCodes error -match regexp -result {.*4: L Error:.*bad1.*
.*5: L Error:.*bad2.*
.*6: L Error:.*bad3.*
.*7: L Error:.*bad4.*
.*8: L Error:.*bad5.*
.*9: L Error:.*bad6.*
.*10: L Error:.*bad7.*
.*11: L Error:.*bad8.*
.*12: L Error:.*bad9.*
.*13: L Error:.*bad10.*
.*14: L Error:.*bad11.*
.*15: L Error:.*bad12.*
.*16: L Error:.*bad13.*
.*17: L Error:.*bad14.*
.*18: L Error:.*bad15.*
}

test typecheck-9.4 {illegal types in struct declarations 1} -body {
#lang L
struct {
	void	bad1;
	void	bad2[];
	void	bad3[][];
	void	bad4{int};
	void	bad5{int}{int};
	void	bad6[]{int};
	void	bad7{int}[];
	int	bad8{void};
	int	bad9[]{void}{int};
	int	&bad10;
	int	&bad11[];
	int	&bad12{int};
	int	&bad13(void);
	int	&bad14(int);
	int	&bad15(int arg);
};
} -returnCodes error -match regexp -result {.*2: L Error:.*bad1.*
.*3: L Error:.*bad2.*
.*4: L Error:.*bad3.*
.*5: L Error:.*bad4.*
.*6: L Error:.*bad5.*
.*7: L Error:.*bad6.*
.*8: L Error:.*bad7.*
.*9: L Error:.*bad8.*
.*10: L Error:.*bad9.*
.*11: L Error:.*bad10.*
.*12: L Error:.*bad11.*
.*13: L Error:.*bad12.*
.*14: L Error:.*bad13.*
.*15: L Error:.*bad14.*
.*16: L Error:.*bad15.*
}

test typecheck-9.4.1 {illegal types in struct declarations 2} -body {
#lang L
struct {
	void	bad1, bad2[], bad3[][], bad4{int}, bad5{int}{int};
	void	bad6[]{int}, bad7{int}[], bad8{void};
	int	bad9[]{void}{int}, &bad10, &bad11[];
	int	&bad12{int}, &bad13(void), &bad14(int), &bad15(int arg);
};
} -returnCodes error -match regexp -result {.*2: L Error:.*bad1.*
.*2: L Error:.*bad2.*
.*2: L Error:.*bad3.*
.*2: L Error:.*bad4.*
.*2: L Error:.*bad5.*
.*3: L Error:.*bad6.*
.*3: L Error:.*bad7.*
.*3: L Error:.*bad8.*
.*4: L Error:.*bad9.*
.*4: L Error:.*bad10.*
.*4: L Error:.*bad11.*
.*5: L Error:.*bad12.*
.*5: L Error:.*bad13.*
.*5: L Error:.*bad14.*
.*5: L Error:.*bad15.*
}

test typecheck-9.4.2 {illegal types in struct declarations 3} -body {
#lang L
typedef void &t942();
struct {
	t942	bad1;
	t942	bad2[];
	t942	bad3[][];
	t942	bad4{int};
	t942	bad5{int}{int};
	t942	bad6[]{int};
	t942	bad7{int}[];
	t942	bad8{void};
	t942	bad9[]{void}{int};
	t942	&bad10;
	t942	&bad11[];
	t942	&bad12{int};
	t942	&bad13(void);
	t942	&bad14(int);
	t942	&bad15(int arg);
};
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*4: L Error:.*bad2.*
.*5: L Error:.*bad3.*
.*6: L Error:.*bad4.*
.*7: L Error:.*bad5.*
.*8: L Error:.*bad6.*
.*9: L Error:.*bad7.*
.*10: L Error:.*bad8.*
.*11: L Error:.*bad9.*
.*12: L Error:.*bad10.*
.*13: L Error:.*bad11.*
.*14: L Error:.*bad12.*
.*15: L Error:.*bad13.*
.*16: L Error:.*bad14.*
.*17: L Error:.*bad15.*
}

test typecheck-9.4.3 {call-by-name type errors} -body {
#lang L -nowarn
typedef int arr_t[];
typedef int hash_t{int};
typedef struct { int i,j; } struc_t;
void t943(int &i, string &s, float &f, arr_t &a, hash_t &h, struc_t &st) {}

void typecheck_9_4_3()
{
	int	i;
	string	s;
	float	f;
	arr_t	a;
	hash_t	h;
	struc_t	st;

	t943( i, &s, &f, &a, &h, &st);
	t943(&i,  s, &f, &a, &h, &st);
	t943(&i, &s,  f, &a, &h, &st);
	t943(&i, &s, &f,  a, &h, &st);
	t943(&i, &s, &f, &a,  h, &st);
	t943(&i, &s, &f, &a, &h,  st);
	t943( i,  s,  f,  a,  h,  st);
}
} -returnCodes error -match regexp -result {.*15: L Error: parameter 1 has incompatible type
.*16: L Error: parameter 2 has incompatible type
.*17: L Error: parameter 3 has incompatible type
.*18: L Error: parameter 4 has incompatible type
.*19: L Error: parameter 5 has incompatible type
.*20: L Error: parameter 6 has incompatible type
.*21: L Error: parameter 1 has incompatible type
.*21: L Error: parameter 2 has incompatible type
.*21: L Error: parameter 3 has incompatible type
.*21: L Error: parameter 4 has incompatible type
.*21: L Error: parameter 5 has incompatible type
.*21: L Error: parameter 6 has incompatible type
}

test typecheck-10.1 {check type errors in op=} -body {
#lang L
void typecheck_10_1()
{
	int	i1, i2;
	string	s1;


	i1 += s1;
	i1 -= s1;
	i1 *= s1;
	i1 /= s1;

	i1 %= s1;
	s1 %= i1;
	i1 &= s1;
	s1 &= i1;
	i1 |= s1;
	s1 |= i1;
	i1 ^= s1;
	s1 ^= i1;
	i1 <<= s1;
	s1 <<= i1;
	i1 >>= s1;
	s1 >>= i1;

	i1 .= i2;
	i1 .= s1;
	s1 .= i1;
}
} -returnCodes error -match regexp -result {.*7: L Error: assignment of incompatible types
.*8: L Error: assignment of incompatible types
.*9: L Error: assignment of incompatible types
.*10: L Error: assignment of incompatible types
.*12: L Error: assignment of incompatible types
.*13: L Error: assignment of incompatible types
.*14: L Error: assignment of incompatible types
.*15: L Error: assignment of incompatible types
.*16: L Error: assignment of incompatible types
.*17: L Error: assignment of incompatible types
.*18: L Error: assignment of incompatible types
.*19: L Error: assignment of incompatible types
.*20: L Error: assignment of incompatible types
.*21: L Error: assignment of incompatible types
.*22: L Error: assignment of incompatible types
.*23: L Error: assignment of incompatible types
.*25: L Error: expected type string but got int in .=
.*26: L Error: assignment of incompatible types
.*27: L Error: assignment of incompatible types
}

test fnptr-1 {function pointers 1} -body {
#lang L
typedef string &fnptr1_t(int);

string fnptr1_doit(int x)
{
	return ("doit got ${x}");
}
string fnptr1_foo(string &f(int))
{
	return (f(33));
}
string fnptr1_foo2(fnptr1_t f)
{
	return (f(44));
}
void fnptr_1()
{
	unless (fnptr1_foo(&fnptr1_doit) eq "doit got 33") puts("bad 1");
	unless (fnptr1_foo2(&fnptr1_doit) eq "doit got 44") puts("bad 2");
}
#lang tcl
fnptr_1
} -output {}

test fnptr-2 {function pointers 2} -body {
#lang L
typedef int &fnptr2_t(poly,poly);

/* Integer comparison. */
int icmp(int a, int b)
{
	if (a < b) {
		return -1;
	} else if (a > b) {
		return 1;
	} else {
		return 0;
	}
}

/* Unary comparison. */
int ucmp(string a, string b)
{
	int	al = strlen(a);
	int	bl = strlen(b);

	if (al < bl) {
		return -1;
	} else if (al > bl) {
		return 1;
	} else {
		return 0;
	}
}

string fnptr2_sort(poly[] a, fnptr2_t compar)
{
	int	i, swapped;

	do {
		swapped = 0;
		for (i = 0; i < length(a)-1; ++i) {
			if (compar(a[i], a[i+1]) > 0) {
				poly t = a[i];
				a[i]   = a[i+1];
				a[i+1] = t;
				swapped = 1;
			}
		}
	} while (swapped);

	return ((string)a);
}

void fnptr_2()
{
	unless (fnptr2_sort((int[])"3 1 4 1 5 9", &icmp) eq "1 1 3 4 5 9") {
		puts("bad 1");
	}
	unless (fnptr2_sort((string[])"111 1 1 11 111111111 11111", &ucmp) eq
		"1 1 11 111 11111 111111111") {
		puts("bad 2");
	}
}
#lang tcl
fnptr_2
} -output {}

test fnptr-3 {function pointer type errors} -body {
#lang L -nowarn
typedef void &fp3_v_v_t(void);
typedef void &fp3_v_i_t(int);
typedef int  &fp3_i_v_t(void);
typedef int  &fp3_i_i_t(int);
typedef void &fp3_v_is_t(int, string);

void fp3_v_v(void)  {}
void fp3_v_i(int i) {}
int  fp3_i_v(void)  { return (0); }
int  fp3_i_i(int i) { return (i); }
void fp3_v_is(int i, string s) {}

void fp3f_vv (fp3_v_v_t f)   { f();  }
void fp3f_vi (fp3_v_i_t f)   { f(1); }
void fp3f_iv (fp3_i_v_t f)   { f();  }
void fp3f_ii (fp3_i_i_t f)   { f(1); }
void fp3f_vis(fp3_v_is_t f) { f(1,"s"); }

void fnptr_3()
{
	fp3f_vv(1);
	fp3f_vv(1.1);
	fp3f_vv((int[])"1 2 3");
	fp3f_vv((hash)"1 2 3 4");
	fp3f_vv((struct { int i,j; })"1 2");

	/* Try all the various error combinations, given the above types. */

	fp3f_vv(fp3_v_v);
	fp3f_vv(&fp3_v_i);
	fp3f_vv(&fp3_i_v);
	fp3f_vv(&fp3_i_i);
	fp3f_vv(&fp3_v_is);

	fp3f_vi(fp3_v_i);
	fp3f_vi(&fp3_v_v);
	fp3f_vi(&fp3_i_v);
	fp3f_vi(&fp3_i_i);
	fp3f_vi(&fp3_v_is);

	fp3f_iv(fp3_i_v);
	fp3f_iv(&fp3_v_v);
	fp3f_iv(&fp3_v_i);
	fp3f_iv(&fp3_i_i);
	fp3f_iv(&fp3_v_is);

	fp3f_ii(fp3_i_i);
	fp3f_ii(&fp3_v_v);
	fp3f_ii(&fp3_v_i);
	fp3f_ii(&fp3_i_v);
	fp3f_ii(&fp3_v_is);

	fp3f_vis(fp3_v_is);
	fp3f_vis(&fp3_v_v);
	fp3f_vis(&fp3_v_i);
	fp3f_vis(&fp3_i_v);
	fp3f_vis(&fp3_i_i);
}
} -returnCodes error -match regexp -result {.*21: L Error: parameter 1.*
.*22: L Error: parameter 1.*
.*23: L Error: parameter 1.*
.*24: L Error: parameter 1.*
.*25: L Error: parameter 1.*
.*30: L Error: parameter 1.*
.*31: L Error: parameter 1.*
.*32: L Error: parameter 1.*
.*33: L Error: parameter 1.*
.*36: L Error: parameter 1.*
.*37: L Error: parameter 1.*
.*38: L Error: parameter 1.*
.*39: L Error: parameter 1.*
.*42: L Error: parameter 1.*
.*43: L Error: parameter 1.*
.*44: L Error: parameter 1.*
.*45: L Error: parameter 1.*
.*48: L Error: parameter 1.*
.*49: L Error: parameter 1.*
.*50: L Error: parameter 1.*
.*51: L Error: parameter 1.*
.*54: L Error: parameter 1.*
.*55: L Error: parameter 1.*
.*56: L Error: parameter 1.*
.*57: L Error: parameter 1.*
}

test assign-1 {check assignment statement value and type} -body {
#lang L
void
assign_1()
{
	/*
	 * Check type and value of "lhs = rhs".  Rhs should be
	 * evaluated before lhs.  The type of (lhs = rhs) should be
	 * the type of lhs and have the value of lhs.
	 */

	int	i, j, k;
	float	f, g;
	string	s1, s2;
	int	a1[], a2[], a3[];
	int	h1{int}, h2{int}, h3{int};

	i = (j = 13);
	unless ((i == 13) && (j == 13)) puts("bad 1");

	i = (j = (k = 14));
	unless ((i == 14) && (j == 14) && (k == 14)) puts("bad 2");

	i = j = k = 14;  // = should be right associative
	unless ((i == 14) && (j == 14) && (k == 14)) puts("bad 2.1");

	/* Note: exact comparisons against floats don't always work. */
	f = (g = (i = 1));
	unless ((f == 1.0) && (g == 1.0)) puts("bad 3");

	s1 = (s2 = "ok");
	unless ((s1 eq "ok") && (s2 eq "ok")) puts("bad 4");

	a1[0] = 3;
	a3 = (a2 = a1);
	unless ((a1[0] == 3) && !defined(a1[1])) puts("bad 5.1");
	unless ((a2[0] == 3) && !defined(a2[1])) puts("bad 5.2");
	unless ((a3[0] == 3) && !defined(a3[1])) puts("bad 5.3");

	h1{1} = 4;
	h3 = (h2 = h1);
	unless ((h1{1} == 4) && (h2{1} == 4) && (h3{1} == 4)) puts("bad 6.1");
	foreach (i in h1) unless (i == 1) puts("bad 6.2");
	foreach (i in h2) unless (i == 1) puts("bad 6.3");
	foreach (i in h3) unless (i == 1) puts("bad 6.4");

	/* Check that rhs is evaluated *before* lhs. */

	i = 0;
	a1[i] = (i = 2);
	unless (a1[2] == 2) puts("bad 7");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] = ++i;
	unless ((a1[3] == 1) && (a1[4] == 4)) puts("bad 8");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] = i++;
	unless ((a1[3] == 1) && (a1[4] == 3)) puts("bad 9");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] += ++i;
	unless ((a1[3] == 1) && (a1[4] == 6)) puts("bad 10");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] += i++;
	unless ((a1[3] == 1) && (a1[4] == 5)) puts("bad 11");
}
#lang tcl
assign_1
} -output {}

test backtrace-1.0 {backtracing in L} -setup {
	set fname [makeFile {
void foo()
{
	puts("foo", "bar");
}

void bar()
{
	foo();
}

int
main()
{
	bar();
}

	} backtrace-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile backtrace-1.0.l
} -returnCodes {error} -match regexp -result {.*line 4.*line 9.*line 15}

test pattern-1.0 {L pattern functions} -body {
#lang L
poly Pattern_()
{
	// This is NOT a pattern function (because the _ is trailing).
	puts("Pattern_");
}
poly Pattern_foo(int a, int b)
{
	puts("Pattern_foo special case ${a} ${b}");
}
poly Pattern_*(int a, int b)
{
	puts("Pattern_* ${$1} ${a} ${b}");
}
void pattern2(string f, string s, int a)
{
	puts("Pattern2 ${f} ${s} ${a}");
}
void p1_0_widget(string f, int a)
{
	puts("widget ${f} ${a}");
}
void pattern_1_0()
{
	string	w = "p1_0_widget";

	Pattern_foo(1, 2);  // calls Pattern_foo(1, 2)
	Pattern_bar(3, 4);  // calls Pattern_*(3, 4) where $1 gets "bar"
	Pattern_baz(5, 6);  // calls Pattern_*(5, 6) where $1 gets "baz"
	Pattern_();	    // calls Pattern_()
	Pattern2_bar(w, 1); // calls p1_0_widget("bar", 1)
}
pattern_1_0();
#lang tcl
} -output {Pattern_foo special case 1 2
Pattern_* bar 3 4
Pattern_* baz 5 6
Pattern_
widget bar 1
}

test pattern-1.1 {L pattern function errors} -body {
#lang L
void pattern_1_1()
{
	string	a[];
	string	h{string};
	poly	p;

	/*
	 * By assigning the return value to a variable, we verify
	 * that the compiler assigns a return type (poly) even
	 * in the face of an error.
	 */

	p = Foo_bar();
	p = Foo_bar(1);
	p = Foo_bar(1.1);
	p = Foo_bar(a);
	p = Foo_bar(h);
}
} -returnCodes {error} -match regexp -result {.*13: L Error: pattern function call has no args
.*14: L Error: first arg to pattern function is not string
.*15: L Error: first arg to pattern function is not string
.*16: L Error: first arg to pattern function is not string
.*17: L Error: first arg to pattern function is not string
}

test pattern-1.2 {check pattern function argument type checking} -body {
#lang L -nowarn
void Pattern120_*() {}
void Pattern121_*(int a) {}
void Pattern122_*(int a, int b) {}
void pattern_1_2()
{
	Pattern120_foo(1);
	Pattern121_foo();
	Pattern121_foo(1,2);
	Pattern122_foo();
	Pattern122_foo(1);
	Pattern122_foo(1,2,3);
}
pattern_1_2();
} -returnCodes {error} -match regexp -result {.*6: L Error: too many arguments for function Pattern120_foo
.*7: L Error: not enough arguments for function Pattern121_foo
.*8: L Error: too many arguments for function Pattern121_foo
.*9: L Error: not enough arguments for function Pattern122_foo
.*10: L Error: not enough arguments for function Pattern122_foo
.*11: L Error: too many arguments for function Pattern122_foo
}

test include-1.0 {include files} -setup {
	set fname [makeFile {
			++include_1_0;
			unless (basename(__FILE__) eq "foo-1.0.l") puts("bad 1");
			unless (__LINE__ == 4) puts("bad 2");
		   } foo-1.0.l ../tests]
} -body {
#lang L
int include_1_0 = 0;
puts(include_1_0);
include("foo-1.0.l");
puts(include_1_0);
// Check variations in spacing and punctation.
// The compiler should include foo-1.0.l only once.
include("foo-1.0.l") ;
include ("foo-1.0.l");
include ("foo-1.0.l") ;
include ( "foo-1.0.l") ;
include ( "foo-1.0.l" ) ;
include("foo-1.0.l");;
puts(include_1_0);
} -cleanup {
	removeFile $fname
} -output {0
1
1
}

test include-1.1 {nested include files} -setup {
#
# The code for these files isn't indented because L recognizes
# include() only when it starts at the beginning of the line.
#
	set fname1 [makeFile {
include("foo-1.1-2.l");
unless (basename(__FILE__) eq "foo-1.1-1.l") puts("bad 1");
unless (__LINE__ == 4) puts("bad 2");
} foo-1.1-1.l ../tests]
	set fname2 [makeFile {
int include_1_1a = 3;
unless (basename(__FILE__) eq "foo-1.1-2.l") puts("bad 3");
unless (__LINE__ == 4) puts("bad 4");
include("foo-1.1-3.l");
unless (basename(__FILE__) eq "foo-1.1-2.l") puts("bad 5");
unless (__LINE__ == 7) puts("bad 6");
} foo-1.1-2.l ../tests]
	set fname3 [makeFile {
int include_1_1b = 4;
unless (basename(__FILE__) eq "foo-1.1-3.l") puts("bad 7");
unless (__LINE__ == 4) puts("bad 8");
} foo-1.1-3.l ../tests]
} -body {
#lang L
include("foo-1.1-1.l");
unless (include_1_1a == 3) puts("bad 10.1");
unless (include_1_1b == 4) puts("bad 10.2");
} -cleanup {
	removeFile $fname1
	removeFile $fname2
	removeFile $fname3
} -output {}

test include-1.2 {malformed includes} -body {
#lang L
include("   // bad
include(""  // bad
include("") // bad "
} -returnCodes {error} -match regexp -result {.*1: L Error: malformed include
.*2: L Error: malformed include
.*3: L Error: malformed include
}

test include-1.3 {test line number tracking with include files} -setup {
	set fname1 [makeFile {int include_1_3a = "bad1";
include("foo-1.3-2.l");} foo-1.3-1.l ../tests]
	set fname2 [makeFile {int include_1_3b = "bad2";
include("foo-1.3-3.l");
int include_1_3c = "bad3";} foo-1.3-2.l ../tests]
	set fname3 [makeFile {int include_1_3d = "bad4";} foo-1.3-3.l ../tests]
} -body {
#lang L
int include_1_3 = "bad0";
include("foo-1.3-1.l");
int include_1_3last = "badn";
} -cleanup {
	removeFile $fname1
	removeFile $fname2
	removeFile $fname3
} -returnCodes {error} -match regexp -result {.*1: L Error: assignment of incompatible types
.*foo-1.3-1.l:1: L Error: assignment of incompatible types
.*foo-1.3-2.l:1: L Error: assignment of incompatible types
.*foo-1.3-3.l:1: L Error: assignment of incompatible types
.*foo-1.3-2.l:3: L Error: assignment of incompatible types
.*3: L Error: assignment of incompatible types
}

test include-1.4 {test missing include file} -body {
#lang L
include("does-not-exist.l");
} -returnCodes {error} -match regexp -result {.*1: L Error: cannot find include file does-not-exist.l
}

# This test creates two slave interps that declare global symbols
# with the same names as those declared in the master interp.
# If the L global state is properly kept per-interp, there
# should be no multiple-declaration errors.

test interp-1 {test per-interp global state} -body {
#lang L
int interp_1_g;
void interp_1_foo() {}

#lang tcl
interp create interp_1_1
interp eval interp_1_1 {
#lang L
int interp_1_g;
void interp_1_foo() {}
}
interp create interp_1_2
interp eval interp_1_2 {
#lang L
int interp_1_g;
void interp_1_foo() {}
}
interp delete interp_1_2
interp delete interp_1_1
} -output {}

test split-1.0 {test split function} -body {
#lang L
void
split_1_0()
{
	int	m;
	string	s;
	string	r[];

	/* These are all white space. */
	string	allspace[] = {
		"",
		" ",
		"  ",
		"   ",
		"    ",
		"\n",
		"\t",
		"\n\n" };

	foreach (s in allspace) {
		r = split(s);
		if (defined(r[0])) printf("bad 1: '%s'\n", s);
	}

	/*
	 * A split followed by a join should give the string back
	 * (modulo a trailing delimeter).
	 */

	s = "This is not a test. This is really not a test.";
	r = split(s);
	unless (s eq join(" ", r)) puts("bad 2.1");

	s = " This is not a test. This is really not a test.";
	r = split(s);
	unless (s eq join(" ", r)) puts("bad 2.2");

	s = "This:is:not:a:test.:This:is:really:not:a:test.";
	r = split(s, ":");
	unless (s eq join(":", r)) puts("bad 2.3");

	s = ":This:is:not:a:test.:This:is:really:not:a:test.";
	r = split(s, ":");
	unless (s eq join(":", r)) puts("bad 2.4");

	/*
	 * A split on ' ' should split on white space but return
	 * no null field for any initial white space.
	 */

	r = split("has none", " ");
	unless ((r[0] eq "has") && (r[1] eq "none")) puts("bad 3.1");
	if (defined(r[2])) puts("bad 3.2");

	r = split(" has one", " ");
	unless ((r[0] eq "has") && (r[1] eq "one")) puts("bad 3.3");
	if (defined(r[2])) puts("bad 3.4");

	r = split(" has one");
	unless ((r[0] eq "") && (r[1] eq "has") && (r[2] eq "one")) {
		puts("bad 3.5");
	}
	if (defined(r[3])) puts("bad 3.6");

	/* Trailing white space never produces a null field. */

	r = split("trail ");
	unless (r[0] eq "trail") puts("bad 4.1");
	if (defined(r[1])) puts("bad 4.2");

	r = split("trail ", " ");
	unless (r[0] eq "trail") puts("bad 4.3");
	if (defined(r[1])) puts("bad 4.4");

	/* Check split on a regexp. */

	r = split("XaXbXcX", "[abc]");
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 5.1");
	}
	if (defined(r[4])) puts("bad 5.2");

	r = split("XaXbXcX", /[abc]/);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 5.3");
	}
	if (defined(r[4])) puts("bad 5.4");

	r = split("XaaXbXcX", "[abc]");
	unless ((r[0] eq "X") && (r[1] eq "") && (r[2] eq "X") &&
	        (r[3] eq "X") && (r[4] eq "X")) {
		puts("bad 5.5");
	}
	if (defined(r[5])) puts("bad 5.6");

	/* A regexp match on the last char never produces a null field. */

	r = split("abcd", /[d]/);
	unless (r[0] eq "abc") puts("bad 5.7");
	if (defined(r[1])) puts("bad 5.8");

	/* A regexp match on the first char produces a  null field. */

	r = split("abcd", /[a]/);
	unless ((r[0] eq "") && (r[1] eq "bcd")) puts("bad 5.9");
	if (defined(r[2])) puts("bad 5.10");

	/* Test interpolated regexp. */

	s = "abc";
	r = split("XaXbXcX", /[${s}]/);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 6.1");
	}
	if (defined(r[4])) puts("bad 6.2");

	/* Test limits. */

	r = split("1 2 3 4", " ", 5);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.1");
	}
	if (defined(r[4])) puts("bad 7.2");

	r = split("1 2 3 4", " ", 4);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.3");
	}
	if (defined(r[4])) puts("bad 7.4");

	r = split("1 2 3 4", " ", 3);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 7.5");
	}
	if (defined(r[3])) puts("bad 7.6");

	r = split("1 2 3 4", " ", 2);
	unless ((r[0] eq "1") && (r[1] eq "2 3 4")) puts("bad 7.7");
	if (defined(r[2])) puts("bad 7.8");

	r = split("1 2 3 4", " ", 1);
	unless (r[0] eq "1 2 3 4") puts("bad 7.9");
	if (defined(r[1])) puts("bad 7.10");

	r = split("1 2 3 4", " ", 0);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.11");
	}
	if (defined(r[4])) puts("bad 7.12");

	r = split("1 2 3 4", " ", -1);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.13");
	}
	if (defined(r[4])) puts("bad 7.14");

	/* Test that an escape of the regexp delimeter works. */

	r = split("/this/is/a/pathname", /\//);
	unless ((r[0] eq "") && (r[1] eq "this") && (r[2] eq "is") &&
		(r[3] eq "a") && (r[4] eq "pathname")) {
		puts("bad 8.1");
	}
	if (defined(r[5])) puts("bad 8.2");

	/* Test alternate form of regexp. */

	r = split("/this/is/a/pathname", m|/|);
	unless ((r[0] eq "") && (r[1] eq "this") && (r[2] eq "is") &&
		(r[3] eq "a") && (r[4] eq "pathname")) {
		puts("bad 9.1");
	}
	if (defined(r[5])) puts("bad 9.2");

	s = "abc";
	r = split("XaXbXcX", m|[${s}]|);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 9.3");
	}
	if (defined(r[4])) puts("bad 9.4");

	r = split("1 2 3 4", m| |, 3);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 9.5");
	}
	if (defined(r[3])) puts("bad 9.6");

	/* Ensure third arg is not parsed as a regexp. */

	m = 3;
	r = split("1 2 3 4", m| |, m);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 9.7");
	}
	if (defined(r[3])) puts("bad 9.8");
}
#lang tcl
split_1_0
} -output ""

test consts-1.0 {test constants function} -body {
#lang L
void
constants_1_0()
{
	int	i;
	float	f;

	i = 1234;
	printf("%u\n", i);
	i = 0xdeadbeef;
	printf("%x\n", i);
	i = 0o755;
	printf("%o\n", i);

	f = 1234.5678;
	printf("%.4f\n", f);
}
#lang tcl
constants_1_0
} -output "1234\ndeadbeef\n755\n1234.5678\n"

# These tests check the L compiler's mapping between the source-file
# offsets of each "command" and the tcl bytecodes generated for it.
# Generally speaking, a command is a statement or expression, although
# some statements don't generate a mapping per-se (like "if"
# statements).  This is tested by generating a bytecode disassembly
# and checking that the text of the commands were identified properly
# in various syntactic contexts.  This seems like the only way to get
# at the mappings easily for testing.

test src-mappings-1 {test bytecode <-> source-file-offset mappings 1} -body {
#lang L -nowarn
struct sm1 {
	int	i;
};
void
src_mappings_1()
{
	/*
	 * This test checks the mappings for declarations.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i1;
	int i2 = 2;
	int i3, i4;
	int i5, i6 = 6, i7;
	string s1;
	string s2 = "str2";
	string s3, s4;
	string s5, s6 = "str6", s7;
	float f1;
	float f2 = 2.0;
	float f3, f4;
	float f5, f6 = 6.0, f7;
	/* The hash ones test typedef names (hash is a typedef). */
	hash h1;
	hash h2 = {2=>2};
	hash h3, h4;
	hash h5, h6 = {6=>6}, h7;
	struct sm1 st1;
	struct sm1 st2 = {2};
	struct sm1 st3, st4;
	struct sm1 st5, st6 = {6}, st7;
	poly p1;
	poly p2 = 2;
	poly p3, p4;
	poly p5, p6 = 6, p7;
	int ai1[];
	int ai2[2];
	int ai3[] = {3};
	int ai4[], ai5[5];
	int ai6[], ai7[] = {7}, ai8[];
	string as1[];
	string as2[2];
	string as3[] = {"3"};
	string as4[], as5[5];
	string as6[], as7[] = {"7"}, as8[];
	float af1[];
	float af2[2];
	float af3[] = {3.0};
	float af4[], af5[5];
	float af6[], af7[] = {7.0}, af8[];
	hash ah1[];
	hash ah2[2];
	hash ah3[], ah4[4], ah5[];
	struct s ast1[];
	struct s ast2[2];
	struct s ast3[], ast4[4], ast5[];

	puts(::tcl::unsupported::disassemble("proc", "src_mappings_1"));
	return;
}
#lang tcl
src_mappings_1
} -match regexp -output {.*Command \d+: "i1"
.*Command \d+: "i2 = 2"
.*Command \d+: "i3"
.*Command \d+: "i4"
.*Command \d+: "i5"
.*Command \d+: "i6 = 6"
.*Command \d+: "i7"
.*Command \d+: "s1"
.*Command \d+: "s2 = \\"str2\\""
.*Command \d+: "s3"
.*Command \d+: "s4"
.*Command \d+: "s5"
.*Command \d+: "s6 = \\"str6\\""
.*Command \d+: "s7"
.*Command \d+: "f1"
.*Command \d+: "f2 = 2.0"
.*Command \d+: "f3"
.*Command \d+: "f4"
.*Command \d+: "f5"
.*Command \d+: "f6 = 6.0"
.*Command \d+: "f7"
.*Command \d+: "h1"
.*Command \d+: "h2 = \{2=>2\}"
.*Command \d+: "h3"
.*Command \d+: "h4"
.*Command \d+: "h5"
.*Command \d+: "h6 = \{6=>6\}"
.*Command \d+: "h7"
.*Command \d+: "st1"
.*Command \d+: "st2 = \{2\}"
.*Command \d+: "st3"
.*Command \d+: "st4"
.*Command \d+: "st5"
.*Command \d+: "st6 = \{6\}"
.*Command \d+: "st7"
.*Command \d+: "p1"
.*Command \d+: "p2 = 2"
.*Command \d+: "p3"
.*Command \d+: "p4"
.*Command \d+: "p5"
.*Command \d+: "p6 = 6"
.*Command \d+: "p7"
.*Command \d+: "ai1\[\]"
.*Command \d+: "ai2\[2\]"
.*Command \d+: "ai3\[\] = \{3\}"
.*Command \d+: "ai4\[\]"
.*Command \d+: "ai5\[5\]"
.*Command \d+: "ai6\[\]"
.*Command \d+: "ai7\[\] = \{7\}"
.*Command \d+: "ai8\[\]"
.*Command \d+: "as1\[\]"
.*Command \d+: "as2\[2\]"
.*Command \d+: "as3\[\] = \{\\"3\\"\}"
.*Command \d+: "as4\[\]"
.*Command \d+: "as5\[5\]"
.*Command \d+: "as6\[\]"
.*Command \d+: "as7\[\] = \{\\"7\\"\}"
.*Command \d+: "as8\[\]"
.*Command \d+: "af1\[\]"
.*Command \d+: "af2\[2\]"
.*Command \d+: "af3\[\] = \{3.0\}"
.*Command \d+: "af4\[\]"
.*Command \d+: "af5\[5\]"
.*Command \d+: "af6\[\]"
.*Command \d+: "af7\[\] = \{7.0\}"
.*Command \d+: "af8\[\]"
.*Command \d+: "ah1\[\]"
.*Command \d+: "ah2\[2\]"
.*Command \d+: "ah3\[\]"
.*Command \d+: "ah4\[4\]"
.*Command \d+: "ah5\[\]"
.*Command \d+: "ast1\[\]"
.*Command \d+: "ast2\[2\]"
.*Command \d+: "ast3\[\]"
.*Command \d+: "ast4\[4\]"
.*Command \d+: "ast5\[\]"
}

test src-mappings-2 {test bytecode <-> source-file-offset mappings 2} -body {
#lang L -nowarn
int f0() { return (0); }
int f1(int i) { return (1); }
int f2(int i, int j) { return (2); }
void
src_mappings_2()
{
	/*
	 * This test checks the mappings for expressions.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i, j;
	int i1 = 1+2;
	int i2 = i1+2*3;
	int i3, i4, i5;
	string s, t;
	float f;
	int ai[];
	int aii[][];
	int ah{int};
	int ahh{int}{int};

	puts(::tcl::unsupported::disassemble("proc", "src_mappings_2"));
	return;

	/* Check assignments. */
	i1 = 1;
	f = 3.14;
	s = "str";

	/* Check array and hash subscripts. */
	i = ai[i1 - i2 - i3];
	i = aii[i1][i2];
	i = ah{i3 - i4};
	i = ahh{i3}{i4 - i5};

	/* Check that each sub-expression has a mapping. */
	i3 = 3;
	i4 = 4 + 3;
	i5 = i3 + i4 * i5 - 5;

	/* Check parameters. */
	f0();
	f1(i1);
	f2(i1, i2);
	f2(i1, i2 + f1(2));

	/* Check that each binary and unary operator gets a mapping. */
	(tcl)i;
	(string)i;
	(float)i;
	!i;
	~i;
	+i;
	-i;
	&i;
	defined(i);
	i = j;
	i += j;
	i -= j;
	i *= j;
	i /= j;
	i %= j;
	i &= j;
	i |= j;
	i <<= j;
	i >>= j;
	i && j;
	i || j;
	s eq t;
	s ne t;
	s gt t;
	s ge t;
	s lt t;
	s le t;
	i == j;
	i != j;
	i > j;
	i >= j;
	i < j;
	i <= j;
	i + j;
	i - j;
	i * j;
	i / j;
	i % j;
	i & j;
	i | j;
	i ^ j;
	i << j;
	i >> j;
	s =~ /x/;
	s =~ /x/i;
	s =~ /x/g;
	s =~ /x/ig;
	s =~ m|x|;
	s =~ m|x|i;
	s =~ m|x|g;
	s =~ m|x|ig;
	s =~ s/x/y/;
	s =~ s/x/y/i;
	s =~ s/x/y/g;
	s =~ s/x/y/ig;

	/* Check interpolated strings. */
	s = "abc${t}";
	s = "${t}xyz";
	s = "abc${t}xyz";
	s = "abc${"${t}"}xyz";
}
#lang tcl
src_mappings_2
} -match regexp -output {.*Command \d+: "1\+2"
.*Command \d+: "i1 = 1\+2"
.*Command \d+: "i1\+2\*3"
.*Command \d+: "i2 = i1\+2\*3"
.*Command \d+: "2\*3"
.*Command \d+: "i1 = 1"
.*Command \d+: "f = 3.14"
.*Command \d+: "s = \\"str\\""
.*Command \d+: "ai\[i1 - i2 - i3\]"
.*Command \d+: "i = ai\[i1 - i2 - i3\]"
.*Command \d+: "i1 - i2"
.*Command \d+: "i1 - i2 - i3"
.*Command \d+: "aii\[i1\]\[i2\]"
.*Command \d+: "i = aii\[i1\]\[i2\]"
.*Command \d+: "ah\{i3 - i4\}"
.*Command \d+: "i = ah\{i3 - i4\}"
.*Command \d+: "i3 - i4"
.*Command \d+: "ahh\{i3\}\{i4 - i5\}"
.*Command \d+: "i = ahh\{i3\}\{i4 - i5\}"
.*Command \d+: "i4 - i5"
.*Command \d+: "i3 = 3"
.*Command \d+: "4 \+ 3"
.*Command \d+: "i4 = 4 \+ 3"
.*Command \d+: "i3 \+ i4 \* i5"
.*Command \d+: "i3 \+ i4 \* i5 - 5"
.*Command \d+: "i5 = i3 \+ i4 \* i5 - 5"
.*Command \d+: "i4 \* i5"
.*Command \d+: "f0\(\)"
.*Command \d+: "f1\(i1\)"
.*Command \d+: "f2\(i1, i2\)"
.*Command \d+: "f2\(i1, i2 \+ f1\(2\)\)"
.*Command \d+: "i2 \+ f1\(2\)"
.*Command \d+: "f1\(2\)"
.*Command \d+: "\(tcl\)i"
.*Command \d+: "\(string\)i"
.*Command \d+: "\(float\)i"
.*Command \d+: "!i"
.*Command \d+: "~i"
.*Command \d+: "\+i"
.*Command \d+: "-i"
.*Command \d+: "&i"
.*Command \d+: "defined\(i\)"
.*Command \d+: "i = j"
.*Command \d+: "i \+= j"
.*Command \d+: "i -= j"
.*Command \d+: "i \*= j"
.*Command \d+: "i /= j"
.*Command \d+: "i %= j"
.*Command \d+: "i <<= j"
.*Command \d+: "i >>= j"
.*Command \d+: "i && j"
.*Command \d+: "i \|\| j"
.*Command \d+: "s eq t"
.*Command \d+: "s ne t"
.*Command \d+: "s gt t"
.*Command \d+: "s ge t"
.*Command \d+: "s lt t"
.*Command \d+: "s le t"
.*Command \d+: "i == j"
.*Command \d+: "i != j"
.*Command \d+: "i > j"
.*Command \d+: "i >= j"
.*Command \d+: "i < j"
.*Command \d+: "i <= j"
.*Command \d+: "i \+ j"
.*Command \d+: "i - j"
.*Command \d+: "i \* j"
.*Command \d+: "i / j"
.*Command \d+: "i % j"
.*Command \d+: "i & j"
.*Command \d+: "i \| j"
.*Command \d+: "i \^ j"
.*Command \d+: "i << j"
.*Command \d+: "i >> j"
.*Command \d+: "s =~ /x/"
.*Command \d+: "s =~ /x/i"
.*Command \d+: "s =~ /x/g"
.*Command \d+: "s =~ /x/ig"
.*Command \d+: "s =~ m\|x\|"
.*Command \d+: "s =~ m\|x\|i"
.*Command \d+: "s =~ m\|x\|g"
.*Command \d+: "s =~ m\|x\|ig"
.*Command \d+: "s =~ s/x/y/"
.*Command \d+: "s =~ s/x/y/i"
.*Command \d+: "s =~ s/x/y/g"
.*Command \d+: "s =~ s/x/y/ig"
.*Command \d+: "\\"abc\$\{t\}\\""
.*Command \d+: "s = \\"abc\$\{t\}\\""
.*Command \d+: "\\"\$\{t\}xyz\\""
.*Command \d+: "s = \\"\$\{t\}xyz\\""
.*Command \d+: "\\"abc\$\{t\}xyz\\""
.*Command \d+: "s = \\"abc\$\{t\}xyz\\""
.*Command \d+: "\\"abc\$\{\\"\$\{t\}\\"\}xyz\\""
.*Command \d+: "s = \\"abc\$\{\\"\$\{t\}\\"\}xyz\\""
.*Command \d+: "\\"\$\{t\}\\""
}

test src-mappings-3 {test bytecode <-> source-file-offset mappings 3} -body {
#lang L -nowarn
int
f()
{
	return (0);
}
void
fv()
{
	return;
}
int{int}
fh()
{
	int h{int};
	return (h);
}
int[]
fa()
{
	int a[5];
	return (a);
}
int
src_mappings_3()
{
	/*
	 * This test checks the mappings for statements.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i, j, k, v;
	int a[5];
	int h{int};

	/* Disassemble fv() to get its "return" stmt w/no arg. */
	puts(::tcl::unsupported::disassemble("proc", "fv"));
	puts(::tcl::unsupported::disassemble("proc", "src_mappings_3"));
	return(0);

	while (0) f();
	do f(); while (0);
	for (i = 0; i < 10;) f();
	for (i = 0; i < 10; ++i) f();
	foreach (k => v in fh()) f();
	foreach (i,j in fa()) f();
	push (&a, f());
	/* Check break and continue. */
	do {
		break;
		continue;
	} while (0);
	goto L1;
 L1:
}
#lang tcl
src_mappings_3
} -match regexp -output {.*Command \d+: "return"
.*Command \d+: "return\(0\)"
.*Command \d+: "while \(0\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "do f\(\); while \(0\);"
.*Command \d+: "i = 0"
.*Command \d+: "for \(i = 0; i < 10;\) f\(\);"
.*Command \d+: "i < 10"
.*Command \d+: "f\(\)"
.*Command \d+: "i = 0"
.*Command \d+: "for \(i = 0; i < 10; \+\+i\) f\(\);"
.*Command \d+: "i < 10"
.*Command \d+: "f\(\)"
.*Command \d+: "\+\+i"
.*Command \d+: "fh\(\)"
.*Command \d+: "foreach \(k => v in fh\(\)\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "fa\(\)"
.*Command \d+: "foreach \(i,j in fa\(\)\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "push \(&a, f\(\)\)"
.*Command \d+: "break"
.*Command \d+: "continue"
.*Command \d+: "goto L1;"
}

test src-mappings-4 {test bytecode <-> source-file-offset mappings with includes} -setup {
	set fname1 [makeFile {
void src_mappings_4_foo1()
{
	int v1 = 123;
	while (0) {
		puts(v1);
	}
}
include ("foo-sm4-2.l");
} foo-sm4-1.l ../tests]
	set fname2 [makeFile {
void src_mappings_4_foo2()
{
	int	i, j;
	i = j+1;
}
} foo-sm4-2.l ../tests]
} -body {
#lang L
include ("foo-sm4-1.l");
void src_mappings_4()
{
	/*
	 * We don't need much for this test.  If the source offsets are
	 * mis-aligned, it can be seen with even just one command.
	 */

	int	k, l;

	puts("--foo1--");
	puts(::tcl::unsupported::disassemble("proc", "src_mappings_4_foo1"));
	puts("--foo2--");
	puts(::tcl::unsupported::disassemble("proc", "src_mappings_4_foo2"));
	puts("--main--");
	puts(::tcl::unsupported::disassemble("proc", "src_mappings_4"));
	return;

	k = l+2;
}
src_mappings_4();
} -match regexp -output {--foo1--
.*Command \d+: "v1 = 123"
.*Command \d+: "puts\(v1\)"
.*--foo2--
.*Command \d+: "i = j\+1"
.*--main--
.*Command \d+: "return"
.*Command \d+: "k = l\+2"
}

test src-mappings-5 {test bytecode <-> source-file-offset mappings w/here docs} -body {
#lang L -nowarn
void src_mappings_5()
{
	string s1 = <<END
str1
END
	string s2 = <<'END'
str2
END

	puts(::tcl::unsupported::disassemble("proc", "src_mappings_5"));
}
src_mappings_5();
} -match regexp -output {.*Command \d+: "s1 = <<END\\nstr1\\nEND"
.*Command \d+: "s2 = <<'END'\\nstr2\\nEND"
}

test function-1.0 {check function call rules} -body {
#lang L
void function_1_0_foo() { puts("foo"); }
void function_1_0_f()   { puts("f"); }
void
function_1_0()
{
	function_1_0_foo();
	function_1_0_f();

	/*
	 * Calling an undeclared function is not an error, we just get
	 * no arg type checking, so passing anything should be allowed.
	 */
	if (0) {
		string	s, p;

		not_defined1();
		not_defined1(s);
		not_defined1(s, p);
		not_defined2(1, 2, 3, 4);
	}
}
#lang tcl
function_1_0
} -output {foo
f
}

test function-1.1 {check function call rules error cases} -body {
#lang L
int function_1_1_f1;
int function_1_1_f1() { return (0); }	// err -- already declared as variable
int function_1_1_f2() { return (0); }
int function_1_1_f2;			// err -- already declared as function
int function_1_1_f3() { return (0); }
int function_1_1_f3() { return (0); }	// err -- multiply declared function
void
function_1_1()
{
	int	i;
	float	f;
	int	a[];
	int	h{int};
	struct { int i,j; } st;

	/* All illegal because the var isn't a string or poly. */
	i();
	f();
	a();
	h();
	st();
}
#lang tcl
function_1_1
} -returnCodes {error} -match regexp -result {.*1: L Error: multiple declaration of global function_1_1_f1
.*4: L Error: multiple declaration of global function_1_1_f2
.*6: L Error: function function_1_1_f3 already declared
.*:17: L Error: 'i' is declared but not as a function
.*:18: L Error: 'f' is declared but not as a function
.*:19: L Error: 'a' is declared but not as a function
.*:20: L Error: 'h' is declared but not as a function
.*:21: L Error: 'st' is declared but not as a function
}

test function-1.2 {check function prototypes} -body {
#lang L -nowarn
int function_1_2_f1();
int function_1_2_f1() { return (1); }

int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2() { return (1); }

int function_1_2_f3() { return (1); }
int function_1_2_f3();

string function_1_2_f4(int a, string b, float c, int d[], hash e);
string function_1_2_f4(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_2_f5(int a, string b, float c, int d[], hash e){ return (b); }
string function_1_2_f5(int a, string b, float c, int d[], hash e);

void
function_1_2()
{
	int	a;
	string	s;
	float	c;
	int	d[];
	hash	e;

	s = function_1_2_f4(a, "f4", c, d, e);
	unless (s eq "f4") puts("bad 1");

	s = function_1_2_f5(a, "f5", c, d, e);
	unless (s eq "f5") puts("bad 2");

	unless (function_1_2_f10(12) == 12) puts("bad 3");
	unless (function_1_2_f11(13) == 13) puts("bad 4");
	unless (function_1_2_f12(14) == 14) puts("bad 5");

	/*
	 * These check that the right parameter-passing mode is
	 * in the calls to the functions declared later.
	 */

	d = {1,2,3,4};
	unless (function_1_2_sum_ref(&d) == 10) puts("bad 6.1");
	unless (length(d) == 3) puts("bad 6.2");
	unless ((d[0] == 9) && (d[1] == 10) && (d[2] == 11)) puts("bad 6.3");

	d = {1,2,3,4};
	unless (function_1_2_sum_cow(d) == 10) puts("bad 7.1");
	unless (length(d) == 4) puts("bad 7.2");
	unless ((d[0] == 1) && (d[1] == 2)) puts("bad 7.3");
	unless ((d[2] == 3) && (d[3] == 4)) puts("bad 7.4");
}
function_1_2();
int function_1_2_f10(int a) { return (a); }
int function_1_2_f11(int a) { return (a); }
int function_1_2_f11(int a);
int function_1_2_f12(int a);
int function_1_2_f12(int a) { return (a); }
int function_1_2_sum_ref(int &a[])
{
	int	i, sum = 0;

	foreach (i in a) sum += i;
	a = {9,10,11};
	return (sum);
}
int function_1_2_sum_cow(int a[])
{
	int	i, sum = 0;

	foreach (i in a) sum += i;
	a = {9,10,11};
	return (sum);
}
} -output {}

test function-1.3 {check function prototypes 2} -body {
#lang L
void
function_1_3()
{
	/* Call some libl functions correctly.  There should be no type errs. */

	unless (streq("testing", "testing")) puts("bad 1");
	unless (strlen("three") == 5) puts("bad 2");
	unless (strneq("test", "testing", 4)) puts("bad 3");
}
#lang tcl
function_1_3
} -output {}

test function-1.3.2 {check function prototypes 3} -body {
#lang L
/*
 * Check that a void formal-parameter list is treated exactly like no
 * parameters.
 */
string function_1_3_2_f1();
string function_1_3_2_f2();
string function_1_3_2_f3(void);
string function_1_3_2_f4(void);
void
function_1_3_2()
{
	function_1_3_2_f1();
	function_1_3_2_f2();
	function_1_3_2_f3();
	function_1_3_2_f4();
}
function_1_3_2();
string function_1_3_2_f1()     { puts("f1"); }
string function_1_3_2_f2(void) { puts("f2"); }
string function_1_3_2_f3()     { puts("f3"); }
string function_1_3_2_f4(void) { puts("f4"); }
} -output {f1
f2
f3
f4
}

test function-1.4 {check function prototype errors} -body {
#lang L
void
function_1_4()
{
	/* Call a libl function with incorrect args. */

	streq();
	streq("a");
	streq("a", 2);
	streq("a", "b", 2);
}
} -returnCodes {error} -match regexp -result {.*6: L Error: not enough arguments for function streq
.*7: L Error: not enough arguments for function streq
.*8: L Error: parameter 2 has incompatible type
.*9: L Error: too many arguments for function streq
}

test function-1.5 {check function prototype errors 2} -body {
#lang L
void function_1_5_f1();
int function_1_5_f1() { return (0); }

int function_1_5_f2() { return (0); }
void function_1_5_f2();

void function_1_5_f3(int a);
void function_1_5_f3() { }

void function_1_5_f4() { }
void function_1_5_f4(int a);

int function_1_5_f5(int a);
void function_1_5_f5() { }

void function_1_5_f6() { }
int function_1_5_f6(int a);

string function_1_5_f7(int a, string b, float c, int d[]);
string function_1_5_f7(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_5_f8(string b, float c, int d[], hash e);
string function_1_5_f8(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_5_f9(string b, float c, int d[], hash e);
string function_1_5_f9(string b, ...rest){ return (b); }
} -returnCodes {error} -match regexp -result {.*2: L Error: does not match other declaration of function_1_5_f1
.*5: L Error: does not match other declaration of function_1_5_f2
.*8: L Error: does not match other declaration of function_1_5_f3
.*11: L Error: does not match other declaration of function_1_5_f4
.*14: L Error: does not match other declaration of function_1_5_f5
.*17: L Error: does not match other declaration of function_1_5_f6
.*20: L Error: does not match other declaration of function_1_5_f7
.*23: L Error: does not match other declaration of function_1_5_f8
.*26: L Error: does not match other declaration of function_1_5_f9
}

test function-1.6 {check function prototype errors 3} -body {
#lang L
void function_1_6()
{
	/*
	 * Check that type checking is done to calls of functions
	 * declared later.
	 */

	function_1_6_v(1);
	function_1_6_i();
	function_1_6_i("bad");
}
void function_1_6_v() {}
void function_1_6_i(int i) { i = 0; }
} -returnCodes {error} -match regexp -result {.*8: L Error: too many arguments for function function_1_6_v
.*9: L Error: not enough arguments for function function_1_6_i
.*10: L Error: parameter 1 has incompatible type
}

test initializers-1 {check variable initializer error cases} -body {
#lang L
extern int g = 0;
void initializers_1() {
	/*
	 * Externs in local scopes are illegal as well as extern
	 * initializers, so this is error on two counts.
	 */
	extern int l = 0;
}
} -returnCodes {error} -match regexp -result {.*1: L Error: extern initializers illegal
.*7: L Error: extern.*
}

test initializers-2 {check variable initializers} -body {
#lang L
struct initializers_2_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};
struct initializers_2_s2 {
	int	i, j;
};
typedef struct initializers_2_s2 h_of_s2{int};

void initializers_2()
{
	/*
	 * In addition to the initializers themselves, check various
	 * number of initializers per declaration.
	 */
	int	i;
	int	i1 = 11;
	int	i2 = 0, i3 = 33;
	int	i4 = 0, i5 = 55, i6 = 0;
	int	i7 = 0, i8 = 88, i9 = 99, i10 = 111;
	string	s = "s";
	float	f = 3.1, f2 = 3;
	string	ai[] = { "a", "b", "c" };
	string	hs{int} = { 1=>"one", 2=>"two", 3=>"three" };
	struct initializers_2_s1 st = {
		1,
		2, 3,
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" },   // note the trailing comma (legal)
	};
	string	aempty[] = {};
	h_of_s2	h2 = { 1 => {2,3}, 2 => {4,5} };

	unless (i1 == 11) puts("bad 1");
	unless (!i2 && !i4 && !i6 && !i7) puts("bad 2");
	unless (i3 == 33) puts("bad 3");
	unless (i5 == 55) puts("bad 4");
	unless (i8 == 88) puts("bad 5");
	unless (i9 == 99) puts("bad 6");
	unless (i10 == 111) puts("bad 7");
	unless (s eq "s") puts("bad 8");
	unless (f == 3.1) puts("bad 9");
	unless (f2 == 3) puts("bad 9.1");
	unless ((ai[0] eq "a") && (ai[1] eq "b")) puts("bad 10");
	unless ((ai[2] eq "c") && !defined(ai[3])) puts("bad 11");
	i = 0;
	foreach (s in ai) ++i;
	unless (i == 3) puts("bad 12");
	unless ((hs{1} eq "one") && (hs{2} eq "two")) puts("bad 13");
	unless ((hs{3} eq "three")) puts("bad 14");
	i = 0;
	foreach (i1 in hs) ++i;
	unless (i == 3) puts("bad 15");

	unless ((st.i == 1) && (st.j == 2) && (st.k == 3)) puts("bad 16");
	unless ((st.s eq "s") && (st.as[0] eq "x")) puts("bad 17");
	unless ((st.as[1] eq "y") && (st.as[2] eq "z")) puts("bad 18");
	i = 0;
	foreach (s in st.as) ++i;
	unless (i == 3) puts("bad 19");
	unless ((st.hs{3} eq "t") && (st.hs{6} eq "s")) puts("bad 20");
	i = 0;
	foreach (i1 in st.hs) ++i;
	unless (i == 2) puts("bad 21");

	if (defined(aempty[0])) puts("bad 30");
	unless ((h2{1}.i == 2) && (h2{1}.j == 3)) puts("bad 31");
	unless ((h2{2}.i == 4) && (h2{2}.j == 5)) puts("bad 32");
}
#lang tcl
initializers_2
} -output {}

test initializers-3 {check variable initializer type errors} -body {
#lang L -nowarn
struct initializers_3_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};

void initializers_3()
{
	int	i1 = 1.0;
	int	i2, i3 = "s";
	int	i4, i5 = {3}, i6;
	string	s = 3.1;
	float	f = "3.1";
	string	ai[] = {"a", 2, "c"};
	string	hs{int} = { 1=>"one", "2"=>"two", 3=>"three" };
	struct initializers_2_s1 st = {
		1,
		2,  // err -- omitted initializer for "k"
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" }
	};
	string	hs2{int} = { 1=>"one", 3 };
}
} -returnCodes {error} -match regexp -result {.*11: L Error: assignment of incompatible types
.*12: L Error: assignment of incompatible types
.*13: L Error: assignment of incompatible types
.*14: L Error: assignment of incompatible types
.*15: L Error: assignment of incompatible types
.*16: L Error: assignment of incompatible types
.*17: L Error: hash elements must all be of same type
.*18: L Error: assignment of incompatible types
.*25: L Error: cannot mix hash and non-hash elements
}

test initializers-4 {check expressions in variable initializers} -body {
#lang L
int init_4_g = 33;
void initializers_4()
{
	/*
	 * Initializers are full-blown expressions, so they can contain
	 * variables etc.
	 */
	int	e1 = 11;
	int	e2 = e1*2;
	int	a[] = { init_4_g, init_4_g*2, e1, e2, 3 };

	unless ((e1 == 11) && (e2 == 22)) puts("bad 1");
	unless ((a[0] == 33) && (a[1] == 66) && (a[2] == 11) &&
		(a[3] == 22) && (a[4] == 3)) puts("bad 2");
	if (defined(a[5])) puts("bad 3");
}
#lang tcl
initializers_4
} -output {}

test initializers-5 {check order of variable initializers} -body {
#lang L
void initializers_5()
{
	/*
	 * This checks the variable initializers are compiled
	 * top-to-bottom and left-to-right.
	 */
	int	i1 = 2, i2 = i1 * 7, i3 = i1 + i2;
	int	i4 = i3 * 10;

	unless (i1 == 2) puts("bad 1");
	unless (i2 == 14) puts("bad 2");
	unless (i3 == 16) puts("bad 3");
	unless (i4 == 160) puts("bad 4");
}
initializers_5();
} -output {}

test initializers-6 {check blank initial values} -body {
#lang L
void initializers_6()
{
	int	i;
	float	f;
	string	s;
	poly	p;
	string	as[];
	string	hs{string};
	struct s1 {
		int	i;
		float	f;
		string	s;
		string	sa[];
		string	hs{string};
	} st;

	if (defined(i)) puts("bad 1");
	if (defined(f)) puts("bad 2");
	if (defined(s)) puts("bad 3");
	if (defined(p)) puts("bad 4");
	if (defined(as)) puts("bad 5");
	if (defined(hs)) puts("bad 6");
	if (defined(st)) puts("bad 7");
}
initializers_6();
} -output {}

test composite-1 {check composite values in expressions 1} -body {
#lang L
struct composite_1_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};
int composite_1_g = 33;
void composite_1()
{
	/*
	 * These are taken from the initializer-* tests above but
	 * are used in the rhs of expressions instead of in initializers.
	 */

	int	i, i1;
	int	e1 = 11;
	int	e2 = e1*2;
	string	s;
	int	a[];
	string	ai[];
	string	hs{int};
	struct composite_1_s1 st;
	string	aempty[];
	h_of_s2	h2;

	a = { composite_1_g, composite_1_g*2, e1, e2, 3 };

	unless ((e1 == 11) && (e2 == 22)) puts("bad 1");
	unless ((a[0] == 33) && (a[1] == 66) && (a[2] == 11) &&
		(a[3] == 22) && (a[4] == 3)) puts("bad 2");
	if (defined(a[5])) puts("bad 3");

	ai = { "a", "b", "c" };
	hs = { 1=>"one", 2=>"two", 3=>"three" };
	st = {
		1,
		2, 3,
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" },   // note the trailing comma (legal)
	};
	aempty = {};
	h2 = { 1 => {2,3}, 2 => {4,5} };

	unless ((ai[0] eq "a") && (ai[1] eq "b")) puts("bad 10");
	unless ((ai[2] eq "c") && !defined(ai[3])) puts("bad 11");
	i = 0;
	foreach (s in ai) ++i;
	unless (i == 3) puts("bad 12");
	unless ((hs{1} eq "one") && (hs{2} eq "two")) puts("bad 13");
	unless ((hs{3} eq "three")) puts("bad 14");
	i = 0;
	foreach (i1 in hs) ++i;
	unless (i == 3) puts("bad 15");

	unless ((st.i == 1) && (st.j == 2) && (st.k == 3)) puts("bad 16");
	unless ((st.s eq "s") && (st.as[0] eq "x")) puts("bad 17");
	unless ((st.as[1] eq "y") && (st.as[2] eq "z")) puts("bad 18");
	i = 0;
	foreach (s in st.as) ++i;
	unless (i == 3) puts("bad 19");
	unless ((st.hs{3} eq "t") && (st.hs{6} eq "s")) puts("bad 20");
	i = 0;
	foreach (i1 in st.hs) ++i;
	unless (i == 2) puts("bad 21");

	if (defined(aempty[0])) puts("bad 30");
	unless ((h2{1}.i == 2) && (h2{1}.j == 3)) puts("bad 31");
	unless ((h2{2}.i == 4) && (h2{2}.j == 5)) puts("bad 32");
}
#lang tcl
composite_1
} -output {}

test composite-2 {check composite values in expressions 2} -body {
#lang L
string composite_2_join(string[] a)
{
	string	s;
	string	ret = "";

	foreach (s in a) ret = sprintf("%s%s", ret, s);
	return (ret);
}
void composite_2()
{
	/*
	 * Try more operations with composite values.
	 */

	int	i;

	unless (composite_2_join({"a","b","c"}) eq "abc") puts("bad 1");

	for (i = 0; i < 5; ++i) {
		unless ({0,1,2,3,4}[i] == i) printf("bad 2 %d\n", i);
	}
	if (defined({0,1,2,3,4}[5])) puts("bad 3");

	unless ({1=>"one", 2=>"two", 3=>"three"}{1} eq "one") puts("bad 4");
	unless ({1=>"one", 2=>"two", 3=>"three"}{2} eq "two") puts("bad 5");
	unless ({1=>"one", 2=>"two", 3=>"three"}{3} eq "three") puts("bad 6");

	unless (((struct { int i,j,k; }){1,2,3}).i == 1) puts("bad 10");
	unless (((struct { int i,j,k; }){1,2,3}).j == 2) puts("bad 11");
	unless (((struct { int i,j,k; }){1,2,3}).k == 3) puts("bad 12");

	unless ({{1,2},{3,4},{4,5}}[1][0] == 3) puts("bad 20");
}
#lang tcl
composite_2
} -output {}

test composite-3 {check type errors with composite values} -body {
#lang L -nowarn
void composite_3_as(string[] a) {}
void composite_3_ai(int[] a) {}
void composite_3_his(int{string} a) {}
void composite_3_hsi(string{int} a) {}
void composite_3_hss(string{string} a) {}
void composite_3_hii(int{int} a) {}

void composite_3()
{
	composite_3_as({1,2,3});
	composite_3_ai({"a","b","c"});
	composite_3_his({1,2,3});
	composite_3_his({1=>2,3=>4});
	composite_3_hsi({1=>2,3=>4});
	composite_3_hss({1=>2,3=>4});
	composite_3_hii({"1"=>2,"3"=>4});
}
} -returnCodes {error} -match regexp -result {.*10: L Error:.*incompatible type.*
.*11: L Error:.*incompatible type.*
.*12: L Error:.*incompatible type.*
.*13: L Error:.*incompatible type.*
.*14: L Error:.*incompatible type.*
.*15: L Error:.*incompatible type.*
.*16: L Error:.*incompatible type.*
}

test composite-4 {check composite l-values} -body {
#lang L
class composite_4
{
	public	string c;
	instance {
		public	string i;
	}
}
void composite_4_main()
{
	string	a, b, c;
	string	sa[];
	composite_4 o1, o2, o3;

	a = "bad";
	{ a } = { "one" };
	unless (a eq "one") puts("bad 1.1");

	a = b = "bad";
	{ a, b } = { "one", "two" };
	unless ((a eq "one") && (b eq "two")) puts("bad 2.1");

	a = b = c = "bad";
	{ a, b, c } = { "one", "two", "three" };
	unless ((a eq "one") && (b eq "two") && (c eq "three")) puts("bad 3.1");

	a = "bad";
	{ a } = {};
	if (defined(a)) puts("bad 4.1");

	a = b = "bad";
	{ a, b } = {};
	if (defined(a) || defined(b)) puts("bad 5.1");

	a = b = c = "bad";
	{ a, b, c } = {};
	if (defined(a) || defined(b) || defined(c)) puts("bad 6.1");

	a = b = c = "bad";
	{ a, b, c } = { "one" };
	unless (a eq "one") puts("bad 7.1");
	if (defined(b) || defined(c)) puts("bad 7.2");

	a = b = c = "bad";
	{ a, b, c } = { "one", "two" };
	unless ((a eq "one") && (b eq "two")) puts("bad 8.1");
	if (defined(c)) puts("bad 8.2");

	a = "bad";
	{ a } = { "one", "two" };
	unless (a eq "one") puts("bad 9.1");

	a = "bad";
	{ a } = { "one", "two", "three" };
	unless (a eq "one") puts("bad 10.1");

	a = b = "bad";
	{ a, b } = { "one", "two", "three" };
	unless ((a eq "one") && (b eq "two")) puts("bad 11.1");

	a = "bad";
	{ a, undef } = { "one", "two" };
	unless (a eq "one") puts("bad 12.1");

	a = "bad";
	{ a, undef } = { "one" };
	unless (a eq "one") puts("bad 13.1");

	a = "bad";
	{ a, undef, undef } = { "one" };
	unless (a eq "one") puts("bad 14.1");

	a = "bad";
	{ undef, a } = { "one", "two" };
	unless (a eq "two") puts("bad 15.1");

	a = "bad";
	{ undef, a } = { "one", "two", "three" };
	unless (a eq "two") puts("bad 16.1");

	a = "bad";
	{ undef, a, undef } = { "one", "two", "three" };
	unless (a eq "two") puts("bad 17.1");

	{ undef } = {};
	{ undef, undef } = {};
	{ undef, undef, undef } = {};
	{ undef } = { undef };

	{ sa[0] } = { "one" };
	unless (sa[0] eq "one") puts("bad 18.1");

	{ sa[0], sa[1] } = { "one", "two" };
	unless ((sa[0] eq "one") && (sa[1] eq "two")) puts("bad 19.1");

	{ sa[0], sa[1], sa[3] } = { "one", "two", "four" };
	unless ((sa[0] eq "one") && (sa[1] eq "two") && (sa[3] eq "four")) {
		puts("bad 20.1");
	}
	if (defined(sa[2])) puts("bad 20.2");

	o1 = composite_4_new();
	o2 = composite_4_new();
	o3 = composite_4_new();
	{ o1->i, o2->i, o3->i } = { "one", "two", "three" };
	unless (o1->i eq "one") puts("bad 21.1");
	unless (o2->i eq "two") puts("bad 21.2");
	unless (o3->i eq "three") puts("bad 21.3");
	{ composite_4->c } = { "cvar" };
	unless (composite_4->c eq "cvar") puts("bad 21.4");
	composite_4_delete(o1);
	composite_4_delete(o2);
	composite_4_delete(o3);
}
composite_4_main();
} -output {}

test composite-5 {check composite l-value errors} -body {
#lang L -nowarn
int composite_5_f() { return (0); }
void composite_5()
{
	int	a, b, ai[];
	string	s;

	{ a, b } += 1;
	{ a, b } -= 1;
	{ a, b } *= 1;
	{ a, b } /= 1;
	{ a, b } %= 1;
	{ a, b } &= 1;
	{ a, b } |= 1;
	{ a, b } ^= 1;
	{ a, b } >>= 1;
	{ a, b } <<= 1;
	{ a, b } =~ /bad/;
	{ s } =~ s/bad/bad/;

	{ a, b } = 0;
	{ a, b } = ai;

	{ 1 } = { 1 };
	{ composite_5_f() } = { 1 };
}
} -returnCodes {error} -match regexp -result {.*7: L Error: arithmetic assignment illegal
.*8: L Error: arithmetic assignment illegal
.*9: L Error: arithmetic assignment illegal
.*10: L Error: arithmetic assignment illegal
.*11: L Error: arithmetic assignment illegal
.*12: L Error: arithmetic assignment illegal
.*13: L Error: arithmetic assignment illegal
.*14: L Error: arithmetic assignment illegal
.*15: L Error: arithmetic assignment illegal
.*16: L Error: arithmetic assignment illegal
.*17: L Error: expected type string but got list in =~
.*18: L Error: invalid l-value in =~
.*20: L Error: right-hand side must be list {}
.*21: L Error: right-hand side must be list {}
.*23: L Error: invalid l-value in assignment
.*24: L Error: invalid l-value in assignment
}

test lvalue-1 {check indexing hash/struct/array expressions} -body {
#lang L
void lvalue_1()
{
	/*
	 * This checks deep-dive of an expression rather than a
	 * variable.  There are only two ways an expression can have
	 * an array/struct/hash value: a function return value, and an
	 * assignment.
	 */
	string	a1[] = { "1", "2", "3" };
	string	a2[];

	unless (split("a b c")[0] eq "a") puts("bad 1");
	unless (split("a b c")[1] eq "b") puts("bad 2");
	unless (split("a b c")[2] eq "c") puts("bad 3");

	if (defined(a2[0])) puts("bad 4");
	unless ((a2 = a1)[0] eq "1") puts("bad 5");
	unless ((a2 = a1)[1] eq "2") puts("bad 6");
	unless ((a2 = a1)[2] eq "3") puts("bad 7");
	unless ((a2[0] eq "1") && (a2[1] eq "2") && (a2[2] eq "3")) {
		puts("bad 8");
	}
	if (defined(a2[3])) puts("bad 9");
}
#lang tcl
lvalue_1
} -output {}

test lvalue-2 {illegal l-value in deep-dive assignments} -body {
#lang L
int[] lvalue_2_ints()
{
	int	a[] = { 1, 2, 3 };
	return (a);
}
void lvalue_2()
{
	int	a1[], a2[];
	string	s1[], s2[];

	lvalue_2_ints()[0] = 0;
	lvalue_2_ints()[0] += 1;
	++lvalue_2_ints()[0];
	lvalue_2_ints()[0]--;
	split("a","b","c")[0] =~ s/a/b/;

	(a2 = a1)[0] = 0;
	(a2 = a1)[0] += 1;
	++(a2 = a1)[0];
	(a2 = a1)[0]--;
	(s2 = s1)[0] =~ s/bad/yes-its-still-bad/;
}
#lang tcl
lvalue_2
} -returnCodes {error} -match regexp -result {.*11: L Error: invalid l-value in assignment
.*12: L Error: invalid l-value in assignment
.*13: L Error: invalid l-value in inc/dec
.*14: L Error: invalid l-value in inc/dec
.*15: L Error: invalid l-value in =~
.*17: L Error: invalid l-value in assignment
.*18: L Error: invalid l-value in assignment
.*19: L Error: invalid l-value in inc/dec
.*20: L Error: invalid l-value in inc/dec
.*21: L Error: invalid l-value in =~
}

test lvalue-3 {invalid l-value in inc/dec operators} -body {
#lang L
void lvalue_3()
{
	int	i = 0;

	i----;
	i++++;
	(i++)++;
	(i++)--;
	(i--)++;
	(i--)--;
	++++i;
	----i;
	++(++i);
	++(--i);
	--(++i);
	--(--i);
	--(i--);
	--(i++);
	++(i--);
	++(i++);
	(--i)--;
	(--i)++;
	(++i)--;
	(++i)++;
}
#lang tcl
lvalue_3
} -returnCodes {error} -match regexp -result {.*5: L Error: invalid l-value in inc/dec
.*6: L Error: invalid l-value in inc/dec
.*7: L Error: invalid l-value in inc/dec
.*8: L Error: invalid l-value in inc/dec
.*9: L Error: invalid l-value in inc/dec
.*10: L Error: invalid l-value in inc/dec
.*11: L Error: invalid l-value in inc/dec
.*12: L Error: invalid l-value in inc/dec
.*13: L Error: invalid l-value in inc/dec
.*14: L Error: invalid l-value in inc/dec
.*15: L Error: invalid l-value in inc/dec
.*16: L Error: invalid l-value in inc/dec
.*17: L Error: invalid l-value in inc/dec
.*18: L Error: invalid l-value in inc/dec
.*19: L Error: invalid l-value in inc/dec
.*20: L Error: invalid l-value in inc/dec
.*21: L Error: invalid l-value in inc/dec
.*22: L Error: invalid l-value in inc/dec
.*23: L Error: invalid l-value in inc/dec
.*24: L Error: invalid l-value in inc/dec
}

test lvalue-4 {invalid l-value in assignments} -body {
#lang L
int lvalue_4_foo() { return (1); }
void lvalue_4()
{
	int	i;

	lvalue_4_foo() = i;
	lvalue_4_foo() += i;
	lvalue_4_foo() -= i;
	lvalue_4_foo() *= i;
	lvalue_4_foo() /= i;
	lvalue_4_foo() %= i;
	lvalue_4_foo() &= i;
	lvalue_4_foo() |= i;
	lvalue_4_foo() ^= i;
	lvalue_4_foo() >>= i;
	lvalue_4_foo() <<= i;
	lvalue_4_foo() =~ s/bad/dab/;
}
#lang tcl
lvalue_4
} -returnCodes {error} -match regexp -result {.*6: L Error: invalid l-value in assignment
.*7: L Error: invalid l-value in assignment
.*8: L Error: invalid l-value in assignment
.*9: L Error: invalid l-value in assignment
.*10: L Error: invalid l-value in assignment
.*11: L Error: invalid l-value in assignment
.*12: L Error: invalid l-value in assignment
.*13: L Error: invalid l-value in assignment
.*14: L Error: invalid l-value in assignment
.*15: L Error: invalid l-value in assignment
.*16: L Error: invalid l-value in assignment
.*17: L Error: invalid l-value in =~
}

test lvalue-5 {invalid l-value in & operator} -body {
#lang L -nowarn
int lvalue_5_foo() { return (1); }
void lvalue_5_bar(int &i) {}
void lvalue_5()
{
	int	a[], aa[][];

	lvalue_5_bar(&lvalue_5_foo());
	lvalue_5_bar(&1);
	&1;
	&1.1;
	&"s";
	&{1,2,3};
	&{1=>1};
	&(1+2);
	&a[0];
	&aa[0];
	&aa[0][0];
}
#lang tcl
lvalue_5
} -returnCodes {error} -match regexp -result {.*7: L Error: illegal operand to &
.*8: L Error: illegal operand to &
.*9: L Error: illegal operand to &
.*10: L Error: illegal operand to &
.*11: L Error: illegal operand to &
.*12: L Error: illegal operand to &
.*13: L Error: illegal operand to &
.*14: L Error: illegal operand to &
.*15: L Error: illegal operand to &
.*16: L Error: illegal operand to &
.*17: L Error: illegal operand to &
}

test builtin-1 {check keys built-in} -body {
#lang L
int[]
builtin_1_isort(int a[])
{
	int	sorted[] = sort(a);
	return (sorted);
}
string[]
builtin_1_ssort(string a[])
{
	string	sorted[] = sort(a);
	return (sorted);
}
void builtin_1()
{
	int	hi{int};
	int	hs{string};
	int	hp{poly};
	int	ki[];
	string	ks[];
	poly	kp[];

	hi = { 3=>3, 1=>1, 4=>4, 5=>5, 9=>9 };
	ki = keys(hi);
	ki = builtin_1_isort(ki);
	unless ((ki[0] == 1) && (ki[1] == 3) && (ki[2] == 4)) puts("bad 1.1");
	unless ((ki[3] == 5) && (ki[4] == 9)) puts("bad 1.2");
	if (defined(ki[5])) puts("bad 1.3");

	hs = { "3"=>3, "1"=>1, "4"=>4, "5"=>5, "9"=>9 };
	ks = keys(hs);
	ks = builtin_1_ssort(ks);
	unless ((ks[0] eq "1") && (ks[1] eq "3")) puts("bad 2.1");
	unless ((ks[2] eq "4") && (ks[3] eq "5")) puts("bad 2.2");
	unless (ks[4] eq "9") puts("bad 2.3");
	if (defined(ks[5])) puts("bad 2.4");

	hp{"3"} = 3;
	hp{1}   = 1;
	hp{"4"} = 4;
	hp{5}   = 5;
	hp{"9"} = 9;
	kp = keys(hp);
	kp = builtin_1_ssort(kp);
	unless ((kp[0] eq "1") && (kp[1] eq "3")) puts("bad 3.1");
	unless ((kp[2] eq "4") && (kp[3] eq "5")) puts("bad 3.2");
	unless (kp[4] eq "9") puts("bad 3.3");
	if (defined(kp[5])) puts("bad 3.4");
}
builtin_1();
} -output {}

test builtin-2 {check errors with keys built-in} -body {
#lang L
void builtin_2()
{
	int	h{int};
	int	k[];

	k = keys();
	k = keys(k);
	k = keys(h, h);
}
} -returnCodes {error} -match regexp -result {.*6: L Error: incorrect # args to keys
.*7: L Error: arg to keys is not a hash
.*8: L Error: incorrect # args to keys
}

test builtin-3 {check length built-in} -body {
#lang L
void builtin_3()
{
	int	a[] = {1,2,3,4};
	int	h{int} = {1=>1,2=>2,3=>3};
	poly	p = {1,2,3,4,5,6};

	unless (length("abcde") == 5) puts("bad 1");
	unless (length(a) == 4) puts("bad 2");
	unless (length(p) == 6) puts("bad 4");
	unless (length(h) == 3) puts("bad 5");
}
builtin_3();
} -output {}

test builtin-4 {check errors with length built-in} -body {
#lang L
void builtin_4_f() {}
void builtin_4()
{
	length();
	length(1,2);
	length(3.14159);
	length(builtin_4_f());
}
} -returnCodes {error} -match regexp -result {.*4: L Error: incorrect # args to length
.*5: L Error: incorrect # args to length
.*6: L Error: arg to length has illegal type
.*7: L Error: arg to length has illegal type
}

test builtin-5 {check sort built-in} -body {
#lang L
int builtin_5_compar(string a, string b)
{
	int	la = length(a);
	int	lb = length(b);

	if (la < lb) {
		return (-1);
	} else if (la > lb) {
		return (1);
	} else {
		return (0);
	}
}
void builtin_5()
{
	int	ui[] = {3, 1, 4, 1, 5, 9, 2};
	int	si[];
	string	us[] = {"u","n","s","o","r","t","e","d"};
	string	ss[];
	float	uf[] = {3.1, 1.0, 9.2, -1.0, 5.5};
	float	sf[];
	string	uc[] = {"1", "11111", "111", "11", "1111"};
	string	sc[];

	ss = sort(us);
	unless ((ss[0] eq "d") && (ss[1] eq "e")) puts("bad 1.1");
	unless ((ss[2] eq "n") && (ss[3] eq "o")) puts("bad 1.2");
	unless ((ss[4] eq "r") && (ss[5] eq "s")) puts("bad 1.3");
	unless ((ss[6] eq "t") && (ss[7] eq "u")) puts("bad 1.4");

	si = sort(ui);
	unless ((si[0] == 1) && (si[1] == 1) && (si[2] == 2)) puts("bad 2.1");
	unless ((si[3] == 3) && (si[4] == 4) && (si[5] == 5)) puts("bad 2.2");
	unless (si[6] == 9) puts("bad 2.3");

	/*
	 * Exact comparisons with floats don't always work, so if this
	 * test fails, suspect that first.
	 */
	sf = sort(uf);
	unless ((sf[0] == -1.0) && (sf[1] == 1.0)) puts("bad 3.1");
	unless ((sf[2] == 3.1)  && (sf[3] == 5.5)) puts("bad 3.2");
	unless (sf[4] == 9.2) puts("bad 3.3");

	ss = sort(decreasing:, us);
	unless ((ss[7] eq "d") && (ss[6] eq "e")) puts("bad 4.1");
	unless ((ss[5] eq "n") && (ss[4] eq "o")) puts("bad 4.2");
	unless ((ss[3] eq "r") && (ss[2] eq "s")) puts("bad 4.3");
	unless ((ss[1] eq "t") && (ss[0] eq "u")) puts("bad 4.4");

	sc = sort(command: builtin_5_compar, uc);
	unless ((sc[0] eq "1")   && (sc[1] eq "11")) puts("bad 5.1");
	unless ((sc[2] eq "111") && (sc[3] eq "1111")) puts("bad 5.2");
	unless (sc[4] eq "11111") puts("bad 5.3");
}
builtin_5();
} -output {}

test builtin-6 {check sort built-in errors} -body {
#lang L
void builtin_6()
{
	sort();
	sort(1);
}
} -returnCodes {error} -match regexp -result {.*3: L Error: incorrect # args to sort
.*4: L Error: last arg to sort not an array or list
}

test builtin-7 {check join built-in} -body {
#lang L
void builtin_7()
{
	int	ai[] = {1,2,3};
	string	as[] = {"a","b","c"};
	string	s = "x";
	poly	p = "p";

	unless (join(" ", as) eq "a b c") puts("bad 1");
	unless (join(s, as) eq "axbxc") puts("bad 2");
	unless (join("xyz", as) eq "axyzbxyzc") puts("bad 3");
	unless (join(p, as) eq "apbpc") puts("bad 4");
	unless (join(p,p) eq "p") puts("bad 5");
	unless (join(" ", ai) eq "1 2 3") puts("bad 6");
}
builtin_7();
} -output {}

test builtin-8 {check join built-in errors} -body {
#lang L
void builtin_8()
{
	int	ai[];

	join();
	join(ai,"s1","s2");
	join(ai, "s");
	join(1);
	join(1.1);
	join("s");
	join("s", 1);
}
} -returnCodes {error} -match regexp -result {.*5: L Error: incorrect # args to join
.*6: L Error: incorrect # args to join
.*7: L Error: first arg to join not a string
.*8: L Error: incorrect # args to join
.*9: L Error: incorrect # args to join
.*10: L Error: incorrect # args to join
.*11: L Error: second arg to join not an array or list
}

test builtin-9 {check re-declaration of built-ins} -body {
#lang L
void join() {}
void keys() {}
void length() {}
void push() {}
void sort() {}
void assert() {}
} -returnCodes {error} -match regexp -result {.*1: L Error: function 'join' conflicts with built-in
.*2: L Error: function 'keys' conflicts with built-in
.*3: L Error: function 'length' conflicts with built-in
.*4: L Error: function 'push' conflicts with built-in
.*5: L Error: function 'sort' conflicts with built-in
.*6: L Error: function 'assert' conflicts with built-in
}

test builtin-10 {check built-ins stack integrity} -body {
#lang L
void builtin_10()
{
	/*
	 * This checks that an ignored return value doesn't leave the
	 * stack unbalanced (which would cause a crash).
	 */

	int	a[], i;
	int	n = 100;
	int	h{int} = { 1=>1, 2=>2 };

	for (i = 0; i < n; ++i) {
		push(&a, i);
		keys(h);
		length(h);
		split("x y z");
		sort({3,2,1});
		join(" ", {"a","b"});
	}
	unless (length(a) == n) puts("bad 1");
}
builtin_10();
} -output {}

test builtin-11 {check push onto class and instance variables} -body {
#lang L
class builtin_11
{
	public	int apubl[];
	instance {
		public	int ainst[];
	}
}
void builtin_11_main()
{
	builtin_11 o = builtin_11_new();

	push(&builtin_11->apubl, 1);
	push(&builtin_11->apubl, 2);
	push(&builtin_11->apubl, 3);
	unless (length(builtin_11->apubl) == 3) puts("bad 1.1");
	unless (builtin_11->apubl[0] == 1) puts("bad 1.2");
	unless (builtin_11->apubl[1] == 2) puts("bad 1.3");
	unless (builtin_11->apubl[2] == 3) puts("bad 1.4");

	push(&o->ainst, 1);
	push(&o->ainst, 2);
	push(&o->ainst, 3);
	unless (length(o->ainst) == 3) puts("bad 2.1");
	unless (o->ainst[0] == 1) puts("bad 2.2");
	unless (o->ainst[1] == 2) puts("bad 2.3");
	unless (o->ainst[2] == 3) puts("bad 2.4");

	builtin_11_delete(o);
}
builtin_11_main();
} -output {}

test builtin-12 {check assert built-in errors} -body {
#lang L
void builtin_12_foo();
void builtin_12()
{
	string	s;

	assert();
	assert(1,2);
	assert(builtin_12_foo());
	s = assert(0);
}
} -returnCodes {error} -match regexp -result {.*6: L Error: incorrect # args to assert
.*7: L Error: incorrect # args to assert
.*8: L Error: void type illegal in predicate
.*9: L Error: type void illegal
}

test line-file-1 {test __LINE__ and __FILE__} -body {
#lang L
void line_file_1()
{
	unless(basename(__FILE__) eq "l-core.test") puts("bad 1.1");
	unless(__LINE__ == 4) puts("bad 1.2");
	unless(__LINE__ == 5) puts("bad 1.3");
	unless(__LINE__ == 6) puts("bad 1.4");
}
line_file_1();
} -output {}

test line-file-2 {test __LINE__ and __FILE__ errors} -body {
#lang L
void line_file_2_s(string &s) { s = "bad"; }
void line_file_2_i(int &i) { i = 1; }
void line_file_2()
{
	__FILE__ = "bad";
	__LINE__ = 1;
	line_file_2_s(&__FILE__);
	line_file_2_i(&__LINE__);
}
} -returnCodes {error} -match regexp -result {.*5: L Error: invalid l-value in assignment
.*6: L Error: invalid l-value in assignment
.*7: L Error: illegal operand to &
.*8: L Error: illegal operand to &
}

test lregex-1 {test a trivial regex} -body {
#lang L
int lregex_1(void) {
	if ("x" =~ /x+/) { return(1); } else { return(0); }
}
#lang tcl
lregex_1;
} -result {1}

test class-1.1 {test basic class functionality} -body {
#lang L
int	class_1_1_inits = 0;
int	class_1_1_frees = 0;
int	class_1_1_foos  = 0;
int	class_1_1_privs = 0;
class class_1_1
{
	public	int cvar1 = 123;
	public	int cvar2 = cvar1 * 2;
	instance {
		public	string inst = "initial";
	}
	private void priv();
	constructor class_1_1_init(string s)
	{
		unless (inst eq "initial") puts("bad c1");
		inst = s;
		++class_1_1_inits;
	}
	destructor class_1_1_free(class_1_1 self)
	{
		++class_1_1_frees;
	}
	void class_1_1_foo(class_1_1 self)
	{
		++class_1_1_foos;
		priv();
	}
	string class_1_1_inst(class_1_1 self)
	{
		return (inst);
	}
	int class_1_1_cvar1(class_1_1 self)
	{
		return (cvar1);
	}
	int class_1_1_cvar2(class_1_1 self)
	{
		return (cvar2);
	}
	private void priv()
	{
		++class_1_1_privs;
	}
}
void class_1_1_main()
{
	class_1_1 o = class_1_1_init("constructed");

	unless (class_1_1_inst(o) eq "constructed") puts("bad 1.1");
	unless (class_1_1_cvar1(o) == 123) puts("bad 1.2");
	unless (class_1_1_cvar2(o) == 246) puts("bad 1.3");
	unless (class_1_1_inits == 1) puts("bad 1.4");
	unless (class_1_1_frees == 0) puts("bad 1.5");
	unless (class_1_1_foos  == 0) puts("bad 1.6");
	unless (class_1_1_privs == 0) puts("bad 1.7");

	class_1_1_foo(o);
	unless (class_1_1_inits == 1) puts("bad 2.1");
	unless (class_1_1_frees == 0) puts("bad 2.2");
	unless (class_1_1_foos  == 1) puts("bad 2.3");
	unless (class_1_1_privs == 1) puts("bad 2.4");

	class_1_1_foo(o);
	unless (class_1_1_inits == 1) puts("bad 3.1");
	unless (class_1_1_frees == 0) puts("bad 3.2");
	unless (class_1_1_foos  == 2) puts("bad 3.3");
	unless (class_1_1_privs == 2) puts("bad 3.4");

	unless (class_1_1_inst(o) eq "constructed") puts("bad 4.1");
	unless (class_1_1_inits == 1) puts("bad 4.1");
	unless (class_1_1_frees == 0) puts("bad 4.2");
	unless (class_1_1_foos  == 2) puts("bad 4.3");
	unless (class_1_1_privs == 2) puts("bad 4.4");

	class_1_1_free(o);
	unless (class_1_1_inits == 1) puts("bad 5.1");
	unless (class_1_1_frees == 1) puts("bad 5.2");
	unless (class_1_1_foos  == 2) puts("bad 5.3");
	unless (class_1_1_privs == 2) puts("bad 5.4");
}
class_1_1_main();
} -output {}

test class-1.2 {test multiple object instances} -body {
#lang L
class class_1_2
{
	instance {
		public	int n;
	}
	constructor class_1_2_init(int i) { n = i; }
	destructor class_1_2_free(class_1_2 self) {}
	int class_1_2_inst(class_1_2 self) { return (n); }
}
void class_1_2_main()
{
	int		i, j;
	class_1_2	o[];

	for (i = 0; i < 10; ++i) {
		o[i] = class_1_2_init(i);
		unless (class_1_2_inst(o[i]) == i) printf("bad 1 i=%d\n", i);
	}
	for (i = 0; i < 10; ++i) {
		unless (class_1_2_inst(o[i]) == i) printf("bad 2 i=%d\n", i);
	}
	for (i = 0; i < 10; ++i) {
		class_1_2_free(o[i]);
		for (j = i+1; j < 10; ++j) {
			unless (class_1_2_inst(o[j]) == j) {
				printf("bad 3 j=%d\n", j);
			}
		}
	}
}
class_1_2_main();
} -output {}

test class-1.3 {test class variables} -body {
#lang L
class class_1_3
{
	public	string cls_var = "first";
	constructor class_1_3_init() {}
	destructor class_1_3_free(class_1_3 self) {}
	void class_1_3_set(class_1_3 self, string s)
	{
		cls_var = s;
	}
	string class_1_3_get(class_1_3 self)
	{
		return (cls_var);
	}
}
void class_1_3_main()
{
	int		i, j;
	class_1_3	o[];

	/* As we init objects, cls_var should not change. */
	for (i = 0; i < 10; ++i) {
		o[i] = class_1_3_init();
		for (j = 0; j <= i; ++j) {
			unless (class_1_3_get(o[j]) eq "first") {
				printf("bad 1 j=%d\n", j);
			}
		}
	}
	/* All objects should see the change to "second". */
	class_1_3_set(o[5], "second");
	for (j = 0; i < 10; ++i) {
		unless (class_1_3_get(o[i]) eq "second") {
			printf("bad 2 i=%d\n", i);
		}
	}
	/* Deleting one object shouldn't mess up cls_var. */
	class_1_3_free(o[5]);
	for (j = 0; i < 10; ++i) {
		if (i == 5) continue;
		unless (class_1_3_get(o[i]) eq "second") {
			printf("bad 2 i=%d\n", i);
		}
	}
}
class_1_3_main();
} -output {}

test class-1.4 {test no class instance variables} -body {
#lang L
class class_1_4
{
	public	int cvar = 123;
	constructor class_1_4_new()
	{
		unless (cvar == 123) puts ("bad c1");
	}
	destructor class_1_4_delete(class_1_4 self)
	{
		unless (cvar == 123) puts ("bad d1");
	}
}
void class_1_4_main()
{
	class_1_4 o = class_1_4_new();
	class_1_4_delete(o);
}
class_1_4_main();
} -output {}

test class-1.5 {test no class variables} -body {
#lang L
class class_1_5
{
	instance {
		public	int inst = 123;
	}
	constructor class_1_5_new()
	{
		unless (inst == 123) puts ("bad c1");
	}
	destructor class_1_5_delete(class_1_5 self)
	{
		unless (inst == 123) puts ("bad d1");
	}
}
void class_1_5_main()
{
	class_1_5 o = class_1_5_new();
	class_1_5_delete(o);
}
class_1_5_main();
} -output {}

test class-1.6 {test "->" as member variable selection} -body {
#lang L
class class_1_6
{
	public	string cvar = "cvar";
	instance {
		public	string ivar = "ivar";
	}
}
void class_1_6_main()
{
	/* Check that -> works ("." is not allowed). */

	class_1_6 o = class_1_6_new();

	unless (class_1_6->cvar eq "cvar") puts("bad 1.1");
	unless (o->ivar eq "ivar") puts("bad 2.1");

	class_1_6_delete(o);
}
class_1_6_main();
} -output {}

test class-1.7 {test "." error as member variable selection} -body {
#lang L
class class_1_7
{
	public	string cvar = "cvar";
	instance {
		public	string ivar = "ivar";
	}
}
void class_1_7_main()
{
	/* Check that . is caught as an error. */

	class_1_7 o = class_1_7_new();

	unless (o.ivar eq "ivar") puts("bad 2.1");
}
} -returnCodes {error} -match regexp -result {.*14: L Error: . illegal on objects; use -> instead
}

test class-2.1 {check missing class constructor} -body {
#lang L
class class_2_1
{
	instance {
		public	int inst = 123;
	}
	destructor class_2_1_delete(class_2_1 self)
	{
		unless (inst == 123) puts("bad 1");
	}
}
void class_2_1_main()
{
	class_2_1 o = class_2_1_new();
	class_2_1_delete(o);
}
class_2_1_main();
} -output {}

test class-2.2 {check class missing destructor} -body {
#lang L
class class_2_2
{
	instance {
		public	int inst = 123;
	}
	constructor class_2_2_new()
	{
		unless (inst == 123) puts("bad 1");
	}
}
void class_2_2_main()
{
	class_2_2 o = class_2_2_new();
	class_2_2_delete(o);
}
class_2_2_main();
} -output {}

test class-2.2.1 {check class missing constructor and destructor} -body {
#lang L
class class_2_2_1
{
	instance {
		public	int inst = 123;
	}
	int class_2_2_1_get(class_2_2_1 self) { return inst; }
}
void class_2_2_1_main()
{
	class_2_2_1 o = class_2_2_1_new();
	unless (class_2_2_1_get(o) == 123) puts("bad 1");
	class_2_2_1_delete(o);
}
class_2_2_1_main();
} -output {}

test class-2.3 {check duplicate class constructor} -body {
#lang L
class class_2_3
{
	constructor class_2_3_init1() {}
	constructor class_2_3_init2() {}
}
} -returnCodes {error} -match regexp -result {.*4: L Error: class constructor already declared
}

test class-2.4 {check duplicate class destructor} -body {
#lang L
class class_2_4
{
	destructor class_2_3_free1(class_2_4 self) {}
	destructor class_2_3_free2(class_2_4 self) {}
}
} -returnCodes {error} -match regexp -result {.*4: L Error: class destructor already declared
}

test class-2.5 {check missing self argument in class destructor 1} -body {
#lang L
class class_2_5
{
	constructor class_2_5_init() {}
	destructor class_2_5_free() {}
}
} -returnCodes {error} -match regexp -result {.*4: L Error: class public member function lacks 'self' as first arg
}

test class-2.6 {check missing self argument in class destructor 2} -body {
#lang L -nowarn
class class_2_6
{
	constructor class_2_6_init() {}
	destructor class_2_6_free(string bad) {}
}
} -returnCodes {error} -match regexp -result {.*4: L Error: class public member function lacks 'self' as first arg
}

test class-2.7 {check missing self argument in class destructor 3} -body {
#lang L -nowarn
class class_2_7
{
	constructor class_2_7_init() {}
	destructor class_2_7_free(string bad, class_2_7 self) {}
}
} -returnCodes {error} -match regexp -result {.*4: L Error: class public member function lacks 'self' as first arg
}

test class-2.8 {check missing self argument in public class member fn} -body {
#lang L -nowarn
class class_2_8
{
	constructor class_2_8_init() {}
	destructor class_2_8_free(class_2_8 self) {}
	void class_2_8_foo1() {}
	void class_2_8_foo2(string bad) {}
	void class_2_8_foo3(string bad, class_2_8 self) {}
}
} -returnCodes {error} -match regexp -result {.*5: L Error: class public member function lacks 'self' as first arg
.*6: L Error: class public member function lacks 'self' as first arg
.*7: L Error: class public member function lacks 'self' as first arg
}

test class-2.9 {check use of self argument in class member fn} -body {
#lang L
class class_2_9
{
	constructor class_2_9_init() {}
	destructor class_2_9_free(class_2_9 self) {}
	void class_2_9_foo1(class_2_9 self) {}
	void class_2_9_foo2(class_2_9 self, class_2_9 self) {}
	void class_2_9_foo3(class_2_9 self, string self) {}
}
} -returnCodes {error} -match regexp -result {.*6: L Error: multiple declaration of local self
.*7: L Error: multiple declaration of local self
}

test class-2.10 {check declaration of local named self in class} -body {
#lang L
class class_2_10
{
	constructor class_2_10_init()
	{
		int	self;
	}
	destructor class_2_10_free(class_2_10 self)
	{
		class_2_10 self;
	}
	void class_2_10_foo(class_2_10 self)
	{
		int	self;
	}
}
} -returnCodes {error} -match regexp -result {.*5: L Error: multiple declaration.*
.*9: L Error: multiple declaration.*
.*13: L Error: multiple declaration.*
}

test class-2.11 {check return stmt in class destructor 1} -body {
#lang L
class class_2_11
{
	destructor class_2_11_delete(class_2_11 self)
	{
		return;  // legal -- return type of void
	}
}
void class_2_11_main()
{
	class_2_11 o = class_2_11_new();
	class_2_11_delete(o);
}
class_2_11_main();
} -output {}

test class-2.12 {check return stmt in class destructor 2} -body {
#lang L
class class_2_12
{
	destructor class_2_12_delete(class_2_12 self)
	{
		return ("bad");  // err -- return type is void
	}
}
} -returnCodes {error} -match regexp -result {.*5: L Error: void function cannot return value
}

test class-2.12.1 {check return stmt in class constructor 1} -body {
#lang L
class class_2_12_1
{
	instance { public int inst = 123; }
	constructor class_2_12_1_new()
	{
		return (self);
	}
	int class_2_12_1_get(class_2_12_1 self) { return (inst); }
}
void class_2_12_1_main()
{
	class_2_12_1 o = class_2_12_1_new();
	unless (class_2_12_1_get(o) == 123) puts("bad 1");
	class_2_12_1_delete(o);
}
class_2_12_1_main();
} -output {}

test class-2.12.2 {check return stmt in class constructor 2} -body {
#lang L
class class_2_12_2
{
	constructor class_2_12_2_new()
	{
		return ("bad");  // err -- bad return type
	}
}
} -returnCodes {error} -match regexp -result {.*5: L Error: incompatible return type
}

test class-2.13 {check name clash with class constructor 1} -body {
#lang L
class class_2_13
{
	constructor class_2_13_new() {}
	void class_2_13_new(class_2_13 self) {}  // err
	private void class_2_13_new(class_2_13 self) {}  // err
}
} -returnCodes {error} -match regexp -result {.*4: L Error: function class_2_13_new already declared
.*5: L Error: function class_2_13_new already declared
}

test class-2.14 {check name clash with class constructor 2} -body {
#lang L
class class_2_14
{
	void class_2_14_new(class_2_14 self) {}  // err
	private void class_2_14_new(class_2_14 self) {}  // err
}
} -returnCodes {error} -match regexp -result {.*3: L Error: function class_2_14_new already declared
.*4: L Error: function class_2_14_new already declared
}

test class-2.15 {check name clash with class destructor 1} -body {
#lang L
class class_2_15
{
	destructor class_2_15_delete(class_2_15 self) {}
	void class_2_15_delete(class_2_15 self) {}  // err
	private void class_2_15_delete(class_2_15 self) {}  // err
}
} -returnCodes {error} -match regexp -result {.*4: L Error: function class_2_15_delete already declared
.*5: L Error: function class_2_15_delete already declared
}

test class-2.16 {check name clash with class destructor 2} -body {
#lang L
class class_2_16
{
	void class_2_16_delete(class_2_16 self) {}  // err
	private void class_2_16_delete(class_2_16 self) {}  // err
}
} -returnCodes {error} -match regexp -result {.*3: L Error: function class_2_16_delete already declared
.*4: L Error: function class_2_16_delete already declared
}

test class-2.17 {check illegal self parameter in class constructor 1} -body {
#lang L
class class_2_17
{
	constructor class_2_17_new(class_2_17 self) {}
}
} -returnCodes {error} -match regexp -result {.*3: L Error: 'self' parameter illegal in class constructor
}

test class-2.18 {check illegal self parameter in class constructor 2} -body {
#lang L -nowarn
class class_2_18
{
	constructor class_2_18_new(int a, class_2_17 self) {}
}
} -returnCodes {error} -match regexp -result {.*3: L Error: 'self' parameter illegal in class constructor
}

test class-2.19 {check class constructor not returning self} -body {
#lang L
class class_2_19
{
	/*
	 * Previous tests checked returning something other than
	 * the class type.  This checks when you return the right
	 * type but it's not literally the "self" variable.
	 */
	constructor class_2_19_new()
	{
		class_2_19 o;
		return (o);  // err
	}
}
} -returnCodes {error} -match regexp -result {.*11: L Error: class constructor must return 'self'
}

test class-2.20 {check class public member fn with arg without name} -body {
#lang L -nowarn
class class_2_20
{
	/*
	 * This is syntactically legal and the compiler should check
	 * for this error.
	 */
	public void class_2_20_foo(class_2_20) {}
}
} -returnCodes {error} -match regexp -result {.*7: L Error: class public member function lacks 'self' as first arg
}

test class-2.21 {check class member function use before declare} -body {
#lang L
class class_2_21
{
	public int class_2_21_foo(class_2_21 self, int arg)
	{
		return (priv(arg) + class_2_21_pub(self, arg));
	}
	private int priv(int arg)
	{
		return (arg);
	}
	public int class_2_21_pub(class_2_21 self, int arg)
	{
		return (-arg);
	}
}
void class_2_21_main()
{
	class_2_21 o;

	o = class_2_21_new();
	unless (class_2_21_foo(o, 13) == 0) puts("bad 1");
}
class_2_21_main();
} -output {}

test class-3.1 {check scoping of class vars and class instance vars 1} -body {
#lang L
class class_3_1
{
	/*
	 * Class variables and instance variables should both be at
	 * class scope, so a name clash should be an error.  Note that
	 * because the instance var always get compiled first, we
	 * don't check for line #'s in the error messages.
	 */
	instance {
		public	int x;
	}
	public	int x;
	private	int x;
	public	int x;
	constructor class_3_1_init() {}
	destructor class_3_1_free(class_3_1 self) {}
}
} -returnCodes {error} -match regexp -result {.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
}

test class-3.2 {check scoping of class vars and class instance vars 2} -body {
#lang L
class class_3_2
{
	/*
	 * Like the class_3_1 test but with multiple instance declarations.
	 * Note that because the instance var always get compiled
	 * first, we don't check for line #'s in the error messages.
	 */
	instance {
		public	int x;
		private	int x;
		public	int x;
	}
	public	int x;
	constructor class_3_2_init() {}
	destructor class_3_2_free(class_3_2 self) {}
}
} -returnCodes {error} -match regexp -result {.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
}

test class-3.3 {check empty class instance variable section} -body {
#lang L
class class_3_3
{
	instance {}
}
} -result {}

test class-3.3.1 {check completely empty class declaration} -body {
#lang L
class class_3_3_1 {}
void class_3_3_1_main()
{
	class_3_3_1 o = class_3_3_1_new();
	class_3_3_1_delete(o);
}
class_3_3_1_main();
} -output {}

test class-3.4 {check scoping of class vars and class instance vars 4} -body {
#lang L
class class_3_4
{
	/*
	 * Like the class_3_3 test but with var decls in the reverse order.
	 * Note that because the instance var always get compiled first,
	 * we don't check for line #'s in the error messages.
	 */
	public	int x;
	private	int x;
	instance {
		public	int x;
		private	int x;
	}
	constructor class_3_4_init() {}
	destructor class_3_4_free(class_3_4 self) {}
}
} -returnCodes {error} -match regexp -result {.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
.*: L Error: multiple declaration of x
}

test class-3.5 {check scoping of class vars and class instance vars 5} -body {
#lang L
class class_3_5
{
	/*
	 * Like the class_3_2 test but with private and public function
	 * declarations of the same name as the variables.  Note that
	 * because the instance var always get compiled first, we
	 * don't check for all line #'s in the error messages.
	 */
	instance {
		public	int class_3_5_x;
		public	int class_3_5_x;  // err -- multiply declared
	}
	public	int class_3_5_x;  // err -- multiply declared
	public	int class_3_5_x;  // err -- multiply declared
	private void class_3_5_x() {}  // err -- already declared as a variable
	void class_3_5_x() {}  // err -- already declared as a variable
	public void class_3_5_x() {}  // err -- already declared as a variable
	constructor class_3_5_init() {}
	destructor class_3_5_free(class_3_5 self) {}
}
} -returnCodes {error} -match regexp -result {.*: L Error: multiple declaration of class_3_5_x
.*: L Error: multiple declaration of class_3_5_x
.*: L Error: multiple declaration of class_3_5_x
.*15: L Error: class_3_5_x already declared as a variable
.*16: L Error: class_3_5_x already declared as a variable
.*17: L Error: class_3_5_x already declared as a variable
}

test class-3.6 {check scoping of class vars and class instance vars 6} -body {
#lang L
class class_3_6
{
	/*
	 * Like the class_3_5 test but with only a public function
	 * declaration of the same name as the variables.  Note that
	 * because the instance var always get compiled first, we
	 * don't check for all line #'s in the error messages.
	 */
	instance {
		public	int class_3_6_x;
		public	int class_3_6_x;  // err -- multiply declared
	}
	public	int class_3_6_x;  // err -- multiply declared
	public	int class_3_6_x;  // err -- multiply declared
	void class_3_6_x() {}  // err -- already declared as a variable
	constructor class_3_6_init() {}
	destructor class_3_6_free(class_3_6 self) {}
}
} -returnCodes {error} -match regexp -result {.*: L Error: multiple declaration of class_3_6_x
.*: L Error: multiple declaration of class_3_6_x
.*: L Error: multiple declaration of class_3_6_x
.*15: L Error: class_3_6_x already declared as a variable
}

test class-3.7 {check variable visibility in class member functions} -body {
#lang L
/*
 * Ensure class and instance variables are visible and work
 * inside of all class member functions.
 */
class class_3_7
{
	public	string publ_cvar = "publ_cvar";
	private	string priv_cvar = "priv_cvar";
	instance {
		public	string publ_ivar = "publ_ivar";
		private	string priv_ivar = "priv_ivar";
	}
	constructor class_3_7_init()
	{
		unless (publ_cvar eq "publ_cvar") puts("bad c1");
		unless (priv_cvar eq "priv_cvar") puts("bad c2");
		unless (publ_cvar eq "publ_cvar") puts("bad c3");
		unless (priv_ivar eq "priv_ivar") puts("bad c4");
	}
	destructor class_3_7_free(class_3_7 self)
	{
		unless (publ_cvar eq "publ_cvar") puts("bad d1");
		unless (priv_cvar eq "priv_cvar") puts("bad d2");
		unless (publ_ivar eq "publ_ivar") puts("bad d3");
		unless (priv_ivar eq "priv_ivar") puts("bad d4");
	}
	private void priv()
	{
		unless (publ_cvar eq "publ_cvar") puts("bad p1");
		unless (priv_cvar eq "priv_cvar") puts("bad p2");
		unless (publ_ivar eq "publ_ivar") puts("bad p3");
		unless (priv_ivar eq "priv_ivar") puts("bad p4");
	}
	void class_3_7_foo(class_3_7 self)
	{
		unless (publ_cvar eq "publ_cvar") puts("bad f1");
		unless (priv_cvar eq "priv_cvar") puts("bad f2");
		unless (publ_ivar eq "publ_ivar") puts("bad f3");
		unless (priv_ivar eq "priv_ivar") puts("bad f4");
		priv();
	}
}
void class_3_7_main()
{
	class_3_7 o = class_3_7_init();
	class_3_7_foo(o);
	class_3_7_free(o);
}
class_3_7_main();
} -output {}

test class-3.8 {check missing public/private qualifiers on class vars} -body {
#lang L
class class_3_8
{
	int	bad1, bad2;
	int	bad3;
	instance {
		int	ibad1, ibad2;
		int	ibad3;
	}
}
} -returnCodes {error} -match regexp -result {.*3: L Error: class variable bad1 not declared public or private
.*3: L Error: class variable bad2 not declared public or private
.*4: L Error: class variable bad3 not declared public or private
.*6: L Error: class instance variable ibad1 not declared public or private
.*6: L Error: class instance variable ibad2 not declared public or private
.*7: L Error: class instance variable ibad3 not declared public or private
}

test class-3.9 {check expressions in class and instance variable intializers} -body {
#lang L
class class_3_9
{
	/*
	 * These initializers check that the declarations get compiled
	 * top-to-bottom and left-to-right.
	 */
	private	int c1 = 1;
	private	int c2 = c1 * 2, c3 = c2 + 3;
	instance {
		/* These get evaluated when the constructor runs. */
		private	int i1 = c1;
		private	int i2 = c2 * 2, i3 = i2 + 3;
	}
	constructor class_3_9_new()
	{
		unless (c1 == 1) puts("bad c1");
		unless (c2 == (c1 * 2)) puts("bad c2");
		unless (c3 == (c2 + 3)) puts("bad c3");
		unless (i1 == c1) puts("bad c4");
		unless (i2 == (c2 * 2)) puts("bad c5");
		unless (i3 == (i2 + 3)) puts("bad c6");
	}
}
void class_3_9_main()
{
	class_3_9 o = class_3_9_new();
	class_3_9_delete(o);
}
class_3_9_main();
} -output {}

test class-4.1 {check scoping of private names in classes} -body {
#lang L
/*
 * Check that per-class variables are defined in the class scope,
 * meaning that two classes can have the same variable names and the
 * same names as global variables.
 */
int class_4_1_global_var  = 100;
int class_4_1_global_var2 = 101;
void class_4_1_global_func() {}
class class_4_1_1
{
	public	int class_4_1_global_var = 411;  // OK -- shadows the global
	instance {
		public	int class_4_1_global_var2 = 811;  // also OK
	}

	constructor class_4_1_1_init() {}
	destructor class_4_1_1_free(class_4_1_1 self) {}
	private int priv() { return (class_4_1_global_var); }
	int class_4_1_1_get(class_4_1_1 self)
	{
		unless (class_4_1_global_var2 == 811) puts("bad c1");
		return (priv());
	}
}
class class_4_1_2
{
	public	int class_4_1_global_var = 412;  // OK -- shadows the global
	instance {
		public	int class_4_1_global_var2 = 812;  // also OK
	}

	constructor class_4_1_2_init() {}
	destructor class_4_1_2_free(class_4_1_2 self) {}
	private int priv() { return (class_4_1_global_var); }
	int class_4_1_2_get(class_4_1_2 self)
	{
		unless (class_4_1_global_var2 == 812) puts("bad c2");
		return (priv());
	}
}
void class_4_1()
{
	class_4_1_1	o411 = class_4_1_1_init();
	class_4_1_2	o412 = class_4_1_2_init();

	unless (class_4_1_global_var == 100) puts("bad 1");
	unless (class_4_1_1_get(o411) == 411) puts("bad 2");
	unless (class_4_1_2_get(o412) == 412) puts("bad 3");
	unless (class_4_1_global_var == 100) puts("bad 4");
}
class_4_1();
} -output {}

test class-4.2 {check typedef and struct type scoping in classes 1} -body {
#lang L
/*
 * Check that typedef and struct names declared inside a class get
 * defined at the global scope, not at the class scope.  This test
 * checks that a re-declaration of a global type name inside class
 * scope is an error.
 */
typedef int class_4_2_type;
struct class_4_2_struct {
	int	i;
	string	s;
};
class class_4_2
{
	public	class_4_2_type 	i;
	public	struct class_4_2_struct st;

	typedef string class_4_2_type;	// err -- already defined
	struct class_4_2_struct {	// err -- already defined
		int	a[];
	};

	constructor class_4_2_init() {}
	destructor class_4_2_free(class_4_2_1 self) {}
}
} -returnCodes {error} -match regexp -result {.*17: L Error: Cannot redefine type class_4_2_type
.*19: L Error: multiple declaration of struct class_4_2_struct
}

test class-4.3 {check typedef and struct type scoping in classes 2} -body {
#lang L -nowarn
/*
 * Check that typedef and struct names declared inside a class get
 * defined at the global scope, not at the class scope.  This test
 * checks that a declaration of a global type name inside class scope
 * is visible outside that scope.
 */
class class_4_3_1
{
	typedef string class_4_3_type;
	struct class_4_3_struct {
		string	s;
	};

	public	class_4_3_type s = "431";
	public	struct class_4_3_struct st = { "431" };

	constructor class_4_3_1_init()
	{
		unless (s eq "431") puts("bad c1.1");
		unless (st.s eq "431") puts("bad c1.2");
	}
	destructor class_4_3_1_free(class_4_3_1 self) {}
}

class_4_3_type		gs = "g43";
struct class_4_3_struct	gst = { "g43" };

class class_4_3_2
{
	public	class_4_3_type s = "432";
	public	struct class_4_3_struct st = { "432" };

	constructor class_4_3_2_init()
	{
		unless (s eq "432") puts("bad c2.1");
		unless (st.s eq "432") puts("bad c2.2");
	}
	destructor class_4_3_2_free(class_4_3_2 self) {}
}
void class_4_3_main()
{
	class_4_3_1	o431 = class_4_3_1_init();
	class_4_3_2	o432 = class_4_3_2_init();

	unless (gs eq "g43") puts("bad 1");
	unless (gst.s eq "g43") puts("bad 2");
}
class_4_3_main();
} -output {}

test class-5.1 {check class object type checking} -body {
#lang L -nowarn
class class_5_1_1
{
	constructor class_5_1_1_init() {}
	destructor class_5_1_1_free(class_5_1_1 self) {}
	void class_5_1_1_foo(class_5_1_1 self, int a) {}
}
class class_5_1_2
{
	constructor class_5_1_2_init() {}
	destructor class_5_1_2_free(class_5_1_2 self) {}
	void class_5_1_2_foo(class_5_1_2 self, int a) {}
}
void class_5_1()
{
	class_5_1_1	o511;
	class_5_1_2	o512;

	/* These are all type errors (wrong class). */
	o511 = class_5_1_2_init();
	o512 = class_5_1_1_init();
	class_5_1_1_foo(o512, 0);
	class_5_1_2_foo(o511, 0);
	class_5_1_1_free(o512);
	class_5_1_2_free(o511);
}
} -returnCodes {error} -match regexp -result {.*19: L Error: assignment of incompatible types
.*20: L Error: assignment of incompatible types
.*21: L Error: parameter 1 has incompatible type
.*22: L Error: parameter 1 has incompatible type
.*23: L Error: parameter 1 has incompatible type
.*24: L Error: parameter 1 has incompatible type
}

test class-5.2 {check wrong object type in class member fn declarations} -body {
#lang L
class class_5_2_1
{
	constructor class_5_2_1_init() {}
	destructor class_5_2_1_free(class_5_2_1 self) {}
}
class class_5_2_2
{
	constructor class_5_2_2_init() {}
	/* These have the wrong class as the arg type. */
	destructor class_5_2_2_free(class_5_2_1 self) {}
	void class_5_2_2_foo(class_5_2_1 self) {}
}
} -returnCodes {error} -match regexp -result {.*10: L Error: 'self' parameter must be of class type
.*11: L Error: 'self' parameter must be of class type
}

test class-5.3 {check that class member fn args get type checked 1} -body {
#lang L -nowarn
/*
 * This test checks that class member function arguments are
 * type checked.  There should be no type errors in this example.
 */
typedef string myhash{int};
class class_5_3 {
	constructor class_5_3_init(int a, string b, myhash c) {}
	destructor class_5_3_free(class_5_3 self) {}
	private void priv(myhash a, int b, int c) {}
	string class_5_3_foo(class_5_3 self, string a, int b) {
		myhash	h;
		priv(h, 3, 4);
		return(a);
	}
}
void class_5_3_main()
{
	myhash		h;
	class_5_3	o = class_5_3_init(1, "str", h);
	unless (class_5_3_foo(o, "foo", 3) eq "foo") puts("bad 1");
}
class_5_3_main();
} -output {}

test class-5.4 {check that class member fn args get type checked 2} -body {
#lang L -nowarn
/*
 * This test checks that class member function arguments are
 * type checked.  This example has type errors.
 */
typedef string myhash{int};
class class_5_4 {
	constructor class_5_4_init(int a, string b, myhash c) {}
	destructor class_5_4_free(class_5_4 self) {}
	private void priv(myhash a, int b, int c) {}
	string class_5_4_foo(class_5_4 self, string a, int b) {
		myhash	h;
		priv(3, h, 4);  // args 1,2 backwards
		return(b);  // bad return type
	}
}
void class_5_4_main()
{
	int		i;
	myhash		h;
	class_5_4	o = class_5_4_init(1, h, "str");  // args 2,3 backwards

	i = class_5_4_foo(o, 3, "foo");  // args 2,3 backwards
}
class_5_4_main();
} -returnCodes {error} -match regexp -result {.*12: L Error: parameter 1 has incompatible type
.*12: L Error: parameter 2 has incompatible type
.*13: L Error: incompatible return type
.*20: L Error: parameter 2 has incompatible type
.*20: L Error: parameter 3 has incompatible type
.*22: L Error: parameter 2 has incompatible type
.*22: L Error: parameter 3 has incompatible type
.*22: L Error: assignment of incompatible types
}

test class-6.1 {check class variable access from outside class} -body {
#lang L
void class_6_1_str(string &s, string new)
{
	s = new;
}
void class_6_1_hash(string &h{int}, int k, string v)
{
	h{k} = v;
}
void class_6_1_arr(int &a[][], int i, int j, int v)
{
	a[i][j] = v;
}
class class_6_1
{
	public	string s = "cvar";
	public	string h{int} = { 1=>"one", 2=>"two" };
	public	string a[] = { "zero", "one", "two" };
	public	int aa[][] = { {1,2}, {3,4} };
}
void class_6_1_main()
{
	/*
	 * This test also checks the use of complex class variables
	 * as well as class variables as reference parameters.
	 */

	unless (class_6_1->s eq "cvar") puts("bad 1.1");
	unless (class_6_1->h{1} eq "one") puts("bad 1.2");
	unless (class_6_1->h{2} eq "two") puts("bad 1.3");
	unless (class_6_1->a[0] eq "zero") puts("bad 1.4");
	unless (class_6_1->a[1] eq "one") puts("bad 1.5");
	unless (class_6_1->a[2] eq "two") puts("bad 1.6");
	unless (class_6_1->aa[0][0] == 1) puts("bad 1.10");
	unless (class_6_1->aa[0][1] == 2) puts("bad 1.11");
	unless (class_6_1->aa[1][0] == 3) puts("bad 1.12");
	unless (class_6_1->aa[1][1] == 4) puts("bad 1.13");

	class_6_1->s = "new";
	unless (class_6_1->s eq "new") puts("bad 2.1");

	class_6_1->h = { 3=>"three" };
	unless (class_6_1->h{3} eq "three") puts("bad 3.1");
	unless (length(class_6_1->h) == 1) puts("bad 3.2");

	class_6_1->a = { "just-one" };
	unless (class_6_1->a[0] eq "just-one") puts("bad 4.1");
	unless (length(class_6_1->a) == 1) puts("bad 4.2");

	class_6_1->aa = { {5} };
	unless (class_6_1->aa[0][0] == 5) puts("bad 5.1");
	unless (length(class_6_1->aa) == 1) puts("bad 5.2");
	unless (length(class_6_1->aa[0]) == 1) puts("bad 5.3");

	class_6_1_str(&class_6_1->s, "new-s");
	unless (class_6_1->s eq "new-s") puts("bad 6.1");

	class_6_1->h = {};
	class_6_1_hash(&class_6_1->h, 4, "four");
	unless (class_6_1->h{4} eq "four") puts("bad 7.1");
	unless (length(class_6_1->h) == 1) puts("bad 7.2");
	if (defined(class_6_1->h{5})) puts("bad 7.3");

	class_6_1->aa = {};
	class_6_1_arr(&class_6_1->aa, 0, 0, 11);
	class_6_1_arr(&class_6_1->aa, 0, 1, 12);
	class_6_1_arr(&class_6_1->aa, 1, 0, 13);
	class_6_1_arr(&class_6_1->aa, 1, 1, 14);
	unless (class_6_1->aa[0][0] == 11) puts("bad 8.1");
	unless (class_6_1->aa[0][1] == 12) puts("bad 8.2");
	unless (class_6_1->aa[1][0] == 13) puts("bad 8.3");
	unless (class_6_1->aa[1][1] == 14) puts("bad 8.4");
	unless (length(class_6_1->aa) == 2) puts("bad 8.5");
	unless (length(class_6_1->aa[0]) == 2) puts("bad 8.6");
	unless (length(class_6_1->aa[1]) == 2) puts("bad 8.7");
	if (defined(class_6_1->aa[2])) puts("bad 8.8");
}
class_6_1_main();
} -output {}

test class-6.2 {check class variable access errors from outside class} -body {
#lang L -nowarn
class class_6_2
{
	private	string s = "cvar";
}
void class_6_2_main()
{
	string	bad = class_6_2->s;  // error
}
} -returnCodes {error} -match regexp -result {.*7: L Error: s is not a public variable of class class_6_2
}

test class-6.3 {check class variable access from inside class} -body {
#lang L
class class_6_3
{
	public	string cpubl = "publ-cvar";
	private	string cpriv = "priv-cvar";
	constructor class_6_3_new()
	{
		unless (cpubl eq "publ-cvar") puts("bad c1");
		unless (cpriv eq "priv-cvar") puts("bad c2");
		unless (class_6_3->cpubl eq "publ-cvar") puts("bad c3");
		unless (class_6_3->cpriv eq "priv-cvar") puts("bad c4");
	}
	public void class_6_3_foo(class_6_3 self)
	{
		unless (cpubl eq "publ-cvar") puts("bad foo.1");
		unless (cpriv eq "priv-cvar") puts("bad foo.2");
		unless (class_6_3->cpubl eq "publ-cvar") puts("bad foo.3");
		unless (class_6_3->cpriv eq "priv-cvar") puts("bad foo.4");
	}
	destructor class_6_3_delete(class_6_3 self)
	{
		unless (cpubl eq "publ-cvar") puts("bad d1");
		unless (cpriv eq "priv-cvar") puts("bad d2");
		unless (class_6_3->cpubl eq "publ-cvar") puts("bad d3");
		unless (class_6_3->cpriv eq "priv-cvar") puts("bad d4");
	}
}
void class_6_3_main()
{
	class_6_3 o = class_6_3_new();
	class_6_3_foo(o);
	class_6_3_delete(o);
}
class_6_3_main();
} -output {}

test class-6.4 {check erroneous class instance var access via class name} -body {
#lang L
class class_6_4
{
	instance {
		public	string ipubl;
		private	string ipriv;
	}
	constructor class_6_4_new()
	{
		string	s;
		s = class_6_4->ipubl;  // err
		s = class_6_4->ipriv;  // err
	}
}
void class_6_4_main()
{
	string	s;
	class_6_4 o = class_6_4_new();

	s = class_6_4->ipubl;  // err
	s = class_6_4->ipriv;  // err

	class_6_4_delete(o);
}
class_6_4_main();
} -returnCodes {error} -match regexp -result {.*10: L Error: ipubl is not a class variable of class class_6_4
.*11: L Error: ipriv is not a class variable of class class_6_4
.*19: L Error: ipubl is not a class variable of class class_6_4
.*20: L Error: ipriv is not a class variable of class class_6_4
}

test class-6.5 {check class instance var access from outside class} -body {
#lang L
class class_6_5
{
	instance {
		public	string	ivar1;
		public	string	ivar2;
	}
	constructor class_6_5_new(string s1, string s2)
	{
		ivar1 = s1;
		ivar2 = s2;
	}
}
void class_6_5_main()
{
	class_6_5 o1 = class_6_5_new("a", "b");
	class_6_5 o2 = class_6_5_new("c", "d");
	class_6_5 o3 = class_6_5_new("e", "f");

	unless (o1->ivar1 eq "a") puts("bad 1");
	unless (o1->ivar2 eq "b") puts("bad 2");
	unless (o2->ivar1 eq "c") puts("bad 3");
	unless (o2->ivar2 eq "d") puts("bad 4");
	unless (o3->ivar1 eq "e") puts("bad 5");
	unless (o3->ivar2 eq "f") puts("bad 6");

	class_6_5_delete(o1);
	class_6_5_delete(o2);
	class_6_5_delete(o3);
}
class_6_5_main();
} -output {}

test class-6.6 {check class instance var access errs from outside class} -body {
#lang L
class class_6_6
{
	instance {
		private	string	ivar1;
		public	string	ivar2;
	}
}
void class_6_6_main()
{
	string	s;
	class_6_6 o = class_6_6_new();

	s = o->ivar1;  // err
}
} -returnCodes {error} -match regexp -result {.*13: L Error: ivar1 is not a public variable of class class_6_6
}

test class-6.7 {check class instance var access from inside class} -body {
#lang L
class class_6_7
{
	instance {
		public	string	ivar1;
		public	string	ivar2;
	}
	constructor class_6_7_new(string s1, string s2)
	{
		ivar1 = s1;
		ivar2 = s2;
	}
	public void class_6_7_chk(class_6_7 self, string s1, string s2)
	{
		unless (ivar1 eq s1) puts("bad chk.1");
		unless (ivar2 eq s2) puts("bad chk.2");
		unless (self->ivar1 eq s1) puts("bad chk.3");
		unless (self->ivar2 eq s2) puts("bad chk.4");
	}
	private void chkother(class_6_7 other, string s1, string s2)
	{
		unless (other->ivar1 eq s1) puts("bad priv.chkother.1");
		unless (other->ivar2 eq s2) puts("bad priv.chkother.2");
	}
	public void class_6_7_chkother(class_6_7 self, class_6_7 other,
				       string s1, string s2)
	{
		unless (other->ivar1 eq s1) puts("bad chkother.1");
		unless (other->ivar2 eq s2) puts("bad chkother.2");
		chkother(other, s1, s2);
	}
}
void class_6_7_main()
{
	class_6_7 o1 = class_6_7_new("a", "b");
	class_6_7 o2 = class_6_7_new("c", "d");
	class_6_7 o3 = class_6_7_new("e", "f");

	class_6_7_chk(o1, "a", "b");
	class_6_7_chk(o2, "c", "d");
	class_6_7_chk(o3, "e", "f");

	class_6_7_chkother(o2, o1, "a", "b");
	class_6_7_chkother(o1, o2, "c", "d");
	class_6_7_chkother(o1, o3, "e", "f");

	class_6_7_delete(o1);
	class_6_7_delete(o2);
	class_6_7_delete(o3);
}
class_6_7_main();
} -output {}

test class-6.8 {check class variable access errors} -body {
#lang L
class class_6_8
{
	public	string cpubl;
	private	string cpriv;
}
void class_6_8_main()
{
	string	s;
	class_6_8 o = class_6_8_new();

	s = o->cpubl;  // err
	s = o->cpriv;  // err
}
} -returnCodes {error} -match regexp -result {.*11: L Error: cpubl is not an instance variable of class class_6_8
.*12: L Error: cpriv is not an instance variable of class class_6_8
}

test class-7.1 {check object erroneously declared with same name as class} -body {
#lang L -nowarn
class class_7_1 {}
void class_7_1_main()
{
	class_7_1 class_7_1;  // err
}
} -returnCodes {error} -match regexp -result {.*4: L Error: cannot declare object with same name as class
}

test class-8.1 {check class variables as l-values} -body {
#lang L
class class_8_1
{
	public	string	s;
	public	int	i;

	public void class_8_1_chk(class_8_1 self)
	{
		class_8_1->s = "abcd";
		unless (class_8_1->s eq "abcd") puts("bad c1.1");

		class_8_1->s[0] = "xyz";
		unless (class_8_1->s eq "xyzbcd") puts("bad c1.2");

		class_8_1->s[END+1] = "pdq";
		unless (class_8_1->s eq "xyzbcdpdq") puts("bad c1.3");

		unless (class_8_1->s =~ /bcd/) puts("bad c1.4");

		class_8_1->s =~ s/bcd/dcb/;
		unless (class_8_1->s eq "xyzdcbpdq") puts("bad c1.5");

		class_8_1->s[0] =~ s/x/0/;
		unless (class_8_1->s eq "0yzdcbpdq") puts("bad c1.6");

		class_8_1->i = 2;
		unless (class_8_1->i == 2) puts("bad c2.1");

		class_8_1->i += 2;
		unless (class_8_1->i == 4) puts("bad c2.2");

		class_8_1->i += class_8_1->i;
		unless (class_8_1->i == 8) puts("bad c2.3");
	}
}
void class_8_1_main()
{
	class_8_1 o = class_8_1_new();

	class_8_1_chk(o);

	class_8_1->s = "abcd";
	unless (class_8_1->s eq "abcd") puts("bad 1.1");

	class_8_1->s[0] = "xyz";
	unless (class_8_1->s eq "xyzbcd") puts("bad 1.2");

	class_8_1->s[END+1] = "pdq";
	unless (class_8_1->s eq "xyzbcdpdq") puts("bad 1.3");

	unless (class_8_1->s =~ /bcd/) puts("bad 1.4");

	class_8_1->s =~ s/bcd/dcb/;
	unless (class_8_1->s eq "xyzdcbpdq") puts("bad 1.5");

	class_8_1->s[0] =~ s/x/0/;
	unless (class_8_1->s eq "0yzdcbpdq") puts("bad 1.6");

	class_8_1->i = 2;
	unless (class_8_1->i == 2) puts("bad 2.1");

	class_8_1->i += 2;
	unless (class_8_1->i == 4) puts("bad 2.2");

	class_8_1->i += class_8_1->i;
	unless (class_8_1->i == 8) puts("bad 2.3");

	class_8_1_chk(o);
}
class_8_1_main();
} -output {}

test class-8.1.5 {check class and class instance variables used in nested scopes} -body {
#lang L
class class_8_1_5
{
	private	int n = 0;
	public	int cnum = -1;
	instance { public int num = n++; }
	constructor class_8_1_5_new() { ++cnum; }
}
void class_8_1_5_main()
{
	/*
	 * This test checks that the compiler-generated temps used for
	 * accessing class and instance variables are allocated
	 * properly in the presence of nested scopes.  There was a
	 * prior compiler bug where duplicate temps could be created.
	 */

	int	i, j;
	int	n = 10;
	class_8_1_5 o1, o2, o3, o4, o[];

	o1 = class_8_1_5_new();
	unless ((o1->num == 0) && (class_8_1_5->cnum == 0)) puts("bad 1");
	o2 = class_8_1_5_new();
	unless ((o2->num == 1) && (class_8_1_5->cnum == 1)) puts("bad 2");

	for (i = 0; i < n; ++i) {
		o[i] = class_8_1_5_new();
		unless (o[i]->num == (i+2)) puts("bad 3.1");
		unless (class_8_1_5->cnum == (i+2)) puts("bad 3.2");
		for (j = 0; j < i; ++j) {
			unless (o[j]->num == (j+2)) puts("bad 4.1");
		}
	}
	for (i = 0; i < n; ++i) {
		unless (o[i]->num == (i+2)) puts("bad 5.1");
	}
	o3 = class_8_1_5_new();
	unless (o3->num == (n+2)) puts("bad 6.1");
	unless (class_8_1_5->cnum == (n+2)) puts("bad 6.2");
	o4 = class_8_1_5_new();
	unless (o4->num == (n+3)) puts("bad 7.1");
	unless (class_8_1_5->cnum == (n+3)) puts("bad 7.2");
}
class_8_1_5_main();
} -output {}

test class-8.2 {check class instance variables as l-values} -body {
#lang L
class class_8_2
{
	instance {
		public	string	s;
		public	int	i;
	}
	constructor class_8_2_new()
	{
		self->s = "abcd";
		unless (self->s eq "abcd") puts("bad 1.1");

		self->s[0] = "xyz";
		unless (self->s eq "xyzbcd") puts("bad 1.2");

		self->s[END+1] = "pdq";
		unless (self->s eq "xyzbcdpdq") puts("bad 1.3");

		unless (self->s =~ /bcd/) puts("bad 1.4");

		self->s =~ s/bcd/dcb/;
		unless (self->s eq "xyzdcbpdq") puts("bad 1.5");

		self->s[0] =~ s/x/0/;
		unless (self->s eq "0yzdcbpdq") puts("bad 1.6");

		self->i = 2;
		unless (self->i == 2) puts("bad 2.1");

		self->i += 2;
		unless (self->i == 4) puts("bad 2.2");

		self->i += self->i;
		unless (self->i == 8) puts("bad 2.3");
	}
	public void class_8_2_chk(class_8_2 self, class_8_2 other)
	{
		other->s = "abcd";
		unless (other->s eq "abcd") puts("bad 1.1");

		other->s[0] = "xyz";
		unless (other->s eq "xyzbcd") puts("bad 1.2");

		other->s[END+1] = "pdq";
		unless (other->s eq "xyzbcdpdq") puts("bad 1.3");

		unless (other->s =~ /bcd/) puts("bad 1.4");

		other->s =~ s/bcd/dcb/;
		unless (other->s eq "xyzdcbpdq") puts("bad 1.5");

		other->s[0] =~ s/x/0/;
		unless (other->s eq "0yzdcbpdq") puts("bad 1.6");

		other->i = 2;
		unless (other->i == 2) puts("bad 2.1");

		other->i += 2;
		unless (other->i == 4) puts("bad 2.2");

		other->i += other->i;
		unless (other->i == 8) puts("bad 2.3");
	}
}
void class_8_2_main()
{
	class_8_2 o = class_8_2_new();

	class_8_2_chk(o, o);

	o->s = "abcd";
	unless (o->s eq "abcd") puts("bad 1.1");

	o->s[0] = "xyz";
	unless (o->s eq "xyzbcd") puts("bad 1.2");

	o->s[END+1] = "pdq";
	unless (o->s eq "xyzbcdpdq") puts("bad 1.3");

	unless (o->s =~ /bcd/) puts("bad 1.4");

	o->s =~ s/bcd/dcb/;
	unless (o->s eq "xyzdcbpdq") puts("bad 1.5");

	o->s[0] =~ s/x/0/;
	unless (o->s eq "0yzdcbpdq") puts("bad 1.6");

	o->i = 2;
	unless (o->i == 2) puts("bad 2.1");

	o->i += 2;
	unless (o->i == 4) puts("bad 2.2");

	o->i += o->i;
	unless (o->i == 8) puts("bad 2.3");
}
class_8_2_main();
} -output {}

test class-8.3 {check class instance variables as reference parameters} -body {
#lang L
void class_8_3_str(string &s, string new)
{
	s = new;
}
void class_8_3_hash(string &h{int}, int k, string v)
{
	h{k} = v;
}
void class_8_3_arr(int &a[][], int i, int j, int v)
{
	a[i][j] = v;
}
class class_8_3
{
	instance {
		public	string s = "cvar";
		public	string h{int} = { 1=>"one", 2=>"two" };
		public	string a[] = { "zero", "one", "two" };
		public	int aa[][] = { {1,2}, {3,4} };
	}
}
void class_8_3_main()
{
	/*
	 * Note that test class-6.1 checked class variables as
	 * reference parameters.  This test is basically that test but
	 * it checks instance variables instead.
	 */

	class_8_3 o = class_8_3_new();

	unless (o->s eq "cvar") puts("bad 1.1");
	unless (o->h{1} eq "one") puts("bad 1.2");
	unless (o->h{2} eq "two") puts("bad 1.3");
	unless (o->a[0] eq "zero") puts("bad 1.4");
	unless (o->a[1] eq "one") puts("bad 1.5");
	unless (o->a[2] eq "two") puts("bad 1.6");
	unless (o->aa[0][0] == 1) puts("bad 1.10");
	unless (o->aa[0][1] == 2) puts("bad 1.11");
	unless (o->aa[1][0] == 3) puts("bad 1.12");
	unless (o->aa[1][1] == 4) puts("bad 1.13");

	o->s = "new";
	unless (o->s eq "new") puts("bad 2.1");

	o->h = { 3=>"three" };
	unless (o->h{3} eq "three") puts("bad 3.1");
	unless (length(o->h) == 1) puts("bad 3.2");

	o->a = { "just-one" };
	unless (o->a[0] eq "just-one") puts("bad 4.1");
	unless (length(o->a) == 1) puts("bad 4.2");

	o->aa = { {5} };
	unless (o->aa[0][0] == 5) puts("bad 5.1");
	unless (length(o->aa) == 1) puts("bad 5.2");
	unless (length(o->aa[0]) == 1) puts("bad 5.3");

	class_8_3_str(&o->s, "new-s");
	unless (o->s eq "new-s") puts("bad 6.1");

	o->h = {};
	class_8_3_hash(&o->h, 4, "four");
	unless (o->h{4} eq "four") puts("bad 7.1");
	unless (length(o->h) == 1) puts("bad 7.2");
	if (defined(o->h{5})) puts("bad 7.3");

	o->aa = {};
	class_8_3_arr(&o->aa, 0, 0, 11);
	class_8_3_arr(&o->aa, 0, 1, 12);
	class_8_3_arr(&o->aa, 1, 0, 13);
	class_8_3_arr(&o->aa, 1, 1, 14);
	unless (o->aa[0][0] == 11) puts("bad 8.1");
	unless (o->aa[0][1] == 12) puts("bad 8.2");
	unless (o->aa[1][0] == 13) puts("bad 8.3");
	unless (o->aa[1][1] == 14) puts("bad 8.4");
	unless (length(o->aa) == 2) puts("bad 8.5");
	unless (length(o->aa[0]) == 2) puts("bad 8.6");
	unless (length(o->aa[1]) == 2) puts("bad 8.7");
	if (defined(o->aa[2])) puts("bad 8.8");
}
class_8_3_main();
} -output {}

test class-8.4 {check objects in complex variables} -body {
#lang L
class class_8_4_1
{
	instance {
		public	class_8_4_1 o;
		public	string s;
	}
}
class class_8_4_2
{
	instance {
		public	class_8_4_1 o;
		public	string s;
	}
}
void class_8_4_foo(class_8_4_1 &o, string s)
{
	o->s = s;
}
void class_8_4_str(string &s1, string s2)
{
	s1 = s2;
}
void class_8_4_main()
{
	class_8_4_1 a[] = { class_8_4_1_new(), class_8_4_1_new() };
	class_8_4_1 o841 = class_8_4_1_new();
	class_8_4_2 o842 = class_8_4_2_new();

	o841->s = "841";
	o842->s = "842";
	unless ((o841->s eq "841") && (o842->s eq "842")) puts("bad 1.1");

	o841->o = class_8_4_1_new();
	o841->o->s = "841 in 841";
	unless (o841->o->s eq "841 in 841") puts("bad 2.1");

	o842->o = class_8_4_1_new();
	o842->o->s = "841 in 842";
	unless (o842->o->s eq "841 in 842") puts("bad 3.1");

	o842->o->o = class_8_4_1_new();
	o842->o->o->s = "841 in 841 in 842";
	unless (o842->o->o->s eq "841 in 841 in 842") puts("bad 4.1");

	class_8_4_foo(&o842->o->o, "new");
	unless (o842->o->o->s eq "new") puts("bad 5.1");

	class_8_4_1_delete(o841->o);
	class_8_4_1_delete(o841);
	class_8_4_1_delete(o842->o->o);
	class_8_4_1_delete(o842->o);
	class_8_4_2_delete(o842);

	unless (length(a) == 2) puts("bad 10.0");
	a[0]->s = "0-841";
	a[1]->s = "1-841";
	unless (a[0]->s eq "0-841") puts("bad 10.1");
	unless (a[1]->s eq "1-841") puts("bad 10.2");
	a[0]->o = class_8_4_1_new();
	a[0]->o->s = "0-841 in 841";
	unless (a[0]->o->s eq "0-841 in 841") puts("bad 10.3");
	class_8_4_foo(&a[0]->o, "new");
	unless (a[0]->o->s eq "new") puts("bad 10.4");
	class_8_4_str(&a[0]->o->s, "new2");
	unless (a[0]->o->s eq "new2") puts("bad 10.5");
}
class_8_4_main();
} -output {}

test class-8.5 {check objects as reference parameters} -body {
#lang L
class class_8_5
{
	private int n = 0;
	instance { public int num = n++; }
}
void class_8_5_create_1(class_8_5 &o)
{
	o = class_8_5_new();
}
void class_8_5_create_n(class_8_5 &o[], int n)
{
	int	i;

	for (i = 0; i < n; ++i) o[i] = class_8_5_new();
}
void class_8_5_check_n(class_8_5 o[], class_8_5 &oref[], int n)
{
	int	i;

	for (i = 0; i < n; ++i) {
		unless (o[i]->num    == (i+2)) puts("bad chk.1");
		unless (oref[i]->num == (i+2)) puts("bad chk.2");
	}
}
void class_8_5_main()
{
	int	n = 10;
	class_8_5 o1, o2;
	class_8_5 o[];

	class_8_5_create_1(&o1);
	class_8_5_create_1(&o2);
	unless (o1->num == 0) puts("bad 1");
	unless (o2->num == 1) puts("bad 2");
	class_8_5_delete(o1);
	class_8_5_delete(o2);

	class_8_5_create_n(&o, n);
	class_8_5_check_n( o, &o, n);
}
class_8_5_main();
} -output {}

test class-9.1 {check class and instance variables in comma expression} -body {
#lang L
class class_9_1
{
	public	string cvar = "cvar";
	instance {
		public	string ivar = "ivar";
	}
}
void class_9_1_main()
{
	/*
	 * This checks an obscure case to ensure that a class or
	 * instance variable whose value is discarded -- the first
	 * expression in a comma expression -- is compiled properly.
	 * These are run in a loop as a way to check that the
	 * run-time stack remains balanced.
	 */

	int	i;
	int	n = 100;
	class_9_1 o = class_9_1_new();

	for (i = 0; i < n; ++i) {
		unless (class_9_1->cvar,"val" eq "val") puts("bad 1.1");
		unless (o->ivar,"val" eq "val") puts("bad 1.2");
	}
}
class_9_1_main();
} -output {}

test goto-1 {check goto statement} -body {
#lang L
/*
 * Test gotos at global scope.  None of these labels should clash with
 * those in goto_1a() or goto_1b() below.
 */
	goto L1;
	puts("bad");
 L1:	puts("L1");
	goto L2;

/* Now test at proc scope. */
void goto_1a()
{
	int	i;

	/* Use before define. */
	goto L1;
	puts("bad 1");
 L1:	puts("L1");

	/* Use after define. */
	i = 0;
 L2:	if (++i == 2) goto L3;
	puts("L2");
	goto L2;
 L3:	puts("L3");

	/* Multiple uses before define. */
	for (i = 0; i < 4; ++i) {
		if (i == 0) goto L4;
		if (i == 1) goto L4;
		if (i == 2) goto L4;
		if (i == 3) goto L4;
		continue;
	L4:	puts("L4");
	}

	/* Multiple uses after define. */
	for (i = 0; i < 4; ++i) {
		goto L6;
		puts("bad");
	L5:	puts("L5");
		continue;
	L6:	if (i == 0) goto L5;
		if (i == 1) goto L5;
		if (i == 2) goto L5;
		if (i == 3) goto L5;
	}

	/* Multiple labels per statement. */
	for (i = 0; i < 4; ++i) {
		if (i == 0) goto L7;
		if (i == 1) goto L8;
		if (i == 2) goto L9;
		if (i == 3) goto L10;
		continue;
	L7:
	L8:
	L9:
	L10:
		puts("L7-10");
	}

	/* Label without statement. */
	do {
		goto L11;
		puts("bad");
	L11:
	} while(0);

	/* Multiple labels without statement. */
	for (i = 0; i < 4; ++i) {
		if (i == 0) goto L12;
		if (i == 1) goto L13;
		if (i == 2) goto L14;
		puts("i == 3");
	L12:
	L13:
	L14:
	} while(0);

	/*
	 * Label on a single statement (bizarre perhaps, but allowed
	 * by the grammar).
	 */

	goto L15;
	puts("bad");
	while (0) L15: puts("L15");

	goto L16;
	puts("bad");
	do L16: puts("L16"); while(0);

	goto L17;
	puts("bad");
	for (; 0; ) L17: puts("L17");

	goto L18;
	puts("bad");
	for (; 0; 0) L18: puts("L18");

	/* Labels in nested scopes. */

	i = 0;
	goto L19;
	puts("bad");
	do {
		puts("bad");
	L19:	puts("L19");
	} while (0);
	if (i++ == 0) goto L19;

	i = 0;
	goto L20;
	puts("bad");
	do {
		puts("bad");
		do {
			puts("bad");
		L20:	puts("L20");
		}
		while (0);
	} while (0);
	if (i++ == 0) goto L20;

	do {
		goto L21;  // jump out of the scope
		puts("bad");
	} while (0);
 L21:	puts("L21");
}
void goto_1b()
{
	/*
	 * Goto labels should be per proc scope, so none of these labels
	 * should clash with those in goto_1a().
	 */

	goto L1;
	puts("bad");
 L1:	puts("L1");
}
L2:
goto_1a();
goto_1b();
} -output {L1
L1
L2
L3
L4
L4
L4
L4
L5
L5
L5
L5
L7-10
L7-10
L7-10
L7-10
i == 3
L15
L16
L17
L18
L19
L19
L20
L20
L21
L1
}

test goto-2 {check gotos with labels in enclosing scopes} -body {
#lang L
goto L1;
L2: puts("global L2");
return;
void goto_2()
{
	goto L2;  // should go to goto_2()'s L2, NOT the L2 at global scope
	puts("bad");
 L2:	puts("L2");
}
L1:
goto_2();
goto L2;  // should go to the L2 at global scope, NOT goto_2()'s L2
} -output {L2
global L2
}

test goto-3 {check goto statement errors} -body {
#lang L
void goto_3()
{
	goto L1;
 L1:
 L1:
 L2:
 L2:
 L2:

 L3:
	do {
	L3:
	} while (0);

	goto L4;
	goto L6;  // error even though an L6 is defined at global scope
}
goto L5;
L6:
} -returnCodes error -match regexp -result {.*: L Error: label L1 already defined
.*: L Error: label L2 already defined
.*: L Error: label L3 already defined
.*: L Error: label L4 referenced but not defined
.*: L Error: label L6 referenced but not defined
.*: L Error: label L5 referenced but not defined
}

::tcltest::cleanupTests
return
