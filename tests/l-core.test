# Test the L language.
# Copyright (c) 2007 BitMover, Inc.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
    testConstraint exec [llength [info commands exec]]
}

test lfile-1.0 {Test autowrapping of empty .l file} -setup {
	set fname [makeFile {} lfile-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.0.l
} -result {}

test lfile-1.1 {Test autowrapping of .l works} -setup {
	set fname [makeFile {
		void main() {
			printf("hi mom\n");
		}
	} lfile-1.1.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.1.l
} -result {hi mom}

# main shouldn't be automatically called if within an .l file we find
# the #lang L directive... right?
test lfile-1.2 {Test autowrapping doesn't wrap twice} -setup {
	set fname [makeFile {#lang L -nowarn
		void main(int ac, string av[]) {
			printf("hi dad\n");
		}
	} lfile-1.2.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile lfile-1.2.l
} -result {}

test parse-1.0 {Test parsing an empty L script} -body {
#lang L
}

test parse-1.1 {Test parsing an L script that's just white space} -body {
#lang L
	


}

test parse-1.2 {Test parsing an empty L file} -setup {
	set fName [makeFile {} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.3 {Test parsing an L file that just has whitespace} -setup {
	set fName [makeFile {



	} LFileTest]
} -constraints {
	exec
} -body {
	exec [interpreter] $fName
} -cleanup {
	removeFile LFileTest
} -result {}

test parse-1.4 {parse an L function named by a pattern} -body {
#lang L
poly Parse14Pattern_*(int a, ...rest)
{
	puts("${$1}${a}${rest}");
}
#lang tcl
} -result {}

test parse-1.5 {test handling of illegal character} -body {
#lang L
?
} -returnCodes error -match regexp -result {.*1: L Error: illegal character '\?'
}

test proc-1.0 {Test L function definition.} -body {
#lang L
void proc_1_0(void) {
        puts("foo");
}
#lang tcl
proc_1_0
} -output "foo\n"


test proc-1.1 {Test L function returns.} -body {
#lang L
void proc_1_1_f1() {
        puts("whiz");
}
string proc_1_1_f2() {
        puts("bang");
        return "foo";
        return "bar";
}
void proc_1_1_f3() {
        return;
}
void proc_1_1(void) {
        puts(proc_1_1_f1());
        puts(proc_1_1_f2());
        puts(proc_1_1_f3());
}
#lang tcl
proc_1_1
} -output "whiz\n\nbang\nfoo\n\n"

test proc-1.2 {Test L function parameters.} -body {
#lang L
void proc_1_2(string arg1, string arg2) {
        puts(arg1);
        puts(arg2);
} 
#lang tcl
proc_1_2 "val1" "val2" 
} -output "val1\nval2\n"

test proc-1.3 {Test variable arity functions} -body {
#lang L
string proc_1_3_foo(...stuff) {
	int i;
	for (i=0; defined(stuff[i]); i++) {
		printf("%s ", stuff[i]);
	}
	printf("\n");
}
string proc_1_3_bar(int a, ...stuff) {
	puts(a);
	puts(stuff);
}
void proc_1_3() {
	proc_1_3_foo("a", "b", "c", "d");
	proc_1_3_foo();
	proc_1_3_bar(1, 2, 3, 4);
	proc_1_3_bar(1);
}
#lang tcl
proc_1_3
} -output "a b c d \n\n1\n2 3 4\n1\n\n"

test proc-1.4 {Ensure rest parameter comes last} -body {
#lang L -nowarn
void proc_1_4(int a, ...b, int c) {
	puts("oops");
}
#lang tcl
proc_1_4
} -returnCodes {error} -match glob -result "*:1: L Error: Rest parameter must be last\n"


test var-1.0 {Test L variable assignment and reference} -body {
#lang L
void var_1_0(void)
{
	string s;
        s = "Hello";
	puts(s);
}
#lang tcl
var_1_0
} -output "Hello\n"

test var-1.1 {L global variables} -body {
#lang L
int lglobal1_1 = 1;
void var_1_1(void)
{
        puts(lglobal1_1);
}
#lang tcl
var_1_1
} -output "1\n"


test var-1.2 {L global variables, harder} -body {
#lang L
int lglobal1_2 = 3;
void var_1_2(void)
{
        puts(lglobal1_2);
        lglobal1_2 = 4;
        var_1_2_aux();
        puts(lglobal1_2);
}

void var_1_2_aux()
{
        puts(lglobal1_2);
        lglobal1_2 = 5;
}
#lang tcl
var_1_2
} -output "3\n4\n5\n"

test var-1.3 {A global array of structs} -body {
#lang L

struct var_1_3_point { int x, y; };
struct var_1_3_point lglobal1_3[5];

void var_1_3(void)
{
        int i = 0;

        puts(lglobal1_3);
        while (i < 5) {
          lglobal1_3[i].x = i * 10;
          lglobal1_3[i].y = i * 20;
          i++;
        }
        puts(lglobal1_3);
        var_1_3_aux(3);
        puts(lglobal1_3);
}

void var_1_3_aux(int i)
{
        lglobal1_3[i].x = i * 35;
        lglobal1_3[i].y = i * 45;
}
#lang tcl
var_1_3
} -output "
{0 0} {10 20} {20 40} {30 60} {40 80}
{0 0} {10 20} {20 40} {105 135} {40 80}
"

test var-1.4 {Test extern variables} -body {
set tclvar "this is an extern variable"
#lang L
extern string tclvar;
void var_1_4()
{
	puts(tclvar);
}
#lang tcl
var_1_4
} -output "this is an extern variable\n"

test var-1.5 {Variable function names} -body {
#lang L
void var_1_5() {
  string printfvar = "printf";
  printfvar("Earth calling printf\n");
}
#lang tcl
var_1_5
} -output "Earth calling printf\n"

test lang-1.0 {Test lang parsing} -body {
# These are some Tcl Comments
#lang L
void lang_1_0(void)
{
	puts("worked");
}

#lang tcl
# More comments
lang_1_0
} -output "worked\n"

test lang-2.0 {Test failure path in lang parsing} -body {
#lang(foo)
void lang_2_0(void)
{
	puts("worked");
}

#lang tcl
lang_2_0
} -returnCodes {error} -result {malformed pragma}

# no output because we're not calling any functions
test lang-3.0 {Test not switching back to Tcl} -body {
#lang L
void lang_3_0(void)
{
	puts("worked");
}
}

test decl-1.0 {Variable and parameter declaration syntax} -body {
#lang L -nowarn
void decl_1_0_fun1() { }
void decl_1_0_fun2(void) { }
void decl_1_0_fun3() { }
int fdecl_1_0_un4() { }
void decl_1_0_fun5(int foo) { }
hash decl_1_0_fun6(hash foo, hash bar[], hash baz[23]) { }
void decl_1_0_fun7(int foo, float bar, hash baz, string quux, poly quuux, var quuuux) { }
void decl_1_0_fun8() {
        int foo, bar[], baz[84][42][1];
        string foo1[19], mani[], padmi = "hum";
        hash whee;
        if (0) {
                int bleh = 5;
        } else {
                if (1) {
                        poly padmi1 = "om";
                        puts(padmi1);
                }
        }
}
#lang tcl
decl_1_0_fun8
} -output "om\n";

test decl-1.1 {Hairy literal hash syntax in initializers} -body {
#lang L -nowarn
void initmewoo() {
        hash h = { "key" => "val", "key2" => "val" };
}
#lang tcl
}

test decl-1.2 {Undeclared variable error} -body {
#lang L
void decl_1_2_undecl() {
        foo = "bar";
        puts(cheese);
}
#lang tcl
decl_1_2_undecl
} -returnCodes error -match glob -result {*L Error: undeclared variable: foo
*L Error: undeclared variable: cheese
}

test decl-1.3 {Variable shadowing} -body {
#lang L
void decl_1_3_shadow() {
        int foo = 1;
        if (1) {
                int foo = 2;
                puts(foo);
        } 
        puts(foo);
}
#lang tcl
decl_1_3_shadow
} -returnCodes error -match glob -result {*L Error: multiple declaration of local foo
}

test decl-1.4 {Single dimensional initializers actually initialize} -body {
#lang L
void decl_1_4 () {
  int foo[] = {4, 5, 6};
  hash bar = {"foo" => 4, "bar" => 5, "baz" => 6};
  struct { int x; int y; } point = { 1024, 768 };

  printf("%s\n", foo);
  printf("%s\n", bar);
  printf("%s\n", point);
}
#lang tcl
decl_1_4
} -output "4 5 6\nfoo 4 bar 5 baz 6\n1024 768\n"

# Test decl-1.5 removed.

test decl-1.6 {Check scoping rule errors for globals and externs} -body {
#lang L
/*
 * The L scoping rules are as follows:
 *
 * - A name multiply declared at the global scope is illegal.
 * - A name multiply declared in a local scope or any enclosing scopes
 *   is illegal.
 * - A local name hides a global of the same name.
 * - A name is not visible outside the scope in which it is declared.
 * - A name is not visible in a scope before it is declared.
 *
 * This test checks the error cases.
 */
int decl_1_6_g1 = decl_1_6_g2;  // error -- g2 used before being declared
int decl_1_6_g2;
void foo_decl_1_6()
{
	decl_1_6_g3 = 1;  // error -- g3 used before being declared
}
int decl_1_6_g3;
void decl_1_6()
{
	int	l;
	int	l;  // error -- name already declared locally
	puts(decl_1_6_extern);  // error -- extern not yet declared
	if (1) {
		if (1) {
			int decl_1_6_extern;
			decl_1_6_extern = 3;
		}
	}
	if (1) {
		int	l2;
		int	l;  // error -- name already declared locally
		if (1) {
			int	l2;  // error -- name already declared locally
		}
	}
}
extern int decl_1_6_extern;
extern int decl_1_6_extern;  // error -- multiply declared at global scope
int decl_1_6_g2;  // error -- multiply declared at global scope
void decl_1_6_bad()
{
	extern int decl_1_6_g;  // error -- externs illegal in local scopes
}
} -returnCodes error -match regexp -result {.*13: L Error: undeclared variable: decl_1_6_g2
.*17: L Error: undeclared variable: decl_1_6_g3
.*23: L Error: multiple declaration of local l
.*24: L Error: undeclared variable: decl_1_6_extern
.*33: L Error: multiple declaration of local l
.*35: L Error: multiple declaration of local l2
.*40: L Error: multiple declaration of global decl_1_6_extern
.*41: L Error: multiple declaration of global decl_1_6_g2
.*44: L Error: externs illegal in local scopes
}

test decl-1.7 {Check scoping rules for globals and externs} -body {
#lang L
/*
 * This test checks the non-error cases of the scoping rules described
 * above.
 */
extern string decl_1_7_extern;
string decl_1_7_g1;
string decl_1_7_g2 = "g2";
string decl_1_7_g3;
void decl_1_7()
{
	string	s = decl_1_7_g2;  // read the global
	string	decl_1_7_g2 = "g2local"; // now shadow the global

	unless (s eq "g2") puts("bad 1");
	unless (decl_1_7_g2 eq "g2local") puts("bad 2");

	decl_1_7_extern = "ex";
	unless (decl_1_7_extern eq "ex") puts("bad 3");

	decl_1_7_g1 = "g1";
	unless (decl_1_7_g1 eq "g1") puts("bad 4");

	if (1) {
		string	decl_1_7_g1;  // shadow a global, already referenced
		string	decl_1_7_g3;  // shadow a global, not yet referenced
		decl_1_7_g1 = "local1";   // sets the local
		decl_1_7_g3 = "local3";   // sets the local
		unless (decl_1_7_g1 eq "local1") puts("bad 5");
		unless (decl_1_7_g3 eq "local3") puts("bad 6");
	}
	unless (decl_1_7_g1 eq "g1") puts("bad 7");
}
#lang tcl
decl_1_7
} -output ""

test decl-1.8 {Check illegal variable names} -body {
#lang L
void _decl_1_8()  // err -- function names cannot begin with _
{
	int	_bad;  // err -- locals cannot begin with _
}
} -returnCodes error -match regexp -result {.*1: L Error: function names cannot begin with _
.*3: L Error: local variable names cannot begin with _
}

test decl-1.9 {Check mixing types on single decl line} -body {
#lang L
void decl_1_9() {
	/*
	 * This is a regression test.  L used to get the types wrong.
	 * This just checks that the compiler issues no type errors.
	 */
	string	h1{int}, s1;
	string	s2;
	string	h2{int};

	s1 = s2;
	h1 = h2;
	s1 = "s1";
	s2 = "s2";
	h1{1} = "one";
	h2{1} = "one";
}
#lang tcl
decl_1_9
} -output {}

test decl-1.10 {multiple declaration of main in same script disallowed} -body {
#lang L
void main()
{
}
void main()
{
}
void main()
{
}
} -returnCodes error -match regexp -result {.*4: L Error: redeclaration of main
.*7: L Error: redeclaration of main
}

test if-1.0 {If statements} -body {
#lang L
void if_1_0() {
        if (1) puts("0 working");
        if (0) {
                puts("1 broken");
        } 
        puts("between");
        if (1) {
                puts("1 working");
        } 
}
#lang tcl
if_1_0
} -output "0 working\nbetween\n1 working\n"


test if-1.1 {If statements with else clauses and multistatement bodies} -body {
#lang L
void if_1_1() {
        if (1) {
                puts("1 working");
                puts(".");
        } else {
                puts("1 broken");
                puts(".");
        }
        
        if (0) {
                puts("2 broken");
                puts(".");
                puts(".");
        } else {
                puts("2 working");
                puts(".");
                puts(".");
        }
}
#lang tcl
if_1_1
} -output "1 working\n.\n2 working\n.\n.\n"


test if-1.2 {"else if" clauses} -body {
#lang L
void if_1_2() {
        if (0) {
                puts("1 broken");
        } else if (1) {
                puts("1 working");
        }

        puts("between");

        if (0) {
                puts("2 broken");
        } else if (0) {
                puts("2.2 broken");
        } else {
                puts("2 working");
        }
}
#lang tcl
if_1_2
} -output "1 working\nbetween\n2 working\n"

test if-1.3 {nested if statements} -body {
#lang L
void if_1_3() {
        if (1) {
                puts("1 before");
                if (0) {
                        puts("1 broken");
                } else {
                        puts("1 working");
                }
                puts("1 after");
        } else {
                puts("1.1 broken");
        }
        puts("1 done");
}
#lang tcl
if_1_3
} -output "1 before\n1 working\n1 after\n1 done\n"


test if-1.4 {else is only allowed with curly braces} -body {
#lang L
void if_1_4(void)
{
	if (0) puts("1 broken"); else puts("1 even more broken");
}
#lang tcl
} -returnCodes error -match glob -result "*3: L Error: syntax error, unexpected T_ELSE\n"


test unless-1.0 {unless statements} -body {
#lang L
void unless_1_0() {
        unless(0) puts("0 working");
        unless(0) {
                puts("1 working");
        }
        unless(1) {
                puts("2 broken");
        } else {
                puts("2 working");
        }
        unless(1) {
                puts("3 broken");
        } else unless (1) {
                puts("3.1 broken");
        } else {
                puts("3 working");
        }
} 
#lang tcl
unless_1_0
} -output "0 working\n1 working\n2 working\n3 working\n"

test unless-1.1 {unless and if statements mixed} -body {
#lang L
void unless_1_1() {
        unless(1) {
                puts("1 broken");
        } else if (0) {
                puts("1.1 broken");
        } else unless(0) {
                puts("1 working");
        }
        puts("done");
} 
#lang tcl
unless_1_1
} -output "1 working\ndone\n"

test return-1.1 {return from void function allowed} -body {
#lang L
void return_1_1() { return; }
} -returnCodes normal

test return-1.2 {returning int from void function disallowed} -body {
#lang L
void return_1_2() { return 0; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.3 {returning string from void function disallowed} -body {
#lang L
void return_1_3() { return "str"; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.4 {returning float from void function disallowed} -body {
#lang L
void return_1_4() { return 2.99792458; }
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.5 {returning array from void function disallowed} -body {
#lang L
void return_1_5() {
	int	a[3];
	return a;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.6 {returning hash from void function disallowed} -body {
#lang L
void return_1_6() {
	hash	h;
	return h;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.7 {returning struct from void function disallowed} -body {
#lang L
void return_1_7() {
	struct { int x,y; } s;
	return s;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.8 {returning poly from void function disallowed} -body {
#lang L
void return_1_8() {
	poly	p;
	return p;
}
} -returnCodes error -match regexp -result ".*void function cannot return value"

test return-1.9 {return from global scope illegal} -body {
#lang L
return;
} -returnCodes error -match regexp -result ".*return from global scope illegal"

test return-2.1 {int return value from int function allowed} -body {
#lang L
int return_2_1_f() { return 123; }
unless (return_2_1_f() == 123) printf("BAD\n");
} -output ""

test return-2.2 {float return value from float function allowed} -body {
#lang L
float return_2_2_f() { return 123.456; }
unless (return_2_2_f() == 123.456) printf("BAD\n");
} -output ""

test return-2.3 {string return value from string function allowed} -body {
#lang L
string return_2_3_f() { return "str"; }
unless (return_2_3_f() eq "str") printf("BAD\n");
} -output ""

test return-2.4 {array return value from array function allowed} -body {
#lang L
int[] return_2_4_f()
{
	int	a[3] = {2,3,5};
	return a;
}
void return_2_4()
{
	int res[] = return_2_4_f();
	unless ((res[0] == 2) && (res[1] == 3) && (res[2] == 5)) {
		printf("BAD\n");
	}
}
#lang tcl
return_2_4
} -output ""

test return-2.5 {hash return value from hash function allowed} -body {
#lang L
hash return_2_5_f()
{
	hash	h;
	h{"one"} = 1;
	h{"two"} = 2;
	h{"ten"} = 10;
	return h;
}
void return_2_5()
{
	hash res = return_2_5_f();
	unless ((res{"one"} == 1) && (res{"two"} == 2) && (res{"ten"} == 10)) {
		printf("BAD\n");
	}
}
#lang tcl
return_2_5
} -output ""

test return-2.6 {struct return value from struct function allowed} -body {
#lang L
struct return_2_6_s {
	int x, y, z;
};
struct return_2_6_s return_2_6_f()
{
	struct return_2_6_s s;
	s.x = 1;
	s.y = 2;
	s.z = 3;
	return s;
}
void return_2_6()
{
	struct return_2_6_s res = return_2_6_f();
	unless ((res.x == 1) && (res.y == 2) && (res.z == 3)) printf("BAD\n");
}
#lang tcl
return_2_6
} -output ""

# Spot-check some of the type-checking cases to ensure that return-value
# type checking is being done.  Do not check all possible permutations.

test return-3.1 {int return value from string function disallowed} -body {
#lang L
string return_3_1() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.2 {float return value from string function disallowed} -body {
#lang L
string return_3_2() { return 1.2; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.3 {int return value from hash function disallowed} -body {
#lang L
hash return_3_3() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.4 {array return value from hash function disallowed} -body {
#lang L
hash return_3_4() { int a[3]; return a; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.5 {int return value from struct function disallowed} -body {
#lang L
struct s35 {
	int x, y;
};
struct s35 return_3_5() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.6 {hash return value from struct function disallowed} -body {
#lang L
struct s36 {
	int x, y;
};
struct s36 return_3_6() { hash h; return h; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.7 {int return value from array function disallowed} -body {
#lang L
int[] return_3_7() { return 1; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.8 {struct return value from array function disallowed} -body {
#lang L
struct s38 {
	int x, y;
};
int[] return_3_8() { struct s38 s; return s; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test return-3.9 {hash return value from array function disallowed} -body {
#lang L
int[] return_3_9() { hash h; return h; }
} -returnCodes error -match regexp -result ".*incompatible return type"

test syntax-1.0 {single-line comments a la C++} -body {
#lang L
void syntax_1_0() {
        // single-line comments are 
        puts("working"); //see?
        //////cruftilioucious 
}
#lang tcl
syntax_1_0
} -output "working\n" 


test syntax-1.1 {structure syntax} -body {
#lang L -nowarn

struct syntax_1_1_point {
        int x, y;
        string label;
        float froboz[128];
        struct { int m, n; } sub_struct;
};

void syntax_1_1() {
        struct { string firstname; string lastname; } him;
        struct { string firstname; string lastname; } me = {"john", "doe"};
        struct syntax_1_1_point p1, p2 = {
	       1, 2, "label", {1.0}, {1,2} } , p3;
        puts("didn't crash");
}

#lang tcl
syntax_1_1
} -output "didn't crash\n"

test syntax-1.2 {interpolated strings} -body {
#lang L

void syntax_1_2() {
        int i = 1, j = 2;
        string m = "ASDF";

        puts("syntax_${ i + j - 2 }_${j}.");
        puts("foo ${"bar ${m} baz"} zot");
}

#lang tcl
syntax_1_2
} -output "syntax_1_2.\nfoo bar ASDF baz zot\n"

test syntax-1.3 {keywords} -body {
#lang L
void syntax_1_3() {
	printf("%s, %s, %s\n", foo : "bar", baz:);
}
#lang tcl
syntax_1_3
} -output "-foo, bar, -baz\n"

test syntax-1.4 {string appendation} -body {
#lang L
void syntax_1_4() {
	printf("these" "strings"
	    "stick" "together.\n");
}
#lang tcl
syntax_1_4
} -output "thesestringssticktogether.\n"

test op-1.0 {increment and decrement operators} -body {
#lang L
void op_1_0() {
        int i = 1;

        puts("pre:");
        puts(i);
        ++i;
        puts(i);
        puts(++i);
        --i;
        puts(i);
        puts(--i);

        puts("post:");
        puts(i);
        i++;
        puts(i);
        puts(i++);
        puts(i);
        i--;
        puts(i);
        puts(i--);
        puts(i);
}
#lang tcl
op_1_0
} -output "pre:\n1\n2\n3\n2\n1\npost:\n1\n2\n2\n3\n2\n2\n1\n"

test op-1.1 {plus, minus, multiply, divide, and modulus operators} -body {
#lang L
void op_1_1() {
        int i = 2;
        puts(i + 5);
        puts(i - 50);
        puts(i * 500);
        puts(i / 2);
        puts(i / 4.0);
        puts((i + 5) % 3);
        // precedence
        puts(i + i / i - i * i % i);
}
#lang tcl
op_1_1
} -output "7\n-48\n1000\n1\n0.5\n1\n3\n"

test op-1.2 {unary plus and minus} -body {
#lang L
void op_1_2() {
        int i = -2;
        int j = +2;

        puts(i);
        i = i + -100;
        puts(i);
        puts(i * -3);
        puts(-8 - -2);

        puts(j);
        j = j + +100;
        puts(j);
        puts(j * +3);
        puts(+8 - +2);
}
#lang tcl
op_1_2
} -output "-2\n-102\n306\n-6\n2\n102\n306\n6\n"

test op-1.3 {numeric comparison operators} -body {
#lang L
void op_1_3() {
        if (-1 < 1) { puts("1okay"); } else { puts("1broken"); }
        if (1 > -1) { puts("2okay"); } else { puts("2broken"); }
        if (1 == 1) { puts("3okay"); } else { puts("3broken"); }
        if (1 <= 1) { puts("4okay"); } else { puts("4broken"); }
        if (-1 <= 1) { puts("5okay"); } else { puts("5broken"); }
        if (1 >= -1) { puts("6okay"); } else { puts("6broken"); }
        if (1 >= 0) { puts("7okay"); } else { puts("7broken"); }
        if (0 != 1) { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if (1 < 1) { puts("1broken"); } else { puts("1okay"); }
        if (1 > 1) { puts("2broken"); } else { puts("2okay"); }
        if (1 == 0) { puts("3broken"); } else { puts("3okay"); }
        if (1 != 1) { puts("4broken"); } else { puts("4okay"); }
        if (1 <= -1) { puts("5broken"); } else { puts("5okay"); }
        if (-1 >= 1) { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_3
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"

test op-1.4 {lexicographic comparison operators} -body {
#lang L
void op_1_4() {
        if ("aa" lt "ab") { puts("1okay"); } else { puts("1broken"); }
        if ("ab" gt "aa") { puts("2okay"); } else { puts("2broken"); }
        if ("aa" eq "aa") { puts("3okay"); } else { puts("3broken"); }
        if ("aa" le "aa") { puts("4okay"); } else { puts("4broken"); }
        if ("aa" le "ab") { puts("5okay"); } else { puts("5broken"); }
        if ("aa" ge "aa") { puts("6okay"); } else { puts("6broken"); }
        if ("ab" ge "aa") { puts("7okay"); } else { puts("7broken"); }
        if ("aa" ne "ab") { puts("8okay"); } else { puts("8broken"); }
        // now from the other side
        puts("--");
        if ("aa" lt "aa") { puts("1broken"); } else { puts("1okay"); }
        if ("aa" gt "aa") { puts("2broken"); } else { puts("2okay"); }
        if ("ab" eq "aa") { puts("3broken"); } else { puts("3okay"); }
        if ("aa" ne "aa") { puts("4broken"); } else { puts("4okay"); }
        if ("ab" le "aa") { puts("5broken"); } else { puts("5okay"); }
        if ("aa" ge "ab") { puts("6broken"); } else { puts("6okay"); }

}
#lang tcl
op_1_4
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n7okay\n8okay
--\n1okay\n2okay\n3okay\n4okay\n5okay\n6okay\n"


test op-1.5 {boolean operators} -body {
#lang L
void op_1_5() {
        int true = 1, false = 0;
        if (true && true)       { puts("1okay"); } else { puts("1broken"); }
        if (!false)             { puts("2okay"); } else { puts("2broken"); }
        if (false || true)      { puts("3okay"); } else { puts("3broken"); }
        if (true && !false)     { puts("4okay"); } else { puts("4broken"); }
        // && has higher precedence than ||
        if (false && false || true) { puts("5okay"); } else { puts("5broken"); }
        // now from the other side
        puts("--");
        if (true && !true)      { puts("1broken"); } else { puts("1okay"); }
        if (false || false)     { puts("2broken"); } else { puts("2okay"); }
        if (!true)              { puts("3broken"); } else { puts("3okay"); }

}
#lang tcl
op_1_5
} -output "1okay\n2okay\n3okay\n4okay\n5okay\n--\n1okay\n2okay\n3okay\n"


test op-1.6 {bitwise operators} -body {
#lang L
void op_1_6(){
        int bits = 715827882;

        puts(bits << 1);
        puts(bits >> 1);
        puts(bits >> 29);
        puts(-1 << 10);
        puts(-1024 >> 9);
        puts(~bits);
        puts(bits & ~bits);
        puts(bits | ~bits);
        puts(bits ^ (bits + 1));

}
#lang tcl
op_1_6
} -output "1431655764\n357913941\n1\n-1024\n-2\n-715827883\n0\n-1\n1\n"


test op-1.7 {logical operator short-circuiting} -body {
#lang L
int
puts_int(string str) {
        puts(str);
        return 9;
}
void op_1_7(){
        puts(0 && puts_int("1"));
        puts(1 && puts_int("2"));
        puts(0 || puts_int("3"));
        puts(1 || puts_int("4"));
}
#lang tcl
op_1_7
} -output "0\n2\n9\n3\n9\n1\n"

test op-1.8 {compound assignment operators, simple lvalues} -body {
#lang L
void op_1_8() {
  int foo;

  puts(foo += 2);
  puts(foo);
  puts(foo -= 3);
  puts(foo);
  puts(foo *= 4);
  puts(foo);
  puts(foo /= -2);
  puts(foo);
  foo = 17;
  puts(foo %= 7);
  puts(foo);
  puts(foo |= 9);
  puts(foo);
  puts(foo &= 8);
  puts(foo);
  puts(foo ^= 9);
  puts(foo);
  puts(foo <<= 3);
  puts(foo);
  puts(foo >>= 2);
  puts(foo);
}
#lang tcl
op_1_8
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n"

test op-1.9 {compound assignment operators, array lvalues} -body {
#lang L
void op_1_9() {
  int foo[4] = {0,0,0,0};

  puts(foo[2] += 2);
  puts(foo[2]);
  puts(foo[2] -= 3);
  puts(foo[2]);
  puts(foo[2] *= 4);
  puts(foo[2]);
  puts(foo[2] /= -2);
  puts(foo[2]);
  foo[2] = 17;
  puts(foo[2] %= 7);
  puts(foo[2]);
  puts(foo[2] |= 9);
  puts(foo[2]);
  puts(foo[2] &= 8);
  puts(foo[2]);
  puts(foo[2] ^= 9);
  puts(foo[2]);
  puts(foo[2] <<= 3);
  puts(foo[2]);
  puts(foo[2] >>= 2);
  puts(foo[2]);
  puts(foo);
}
#lang tcl
op_1_9
} -output "2\n2\n-1\n-1\n-4\n-4\n2\n2\n3\n3\n11\n11\n8\n8\n1\n1\n8\n8\n2\n2\n0 0 2 0\n"

test op-1.10 {short-circuit conditionals} -body {
#lang L
void op_1_10()
{
	/*
	 * Ensure that conditionals of type string are tested properly
	 * in the short-circuited operators (i.e., tested against "0").
	 */

	int	i = 0, j;

	if ("0" && ++i) j = 1;
	unless (i == 0) puts("bad 1");

	if ("0" || ++i) j = 1;
	unless (i == 1) puts("bad 2");
}
#lang tcl
op_1_10
} -output {}

test op-1.11 {comma operator} -body {
#lang L -nowarn
int op_1_11_f(int a, int b, int c) { return (b); }
string op_1_11_s(string a, string b, string c, string d)
{
	return ((string)concat(a,b,c,d));
}
void op_1_11()
{
	/*
	 * Check precedence and associativity of comma operator.
	 * Should be the lowest and left associative, and not get
	 * confused with comma as an arg seperator.  Also check that
	 * the value of a,b is b.
	 */

	int	i;
	int	j = 2, k;  // declares j & k; is not a comma op
	int	l = (1,2), m = (1,2,3,4,5);
	string	s;

	unless ((j == 2) && (k == 0)) puts("bad d1");
	unless (l == 2) puts("bad d2");
	unless (m == 5) puts("bad d3");

	i = 1,2;
	unless (i == 1) puts("bad 1");
	unless ((i = 1,2) == 2) puts("bad 2");
	unless (op_1_11_f(1, 2, 3) == 2) puts("bad 3");
	unless (op_1_11_f(1, (2,3), 4) == 3) puts("bad 4");
	unless (op_1_11_s("a", "b", kw:"d") eq "a b -kw d") puts("bad 5");
	unless (op_1_11_s("a", kw:"b", "c") eq "a -kw b c") puts("bad 6");
	unless (op_1_11_s(kw:"a", "b", "c") eq "-kw a b c") puts("bad 7");
	unless (op_1_11_s("a", ("b","c"), kw: "d") eq "a c -kw d") {
		puts("bad 8");
	}

	i = (1,2,3);
	unless (i == 3) puts("bad 10");
	i = (1,2,3,4);
	unless (i == 4) puts("bad 11");
	i = (1,2),(3,4);
	unless (i == 2) puts("bad 12");
	i = ((1,2),(3,4));
	unless (i == 4) puts("bad 13");

	/*
	 * Check that the type of a,b is the type of b.
	 */
	i = ("s", 11);
	unless (i == 11) puts("bad t1");
	s = (1, "s");
	unless (s eq "s") puts("bad t2");

	/*
	 * For loops should just automatically get the use of comma op.
	 */
	i = j = -1;
	for (i=0,j=10; i < 10; ++i,j+=10) ;
	unless ((i == 10) && (j == 110)) puts("bad f1");

	/*
	 * Check that the grammar's special switching of the scanner
	 * to/from a regexp for the split built-in, which happens just
	 * before the comma after the first arg is scanned, works when
	 * the comma operator is present.
	 */
	unless (split("a b c", / /)[1] eq "b") puts("bad s1");
	unless (split("a b c")[1] eq "b") puts("bad s2");
	unless (split(("x y z","a b c"), / /)[1] eq "b") puts("bad s3");
	unless (split(("x y z","a b c"))[1] eq "b") puts("bad s4");
}
#lang tcl
op_1_11
} -output {}

test cast-1.0 { Casts to integer and float } -body {
#lang L
void cast_1_0() {
    printf("%d\n", (int)1.9);
    printf("%f\n", (float)5);
}
#lang tcl
cast_1_0
} -output "1\n5.000000\n"

test cast-1.1 { Invalid cast from string to int } -body {
#lang L
void cast_1_1() {
    printf("%d\n", (int)"asdf");
}
#lang tcl
cast_1_1
} -returnCodes {error} -result {expected number but got "asdf"}

test cast-1.2 { Invalid cast from string to float } -body {
#lang L
void cast_1_2() {
    printf("%f\n", (float)"asdf");
}
#lang tcl
cast_1_2
} -returnCodes {error} -result {expected floating-point number but got "asdf"}

test cast-1.3 { Cast to string } -body {
#lang L
void cast_1_3()
{
	string	s;
	widget	w = "w";
	poly	p = "p";
	int	a[] = { 1, 2 };
	int	h{string} = { "a"=>1, "b"=>2 };
	struct { int i,j; } st = { 5, 6 };

	/* This checks not only cast functionality but also type checking. */

	s = (string)1;
	unless (s eq "1") puts("bad 1");

	s = (string)3.14159;
	unless (s =~ /3.14159/) puts("bad 2");

	s = (string)"ok";
	unless (s eq "ok") puts("bad 3");

	s = (string)w;
	unless (s eq "w") puts("bad 4");

	s = (string)a;
	unless (s eq "1 2") puts("bad 5");

	s = (string)h;
	unless (s eq "a 1 b 2") puts("bad 6");

	s = (string)st;
	unless (s eq "5 6") puts("bad 7");

	s = (string)p;
	unless (s eq "p") puts("bad 8");
}
#lang tcl
cast_1_3
} -output {}

test cast-1.4 { Invalid cast from function } -body {
#lang L
void cast_1_4()
{
	int	i;
	float	f;
	string	s;
	widget	w;
	int	h{string};

	i = (int)cast_1_4;
	f = (float)cast_1_4;
	s = (string)cast_1_4;
	s = (tcl)cast_1_4;
	w = (widget)cast_1_4;
	h = (hash)cast_1_4;
}
#lang tcl
cast_1_4
} -returnCodes {error} -match regexp -result {.*9: L Error: type function illegal
.*10: L Error: type function illegal
.*11: L Error: type function illegal
.*12: L Error: type function illegal
.*13: L Error: type function illegal
.*14: L Error: type function illegal
}

test cast-1.5 {cast to hash} -body {
#lang L
void cast_1_5()
{
	int	n = 0;
	string	k;
	string	a[] = { "k1","v1", "k2","v2", "k3","v3" };
	poly	h{poly};

	h = (hash)a;
	unless (h{"k1"} eq "v1") puts("bad 1");
	unless (h{"k2"} eq "v2") puts("bad 2");
	unless (h{"k3"} eq "v3") puts("bad 3");
	foreach (k in h) ++n;
	unless (n == 3) puts("bad 4");
}
#lang tcl
cast_1_5
} -output {}

test cast-1.6 {cast to various structured types} -body {
#lang L
struct s {
	int	i;
	string	s;
	struct {
		string	h{int};
		int	i;
	} st;
};
void cast_1_6()
{
	struct s	st;
	int		a[], i, n;
	string		h{int};

	/* Cast a string to a struct s. */
	st = (struct s)"1 str { { 1 one 2 two } 33 }";
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 1");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 2");
	unless (st.st.i == 33) puts("bad 3");

	/* Same as above except casting from a composite constant. */
	st = (struct s) {
			  1,
			  "str",
			  {
				  { 1=>"one", 2=>"two" },
				  33
			  }
	};
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 4");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 5");
	unless (st.st.i == 33) puts("bad 6");

	/* Cast a string to a struct s but spell out the entire struct type. */
	st = (struct { int i; string s; struct { string h{int}; int i; } st; })
		"1 str { { 1 one 2 two } 33 }";
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 7");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 8");
	unless (st.st.i == 33) puts("bad 9");

	/* Same as above except casting from a composite constant. */
	st = (struct { int i; string s; struct { string h{int}; int i; } st; })
		{
			  1,
			  "str",
			  {
				  { 1=>"one", 2=>"two" },
				  33
			  }
		};
	unless ((st.i == 1) && (st.s eq "str")) puts("bad 10");
	unless ((st.st.h{1} eq "one") && (st.st.h{2} eq "two")) puts("bad 11");
	unless (st.st.i == 33) puts("bad 12");

	a = (int[])"1 2 3";
	n = 0;
	foreach (i in a) {
		unless (i == (n+1)) puts("bad 10");
		++n;
	}
	if (n != 3) puts("bad 11");

	h = (string{int})"1 one 2 two 3 three";
	unless ((h{1} eq "one") && (h{2} eq "two") && (h{3} eq "three")) {
		puts("bad 20");
	}
	n = 0;
	foreach (i in h) ++n;
	unless (n == 3) puts("bad 21");
}
#lang tcl
cast_1_6
} -output {}

test array-1.0 { Single-dimensional array creation and indexing } -body {
#lang L
void array_1_0() {
    int array[3];

    array[0] = 1;
    array[1] = 2;
    array[2] = 3;
    puts(array[2]);
}
#lang tcl
array_1_0
} -output "3\n"

test array-1.1 { Multi-dimensional array creation and indexing } -body {
#lang L
void array_1_1() {
    int array[4][3][2];

    puts(array);
    array[0][0][0] = 1;
    array[1][1][1] = 2;
    array[2][2][0] = 3;
    array[3][0][1] = 4;
    puts(array);
}
#lang tcl
array_1_1
} -output "
1 {{} {{} 2}} {{} {} 3} {{{} 4}}\n"


test array-1.2 {increment and decrement on array elements} -body {
#lang L
void array_1_2() {
  int foo[5] = {0,0,0,0,0};

  foo[3] = 0;
  for (foo[3]=0; foo[3]<5; foo[3]++);
  puts(foo);

  puts("pre:");
  puts(foo[3]);
  ++foo[3];
  puts(foo[3]);
  puts(++foo[3]);
  --foo[3];
  puts(foo[3]);
  puts(--foo[3]);

  puts("post:");
  puts(foo[3]);
  foo[3]++;
  puts(foo[3]);
  puts(foo[3]++);
  puts(foo[3]);
  foo[3]--;
  puts(foo[3]);
  puts(foo[3]--);
  puts(foo[3]);
  puts(foo);
}
#lang tcl
array_1_2
} -output "0 0 0 5 0\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n0 0 0 5 0\n"

test array_1_3 {1d arrays with no length auto-extend by one at a time} -body {
#lang L
void array_1_3() {
  int foo[];

  foo[0] = 4;
  foo[1] = 5;
  foo[2] = 6;
  puts(foo);
}
#lang tcl
array_1_3
} -output "4 5 6\n"

test array_1_4 {extend arrays using push and pop} -body {
#lang L
void array_1_4() {
  int foo[];

  push(&foo, 1);
  push(&foo, 2);
  push(&foo, 3);
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
  puts(pop(&foo));
  puts(foo);
} 
#lang tcl
array_1_4
} -output "1 2 3\n3\n1 2\n2\n1\n1\n\n\n\n"


test loop-1.0 {while loops} -body {
#lang L
void loop_1_0() {
        int i = 0;
        while (i++ < 5) puts (i);
        while (i) {
                int j = i--;
                puts(j);
        }
}
#lang tcl
loop_1_0
} -output "1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\n"
test loop-1.1 {for loops} -body {
#lang L
void loop_1_1() {
        int i;
        for (i=1; i<7; i++) {
                puts(i);
        }
        puts("-*-");
        for ( ; i; i--) {
                puts(i);
        }
}
#lang tcl
loop_1_1
} -output "1\n2\n3\n4\n5\n6\n-*-\n7\n6\n5\n4\n3\n2\n1\n"

test loop-1.2 {do loops} -body {
#lang L
void loop_1_2()
{
	int	i;

	/* Do loops must iterate at least once. */
	i = 0;
	do {
		++i;
	} while (0);
	unless (i == 1) puts("bad 1");

	i = 0;
	do {
		++i;
		puts(i);
	} while (i < 4);
}
#lang tcl
loop_1_2
} -output "1\n2\n3\n4\n"

test loop-1.2.0 {simple foreach loops} -body {
#lang L
struct sl120 {
	int	i;
	int	j;
	string	s;
};
void
loop_1_2_0()
{
	int	k, vi;
	string	vs;
	float	vf;
	hash	h0 = { };
	hash	h1 = { 0=>1 };
	hash	h2 = { 0=>1, 1=>2 };
	hash	h3 = { 0=>1, 1=>2, 2=>3 };
	int	ai0[];
	int	ai1[1] = { 11 };
	int	ai2[2] = { 22, 23 };
	int	ai3[3] = { 33, 34, 35 };
	string	as0[0];
	string	as1[1] = { "a" };
	string	as2[2] = { "b", "c" };
	string	as3[3] = { "d", "e", "f" };
	float	af0[0];
	float	af1[1] = { 1.1 };
	float	af2[2] = { 2.1, 2.2 };
	float	af3[3] = { 3.1, 3.2, 3.3 };
	struct sl120	vc;
	struct sl120	ac[3];

	printf("start\n");
	foreach (k in h0) {
		printf("h0 has %d\n", k);
	}
	foreach (k in h1) {
		printf("h1 has %d\n", k);
	}
	foreach (k in h2) {
		printf("h2 has %d\n", k);
	}
	foreach (k in h3) {
		printf("h3 has %d\n", k);
	}
	foreach (k=>vi in h0) {
		printf("h0 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h1) {
		printf("h1 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h2) {
		printf("h2 has %d=>%d\n", k, vi);
	}
	foreach (k=>vi in h3) {
		printf("h3 has %d=>%d\n", k, vi);
	}
	foreach (vi in ai0) {
		printf("ai0 has %d\n", vi);
	}
	foreach (vi in ai1) {
		printf("ai1 has %d\n", vi);
	}
	foreach (vi in ai2) {
		printf("ai2 has %d\n", vi);
	}
	foreach (vi in ai3) {
		printf("ai3 has %d\n", vi);
	}
	foreach (vs in as0) {
		printf("as0 has %s\n", vs);
	}
	foreach (vs in as1) {
		printf("as1 has %s\n", vs);
	}
	foreach (vs in as2) {
		printf("as2 has %s\n", vs);
	}
	foreach (vs in as3) {
		printf("as3 has %s\n", vs);
	}
	foreach (vf in af0) {
		printf("af0 has %1.1f\n", vf);
	}
	foreach (vf in af1) {
		printf("af1 has %1.1f\n", vf);
	}
	foreach (vf in af2) {
		printf("af2 has %1.1f\n", vf);
	}
	foreach (vf in af3) {
		printf("af3 has %1.1f\n", vf);
	}
	foreach (vf in ai0) {
		printf("ai0 has %1.1f\n", vf);
	}
	foreach (vf in ai1) {
		printf("ai1 has %1.1f\n", vf);
	}
	foreach (vf in ai2) {
		printf("ai2 has %1.1f\n", vf);
	}
	foreach (vf in ai3) {
		printf("ai3 has %1.1f\n", vf);
	}
	ac[0].i = 1;
	ac[0].j = 2;
	ac[0].s = "a";
	ac[1].i = 11;
	ac[1].j = 22;
	ac[1].s = "aa";
	ac[2].i = 111;
	ac[2].j = 222;
	ac[2].s = "aaa";
	foreach (vc in ac) {
		printf("ac has %d,%d,%s\n", vc.i, vc.j, vc.s);
	}
	printf("end\n");
}
#lang tcl
loop_1_2_0
} -output "start
h1 has 0
h2 has 0
h2 has 1
h3 has 0
h3 has 1
h3 has 2
h1 has 0=>1
h2 has 0=>1
h2 has 1=>2
h3 has 0=>1
h3 has 1=>2
h3 has 2=>3
ai1 has 11
ai2 has 22
ai2 has 23
ai3 has 33
ai3 has 34
ai3 has 35
as1 has a
as2 has b
as2 has c
as3 has d
as3 has e
as3 has f
af1 has 1.1
af2 has 2.1
af2 has 2.2
af3 has 3.1
af3 has 3.2
af3 has 3.3
ai1 has 11.0
ai2 has 22.0
ai2 has 23.0
ai3 has 33.0
ai3 has 34.0
ai3 has 35.0
ac has 1,2,a
ac has 11,22,aa
ac has 111,222,aaa
end
"

test loop-1.2.1 {foreach loops over arrays of arrays} -body {
#lang L
void
loop_121_fill2(int d1, int d2, int &a[][])
{
	int	i, j;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			a[i][j] = i*10 + j;
		}
	}
}

void
loop_121_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = i*100 + j*10 + k;
			}
		}
	}
}

void
loop_1_2_1()
{
	int	vi;
	int	ai[3];
	int	aii[4][3];
	int	aiii[5][4][3];

	loop_121_fill2(4, 3, &aii);
	loop_121_fill3(5, 4, 3, &aiii);

	printf("test 1\n");
	foreach (ai in aii) {
		foreach (vi in ai) {
			printf("aii has %d\n", vi);
		}
	}

	printf("test 2\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}

	printf("end\n");
}
loop_1_2_1();
} -output "test 1
aii has 0
aii has 1
aii has 2
aii has 10
aii has 11
aii has 12
aii has 20
aii has 21
aii has 22
aii has 30
aii has 31
aii has 32
test 2
aiii has 0
aiii has 1
aiii has 2
aiii has 10
aiii has 11
aiii has 12
aiii has 20
aiii has 21
aiii has 22
aiii has 30
aiii has 31
aiii has 32
aiii has 100
aiii has 101
aiii has 102
aiii has 110
aiii has 111
aiii has 112
aiii has 120
aiii has 121
aiii has 122
aiii has 130
aiii has 131
aiii has 132
aiii has 200
aiii has 201
aiii has 202
aiii has 210
aiii has 211
aiii has 212
aiii has 220
aiii has 221
aiii has 222
aiii has 230
aiii has 231
aiii has 232
aiii has 300
aiii has 301
aiii has 302
aiii has 310
aiii has 311
aiii has 312
aiii has 320
aiii has 321
aiii has 322
aiii has 330
aiii has 331
aiii has 332
aiii has 400
aiii has 401
aiii has 402
aiii has 410
aiii has 411
aiii has 412
aiii has 420
aiii has 421
aiii has 422
aiii has 430
aiii has 431
aiii has 432
end
"

test loop-1.2.2 {foreach with int variable lists} -body {
#lang L
void
loop_1_2_2()
{
	int	i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12;
	int	a[12] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

	printf("test 1\n");
	foreach (i1 in a) {
		printf("a has %d\n", i1);
	}
	printf("test 2\n");
	foreach (i1,i2 in a) {
		printf("a has %d,%d\n", i1, i2);
	}
	printf("test 3\n");
	foreach (i1,i2,i3 in a) {
		printf("a has %d,%d,%d\n", i1, i2, i3);
	}
	printf("test 4\n");
	foreach (i1,i2,i3,i4 in a) {
		printf("a has %d,%d,%d,%d\n", i1, i2, i3, i4);
	}
	printf("test 5\n");
	foreach (i1,i2,i3,i4,i5,i6 in a) {
		printf("a has %d,%d,%d,%d,%d,%d\n", i1, i2, i3, i4, i5, i6);
	}
	printf("test 6\n");
	foreach (i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12 in a) {
		printf("a has %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
		       i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);
	}
	printf("end\n");
}
loop_1_2_2();
} -output "test 1
a has 1
a has 2
a has 3
a has 4
a has 5
a has 6
a has 7
a has 8
a has 9
a has 10
a has 11
a has 12
test 2
a has 1,2
a has 3,4
a has 5,6
a has 7,8
a has 9,10
a has 11,12
test 3
a has 1,2,3
a has 4,5,6
a has 7,8,9
a has 10,11,12
test 4
a has 1,2,3,4
a has 5,6,7,8
a has 9,10,11,12
test 5
a has 1,2,3,4,5,6
a has 7,8,9,10,11,12
test 6
a has 1,2,3,4,5,6,7,8,9,10,11,12
end
"

test loop-1.2.3 {foreach with string variable lists} -body {
#lang L
void
loop_1_2_3()
{
	string	s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14;
	string	a[12] = { "a","b","c","d","e","f","g","h","i","j","k","l" };

	printf("test 1\n");
	foreach (s1 in a) {
		printf("a has %s\n", s1);
	}
	printf("test 2\n");
	foreach (s1,s2 in a) {
		printf("a has %s,%s\n", s1, s2);
	}
	printf("test 3\n");
	foreach (s1,s2,s3 in a) {
		printf("a has %s,%s,%s\n", s1, s2, s3);
	}
	printf("test 4\n");
	foreach (s1,s2,s3,s4 in a) {
		printf("a has %s,%s,%s,%s\n", s1, s2, s3, s4);
	}
	printf("test 5\n");
	foreach (s1,s2,s3,s4,s5,s6 in a) {
		printf("a has %s,%s,%s,%s,%s,%s\n", s1, s2, s3, s4, s5, s6);
	}
	printf("test 6\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12);
	}

	/*
	 * The current semantics is that extra vars get "", so test that.
	 * This may eventually be changed to be a run-time error.
	 */

	printf("test 7\n");
	foreach (s1,s2,s3,s4,s5 in a) {
		printf("a has %s,%s,%s,%s,%s\n", s1, s2, s3, s4, s5);
	}

	printf("test 8\n");
	foreach (s1,s2,s3,s4,s5,s6,s7 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7);
	}

	printf("test 9\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8);
	}

	printf("test 10\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9);
	}

	printf("test 11\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10);
	}

	printf("test 12\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11);
	}

	printf("test 13\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13);
	}

	printf("test 14\n");
	foreach (s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14 in a) {
		printf("a has %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n",
		       s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,
		       s14);
	}

	printf("end\n");
}
loop_1_2_3();
} -output "test 1
a has a
a has b
a has c
a has d
a has e
a has f
a has g
a has h
a has i
a has j
a has k
a has l
test 2
a has a,b
a has c,d
a has e,f
a has g,h
a has i,j
a has k,l
test 3
a has a,b,c
a has d,e,f
a has g,h,i
a has j,k,l
test 4
a has a,b,c,d
a has e,f,g,h
a has i,j,k,l
test 5
a has a,b,c,d,e,f
a has g,h,i,j,k,l
test 6
a has a,b,c,d,e,f,g,h,i,j,k,l
test 7
a has a,b,c,d,e
a has f,g,h,i,j
a has k,l,,,
test 8
a has a,b,c,d,e,f,g
a has h,i,j,k,l,,
test 9
a has a,b,c,d,e,f,g,h
a has i,j,k,l,,,,
test 10
a has a,b,c,d,e,f,g,h,i
a has j,k,l,,,,,,
test 11
a has a,b,c,d,e,f,g,h,i,j
a has k,l,,,,,,,,
test 12
a has a,b,c,d,e,f,g,h,i,j,k
a has l,,,,,,,,,,
test 13
a has a,b,c,d,e,f,g,h,i,j,k,l,
test 14
a has a,b,c,d,e,f,g,h,i,j,k,l,,
end
"

test loop-1.2.4 {foreach loops with large loop body (>127 bytes of bytecode)} -body {
#lang L
void
loop_1_2_4()
{
	int	i, k, v;
	int	a[3] = { 1,2,3 };
	hash	h = { 1=>2, 2=>3, 3=>4 };

	printf("start\n");
	foreach (i in a) {
		/* Just do whatever to rack up bytecodes. */
		int	x = 1, y = 1, z = 1;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		printf("a has %d\n", i);
	}
	foreach (k=>v in h) {
		/* Just do whatever to rack up bytecodes. */
		int	x = 1, y = 1, z = 1;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		x = x+y*z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y+z+x*y;
		printf("h has %d=>%d\n", k, v);
	}
	printf("end\n");
}
loop_1_2_4();
} -output "start
a has 1
a has 2
a has 3
h has 1=>2
h has 2=>3
h has 3=>4
end
"

test loop-1.2.5 {check hash foreach type checking} -body {
#lang L
void loop_1_2_5()
{
	int	i1, i2;
	string	s1, s2;
	string	h{int};

	foreach (s1=>s2 in h) ;
	foreach (s1=>i2 in h) ;
	foreach (i1=>i2 in h) ;
}
#lang tcl
} -returnCodes error -match regexp -result {.*7: L Error: loop index key type incompatible.*
.*8: L Error: loop index value type incompatible.*
.*8: L Error: loop index key type incompatible.*
.*9: L Error: loop index value type incompatible.*
}

test loop-1.3 {continue statements} -body {
#lang L
void loop_1_3() {
  loop_1_3_for_continue();
  loop_1_3_foreach_continue();
}

void loop_1_3_for_continue() {
  int i;

  for (i=0; i<5; i++) {
    if (i == 2) {
      continue;
    }
    puts(i);
  }
}

void loop_1_3_foreach_continue() {
  hash h;
  string k, v, l;

  h{"a"} = "x";
  h{"b"} = "y";
  h{"c"} = "z";

  printf("foreach test 1\n");
  foreach (k => v in h) {
    if (k eq "b") {
      continue;
    }
    printf("%s => %s\n", k, v);
  }

  printf("foreach test 2\n");
  foreach (l in h) {
    if (l eq "c") continue;
    foreach (k => v in h) {
      if (k eq "b") {
        continue;
      }
      printf("%s: %s => %s\n", l, k, v);
    }
  }
}
#lang tcl
loop_1_3
} -output {0
1
3
4
foreach test 1
a => x
c => z
foreach test 2
a: a => x
a: c => z
b: a => x
b: c => z
}

test loop-1.4 {break statements} -body {
#lang L
void loop_1_4() {
  loop_1_4_foreach_break();
  loop_1_4_for_break();
}

void loop_1_4_foreach_break() {
  hash h;
  string k, v, l;

  h{"a"} = "x";
  h{"b"} = "y";
  h{"c"} = "z";
  foreach (l in h) {
    foreach (k => v in h) {
      if (k eq "b") {
        break;
      }
    }
  }
  printf("loop's over, k is %s, v is %s\n", k, v);
}

void loop_1_4_for_break() {
  int i;

  for (i=0; i<10; i++) {
    puts(i);
    if (i == 5) {
      puts("attempting to break");
      break;
    }
  }
  printf("at the end of the day, i is %d\n", i);
}
#lang tcl
loop_1_4
} -output {loop's over, k is b, v is y
0
1
2
3
4
5
attempting to break
at the end of the day, i is 5
}

test loop-1.5 {continues in nested foreach loops} -body {
#lang L
void
loop_1_5_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = (i+1)*100 + (j+1)*10 + k+1;
			}
		}
	}
}

void
loop_1_5()
{
	int	d1, d2, vi;
	int	ai[3];
	int	aii[3][3];
	int	aiii[3][3][3];

	loop_1_5_fill3(3, 3, 3, &aiii);

	printf("test 1\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				// Omit all even numbers.
				if ((vi%2) == 0) continue;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 2\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		foreach (ai in aii) {
			++d2;
			// Omit 11x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 3\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 4\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			// Omit 21x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 5\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit 1xx.
		if (d1 == 1) continue;
		foreach (ai in aii) {
			++d2;
			// Omit 21x.
			if (d2 == 1) continue;
			foreach (vi in ai) {
				// Omit 3xx.
				if (vi >= 300) continue;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("end\n");
}

loop_1_5();
} -output "test 1
aiii has 111
aiii has 113
aiii has 121
aiii has 123
aiii has 131
aiii has 133
aiii has 211
aiii has 213
aiii has 221
aiii has 223
aiii has 231
aiii has 233
aiii has 311
aiii has 313
aiii has 321
aiii has 323
aiii has 331
aiii has 333
test 2
aiii has 121
aiii has 122
aiii has 123
aiii has 131
aiii has 132
aiii has 133
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 3
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 4
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 5
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
end
"

test loop-1.6 {breaks in nested foreach loops} -body {
#lang L
void
loop_1_6_fill3(int d1, int d2, int d3, int &a[][][])
{
	int	i, j, k;

	for (i = 0; i < d1; ++i) {
		for (j = 0; j < d2; ++j) {
			for (k = 0; k < d3; ++k) {
				a[i][j][k] = (i+1)*100 + (j+1)*10 + k+1;
			}
		}
	}
}

void
loop_1_6()
{
	int	d1, d2, vi;
	int	ai[3];
	int	aii[3][3];
	int	aiii[3][3][3];

	loop_1_6_fill3(3, 3, 3, &aiii);

	printf("test 1\n");
	foreach (aii in aiii) {
		foreach (ai in aii) {
			foreach (vi in ai) {
				// Should have no output.
				break;
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 2\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		foreach (ai in aii) {
			++d2;
			// Omit 13x.
			if (d2 == 3) break;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("test 3\n");
	d1 = d2 = 0;
	foreach (aii in aiii) {
		++d1;
		// Omit [23]xx.
		if (d1 == 2) break;
		foreach (ai in aii) {
			++d2;
			foreach (vi in ai) {
				printf("aiii has %d\n", vi);
			}
		}
	}
	printf("end\n");
}

loop_1_6();
} -output "test 1
test 2
aiii has 111
aiii has 112
aiii has 113
aiii has 121
aiii has 122
aiii has 123
aiii has 211
aiii has 212
aiii has 213
aiii has 221
aiii has 222
aiii has 223
aiii has 231
aiii has 232
aiii has 233
aiii has 311
aiii has 312
aiii has 313
aiii has 321
aiii has 322
aiii has 323
aiii has 331
aiii has 332
aiii has 333
test 3
aiii has 111
aiii has 112
aiii has 113
aiii has 121
aiii has 122
aiii has 123
aiii has 131
aiii has 132
aiii has 133
end
"

test struct-1.0 {structs} -body {
#lang L
struct struct_1_0_point {
        int x, y;
        string label;
};

void struct_1_0() {
        struct struct_1_0_point p1, p2;

        p1.x = 1;
        p1.y = 2;
        p1.label = "this is a label";
        puts("p1 is:");
        puts(p1);
        puts(format("p1.x is %d, p1.y is %d, and p1.label is %s", p1.x, p1.y, p1.label));
        p2 = p1;
        p2.label = "this is another label";
        puts("p1 is:");
        puts(p1);
        puts("p2 is:");
        puts(p2);
}
#lang tcl
struct_1_0
} -output "p1 is:
1 2 {this is a label}
p1.x is 1, p1.y is 2, and p1.label is this is a label
p1 is:
1 2 {this is a label}
p2 is:
1 2 {this is another label}
"

test struct-1.1 {struct allocation and arrays of structs} -body {
#lang L
struct struct_1_1_point {
        int x, y;
        string label;
};

void struct_1_1() {
   int i = 0;
   struct struct_1_1_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_1
} -output "42 0 {10 cows}
43 1 {9 cows}
44 2 {8 cows}
45 3 {7 cows}
46 4 {6 cows}
47 5 {5 cows}
48 6 {4 cows}
49 7 {3 cows}
50 8 {2 cows}
51 9 {1 cows}
"

test struct-1.2 {arrays of structs containing arrays} -body {
#lang L
struct struct_1_2_point {
        int x, y;
        string label;
  int z[4];
};

void struct_1_2() {
   int i = 0;
   struct struct_1_2_point s[10];

   while(i < 10) {
      s[i].y = i;
      s[i].x = 42 + i;
      s[i].label = format("%d cows", 10 - i);
      s[i].z[i%4] = i;
      i++;
   }
   for (i=0; i<10; i++) {
     puts(s[i]);
   }
}
#lang tcl
struct_1_2
} -output "42 0 {10 cows} 0
43 1 {9 cows} {{} 1}
44 2 {8 cows} {{} {} 2}
45 3 {7 cows} {{} {} {} 3}
46 4 {6 cows} 4
47 5 {5 cows} {{} 5}
48 6 {4 cows} {{} {} 6}
49 7 {3 cows} {{} {} {} 7}
50 8 {2 cows} 8
51 9 {1 cows} {{} 9}
"

test struct-1.3 {increment and decrement on struct fields} -body {
#lang L
struct foo {
  int i;
};

void struct_1_3() {
  struct foo v;

  v.i = 0;
  for (v.i=0; v.i<5; v.i++);
  puts(v);

  puts("pre:");
  puts(v.i);
  ++v.i;
  puts(v.i);
  puts(++v.i);
  --v.i;
  puts(v.i);
  puts(--v.i);

  puts("post:");
  puts(v.i);
  v.i++;
  puts(v.i);
  puts(v.i++);
  puts(v.i);
  v.i--;
  puts(v.i);
  puts(v.i--);
  puts(v.i);
}
#lang tcl
struct_1_3
} -output "5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\n"

test struct-1.4 {check struct type declarations} -body {
#lang L
struct struct_1_4_1 {
	int	i;
	int	j;
};
struct struct_1_4_2;
struct struct_1_4_3 {
	int	i;
	int	j;
	struct struct_1_4_2 st;
};
struct struct_1_4_2 {
	string	s;
};
void struct_1_4()
{
	struct struct_1_4_1 st1 = { 2, 3 };
	struct struct_1_4_2 st2 = { "s2" };
	struct struct_1_4_3 st3 = { 4, 5, { "s3" } };
	/* This redeclaration hides the global one. */
	struct struct_1_4_2 { int k,l; } st4 = { 6, 7 };

	unless ((st1.i == 2) && (st1.j == 3)) puts("bad 1");
	unless (st2.s eq "s2") puts("bad 2");
	unless ((st3.i == 4) && (st3.j == 5) && (st3.st.s eq "s3")) {
	       puts("bad 3");
	}
	unless ((st4.k == 6) && (st4.l == 7)) puts("bad 4");

	if (1) {
		/* This redeclaration hides the global one in this scope. */
		struct struct_1_4_1 { string t,u; } st5 = { "t", "u" };
		unless ((st5.t eq "t") && (st5.u eq "u")) puts("bad 5");
	}
	if (1) {
		/* This should reference the global one. */
		struct struct_1_4_1 st6 = { 8, 9 };
		unless ((st6.i == 8) && (st6.j == 9)) puts("bad 7");
	}
}
#lang tcl
struct_1_4
} -output {}

test struct-1.5 {check multiple struct type declarations} -body {
#lang L
struct struct_1_5_1 { int i,j; };
struct struct_1_5_1 { int i,j; };
struct struct_1_5_2 { int i,j; };
void struct_1_5_1()
{
	struct struct_1_5_2 { string s; } st1;
	struct struct_1_5_2 { string s; } st2;
}
} -returnCodes error -match regexp -result {.*2: L Error: multiple declaration of struct struct_1_5_1.*7: L Error: multiple declaration of struct struct_1_5_2
}

test struct-1.6 {check struct member errors} -body {
#lang L
void struct_1_6()
{
	struct struct_1_6 { string s; } st;
	st.x = 1;  // err -- x is not a member
}
} -returnCodes error -match regexp -result {.*4: L Error: struct field x not found
}

test hash-1.0 {basic hashtable support} -body {
#lang L
void hash_1_0() {
  hash foo;
  foo{"key"} = "value";
  puts(foo{"key"});
}
#lang tcl
hash_1_0
} -output "value\n"

test hash-1.1 {array of hashtables} -body {
#lang L
void hash_1_1() {
  hash foo[10];
  foo[5]{"key"} = "value";
  foo[4]{"key"} = "";
  puts(foo[5]{"key"});
  puts(foo[4]{"key"});
}
#lang tcl
hash_1_1
} -output "value\n\n"

test hash-1.2 {increment and decrement on hash elements} -body {
#lang L -poly
void hash_1_2() {
  hash foo;

  foo{"three"} = 0;
  for (foo{"three"}=0; foo{"three"}<5; foo{"three"}++);
  puts(foo);

  puts("pre:");
  puts(foo{"three"});
  ++foo{"three"};
  puts(foo{"three"});
  puts(++foo{"three"});
  --foo{"three"};
  puts(foo{"three"});
  puts(--foo{"three"});

  puts("post:");
  puts(foo{"three"});
  foo{"three"}++;
  puts(foo{"three"});
  puts(foo{"three"}++);
  puts(foo{"three"});
  foo{"three"}--;
  puts(foo{"three"});
  puts(foo{"three"}--);
  puts(foo{"three"});
  puts(foo);
}
#lang tcl
hash_1_2
} -output "three 5\npre:\n5\n6\n7\n6\n5\npost:\n5\n6\n6\n7\n6\n6\n5\nthree 5\n"

# test hash-1.3 removed

test hash-1.4 {basic hash element types} -body {
#lang L
struct sh14 {
	int	x;
	int	y;
};
void
hash_1_4()
{
	int		ki, vi;
	string		ks, vs;
	float		kf, vf;
	poly		kp, vp;
	struct sh14	vst;
	int		ihi{int};
	int		ihs{string};
	int		ihf{float};
	int		ihp{poly};
	string		shi{int};
	string		shs{string};
	string		shf{float};
	string		shp{poly};
	float		fhi{int};
	float		fhs{string};
	float		fhf{float};
	float		fhp{poly};
	poly		phi{int};
	poly		phs{string};
	poly		phf{float};
	poly		php{poly};
	struct sh14	sthi{int};
	struct sh14	sths{string};
	struct sh14	sthf{float};
	struct sh14	sthp{poly};

	printf("start\n");

	ihi{0} = 100;
	ihi{1} = 101;
	ihi{2} = 102;
	foreach (ki=>vi in ihi) {
		printf("ihi has %d=>%d\n", ki, vi);
	}

	ihs{"zero"} = 100;
	ihs{"one"}  = 101;
	ihs{"two"}  = 102;
	foreach (ks=>vi in ihs) {
		printf("ihs has %s=>%d\n", ks, vi);
	}

	ihf{1.1} = 100;
	ihf{2.2} = 101;
	ihf{3.3} = 102;
	foreach (kf=>vi in ihf) {
		printf("ihf has %3.1f=>%d\n", kf, vi);
	}

	ihp{0}     = 100;
	ihp{"two"} = 101;
	ihp{3.3}   = 102;
	foreach (kp=>vi in ihp) {
		printf("ihp has %s=>%d\n", kp, vi);
	}

	shi{0} = "zero";
	shi{1} = "one";
	shi{2} = "two";
	foreach (ki=>vs in shi) {
		printf("shi has %d=>%s\n", ki, vs);
	}

	shs{"zero"} = "zero0";
	shs{"one"}  = "one1";
	shs{"two"}  = "two2";
	foreach (ks=>vs in shs) {
		printf("shs has %s=>%s\n", ks, vs);
	}

	shf{1.1} = "one.one";
	shf{2.2} = "two.two";
	shf{3.3} = "three.three";
	foreach (kf=>vs in shf) {
		printf("shf has %3.1f=>%s\n", kf, vs);
	}

	shp{0}     = "zero";
	shp{1.1}   = "one.one";
	shp{"two"} = "two2";
	foreach (kp=>vs in shp) {
		printf("shp has %s=>%s\n", kp, vs);
	}

	fhi{0} = 1.1;
	fhi{1} = 2.2;
	fhi{2} = 3.3;
	foreach (ki=>vf in fhi) {
		printf("fhi has %d=>%3.1f\n", ki, vf);
	}

	fhs{"zero"} = 1.1;
	fhs{"one"}  = 2.2;
	fhs{"two"}  = 3.3;
	foreach (ks=>vf in fhs) {
		printf("fhs has %s=>%3.1f\n", ks, vf);
	}

	fhf{1.1} = 11.1;
	fhf{2.2} = 22.2;
	fhf{3.3} = 33.3;
	foreach (kf=>vf in fhf) {
		printf("fhf has %3.1f=>%3.1f\n", kf, vf);
	}

	fhp{0}     = 1.1;
	fhp{1.1}   = 2.2;
	fhp{"two"} = 3.3;
	foreach (kp=>vf in fhp) {
		printf("fhp has %s=>%3.1f\n", kp, vf);
	}

	phi{0} = 1;
	phi{1} = "two";
	phi{2} = 3.3;
	foreach (ki=>vp in phi) {
		printf("phi has %d=>%s\n", ki, vp);
	}

	phs{"zero"} = 1;
	phs{"one"}  = "two";
	phs{"two"}  = 3.3;
	foreach (ks=>vp in phs) {
		printf("phs has %s=>%s\n", ks, vp);
	}

	phf{1.1} = 1;
	phf{2.2} = "two";
	phf{3.3} = 33.33;
	foreach (kf=>vp in phf) {
		printf("phf has %3.1f=>%s\n", kf, vp);
	}

	php{"one"} = 1;
	php{1.1}   = "two";
	php{2}     = 3.3;
	foreach (kp=>vp in php) {
		printf("php has %s=>%s\n", kp, vp);
	}

	sthi{0}.x = 100;
	sthi{0}.y = 101;
	sthi{1}.x = 200;
	sthi{1}.y = 201;
	sthi{2}.x = 300;
	sthi{2}.y = 301;
	foreach (ki=>vst in sthi) {
		printf("sthi has %d=>(%d,%d)\n", ki, vst.x, vst.y);
	}

	sths{"zero"}.x = 100;
	sths{"zero"}.y = 101;
	sths{"one"}.x  = 200;
	sths{"one"}.y  = 201;
	sths{"two"}.x  = 300;
	sths{"two"}.y  = 301;
	foreach (ks=>vst in sths) {
		printf("sths has %s=>(%d,%d)\n", ks, vst.x, vst.y);
	}

	sthf{1.1}.x = 100;
	sthf{1.1}.y = 101;
	sthf{2.2}.x = 200;
	sthf{2.2}.y = 201;
	sthf{3.3}.x = 300;
	sthf{3.3}.y = 301;
	foreach (kf=>vst in sthf) {
		printf("sthf has %3.1f=>(%d,%d)\n", kf, vst.x, vst.y);
	}

	sthp{0}.x     = 100;
	sthp{0}.y     = 101;
	sthp{1.1}.x   = 200;
	sthp{1.1}.y   = 201;
	sthp{"two"}.x = 300;
	sthp{"two"}.y = 301;
	foreach (kp=>vst in sthp) {
		printf("sthp has %s=>(%d,%d)\n", kp, vst.x, vst.y);
	}

	printf("end\n");
}
#lang tcl
hash_1_4
} -output "start
ihi has 0=>100
ihi has 1=>101
ihi has 2=>102
ihs has zero=>100
ihs has one=>101
ihs has two=>102
ihf has 1.1=>100
ihf has 2.2=>101
ihf has 3.3=>102
ihp has 0=>100
ihp has two=>101
ihp has 3.300000=>102
shi has 0=>zero
shi has 1=>one
shi has 2=>two
shs has zero=>zero0
shs has one=>one1
shs has two=>two2
shf has 1.1=>one.one
shf has 2.2=>two.two
shf has 3.3=>three.three
shp has 0=>zero
shp has 1.100000=>one.one
shp has two=>two2
fhi has 0=>1.1
fhi has 1=>2.2
fhi has 2=>3.3
fhs has zero=>1.1
fhs has one=>2.2
fhs has two=>3.3
fhf has 1.1=>11.1
fhf has 2.2=>22.2
fhf has 3.3=>33.3
fhp has 0=>1.1
fhp has 1.100000=>2.2
fhp has two=>3.3
phi has 0=>1
phi has 1=>two
phi has 2=>3.300000
phs has zero=>1
phs has one=>two
phs has two=>3.300000
phf has 1.1=>1
phf has 2.2=>two
phf has 3.3=>33.330000
php has one=>1
php has 1.100000=>two
php has 2=>3.300000
sthi has 0=>(100,101)
sthi has 1=>(200,201)
sthi has 2=>(300,301)
sths has zero=>(100,101)
sths has one=>(200,201)
sths has two=>(300,301)
sthf has 1.1=>(100,101)
sthf has 2.2=>(200,201)
sthf has 3.3=>(300,301)
sthp has 0=>(100,101)
sthp has 1.100000=>(200,201)
sthp has two=>(300,301)
end
"

test hash-1.5 {hashes of hashes and arrays} -body {
#lang L
// "keys" eventually will be a built-in, but do an integer one
// here for fun.
int[]
ikeys(poly h{int})
{
	int	k, thekeys[];

	foreach (k in h) push(&thekeys, k);
	return (thekeys);
}

// This is basically a cast since "sort" isn't yet a built-in so
// the compiler doesn't see it as having the proper return type.
int[]
isort(int a[])
{
	int	sorted[] = sort(a);
	return (sorted);
}

void
hash_1_5()
{
	int	k1, k2;
	string	vs;
	string	hai[3]{int};
	string	hia{int}[3];
	string	hii{int}{int};
	string	hi{int};

	printf("start\n");

	// Array of hashes.
	hai[0]{1} = "01";
	hai[0]{6} = "06";
	hai[0]{5} = "05";
	hai[1]{2} = "12";
	hai[1]{3} = "13";
	hai[1]{0} = "10";
	hai[2]{0} = "20";
	hai[2]{1} = "21";
	hai[2]{2} = "22";
	foreach (hi in hai) {
		foreach (k1 in isort(ikeys(hi))) {
			printf("hai has %d=>%s\n", k1, hi{k1});
		}
	}

	// Hash of arrays.
	hia{1}[0] = "10";
	hia{1}[1] = "11";
	hia{1}[2] = "12";
	hia{0}[0] = "00";
	hia{0}[1] = "01";
	hia{0}[2] = "02";
	hia{2}[0] = "20";
	hia{2}[1] = "21";
	hia{2}[2] = "22";
	foreach (k1 in isort(ikeys(hia))) {
		foreach (vs in hia{k1}) {
			printf("hia{%d} has %s\n", k1, vs);
		}
	}

	// Hash of hashes.
	hii{0}{2} = "02";
	hii{1}{0} = "10";
	hii{0}{0} = "00";
	hii{2}{1} = "21";
	hii{1}{2} = "12";
	hii{1}{1} = "11";
	hii{0}{1} = "01";
	hii{2}{0} = "20";
	hii{2}{2} = "22";
	foreach (k1 in isort(ikeys(hii))) {
		foreach (k2 in isort(ikeys(hii{k1}))) {
			printf("hii{%d}{%d} has %s\n", k1, k2, hii{k1}{k2});
		}
	}

	printf("end\n");
}
#lang tcl
hash_1_5
} -output "start
hai has 1=>01
hai has 5=>05
hai has 6=>06
hai has 0=>10
hai has 2=>12
hai has 3=>13
hai has 0=>20
hai has 1=>21
hai has 2=>22
hia{0} has 00
hia{0} has 01
hia{0} has 02
hia{1} has 10
hia{1} has 11
hia{1} has 12
hia{2} has 20
hia{2} has 21
hia{2} has 22
hii{0}{0} has 00
hii{0}{1} has 01
hii{0}{2} has 02
hii{1}{0} has 10
hii{1}{1} has 11
hii{1}{2} has 12
hii{2}{0} has 20
hii{2}{1} has 21
hii{2}{2} has 22
end
"

test deep-1.1 {deep dive 1} -body {
#lang L
struct xy {
	string		x;
	string		y;
};
struct sd11 {
	string		a;
	string		b;
	struct xy	h{int};
};

void
deep_1_1()
{
	int		k1, k2;
	struct sd11	s;
	struct xy	xy;
	struct sd11	h{int};

	printf("start\n");

	/*
	 * Test a hash that has a struct that has another hash.
	 */

	h{0}.a = "h{0}.a";
	h{0}.b = "h{0}.b";
	h{0}.h{0}.x = "h{0}.h{0}.x";
	h{0}.h{0}.y = "h{0}.h{0}.y";
	h{1}.a = "h{1}.a";
	h{1}.b = "h{1}.b";
	h{1}.h{0}.x = "h{1}.h{0}.x";
	h{1}.h{0}.y = "h{1}.h{0}.y";
	h{1}.h{2}.x = "h{1}.h{2}.x";
	h{1}.h{2}.y = "h{1}.h{2}.y";

	foreach (k1=>s in h) {
		printf("h{%d}.a = %s\n", k1, s.a);
		printf("h{%d}.b = %s\n", k1, s.b);
		foreach (k2=>xy in s.h) {
			printf("h{%d}.h{%d}.x = %s\n", k1, k2, xy.x);
			printf("h{%d}.h{%d}.y = %s\n", k1, k2, xy.y);
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_1
} -output "start
h{0}.a = h{0}.a
h{0}.b = h{0}.b
h{0}.h{0}.x = h{0}.h{0}.x
h{0}.h{0}.y = h{0}.h{0}.y
h{1}.a = h{1}.a
h{1}.b = h{1}.b
h{1}.h{0}.x = h{1}.h{0}.x
h{1}.h{0}.y = h{1}.h{0}.y
h{1}.h{2}.x = h{1}.h{2}.x
h{1}.h{2}.y = h{1}.h{2}.y
end
"

test deep-1.2 {deep dive with consecutive hash indices} -body {
#lang L
void
deep_1_2()
{
	int	k1, k2, k3, k4;
	string	v;
	string	h{int};
	string	hh{int}{int};
	string	hhh{int}{int}{int};
	string	hhhh{int}{int}{int}{int};

	printf("start\n");

	/*
	 * Test various cases with consecutive hash indices.
	 */

	hh{0}{0} = "00";
	hh{0}{1} = "01";
	hh{1}{0} = "10";
	foreach (k1=>h in hh) {
		foreach (k2=>v in h) {
			unless (hh{k1}{k2} eq h{k2}) {
				printf("bad 1\n");
			}
			printf("hh{%d}{%d} has %s\n", k1, k2, hh{k1}{k2});
		}
	}

	hhh{0}{0}{0} = "000";
	hhh{0}{0}{1} = "001";
	hhh{0}{1}{0} = "010";
	hhh{1}{0}{0} = "100";
	foreach (k1=>hh in hhh) {
		foreach (k2=>h in hh) {
			foreach (k3=>v in h) {
				unless (hhh{k1}{k2}{k3} eq hh{k2}{k3}) {
					printf("bad 2\n");
				}
				unless (hh{k2}{k3} eq h{k3}) {
					printf("bad 3\n");
				}
				printf("hhh{%d}{%d}{%d} has %s\n", k1, k2, k3,
				       hhh{k1}{k2}{k3});
			}
		}
	}

	hhhh{0}{0}{0}{0} = "0000";
	hhhh{0}{0}{0}{1} = "0001";
	hhhh{0}{0}{1}{0} = "0010";
	hhhh{0}{1}{0}{0} = "0100";
	hhhh{1}{0}{0}{0} = "1000";
	foreach (k1=>hhh in hhhh) {
		foreach (k2=>hh in hhh) {
			foreach (k3=>h in hh) {
				foreach (k4=>v in h) {
					unless (hhhh{k1}{k2}{k3}{k4} eq
						hhh{k2}{k3}{k4}) {
						printf("bad 4\n");
					}
					unless (hhh{k2}{k3}{k4} eq hh{k3}{k4}) {
						printf("bad 5\n");
					}
					unless (hh{k3}{k4} eq h{k4}) {
						printf("bad 6\n");
					}
					printf("hhhh{%d}{%d}{%d}{%d} has %s\n",
					       k1, k2, k3, k4,
					       hhhh{k1}{k2}{k3}{k4});
				}
			}
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_2
} -output "start
hh{0}{0} has 00
hh{0}{1} has 01
hh{1}{0} has 10
hhh{0}{0}{0} has 000
hhh{0}{0}{1} has 001
hhh{0}{1}{0} has 010
hhh{1}{0}{0} has 100
hhhh{0}{0}{0}{0} has 0000
hhhh{0}{0}{0}{1} has 0001
hhhh{0}{0}{1}{0} has 0010
hhhh{0}{1}{0}{0} has 0100
hhhh{1}{0}{0}{0} has 1000
end
"

test deep-1.3 {deep dive with consecutive array indices} -body {
#lang L
void
deep_1_3()
{
	string	v;
	string	a[3];
	string	aa[2][2];
	string	aaa[2][2][2];
	string	aaaa[2][2][2][2];

	printf("start\n");

	/*
	 * Test various cases with consecutive array indices.
	 */

	a[0] = "0";
	a[1] = "1";
	a[2] = "2";
	foreach (v in a) {
		printf("a has '%s'\n", v);
	}

	aa[0][0] = "00";
	aa[0][1] = "01";
	aa[0][2] = "02";
	aa[1][0] = "10";
	foreach (a in aa) {
		foreach (v in a) {
			printf("aa has '%s'\n", v);
		}
	}

	aaa[0][0][0] = "000";
	aaa[0][0][1] = "001";
	aaa[0][1][0] = "010";
	aaa[0][1][1] = "011";
	aaa[1][0][0] = "100";
	foreach (aa in aaa) {
		foreach (a in aa) {
			foreach (v in a) {
				printf("aaa has '%s'\n", v);
			}
		}
	}

	aaaa[0][0][0][0] = "0000";
	aaaa[0][0][0][1] = "0001";
	aaaa[0][0][1][0] = "0010";
	aaaa[0][1][0][0] = "0100";
	aaaa[1][0][0][0] = "1000";
	foreach (aaa in aaaa) {
		foreach (aa in aaa) {
			foreach (a in aa) {
				foreach (v in a) {
					printf("aaaa has '%s'\n", v);
				}
			}
		}
	}

	printf("end\n");
}
#lang tcl
deep_1_3
} -output "start
a has '0'
a has '1'
a has '2'
aa has '00'
aa has '01'
aa has '02'
aa has '10'
aaa has '000'
aaa has '001'
aaa has '010'
aaa has '011'
aaa has '100'
aaaa has '0000'
aaaa has '0001'
aaaa has '0010'
aaaa has '0100'
aaaa has '1000'
end
"

test deep-1.4 {deep dive with alternating hash and array indices} -body {
#lang L
void
deep_1_4()
{
	/*
	 * Note that, because of the array auto-extend semantics, if
	 * you write to a[i] but there are values before index i not
	 * yet written, those get automatically set to an undefined
	 * value, which the foreach's will iterate through.  When used
	 * as a string, the undefined value shows up as "".  (Tcl
	 * doesn't let you use it as an integer, which is why the
	 * hashes are string hashes in these tests.)
	 */

	int	i, j, ki, k1, k2;
	string	vs;
	string	a[3];
	string	aa[3][3];
	string	h{int};
	string	hh{int}{int};
	string	ah[3]{int};
	string	ha{int}[3];
	string	aah[3][3]{int};
	string	aha[3]{int}[3];
	string	ahh[3]{int}{int};
	string	haa{int}[3][3];
	string	hah{int}[3]{int};
	string	hha{int}{int}[3];

	printf("start\n");

	ah[0]{0} = "ah[0]{0}";
	ah[2]{0} = "ah[2]{0}";
	ah[2]{1} = "ah[2]{1}";
	i = 0;
	foreach (h in ah) {
		foreach (ki=>vs in h) {
			unless (ah[i]{ki} eq vs) printf("bad 1\n");
			printf("ah[%d]{%d} = '%s'\n", i, ki, vs);
		}
		++i;
	}

	ha{0}[0] = "ha{0}[0]";
	ha{0}[1] = "ha{0}[1]";
	ha{1}[1] = "ha{1}[1]";
	foreach (ki=>a in ha) {
		i = 0;
		foreach (vs in a) {
			unless (ha{ki}[i] eq vs) printf("bad 2\n");
			printf("ha{%d}[%d] = '%s'\n", ki, i, vs);
			++i;
		}
	}

	aah[0][0]{0} = "aah[0][0]{0}";
	aah[0][1]{1} = "aah[0][1]{1}";
	aah[1][0]{2} = "aah[1][0]{2}";
	aah[1][0]{3} = "aah[1][0]{3}";
	i = 0;
	foreach (ah in aah) {
		j = 0;
		foreach (h in ah) {
			foreach (ki=>vs in h) {
				unless (aah[i][j]{ki} eq vs) printf("bad 3\n");
				unless (ah[j]{ki} eq vs) printf("bad 4\n");
				unless (h{ki} eq vs) printf("bad 5\n");
				printf("aah[%d][%d]{%d} = '%s'\n", i, j, ki,
				       aah[i][j]{ki});
			}
			++j;
		}
		++i;
	}

	aha[0]{0}[0] = "aha[0]{0}[0]";
	aha[0]{1}[1] = "aha[0]{1}[1]";
	aha[1]{2}[0] = "aha[1]{2}[0]";
	aha[0]{3}[2] = "aha[0]{3}[2]";
	i = 0;
	foreach (ha in aha) {
		foreach (ki=>a in ha) {
			j = 0;
			foreach (vs in a) {
				unless (aha[i]{ki}[j] eq vs) printf("bad 6\n");
				unless (ha{ki}[j] eq vs) printf("bad 7\n");
				unless (a[j] eq vs) printf("bad 7\n");
				printf("aha[%d]{%d}[%d] = '%s'\n", i, ki, j,
				       aha[i]{ki}[j]);
				++j;
			}
		}
		++i;
	}

	ahh[0]{0}{1} = "ahh[0]{0}{1}";
	ahh[0]{2}{3} = "ahh[0]{2}{3}";
	ahh[1]{4}{5} = "ahh[1]{4}{5}";
	ahh[2]{6}{7} = "ahh[2]{6}{7}";
	i = 0;
	foreach (hh in ahh) {
		foreach (k1=>h in hh) {
			foreach (k2=>vs in h) {
				unless (ahh[i]{k1}{k2} eq vs) printf("bad 7\n");
				unless (hh{k1}{k2} eq vs) printf("bad 8\n");
				unless (h{k2} eq vs) printf("bad 9\n");
			printf("ahh[%d]{%d}{%d} = '%s'\n", i, k1, k2,
			       ahh[i]{k1}{k2});
			}
		}
		++i;
	}

	haa{0}[0][0] = "haa{0}[0][0]";
	haa{0}[1][0] = "haa{0}[1][0]";
	haa{1}[0][0] = "haa{1}[0][0]";
	haa{2}[0][1] = "haa{2}[0][1]";
	foreach (ki=>aa in haa) {
		i = 0;
		foreach (a in aa) {
			j = 0;
			foreach (vs in a) {
				unless (haa{ki}[i][j] eq vs) printf("bad 10\n");
				unless (aa[i][j] eq vs) printf("bad 11\n");
				unless (a[j] eq vs) printf("bad 12\n");
				printf("haa{%d}[%d][%d] = '%s'\n", ki, i, j,
				       haa{ki}[i][j]);
				++j;
			}
			++i;
		}
	}

	hha{0}{1}[0] = "hha{0}{1}[0]";
	hha{2}{3}[0] = "hha{2}{3}[0]";
	hha{4}{5}[1] = "hha{4}{5}[1]";
	hha{6}{7}[2] = "hha{6}{7}[2]";
	foreach (k1=>ha in hha) {
		foreach (k2=>a in ha) {
			i = 0;
			foreach (vs in a) {
				unless (hha{k1}{k2}[i] eq vs) printf("bad13\n");
				unless (ha{k2}[i] eq vs) printf("bad 14n");
				unless (a[i] eq vs) printf("bad 15\n");
				printf("hha{%d}{%d}[%d] = '%s'\n", k1, k2, i,
				       hha{k1}{k2}[i]);
				++i;
			}
		}
	}

	hah{0}[0]{0} = "hah{0}[0]{0}";
	hah{1}[0]{2} = "hah{1}[0]{2}";
	hah{3}[1]{4} = "hah{3}[1]{4}";
	hah{5}[2]{6} = "hah{5}[2]{6}";
	foreach (k1=>ah in hah) {
		i = 0;
		foreach (h in ah) {
			foreach (k2=>vs in h) {
				unless (hah{k1}[i]{k2} eq vs) printf("bad16\n");
				unless (ah[i]{k2} eq vs) printf("bad 17\n");
				unless (h{k2} eq vs) printf("bad 18\n");
				printf("hah{%d}[%d]{%d} = '%s'\n", k1, i, k2,
				       hah{k1}[i]{k2});
			}
			++i;
		}
	}

	printf("end\n");
}

#lang tcl
deep_1_4
} -output {start
ah[0]{0} = 'ah[0]{0}'
ah[2]{0} = 'ah[2]{0}'
ah[2]{1} = 'ah[2]{1}'
ha{0}[0] = 'ha{0}[0]'
ha{0}[1] = 'ha{0}[1]'
ha{1}[0] = ''
ha{1}[1] = 'ha{1}[1]'
aah[0][0]{0} = 'aah[0][0]{0}'
aah[0][1]{1} = 'aah[0][1]{1}'
aah[1][0]{2} = 'aah[1][0]{2}'
aah[1][0]{3} = 'aah[1][0]{3}'
aha[0]{0}[0] = 'aha[0]{0}[0]'
aha[0]{1}[0] = ''
aha[0]{1}[1] = 'aha[0]{1}[1]'
aha[0]{3}[0] = ''
aha[0]{3}[1] = ''
aha[0]{3}[2] = 'aha[0]{3}[2]'
aha[1]{2}[0] = 'aha[1]{2}[0]'
ahh[0]{0}{1} = 'ahh[0]{0}{1}'
ahh[0]{2}{3} = 'ahh[0]{2}{3}'
ahh[1]{4}{5} = 'ahh[1]{4}{5}'
ahh[2]{6}{7} = 'ahh[2]{6}{7}'
haa{0}[0][0] = 'haa{0}[0][0]'
haa{0}[1][0] = 'haa{0}[1][0]'
haa{1}[0][0] = 'haa{1}[0][0]'
haa{2}[0][0] = ''
haa{2}[0][1] = 'haa{2}[0][1]'
hha{0}{1}[0] = 'hha{0}{1}[0]'
hha{2}{3}[0] = 'hha{2}{3}[0]'
hha{4}{5}[0] = ''
hha{4}{5}[1] = 'hha{4}{5}[1]'
hha{6}{7}[0] = ''
hha{6}{7}[1] = ''
hha{6}{7}[2] = 'hha{6}{7}[2]'
hah{0}[0]{0} = 'hah{0}[0]{0}'
hah{1}[0]{2} = 'hah{1}[0]{2}'
hah{3}[1]{4} = 'hah{3}[1]{4}'
hah{5}[2]{6} = 'hah{5}[2]{6}'
end
}

test deep-2.1 {deep dive array auto-extend} -body {
#lang L
void
deep_2_1()
{
	int	i, j;
	int	a1[];
	int	a2[];
	int	aa1[][];
	int	aa2[][];

	/*
	 * Test that arrays auto-extend properly.
	 */

	a1[0] = 0;
	a1[1] = 1;
	a1[2] = 2;
	unless ((a1[0] == 0) && (a1[1] == 1) && (a1[2] == 2)) {
		puts("a1 bad 1");
	}
	if (defined(a1[3])) puts("a1 bad 2");

	a2[1]  = 1;
	a2[3]  = 3;
	a2[6]  = 6;
	a2[10] = 10;
	unless ((a2[1] == 1) && (a2[3] == 3) && (a2[6] == 6) && (a2[10] == 10)) {
		puts("a2 bad 1");
	}
	if (defined(a2[0])) puts("a2 bad 2");
	if (defined(a2[2])) puts("a2 bad 3");
	if (defined(a2[4])) puts("a2 bad 4");
	if (defined(a2[5])) puts("a2 bad 5");
	if (defined(a2[7])) puts("a2 bad 6");
	if (defined(a2[8])) puts("a2 bad 7");
	if (defined(a2[9])) puts("a2 bad 8");
	if (defined(a2[11])) puts("a2 bad 9");

	aa1[0][0] = 100;
	aa1[0][1] = 101;
	aa1[0][2] = 102;
	aa1[1][0] = 110;
	aa1[1][1] = 111;
	aa1[2][0] = 120;
	unless ((aa1[0][0] == 100) && (aa1[0][1] == 101) && (aa1[0][2] == 102) &&
		(aa1[1][0] == 110) && (aa1[1][1] == 111) && (aa1[2][0] == 120)) {
		puts("aa1 bad 1");
	}
	if (defined(aa1[0][3])) puts("aa1 bad 2");
	if (defined(aa1[1][3])) puts("aa1 bad 3");
	if (defined(aa1[2][1])) puts("aa1 bad 4");

	aa2[1][1]   = 111;
	aa2[3][3]   = 133;
	aa2[6][6]   = 166;
	aa2[10][10] = 1010;
	unless ((aa2[1][1] == 111) && (aa2[3][3] == 133) && (aa2[6][6] == 166) &&
		(aa2[10][10] == 1010)) {
		puts("aa2 bad 2");
	}
	for (i = 0; i <= 10; ++i) {
		for (j = 0; j <= i; ++j) {
			if ((i == 1)  && (j == 1))  continue;
			if ((i == 3)  && (j == 3))  continue;
			if ((i == 6)  && (j == 6))  continue;
			if ((i == 10) && (j == 10)) continue;
			if (defined(aa2[i][j])) printf("aa2[%d][%d] defined\n",
						       i, j);
		}
	}
}
#lang tcl
deep_2_1
} -output ""

test deep-2.2 {check that a negative array index is an error} -body {
#lang L
void
deep_2_2()
{
	int	a[3];
	a[-1] = 0;
}
#lang tcl
deep_2_2
} -returnCodes error -match regexp -result {cannot write to negative array index}

test deep-2.3 {check deep-dive element create/read} -body {
#lang L
void
deep_2_3()
{
	/*
	 * This checks that an op= works on an undefined deep-dive
	 * element.  A string substitute is the only one we can test;
	 * because undef isn't a valid integer, ++a[0] would cause a
	 * run-time error that you can't use "" in a + operation.
	 */

	string	a[];
	string	h{string};

	h{"undefined"} =~ s//ShouldWork/;
	unless (h{"undefined"} eq "ShouldWork") puts("bad 1");

	a[0] =~ s//ShouldWork/;
	unless (a[0] eq "ShouldWork") puts("bad 2");
}
#lang tcl
deep_2_3
} -output {}

test regexp-1.0 {regular expression support} -body {
#lang L
void regexp_1_0() {
        string s = "string";
        puts(s =~ /ring/);
        puts(s =~ /bob/);
}
#lang tcl
regexp_1_0
} -output "1\n0\n"

test regexp-1.1 {magic submatch variables ($1, $2, ...)} -body {
#lang L
void regexp_1_1() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";

        if (s =~ /((Go).*(elves)).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_1
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"


test regexp-1.2 {magic submatch variables with interpolation} -body {
#lang L
void regexp_1_2() {
        string s = "Go not to the elves for counsel, for they will say both yes and no.";
        string interp = "elves";

        if (s =~ /((Go).*(${interp})).*/) {
                puts($0);
                puts($1);
                puts($2);
                puts($3);
        }
}
#lang tcl
regexp_1_2
} -output "Go not to the elves for counsel, for they will say both yes and no.
Go not to the elves\nGo\nelves\n"

test regexp-1.3 {regexp substitution} -body {
#lang L -poly
void regexp_1_3() {
        string s = "string";
	string s1[] = {"a", "b", "coochie"};
	hash h[2];

        puts(s =~ m/ring/);
        puts(s =~ m|bob|);
	puts("--------");
	puts(s =~ s/ring/ling/);
	puts(s);
	puts("--------");
	puts(s1[2] =~ s/c/f/);
	puts(s1);
	puts("--------");
	h[0]{"a"} = "string";
	h[1]{"m"} = "not a string";
	puts(h);
	h[1]{"m"} =~ s/not a/probably a/;
	puts(h);
}
#lang tcl
regexp_1_3
} -output "1\n0\n--------\n1\nstling\n--------\n1\na b foochie\n--------\n{a string} {m {not a string}}\n{a string} {m {probably a string}}\n"

test regexp-1.4 {regexp modifiers i and g} -body {
#lang L -poly
void regexp_1_4() {
	string foo = "aaa";
	foo =~ s/a/b/;
	puts(foo);
	foo =~ s/a/b/g;
	puts(foo);
	foo =~ s/B/a/;
	puts(foo);
	foo =~ s/B/a/i;
	puts(foo);
	foo =~ s/B/a/ig;
	puts(foo);
	if (foo =~ /A/) {
		puts("busted");
	}
	if (foo =~ /A/i) {
		puts("works");
	}
}
#lang tcl
regexp_1_4
} -output "baa\nbbb\nbbb\nabb\naaa\nworks\n"

test regexp-1.5 {regexp quoting} -body {
#lang L
void
regexp_1_5()
{
	string	r, s;

	s = "a b c d";
	s =~ s/\s//;
	unless (s eq "ab c d") puts("bad 1");

	s = "a  b    c     d";
	s =~ s/\s+//g;
	unless (s eq "abcd") puts("bad 2");

	r = "\\s+";
	s = "a  b    c     d";
	s =~ s/${r}//g;
	unless (s eq "abcd") puts("bad 3");

	r = "\\s+";
	s = "a  b    c     d";
	s =~ s/\${r}//g;
	unless (s eq "a  b    c     d") puts("bad 4");

	s = "$a$b";
	s =~ s/\$//g;  // should match a dollar sign
	unless (s eq "ab") puts("bad 5");

 	r = "\\s+";
	s = '${r} ${r}';
	s =~ s/\${r}//g;  // should match '${r}' literally
	unless (s eq " ") puts("bad 6");

	s = "(in parens)";
	s =~ s/\(//;
	unless (s eq "in parens)") puts("bad 7");
	s =~ s/(in)//;
	unless (s eq " parens)") puts("bad 8");
}
#lang tcl
regexp_1_5
} -output ""

test reference-1.0 {L references} -body {
#lang L -nowarn
void reference_1_0() {
  string foo = "this is a string";
  printf("so far, so good: %s\n", foo);
  reference_1_0_aux("bleh", &foo);
  printf("%s\n", foo);
}

void reference_1_0_aux(string dummy, string &bob) {
  printf("foot: %s\n", bob);
  bob = "This was a string.";
}
#lang tcl
reference_1_0
} -output "so far, so good: this is a string
foot: this is a string
This was a string.
"

test reference-1.1 {L references} -body {
#lang L
struct reference_1_1_point { int x, y; };

void reference_1_1() {
  struct reference_1_1_point a;
  puts(a);
  reference_1_1_tweak(&a);
  puts(a);
}

void reference_1_1_tweak(struct reference_1_1_point &foo) {
  foo.x = 2;
}
#lang tcl
reference_1_1
} -output "
2
"
test reference-1.2 {widget pointer thingys} -body {
#lang L
int
reference_1_2()
{
	int	a;

	a = 5;
	printf("%s %s\n", variable: &a);
	eval("puts [set ::Lptr::[list 1 a]]");
}
#lang tcl
reference_1_2
} -output "-variable ::Lptr::1 a\n5\n"

test reference-1.3 {widget pointers via the Lptr namespace} -body {
#lang L
void reference_1_3()
{
  int reference_1_3_foo = 0;
  printf("%s, %s\n", variable: &reference_1_3_foo);
  eval("set {::Lptr::1 reference_1_3_foo} 93");
  puts(reference_1_3_foo);
}
#lang tcl
reference_1_3
} -output "-variable, ::Lptr::1 reference_1_3_foo\n93\n"

test typedef-1.0 {basic typedef support} -body {
#lang L
typedef int typedef_1_0_foot[5];
typedef string typedef_1_0_nike;
typedef struct typedef_1_0_point {
  int x;
  int y;
} typedef_1_0_point;

void typedef_1_0() {
  puts(typedef_1_0_aux());
}

typedef_1_0_nike typedef_1_0_aux() {
  typedef_1_0_foot cheese;
  typedef_1_0_nike shoe = "pegasus";
  typedef_1_0_point p;

  p.x = 1;
  p.y = 2;
  puts(p);
  cheese[2] = 1;
  cheese[3] = 2;
  cheese[4] = 3;
  puts(cheese[3]);
  puts(shoe);
  return shoe;
}
#lang tcl
typedef_1_0
} -output "1 2\n2\npegasus\npegasus\n"

test typedef-1.1 {test redefining identical typedefs} -body {
#lang L
typedef int t1;
typedef int t1;
typedef int t1;

typedef float t2;
typedef float t2;
typedef float t2;

typedef string t3;
typedef string t3;
typedef string t3;

typedef widget t4;
typedef widget t4;
typedef widget t4;

typedef poly t5;
typedef poly t5;
typedef poly t5;

typedef int a11_1[];
typedef int a11_1[];
typedef int a11_1[];

typedef int a11_2[2];
typedef int a11_2[2];
typedef int a11_2[2];

typedef int a11_3{int};
typedef int a11_3{int};
typedef int a11_3{int};

typedef int a11_4[2][3];
typedef int a11_4a[3];
typedef a11_4a a11_4[2];

typedef struct { int x,y; } s11_1;
typedef struct { int x,y; } s11_1;
typedef struct { int x,y; } s11_1;

typedef int int_typedef;

typedef int h11_1{int};
typedef int h11_1{int_typedef};
typedef int_typedef h11_1{int};
typedef int_typedef h11_1{int_typedef};

typedef int h11_2{int}{int};
typedef int h11_2a{int};
typedef h11_2a h11_2{int};
} -output ""

test typedef-1.2 {test redefining different typedefs} -body {
#lang L
typedef int t12;
typedef float t12;
typedef string t12;
typedef widget t12;
typedef poly t12;     // not an error, but perhaps should be
typedef int t12[];
typedef int t12[2];
typedef int t12{int};
typedef struct { int i; } t12;

typedef int a12_1[];  // not an error -- array size is ignored
typedef int a12_1[2];

typedef int a12_2[2]; // not an error -- array size is ignored
typedef int a12_2[];

typedef int a12_3[2];
typedef string a12_3[2];

typedef int h12_1{int};
typedef int h12_1{string};

typedef int h12_2{int};
typedef string h12_2{int};

typedef int h12_3{int};
typedef string h12_3{string};

typedef struct { int x; } s12_1;
typedef struct { string x; } s12_1;

typedef struct { int x; } s12_2;
typedef struct { int x,y; } s12_2;

typedef struct { int x,y; } s12_3;
typedef struct { int x; } s12_3;

typedef struct s1 { int x; } s12_4;
typedef struct s2 { string x; } s12_4;

typedef struct s3 { int x; } s12_5;
typedef struct s4 { int x,y; } s12_5;

typedef struct s5 { int x,y; } s12_6;
typedef struct s6 { int x; } s12_6;
} -returnCodes error -match regexp -result {.*2: L Error: Cannot redefine type t12
.*3: L Error: Cannot redefine type t12
.*4: L Error: Cannot redefine type t12
.*6: L Error: Cannot redefine type t12
.*7: L Error: Cannot redefine type t12
.*8: L Error: Cannot redefine type t12
.*9: L Error: Cannot redefine type t12
.*18: L Error: Cannot redefine type a12_3
.*21: L Error: Cannot redefine type h12_1
.*24: L Error: Cannot redefine type h12_2
.*27: L Error: Cannot redefine type h12_3
.*30: L Error: Cannot redefine type s12_1
.*33: L Error: Cannot redefine type s12_2
.*36: L Error: Cannot redefine type s12_3
.*39: L Error: Cannot redefine type s12_4
.*42: L Error: Cannot redefine type s12_5
.*45: L Error: Cannot redefine type s12_6
}

test typedef-1.3 {test some typedef cases} -body {
#lang L
/*
 * This is really a regression test.  These have caused errors in the past.
 */
typedef int	int_t;
typedef int	h1_t{int_t};
typedef int_t	h2_t{int};
typedef int_t	h3_t{int_t};
void typedef_1_3()
{
	int	k, n;
	h1_t	h1 = { 1=>2 };
	h2_t	h2 = { 3=>4, 5=>6 };
	h3_t	h3 = { 7=>8, 9=>10, 11=>12 };

	unless (h1{1} == 2) puts("bad 1");
	n = 0;
	foreach (k in h1) ++n;
	unless (n == 1) puts("bad 2");

	unless ((h2{3} == 4) && (h2{5} == 6)) puts("bad 3");
	n = 0;
	foreach (k in h2) ++n;
	unless (n == 2) puts("bad 4");

	unless ((h3{7} == 8) && (h3{9} == 10) && (h3{11} == 12)) puts("bad 4");
	n = 0;
	foreach (k in h3) ++n;
	unless (n == 3) puts("bad 5");
}
#lang tcl
typedef_1_3
} -output {}

test typedef-1.4 {test another typedef case} -body {
#lang L
/* Another regression test.  This used to fail. */
typedef struct {
	int x;
	int y;
} typedef_1_4_t;

typedef_1_4_t typedef_1_4_bars{string};

void typedef_1_4_foo(typedef_1_4_t f)
{
	typedef_1_4_bars{"FOO"} = f;
	puts("X = ${f.x}");
}

void typedef_1_4()
{
	typedef_1_4_t	f = { 1, 2 };
	typedef_1_4_foo(f);
}
#lang tcl
typedef_1_4
} -output {X = 1
}


test defined-1.0 {interesting defined form support} -body {
#lang L
void defined_1_0() {
  int arr[5][2], i, j;
  for (i = 0; defined(arr[i]); i++) {
    for (j = 0; defined(arr[i][j]); j++) {
      puts(format("%d, %d", i, j));
    }
  }
  puts("-*-");
  puts(defined(arr[3]));
  puts(defined(arr[-1]));
}
#lang tcl
defined_1_0
} -output "-*-
0
0
"

test defined-1.1 {defined works on hashes} -body {
#lang L
void defined_1_1() {
	hash foo[5];

	foo[2]{"a"} = 1;
	foo[3]{"b"} = 2;
	
	if (defined(foo[2]{"a"})) {
		puts("defined works");
	}
	if (!defined(foo[2]{"b"})) {
		puts("defined works even better");
	}
}
#lang tcl
defined_1_1
} -output "defined works\ndefined works even better\n"

test main-1.0 {test that main gets called} -setup {
	set fname [makeFile {
		void main() {
			printf("main got called\n");
		}
	} test-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile test-1.0.l
} -result {main got called}

test defined-1.2 {defined operator on scalars} -body {
#lang L
int d12_fint() { return 0; }
float d12_ffloat() { return 0.0; }
string d12_fstring() { return "0"; }
void
defined_1_2()
{
	int	i;
	int	ii = 0;
	string	s;
	string	ss = "";
	float	f;
	float	ff = 3.14159;

	unless (defined(i))  puts("err 1");
	unless (defined(ii)) puts("err 2");
	unless (defined(s))  puts("err 3");
	unless (defined(ss)) puts("err 4");
	unless (defined(f))  puts("err 5");
	unless (defined(ff)) puts("err 6");
	unless (defined(0))  puts("err 7");
	unless (defined(1))  puts("err 7");
	unless (defined("")) puts("err 8");
	unless (defined("x")) puts("err 9");
	unless (defined(0.0)) puts("err 10");
	unless (defined(1.0)) puts("err 11");
	unless (defined(d12_fint()))    puts("err 12");
	unless (defined(d12_ffloat()))  puts("err 13");
	unless (defined(d12_fstring())) puts("err 14");
	unless (defined(1-0))     puts("err 16");
	unless (defined(1+2+3+4)) puts("err 17");
}
#lang tcl
defined_1_2
} -output ""

test defined-1.3 {defined operator on auto-extended arrays} -body {
#lang L
void
defined_1_3()
{
	int	i;
	int	a[];
	int	a3[3] = {0, 0, 0};
	string	s[];
	string	s3[3] = {"", "", ""};
	float	f[];
	float	f3[3] = {0.0, 0.0, 0.0};
	string	h{int}[];

	a[3] = 3;
	a[5] = 5;
	a[6] = 6;
	a[8] = 8;
	if (defined(a[0]))     puts("err 1.1");
	if (defined(a[1]))     puts("err 1.2");
	if (defined(a[2]))     puts("err 1.3");
	unless (defined(a[3])) puts("err 1.4");
	if (defined(a[4]))     puts("err 1.5");
	unless (defined(a[5])) puts("err 1.6");
	unless (defined(a[6])) puts("err 1.7");
	if (defined(a[7]))     puts("err 1.8");
	unless (defined(a[8])) puts("err 1.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(a[i])) printf("err 1.10 i=%d\n", i);
	}

	unless (defined(a3[0])) puts("err 2.1");
	unless (defined(a3[1])) puts("err 2.2");
	unless (defined(a3[2])) puts("err 2.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(a3[i])) printf("err 2.4 i=%d\n", i);
	}

	s[3] = "3";
	s[5] = "5";
	s[6] = "6";
	s[8] = "8";
	if (defined(s[0]))     puts("err 3.1");
	if (defined(s[1]))     puts("err 3.2");
	if (defined(s[2]))     puts("err 3.3");
	unless (defined(s[3])) puts("err 3.4");
	if (defined(s[4]))     puts("err 3.5");
	unless (defined(s[5])) puts("err 3.6");
	unless (defined(s[6])) puts("err 3.7");
	if (defined(s[7]))     puts("err 3.8");
	unless (defined(s[8])) puts("err 3.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(s[i])) printf("err 3.10 i=%d\n", i);
	}

	unless (defined(s3[0])) puts("err 4.1");
	unless (defined(s3[1])) puts("err 4.2");
	unless (defined(s3[2])) puts("err 4.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(s3[i])) printf("err 4.4 i=%d\n", i);
	}

	f[3] = 3.0;
	f[5] = 5.0;
	f[6] = 6.0;
	f[8] = 8.0;
	if (defined(f[0]))     puts("err 5.1");
	if (defined(f[1]))     puts("err 5.2");
	if (defined(f[2]))     puts("err 5.3");
	unless (defined(f[3])) puts("err 5.4");
	if (defined(f[4]))     puts("err 5.5");
	unless (defined(f[5])) puts("err 5.6");
	unless (defined(f[6])) puts("err 5.7");
	if (defined(f[7]))     puts("err 5.8");
	unless (defined(f[8])) puts("err 5.9");
	for (i = 9; i < 1000; ++i) {
		if (defined(f[i])) printf("err 5.10 i=%d\n", i);
	}

	unless (defined(f3[0])) puts("err 5.1");
	unless (defined(f3[1])) puts("err 5.2");
	unless (defined(f3[2])) puts("err 5.3");
	for (i = 3; i < 1000; ++i) {
		if (defined(f3[i])) printf("err 5.4 i=%d\n", i);
	}

	h{0}[2] = "2";
	if (defined(h{0}[0]))     puts("err 6.1");
	if (defined(h{0}[1]))     puts("err 6.2");
	unless (defined(h{0}[2])) puts("err 6.3");
	if (defined(h{0}[3]))     puts("err 6.4");
}
#lang tcl
defined_1_3
} -output ""

test defined-1.4 {check propagation of undefined values} -body {
#lang L
int
d14(int i)
{
	return (i);
}
void
defined_1_4()
{
	int	i, j;
	int	a[];

	a[1] = 1;  // a[0] is now undefined
	i = a[0];  // i is now undefined
	j = d14(i);  // j is now undefined

	if (defined(a[0])) puts("err 1");
	if (defined(i)) puts("err 2");
	if (defined(j)) puts("err 3");
	if (defined(d14(i))) puts("err 4");
	if (defined(d14(j))) puts("err 5");
	if (defined(d14(d14(j)))) puts("err 6");
	if (defined(d14(d14(d14(j))))) puts("err 7");
}
#lang tcl
defined_1_4
} -output ""


test lib-1.0 {L library functions -- setenv, getenv, and unsetenv} -body {
#lang L
void lib_1_0() {
	puts("don't overwrite");
	setenv("PATH", "nil", 0);
	if (getenv("PATH") ne "nil") {
		puts("worked");
	}
	puts("overwrite");
	setenv("PATH", "nil");
	if (getenv("PATH") eq "nil") {
		puts("worked");
	}
	puts("unset");
	unsetenv("PATH");
	if (getenv("PATH") eq "") {
		puts("worked");
	}
}
#lang tcl
lib_1_0
} -output {don't overwrite
worked
overwrite
worked
unset
worked
}

test toplevel-1.0 {Toplevel code in L} -body {
#lang L
int toplevel_1_0_i = 2;
printf("at the toplevel, i is: %d\n", toplevel_1_0_i);

void toplevel_1_0(void) {
  printf("in toplevel_1_0, i is: %d\n", toplevel_1_0_i);
}
#lang tcl
toplevel_1_0
} -output {at the toplevel, i is: 2
in toplevel_1_0, i is: 2
}

test toplevel-1.1 {Toplevel code via the L command, sharing variables} -body {
L { puts("Accent on helpful side of your nature.  Drain the moat."); }
proc toplevel_1_1 {} {
    set v 2
    L {
        string v = "Sphenic numbers always have exactly eight divisors.";
    }
    puts $v
}
toplevel_1_1
} -output {Accent on helpful side of your nature.  Drain the moat.
Sphenic numbers always have exactly eight divisors.
}

test typecheck-1.0 {L typechecking} -body {
#lang L
string typecheck_1_0_foo() {
	return "string";
}

void typecheck_1_0() {
	puts(typecheck_1_0_foo() + 22);
}
#lang tcl
typecheck_1_0
} -returnCodes {error} -match glob \
-result "*:6: L Error: expected type int or float but got string*\n"

test typecheck-1.1 {arity check} -body {
#lang L -nowarn
void typecheck_1_1_foo() {}
void typecheck_1_1_bar(int a, int b) {}
void typecheck_1_1() {
	typecheck_1_1_foo(1, 2, 3);
	typecheck_1_1_bar();
}
#lang tcl
} -returnCodes {error} -match glob \
-result "*:4: L Error: too many arguments for function typecheck_1_1_foo
*:5: L Error: not enough arguments for function typecheck_1_1_bar\n"

test typecheck-1.2 {check functions returning int arrays of arrays} -body {
#lang L
int[]
typecheck_1_2_int()
{
	int	i, a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = i;
	}
	return a;
}
int[][]
typecheck_1_2_int_int()
{
	int	i, j, a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = 10*i + j;
		}
	}
	return a;
}
int[][][]
typecheck_1_2_int_int_int()
{
	int	i, j, k, a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = 100*i + 10*j + k;
			}
		}
	}
	return a;
}
void
typecheck_1_2()
{
	int	i, j, k;
	int	one[3];
	int	two[3][4];
	int	three[3][4][5];

	one   = typecheck_1_2_int();
	two   = typecheck_1_2_int_int();
	three = typecheck_1_2_int_int_int();

	for (i = 0; i < 3; ++i) {
		unless (one[i] == i) {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] == (10*i + j)) {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] == (100*i + 10*j + k)) {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_2();
} -output {}

test typecheck-1.3 {check functions returning float arrays of arrays} -body {
#lang L
float[]
typecheck_1_3_float()
{
	int	i;
	float	a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = i;
	}
	return a;
}
float[][]
typecheck_1_3_float_float()
{
	int	i, j;
	float	a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = 10.0*i + j;
		}
	}
	return a;
}
float[][][]
typecheck_1_3_float_float_float()
{
	int	i, j, k;
	float	a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = 100.0*i + 10.0*j + k;
			}
		}
	}
	return a;
}
void
typecheck_1_3()
{
	int	i, j, k;
	float	one[3];
	float	two[3][4];
	float	three[3][4][5];

	one   = typecheck_1_3_float();
	two   = typecheck_1_3_float_float();
	three = typecheck_1_3_float_float_float();

	/*
	 * Although testing equality of floats is usually unwise,
	 * there should be sufficient precision in this case to make
	 * the comparisons true when they should be.
	 */
	for (i = 0; i < 3; ++i) {
		unless (one[i] == i) {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] == (10.0*i + j)) {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] == (100.0*i+10.0*j+k)) {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_3();
} -output {}

test typecheck-1.4 {check functions returning string arrays of arrays} -body {
#lang L
string[]
typecheck_1_4_string()
{
	int	i;
	string	a[3];

	for (i = 0; i < 3; ++i) {
		a[i] = "${i}";
	}
	return a;
}
string[][]
typecheck_1_4_string_string()
{
	int	i, j;
	string	a[3][4];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			a[i][j] = "${i}:${j}";
		}
	}
	return a;
}
string[][][]
typecheck_1_4_string_string_string()
{
	int	i, j, k;
	string	a[3][4][5];

	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				a[i][j][k] = "${i}:${j}:${k}";
			}
		}
	}
	return a;
}
void
typecheck_1_4()
{
	int	i, j, k;
	string	one[3];
	string	two[3][4];
	string	three[3][4][5];

	one   = typecheck_1_4_string();
	two   = typecheck_1_4_string_string();
	three = typecheck_1_4_string_string_string();

	for (i = 0; i < 3; ++i) {
		unless (one[i] eq "${i}") {
			printf("one: i=%d bad\n", i);
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			unless (two[i][j] eq "${i}:${j}") {
				printf("two: i=%d j=%d bad\n", i, j);
			}
		}
	}
	for (i = 0; i < 3; ++i) {
		for (j = 0; j < 4; ++j) {
			for (k = 0; k < 5; ++k) {
				unless (three[i][j][k] eq "${i}:${j}:${k}") {
					printf("three: i=%d j=%d k=%d bad\n",
					       i, j, k);
				}
			}
		}
	}
}
typecheck_1_4();
} -output {}

test typecheck-1.5 {check functions returning void arrays are illegal} -body {
#lang L
void[] typecheck_1_5() { return; }
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal.*
}

test typecheck-2.1 {check int-to-float casts and coercions} -body {
#lang L
float
typecheck_2_1_return_float(float f)
{
	return f;
}

float
typecheck_2_1_sum_three_floats(float f1, float f2, float f3)
{
	return f1 + f2 + f3;
}

void
typecheck_2_1()
{
	/*
	 * Exact comparisons with floats must be done with care.  Keep
	 * the precision of the numbers low so there is sufficient
	 * precision for the variable comparisons to be true when
	 * intended.
	 */

	/* Test initializers and all comparison ops that allow floats. */

	int	i2, i1 = 1964;
	float	f2, f1 = i1;

	unless (f1 == 1964)        puts("BAD 1.1.1");
	unless (1964 == f1)        puts("BAD 1.1.2");
	unless (f1 == 1964.0)      puts("BAD 1.1.3");
	unless (1964.0 == f1)      puts("BAD 1.1.4");
	unless (f1 == (float)1964) puts("BAD 1.1.5");
	unless ((float)1964 == f1) puts("BAD 1.1.6");
	unless (f1 == (float)i1)   puts("BAD 1.1.7");
	unless ((float)i1 == f1)   puts("BAD 1.1.8");
	unless (f1 == i1)          puts("BAD 1.1.9");
	unless (i1 == f1)          puts("BAD 1.1.10");

	unless (f1 >= 1964)        puts("BAD 1.2.1");
	unless (1964 >= f1)        puts("BAD 1.2.2");
	unless (f1 >= 1964.0)      puts("BAD 1.2.3");
	unless (1964.0 >= f1)      puts("BAD 1.2.4");
	unless (f1 >= (float)1964) puts("BAD 1.2.5");
	unless ((float)1964 >= f1) puts("BAD 1.2.6");
	unless (f1 >= (float)i1)   puts("BAD 1.2.7");
	unless ((float)i1 >= f1)   puts("BAD 1.2.8");
	unless (f1 >= i1)          puts("BAD 1.2.9");
	unless (i1 >= f1)          puts("BAD 1.2.10");

	unless (f1 <= 1964)        puts("BAD 1.3.1");
	unless (1964 <= f1)        puts("BAD 1.3.2");
	unless (f1 <= 1964.0)      puts("BAD 1.3.3");
	unless (1964.0 <= f1)      puts("BAD 1.3.4");
	unless (f1 <= (float)1964) puts("BAD 1.3.5");
	unless ((float)1964 <= f1) puts("BAD 1.3.6");
	unless (f1 <= (float)i1)   puts("BAD 1.3.7");
	unless ((float)i1 <= f1)   puts("BAD 1.3.8");
	unless (f1 <= i1)          puts("BAD 1.3.9");
	unless (i1 <= f1)          puts("BAD 1.3.10");

	unless (f1 != 1999)        puts("BAD 1.4.1");
	unless (1999 != f1)        puts("BAD 1.4.2");
	unless (f1 != 1999.0)      puts("BAD 1.4.3");
	unless (1999.0 != f1)      puts("BAD 1.4.4");
	unless (f1 != (float)1999) puts("BAD 1.4.5");
	unless ((float)1999 != f1) puts("BAD 1.4.6");
	unless (f1 != (float)i2)   puts("BAD 1.4.7");
	unless ((float)i2 != f1)   puts("BAD 1.4.8");
	unless (f1 != i2)          puts("BAD 1.4.9");
	unless (i2 != f1)          puts("BAD 1.4.10");

	/* Test assignments and all binary ops that allow floats. */

	i2 = 1965;
	f2 = i2;
	unless (f2 == 1965.0) puts("BAD 2.1");

	f2 = f2 + 1;
	unless (f2 == 1966.0) puts("BAD 2.2");

	f2 = f2 - 2;
	unless (f2 == 1964.0) puts("BAD 2.3");

	f2 = f2 / 2;
	unless (f2 == 982.0)  puts("BAD 2.4");

	f2 = f2 * 2;
	unless (f2 == 1964.0) puts("BAD 2.5");

	f2 = i2;
	f2 = 1 + f2;
	unless (f2 == 1966.0) puts("BAD 3.1");

	f2 = -2 + f2;
	unless (f2 == 1964.0) puts("BAD 3.2");

	f2 = f2 / 2;
	unless (f2 == 982.0)  puts("BAD 3.3");

	f2 = 2;
	f2 = 2 / f2;
	unless (f2 == 1.0)    puts("BAD 3.4");

	i2 = 1965;
	f2 = i2;
	f2 += 1;
	unless (f2 == 1966.0) puts("BAD 4.1");

	f2 -= 2;
	unless (f2 == 1964.0) puts("BAD 4.2");

	f2 /= 2;
	unless (f2 == 982.0)  puts("BAD 4.3");

	f2 *= 2;
	unless (f2 == 1964.0) puts("BAD 4.4");

	/* Test that int actuals coerce to a float when the formal is a float. */

	f2 = typecheck_2_1_return_float(1);
	unless (f2 == 1.0)    puts("BAD 5.1");

	i2 = 3;
	f2 = typecheck_2_1_return_float(i2);
	unless (f2 == 3.0)    puts("BAD 5.2");

	f2 = typecheck_2_1_sum_three_floats(1, 2, 3);
	unless (f2 = 6.0)     puts("BAD 5.3");

	i1 = 1;
	i2 = 3;
	f2 = typecheck_2_1_sum_three_floats(i1, i2, 3);
	unless (f2 = 6.0)     puts("BAD 5.4");
}
typecheck_2_1();
} -output ""

test typecheck-3.1 {void illegal in if-stmt conditional} -body {
#lang L
void typecheck_3_1_v() { return; }
void
typecheck_3_1()
{
	if (typecheck_3_1_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.2 {void illegal in unless-stmt conditional} -body {
#lang L
void typecheck_3_2_v() { return; }
void
typecheck_3_2()
{
	unless (typecheck_3_2_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.3 {void illegal in while-loop conditional} -body {
#lang L
void typecheck_3_3_v() { return; }
void
typecheck_3_3()
{
	while (typecheck_3_3_v()) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.4 {void illegal in do-loop conditional} -body {
#lang L
void typecheck_3_4_v() { return; }
void
typecheck_3_4()
{
	do {
		return;
	} while(typecheck_3_4_v());
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.5 {void illegal in for-loop conditional} -body {
#lang L
void typecheck_3_5_v() { return; }
void
typecheck_3_5()
{
	for (1; typecheck_3_5_v(); 1) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.6 {void illegal in abbreviated-for-loop conditional} -body {
#lang L
void typecheck_3_6_v() { return; }
void
typecheck_3_6()
{
	for (1; typecheck_3_6_v();) return;
}
} -returnCodes error -match regexp -result {void type illegal in predicate}

test typecheck-3.10 {void illegal in binary operators} -body {
#lang L
void t310v() { return; }
void
typecheck_3_10()
{
	int	i;

	if (t310v() && 0) return;
	if (0 && t310v()) return;
	if (t310v() || 0) return;
	if (0 || t310v()) return;
	if (t310v() =~ /bad/) return;
	if (t310v() eq "") return;
	if ("" eq t310v()) return;
	if (t310v() ne "") return;
	if ("" ne t310v()) return;
	if (t310v() gt "") return;
	if ("" gt t310v()) return;
	if (t310v() ge "") return;
	if ("" ge t310v()) return;
	if (t310v() lt "") return;
	if ("" lt t310v()) return;
	if (t310v() le "") return;
	if ("" le t310v()) return;
	if (t310v() == 0)  return;
	if (0 == t310v())  return;
	if (t310v() != 0)  return;
	if (0 != t310v())  return;
	if (t310v() > 0)   return;
	if (0 > t310v())   return;
	if (t310v() >= 0)  return;
	if (0 >= t310v())  return;
	if (t310v() < 0)   return;
	if (0 < t310v())   return;
	if (t310v() <= 0)  return;
	if (0 <= t310v())  return;
	i = t310v() + 1;
	i = 1 + t310v();
	i = t310v() - 1;
	i = 1 - t310v();
	i = t310v() * 1;
	i = 1 * t310v();
	i = t310v() / 1;
	i = 1 / t310v();
	i = t310v() % 1;
	i = 1 % t310v();
	i = t310v() & 1;
	i = 1 & t310v();
	i = t310v() | 1;
	i = 1 | t310v();
	i = t310v() ^ 1;
	i = 1 ^ t310v();
	i = t310v() << 1;
	i = 1 << t310v();
	i = t310v() >> 1;
	i = 1 >> t310v();
}
} -returnCodes error -match regexp -result {.*7: L Error: void type illegal in predicate
.*8: L Error: void type illegal in predicate
.*9: L Error: void type illegal in predicate
.*10: L Error: void type illegal in predicate
.*11: L Error: expected type.*but got void in =~
.*12: L Error: expected type.*but got void in string comparison
.*13: L Error: expected type.*but got void in string comparison
.*14: L Error: expected type.*but got void in string comparison
.*15: L Error: expected type.*but got void in string comparison
.*16: L Error: expected type.*but got void in string comparison
.*17: L Error: expected type.*but got void in string comparison
.*18: L Error: expected type.*but got void in string comparison
.*19: L Error: expected type.*but got void in string comparison
.*20: L Error: expected type.*but got void in string comparison
.*21: L Error: expected type.*but got void in string comparison
.*22: L Error: expected type.*but got void in string comparison
.*23: L Error: expected type.*but got void in string comparison
.*24: L Error: expected type.*but got void in arithmetic operator
.*25: L Error: expected type.*but got void in arithmetic operator
.*26: L Error: expected type.*but got void in arithmetic operator
.*27: L Error: expected type.*but got void in arithmetic operator
.*28: L Error: expected type.*but got void in arithmetic operator
.*29: L Error: expected type.*but got void in arithmetic operator
.*30: L Error: expected type.*but got void in arithmetic operator
.*31: L Error: expected type.*but got void in arithmetic operator
.*32: L Error: expected type.*but got void in arithmetic operator
.*33: L Error: expected type.*but got void in arithmetic operator
.*34: L Error: expected type.*but got void in arithmetic operator
.*35: L Error: expected type.*but got void in arithmetic operator
.*36: L Error: expected type.*but got void in arithmetic operator
.*37: L Error: expected type.*but got void in arithmetic operator
.*38: L Error: expected type.*but got void in arithmetic operator
.*39: L Error: expected type.*but got void in arithmetic operator
.*40: L Error: expected type.*but got void in arithmetic operator
.*41: L Error: expected type.*but got void in arithmetic operator
.*42: L Error: expected type.*but got void in arithmetic operator
.*43: L Error: expected type.*but got void in arithmetic operator
.*44: L Error: expected type.*but got void in arithmetic operator
.*45: L Error: expected type.*but got void in arithmetic operator
.*46: L Error: expected type.*but got void in arithmetic operator
.*47: L Error: expected type.*but got void in arithmetic operator
.*48: L Error: expected type.*but got void in arithmetic operator
.*49: L Error: expected type.*but got void in arithmetic operator
.*50: L Error: expected type.*but got void in arithmetic operator
.*51: L Error: expected type.*but got void in arithmetic operator
.*52: L Error: expected type.*but got void in arithmetic operator
.*53: L Error: expected type.*but got void in arithmetic operator
.*54: L Error: expected type.*but got void in arithmetic operator
.*55: L Error: expected type.*but got void in arithmetic operator
}

test typecheck-3.11 {void illegal in casts and unary operators} -body {
#lang L
void t311v() { return; }
void
typecheck_3_11()
{
	int	i;
	float	f;
	string	s;
	hash	h;

	i = (int)t311v();
	f = (float)t311v();
	s = (string)t311v();
	h = (hash)t311v();
	i = !t311v();
	i = ~t311v();
	i = +t311v();
	i = -t311v();
}
} -returnCodes error -match regexp -result {.*10: L Error: type void illegal
.*11: L Error: type void illegal
.*12: L Error: type void illegal
.*13: L Error: type void illegal
.*14: L Error: expected type int.*
.*15: L Error: expected type int.*
.*16: L Error: expected type int or float.*
.*17: L Error: expected type int or float.*
}

test typecheck-3.12 {void illegal in assignments} -body {
#lang L
void t312v() { return; }
int takes_int(int i) { return i; }
void
typecheck_3_12()
{
	int	i;

	i = t312v();
	i += t312v();
	i -= t312v();
	i /= t312v();
	i *= t312v();
	i %= t312v();
	i &= t312v();
	i |= t312v();
	i ^= t312v();
	i >>= t312v();
	i <<= t312v();
	takes_int(t312v());
}
} -returnCodes error -match regexp -result {.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal
.*11: L Error: type void illegal
.*12: L Error: type void illegal
.*13: L Error: type void illegal
.*14: L Error: type void illegal
.*15: L Error: type void illegal
.*16: L Error: type void illegal
.*17: L Error: type void illegal
.*18: L Error: type void illegal
.*19: L Error: parameter 1 has incompatible type
}

test typehceck-3.13 {void illegal as foreach expr} -body {
#lang L -nowarn
void t313v() { return; }
void
typecheck_3_13()
{
	int	k;

	foreach (k in t313v()) { }
}
} -returnCodes error -match regexp -result {.*Illegal foreach expression}

test typecheck-4.1 {type errors in foreach} -body {
#lang L
void
typecheck_4_1()
{
	int	vi;
	float	vf;
	string	vs;
	int	ai[2] = { 22, 23 };
	string	as[2] = { "b", "c" };
	float	af[2] = { 2.1, 2.2 };
	hash	h = { 1=>2, 2=>3 };

	foreach (vi in as) {}
	foreach (vi in af) {}
	foreach (vs in ai) {}
	foreach (vs in af) {}
	foreach (vf in as) {}
	foreach (vi,vi in h) {}
}
} -returnCodes error -match regexp -result {.*12: L Error: loop index type incompatible with array element type
.*13: L Error: loop index type incompatible with array element type
.*14: L Error: loop index type incompatible with array element type
.*15: L Error: loop index type incompatible with array element type
.*16: L Error: loop index type incompatible with array element type
.*17: L Error: multiple variables illegal in foreach over hash
}

test typecheck-4.2 {type errors in foreach with multiple variables} -body {
#lang L
void
typecheck_4_2()
{
	int	i1,i2,i3;
	float	f1,f2,f3;
	string	s1,s2,s3;
	int	ai[3] = { 22, 23, 24 };
	string	as[3] = { "b", "c", "d" };
	float	af[3] = { 2.1, 2.2, 2.3 };

	foreach (i1,s2,s3 in as) {}
	foreach (s1,i2,s3 in as) {}
	foreach (s1,s2,i3 in as) {}
	foreach (s1,i2,i3 in ai) {}
	foreach (i1,s2,i3 in ai) {}
	foreach (i1,i2,s3 in ai) {}
	foreach (s1,f2,f3 in af) {}
	foreach (f1,s2,f3 in af) {}
	foreach (f1,f2,s3 in af) {}

	/* Make sure that multiple type errors get caught. */
	foreach (i1,i2,s3 in as) {}
	foreach (i1,i2,i3 in as) {}
}
} -returnCodes error -match regexp -result {.*11: L Error: loop index type incompatible with array element type
.*12: L Error: loop index type incompatible with array element type
.*13: L Error: loop index type incompatible with array element type
.*14: L Error: loop index type incompatible with array element type
.*15: L Error: loop index type incompatible with array element type
.*16: L Error: loop index type incompatible with array element type
.*17: L Error: loop index type incompatible with array element type
.*18: L Error: loop index type incompatible with array element type
.*19: L Error: loop index type incompatible with array element type
.*22: L Error: loop index type incompatible with array element type
.*22: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
.*23: L Error: loop index type incompatible with array element type
}

test typecheck-4.3 {type errors in conditional expressions} -body {
#lang L
void
typecheck_4_3()
{
	/* Conditional expressions must be of scalar type. */

	int	a[];
	int	h{int};
	struct { int i,j; } st;

	if (a) puts("bad");
	if (h) puts("bad");
	if (st) puts("bad");
}
#lang tcl
} -returnCodes error -match regexp -result {.*10: L Error: predicate must be scalar
.*11: L Error: predicate must be scalar
.*12: L Error: predicate must be scalar
}

test typehceck-4.4 {scalars as condition expressions} -body {
#lang L
void
typecheck_4_4()
{
	/* These are all legal. */

	int	i = 0;
	float	f = 0.0;
	string	s1 = "0", s2 = "1";
	widget	w = "0";
	poly	p = "0";

	if (i) puts("bad 1");
	if (f) puts("bad 2");  // Exact comparisons w/floats don't always work

	/* Strings as conditionals get compared against "0". */
	if (s1) puts("bad 3");
	unless (s2) puts("bad 4");

	if (w) puts("bad 5");
	if (p) puts("bad 6");
}
#lang tcl
} -output {}

test typecheck-5.1 {type errors in hash elements} -body {
#lang L
struct st51 {
	int	x;
	int	y;
};
void
typecheck_5_1()
{
	int		a[3], i;
	string		s;
	float		f;
	poly		p;
	struct st51	st = {0,0};

	int		ihi{int};
	int		ihs{string};
	int		ihf{float};

	string		shi{int};
	string		shs{string};
	string		shf{float};

	float		fhi{int};
	float		fhs{string};
	float		fhf{float};

	poly		phi{int};
	poly		phs{string};
	poly		phf{float};

	ihi{1.1} = 0;	// These want an index of type int.
	ihi{"s"} = 0;
	ihi{st}  = 0;
	ihi{a}   = 0;
	ihi{shi} = 0;
	shi{1.1} = "s";
	shi{"s"} = "s";
	shi{st}  = "s";
	shi{a}   = "s";
	shi{shi} = "s";
	fhi{1.1} = 0.0;
	fhi{"s"} = 0.0;
	fhi{st}  = 0.0;
	fhi{a}   = 0.0;
	fhi{shi} = 0.0;
	phi{1.1} = 0.0;
	phi{"s"} = 0.0;
	phi{st}  = 0.0;
	phi{a}   = 0.0;
	phi{shi} = 0.0;
	i = ihi{1.1};
	i = ihi{"s"};
	i = ihi{st};
	i = ihi{a};
	i = ihi{shi};
	s = shi{1.1};
	s = shi{"s"};
	s = shi{st};
	s = shi{a};
	s = shi{shi};
	f = fhi{1.1};
	f = fhi{"s"};
	f = fhi{st};
	f = fhi{a};
	f = fhi{shi};
	p = phi{1.1};
	p = phi{"s"};
	p = phi{st};
	p = phi{a};
	p = phi{shi};
	ihs{1.1} = 0;	// These want an index of type string.
	ihs{0}   = 0;
	ihs{st}  = 0;
	ihs{a}   = 0;
	ihs{shi} = 0;
	shs{1.1} = "s";
	shs{0}   = "s";
	shs{st}  = "s";
	shs{a}   = "s";
	shs{shi} = "s";
	fhs{1.1} = 0.0;
	fhs{0}   = 0.0;
	fhs{st}  = 0.0;
	fhs{a}   = 0.0;
	fhs{shi} = 0.0;
	phs{1.1} = 0.0;
	phs{0}   = 0.0;
	phs{st}  = 0.0;
	phs{a}   = 0.0;
	phs{shi} = 0.0;
	i = ihs{1.1};
	i = ihs{0};
	i = ihs{st};
	i = ihs{a};
	i = ihs{shi};
	s = shs{1.1};
	s = shs{0};
	s = shs{st};
	s = shs{a};
	s = shs{shi};
	f = fhs{1.1};
	f = fhs{0};
	f = fhs{st};
	f = fhs{a};
	f = fhs{shi};
	p = phs{1.1};
	p = phs{0};
	p = phs{st};
	p = phs{a};
	p = phs{shi};
	ihf{"s"} = 0;	// These want an index of type float (but int is OK).
	ihf{st}  = 0;
	ihf{a}   = 0;
	ihf{shi} = 0;
	shf{"s"} = "s";
	shf{st}  = "s";
	shf{a}   = "s";
	shf{shi} = "s";
	fhf{"s"} = 0.0;
	fhf{st}  = 0.0;
	fhf{a}   = 0.0;
	fhf{shi} = 0.0;
	phf{"s"} = 0.0;
	phf{st}  = 0.0;
	phf{a}   = 0.0;
	phf{shi} = 0.0;
	i = ihf{"s"};
	i = ihf{st};
	i = ihf{a};
	i = ihf{shi};
	s = shf{"s"};
	s = shf{st};
	s = shf{a};
	s = shf{shi};
	f = fhf{"s"};
	f = fhf{st};
	f = fhf{a};
	f = fhf{shi};
	p = phf{"s"};
	p = phf{st};
	p = phf{a};
	p = phf{shi};
}
#lang tcl
typecheck_5_1
} -returnCodes error -match regexp -result {.*30: L Error: expected type int but got float in hash index
.*31: L Error: expected type int but got string in hash index
.*32: L Error: expected type int but got struct in hash index
.*33: L Error: expected type int but got array in hash index
.*34: L Error: expected type int but got hash in hash index
.*35: L Error: expected type int but got float in hash index
.*36: L Error: expected type int but got string in hash index
.*37: L Error: expected type int but got struct in hash index
.*38: L Error: expected type int but got array in hash index
.*39: L Error: expected type int but got hash in hash index
.*40: L Error: expected type int but got float in hash index
.*41: L Error: expected type int but got string in hash index
.*42: L Error: expected type int but got struct in hash index
.*43: L Error: expected type int but got array in hash index
.*44: L Error: expected type int but got hash in hash index
.*45: L Error: expected type int but got float in hash index
.*46: L Error: expected type int but got string in hash index
.*47: L Error: expected type int but got struct in hash index
.*48: L Error: expected type int but got array in hash index
.*49: L Error: expected type int but got hash in hash index
.*50: L Error: expected type int but got float in hash index
.*51: L Error: expected type int but got string in hash index
.*52: L Error: expected type int but got struct in hash index
.*53: L Error: expected type int but got array in hash index
.*54: L Error: expected type int but got hash in hash index
.*55: L Error: expected type int but got float in hash index
.*56: L Error: expected type int but got string in hash index
.*57: L Error: expected type int but got struct in hash index
.*58: L Error: expected type int but got array in hash index
.*59: L Error: expected type int but got hash in hash index
.*60: L Error: expected type int but got float in hash index
.*61: L Error: expected type int but got string in hash index
.*62: L Error: expected type int but got struct in hash index
.*63: L Error: expected type int but got array in hash index
.*64: L Error: expected type int but got hash in hash index
.*65: L Error: expected type int but got float in hash index
.*66: L Error: expected type int but got string in hash index
.*67: L Error: expected type int but got struct in hash index
.*68: L Error: expected type int but got array in hash index
.*69: L Error: expected type int but got hash in hash index
.*70: L Error: expected type string but got float in hash index
.*71: L Error: expected type string but got int in hash index
.*72: L Error: expected type string but got struct in hash index
.*73: L Error: expected type string but got array in hash index
.*74: L Error: expected type string but got hash in hash index
.*75: L Error: expected type string but got float in hash index
.*76: L Error: expected type string but got int in hash index
.*77: L Error: expected type string but got struct in hash index
.*78: L Error: expected type string but got array in hash index
.*79: L Error: expected type string but got hash in hash index
.*80: L Error: expected type string but got float in hash index
.*81: L Error: expected type string but got int in hash index
.*82: L Error: expected type string but got struct in hash index
.*83: L Error: expected type string but got array in hash index
.*84: L Error: expected type string but got hash in hash index
.*85: L Error: expected type string but got float in hash index
.*86: L Error: expected type string but got int in hash index
.*87: L Error: expected type string but got struct in hash index
.*88: L Error: expected type string but got array in hash index
.*89: L Error: expected type string but got hash in hash index
.*90: L Error: expected type string but got float in hash index
.*91: L Error: expected type string but got int in hash index
.*92: L Error: expected type string but got struct in hash index
.*93: L Error: expected type string but got array in hash index
.*94: L Error: expected type string but got hash in hash index
.*95: L Error: expected type string but got float in hash index
.*96: L Error: expected type string but got int in hash index
.*97: L Error: expected type string but got struct in hash index
.*98: L Error: expected type string but got array in hash index
.*99: L Error: expected type string but got hash in hash index
.*100: L Error: expected type string but got float in hash index
.*101: L Error: expected type string but got int in hash index
.*102: L Error: expected type string but got struct in hash index
.*103: L Error: expected type string but got array in hash index
.*104: L Error: expected type string but got hash in hash index
.*105: L Error: expected type string but got float in hash index
.*106: L Error: expected type string but got int in hash index
.*107: L Error: expected type string but got struct in hash index
.*108: L Error: expected type string but got array in hash index
.*109: L Error: expected type string but got hash in hash index
.*110: L Error: expected type float but got string in hash index
.*111: L Error: expected type float but got struct in hash index
.*112: L Error: expected type float but got array in hash index
.*113: L Error: expected type float but got hash in hash index
.*114: L Error: expected type float but got string in hash index
.*115: L Error: expected type float but got struct in hash index
.*116: L Error: expected type float but got array in hash index
.*117: L Error: expected type float but got hash in hash index
.*118: L Error: expected type float but got string in hash index
.*119: L Error: expected type float but got struct in hash index
.*120: L Error: expected type float but got array in hash index
.*121: L Error: expected type float but got hash in hash index
.*122: L Error: expected type float but got string in hash index
.*123: L Error: expected type float but got struct in hash index
.*124: L Error: expected type float but got array in hash index
.*125: L Error: expected type float but got hash in hash index
.*126: L Error: expected type float but got string in hash index
.*127: L Error: expected type float but got struct in hash index
.*128: L Error: expected type float but got array in hash index
.*129: L Error: expected type float but got hash in hash index
.*130: L Error: expected type float but got string in hash index
.*131: L Error: expected type float but got struct in hash index
.*132: L Error: expected type float but got array in hash index
.*133: L Error: expected type float but got hash in hash index
.*134: L Error: expected type float but got string in hash index
.*135: L Error: expected type float but got struct in hash index
.*136: L Error: expected type float but got array in hash index
.*137: L Error: expected type float but got hash in hash index
.*138: L Error: expected type float but got string in hash index
.*139: L Error: expected type float but got struct in hash index
.*140: L Error: expected type float but got array in hash index
.*141: L Error: expected type float but got hash in hash index
}

test typecheck-6.1 {type check errors with push built-in} -body {
#lang L
void
typecheck_6_1()
{
	int	a[], i, j;
	int	h{int};
	float	f;
	string	s;
	struct { int i,j; } st;
	poly	p;
	widget	w;

	/* Errors -- first arg not a reference (&). */
	push(a, i);
	push(i, i);
	push(h, i);
	push(f, i);
	push(s, i);
	push(st, i);
	push(p, i);
	push(w, i);

	/* Error -- too many arguments. */
	push(a, i, j);
	push(a, i, j, j);

	/* Error -- too few arguments. */
	push(&a);
	push();

	/* Error -- first arg not an array reference. */
	push(&i, i);
	push(&h, i);
	push(&f, i);
	push(&s, i);
	push(&st, i);
	push(&w, i);
}
#lang tcl
typecheck_6_1
} -returnCodes {error} -match regexp -result {.*:13: L Error: first arg to push not an array reference.*:14: L Error: first arg to push not an array reference.*
.*:15: L Error: first arg to push not an array reference.*
.*:16: L Error: first arg to push not an array reference.*
.*:17: L Error: first arg to push not an array reference.*
.*:18: L Error: first arg to push not an array reference.*
.*:19: L Error: first arg to push not an array reference.*
.*:20: L Error: first arg to push not an array reference.*
.*:23: L Error: incorrect # arguments to push
.*:24: L Error: incorrect # arguments to push
.*:27: L Error: incorrect # arguments to push
.*:28: L Error: incorrect # arguments to push
.*:31: L Error: first arg to push not an array reference.*
.*:32: L Error: first arg to push not an array reference.*
.*:33: L Error: first arg to push not an array reference.*
.*:34: L Error: first arg to push not an array reference.*
.*:35: L Error: first arg to push not an array reference.*
.*:36: L Error: first arg to push not an array reference.*
}

test typecheck-6.2 {type check errors with push built-in 2} -body {
#lang L
void typecheck_6_2_v() { }
void
typecheck_6_2()
{
	int	ai[], i;
	string	as[], s;
	float	af[], f;
	widget	aw[], w;
	int	aa[][], a[];		// array of array, and an array
	int	ah[]{int}, h{int};	// array of hash, and a hash
	struct { int i,j; } ast[], st;	// array of struct, and a struct

	/*
	 * Check pushing incompatible type onto the array.  Just check
	 * for an array of int, since we check the full type-checker
	 * elsewhere.
	 */

	push(&ai, typecheck_6_2_v());  // pushing a void

	push(&ai, f);
	push(&ai, s);
	push(&ai, w);
	push(&ai, a);
	push(&ai, aa);
	push(&ai, h);
	push(&ai, ah);
	push(&ai, st);
	push(&ai, ast);
}
#lang tcl
typecheck_6_2
} -returnCodes {error} -match regexp -result {.*:19: L Error: pushing incompatible type onto array
.*:21: L Error: pushing incompatible type onto array
.*:22: L Error: pushing incompatible type onto array
.*:23: L Error: pushing incompatible type onto array
.*:24: L Error: pushing incompatible type onto array
.*:25: L Error: pushing incompatible type onto array
.*:26: L Error: pushing incompatible type onto array
.*:27: L Error: pushing incompatible type onto array
.*:28: L Error: pushing incompatible type onto array
.*:29: L Error: pushing incompatible type onto array
}

test typecheck-6.3 {type check push built-in} -body {
#lang L
void
typecheck_6_3()
{
	int	ai[], i;
	string	as[], s;
	float	af[], f;
	poly	ap[], p;
	widget	aw[], w;
	int	aa[][], a[];		// array of array, and an array
	int	ah[]{int}, h{int};	// array of hash, and a hash
	struct { int i,j; } ast[], st;	// array of struct, and a struct

	/* All legal. */

	push(&ai, 0);
	push(&ai, i);

	push(&as, "s");
	push(&as, s);

	push(&af, 3.14);
	push(&af, f);
	push(&af, 0);  // legal to push ints onto a float array
	push(&af, i);

	push(&ap, 0);
	push(&ap, 3.14);
	push(&ap, "s");
	push(&ap, i);
	push(&ap, s);
	push(&ap, f);
	push(&ap, w);
	push(&ap, p);
	push(&ap, ai);
	push(&ap, as);
	push(&ap, af);
	push(&ap, ap);
	push(&ap, aw);
	push(&ap, ast);
	push(&ap, h);
	push(&ap, st);

	push(&aw, w);
	push(&aw, (widget)"w");
	push(&aw, s);  // legal to push strings onto a widget array
	push(&aw, "w");

	push(&ah, h);

	push(&aa, a);

	push(&ast, st);
}
#lang tcl
typecheck_6_3
} -output {}

test typecheck-7.1 {type check reference parameters} -body {
#lang L -nowarn
void typecheck_7_1_foo(int &a) {}
void
typecheck_7_1()
{
	int	a;

	typecheck_7_1_foo(a);  // incorrect arg type
}
#lang tcl
typecheck_7_1
} -returnCodes {error} -match regexp -result {.*:7: L Error: parameter 1 has incompatible type}

test typecheck-8.1 {widget and string type compatibility} -body {
#lang L
void typecheck_8_1()
{
	poly	p = "p";
	string	s = "s";
	widget	w = "w";

	p = s;
	unless (p eq "s") puts("bad 1");
	p = w;
	unless (p eq "w") puts("bad 2");
	p = p;
	unless (p eq "w") puts("bad 3");
	p = "p";
	s = p;
	unless (s eq "p") puts("bad 4");
	s = s;
	unless (s eq "p") puts("bad 5");
	s = w;
	unless (s eq "w") puts("bad 6");
	s = "s";
	w = p;
	unless (w eq "p") puts("bad 7");
	w = s;
	unless (w eq "s") puts("bad 8");
	w = w;
	unless (w eq "s") puts("bad 9");
	w = "w";

	unless (p ne s) puts("bad 10");
	unless (s ne p) puts("bad 11");
	unless (p ne w) puts("bad 12");
	unless (w ne p) puts("bad 13");
	unless (s ne w) puts("bad 14");
	unless (w ne s) puts("bad 15");
	unless (p eq p) puts("bad 16");
	unless (s eq s) puts("bad 17");
	unless (w eq w) puts("bad 18");
}
#lang tcl
typecheck_8_1
} -output {}

test typecheck-9.1 {illegal types in function prototype declarations} -body {
#lang L
void typecheck_9_1_1(void, void);
void typecheck_9_1_2(void, void, void);
void typecheck_9_1_3(int, void);
void typecheck_9_1_4(void, int);
void typecheck_9_1_5(void[]);
void typecheck_9_1_6(void[][]);
void typecheck_9_1_7(void{int});
void typecheck_9_1_8(void{int}[]);
void typecheck_9_1_9(void[]{int});
void typecheck_9_1_10(void &bad);
void typecheck_9_1_11(int{void});
void{int} typecheck_9_1_12();
void[] typecheck_9_1_13();
int{void} typecheck_9_1_14();
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal
.*1: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*3: L Error: type void illegal
.*4: L Error: type void illegal
.*5: L Error: type void illegal
.*6: L Error: type void illegal
.*7: L Error: type void illegal
.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal in declaration of 'bad'
.*11: L Error: type void illegal
.*12: L Error: type void illegal in declaration of 'typecheck_9_1_12'
.*13: L Error: type void illegal in declaration of 'typecheck_9_1_13'
.*14: L Error: type void illegal in declaration of 'typecheck_9_1_14'
}

test typecheck-9.2 {illegal types in function pointer args} -body {
#lang L
void typecheck_9_2_1(void &bad(void, void));
void typecheck_9_2_2(void &bad(void, void, void));
void typecheck_9_2_3(void &bad(int, void));
void typecheck_9_2_4(void &bad(void, int));
void typecheck_9_2_5(void &bad(void[]));
void typecheck_9_2_6(void &bad(void[][]));
void typecheck_9_2_7(void &bad(void{int}));
void typecheck_9_2_8(void &bad(void{int}[]));
void typecheck_9_2_9(void &bad(void[]{int}));
void typecheck_9_2_10(void &bad(void &bad));
void typecheck_9_2_11(void &bad(int{void}));
void typecheck_9_2_12(void{int} &bad());
void typecheck_9_2_13(void[] &bad());
void typecheck_9_2_14(int{void} &bad());
} -returnCodes error -match regexp -result {.*1: L Error: type void illegal
.*1: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*2: L Error: type void illegal
.*3: L Error: type void illegal
.*4: L Error: type void illegal
.*5: L Error: type void illegal
.*6: L Error: type void illegal
.*7: L Error: type void illegal
.*8: L Error: type void illegal
.*9: L Error: type void illegal
.*10: L Error: type void illegal in declaration of 'bad'
.*11: L Error: type void illegal
.*12: L Error: type void illegal in declaration of 'bad'
.*13: L Error: type void illegal in declaration of 'bad'
.*14: L Error: type void illegal in declaration of 'bad'
}

test typecheck-9.3 {illegal types in variable declarations 1} -body {
#lang L
void typecheck_9_3()
{
	void	bad1;
	void	bad2[];
	void	bad3[][];
	void	bad4{int};
	void	bad5{int}{int};
	void	bad6[]{int};
	void	bad7{int}[];
	int	bad8{void};
	int	bad9[]{void}{int};
	int	&bad10;
	int	&bad11[];
	int	&bad12{int};
	int	&bad13(void);
	int	&bad14(int);
	int	&bad15(int arg);
}
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*4: L Error:.*bad2.*
.*5: L Error:.*bad3.*
.*6: L Error:.*bad4.*
.*7: L Error:.*bad5.*
.*8: L Error:.*bad6.*
.*9: L Error:.*bad7.*
.*10: L Error:.*bad8.*
.*11: L Error:.*bad9.*
.*12: L Error:.*bad10.*
.*13: L Error:.*bad11.*
.*14: L Error:.*bad12.*
.*15: L Error:.*bad13.*
.*16: L Error:.*bad14.*
.*17: L Error:.*bad15.*
}

test typecheck-9.3.1 {illegal types in variable declarations 2} -body {
#lang L
void typecheck_9_3_1()
{
	void	bad1, bad2[], bad3[][],	bad4{int}, bad5{int}{int};
	void	bad6[]{int}, bad7{int}[], bad8{void}, bad9[]{void}{int};
	int	&bad10, &bad11[], &bad12{int}, &bad13(void);
	int	&bad14(int), &bad15(int arg);
}
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*3: L Error:.*bad2.*
.*3: L Error:.*bad3.*
.*3: L Error:.*bad4.*
.*3: L Error:.*bad5.*
.*4: L Error:.*bad6.*
.*4: L Error:.*bad7.*
.*4: L Error:.*bad8.*
.*4: L Error:.*bad9.*
.*5: L Error:.*bad10.*
.*5: L Error:.*bad11.*
.*5: L Error:.*bad12.*
.*5: L Error:.*bad13.*
.*6: L Error:.*bad14.*
.*6: L Error:.*bad15.*
}

test typecheck-9.3.2 {illegal types in variable declarations 3} -body {
#lang L
typedef void &t932();
void typecheck_9_3_2()
{
	t932	bad1;
	t932	bad2[];
	t932	bad3[][];
	t932	bad4{int};
	t932	bad5{int}{int};
	t932	bad6[]{int};
	t932	bad7{int}[];
	t932	bad8{void};
	t932	bad9[]{void}{int};
	t932	&bad10;
	t932	&bad11[];
	t932	&bad12{int};
	t932	&bad13(void);
	t932	&bad14(int);
	t932	&bad15(int arg);
}
} -returnCodes error -match regexp -result {.*4: L Error:.*bad1.*
.*5: L Error:.*bad2.*
.*6: L Error:.*bad3.*
.*7: L Error:.*bad4.*
.*8: L Error:.*bad5.*
.*9: L Error:.*bad6.*
.*10: L Error:.*bad7.*
.*11: L Error:.*bad8.*
.*12: L Error:.*bad9.*
.*13: L Error:.*bad10.*
.*14: L Error:.*bad11.*
.*15: L Error:.*bad12.*
.*16: L Error:.*bad13.*
.*17: L Error:.*bad14.*
.*18: L Error:.*bad15.*
}

test typecheck-9.4 {illegal types in struct declarations 1} -body {
#lang L
struct {
	void	bad1;
	void	bad2[];
	void	bad3[][];
	void	bad4{int};
	void	bad5{int}{int};
	void	bad6[]{int};
	void	bad7{int}[];
	int	bad8{void};
	int	bad9[]{void}{int};
	int	&bad10;
	int	&bad11[];
	int	&bad12{int};
	int	&bad13(void);
	int	&bad14(int);
	int	&bad15(int arg);
};
} -returnCodes error -match regexp -result {.*2: L Error:.*bad1.*
.*3: L Error:.*bad2.*
.*4: L Error:.*bad3.*
.*5: L Error:.*bad4.*
.*6: L Error:.*bad5.*
.*7: L Error:.*bad6.*
.*8: L Error:.*bad7.*
.*9: L Error:.*bad8.*
.*10: L Error:.*bad9.*
.*11: L Error:.*bad10.*
.*12: L Error:.*bad11.*
.*13: L Error:.*bad12.*
.*14: L Error:.*bad13.*
.*15: L Error:.*bad14.*
.*16: L Error:.*bad15.*
}

test typecheck-9.4.1 {illegal types in struct declarations 2} -body {
#lang L
struct {
	void	bad1, bad2[], bad3[][], bad4{int}, bad5{int}{int};
	void	bad6[]{int}, bad7{int}[], bad8{void};
	int	bad9[]{void}{int}, &bad10, &bad11[];
	int	&bad12{int}, &bad13(void), &bad14(int), &bad15(int arg);
};
} -returnCodes error -match regexp -result {.*2: L Error:.*bad1.*
.*2: L Error:.*bad2.*
.*2: L Error:.*bad3.*
.*2: L Error:.*bad4.*
.*2: L Error:.*bad5.*
.*3: L Error:.*bad6.*
.*3: L Error:.*bad7.*
.*3: L Error:.*bad8.*
.*4: L Error:.*bad9.*
.*4: L Error:.*bad10.*
.*4: L Error:.*bad11.*
.*5: L Error:.*bad12.*
.*5: L Error:.*bad13.*
.*5: L Error:.*bad14.*
.*5: L Error:.*bad15.*
}

test typecheck-9.4.2 {illegal types in struct declarations 3} -body {
#lang L
typedef void &t942();
struct {
	t942	bad1;
	t942	bad2[];
	t942	bad3[][];
	t942	bad4{int};
	t942	bad5{int}{int};
	t942	bad6[]{int};
	t942	bad7{int}[];
	t942	bad8{void};
	t942	bad9[]{void}{int};
	t942	&bad10;
	t942	&bad11[];
	t942	&bad12{int};
	t942	&bad13(void);
	t942	&bad14(int);
	t942	&bad15(int arg);
};
} -returnCodes error -match regexp -result {.*3: L Error:.*bad1.*
.*4: L Error:.*bad2.*
.*5: L Error:.*bad3.*
.*6: L Error:.*bad4.*
.*7: L Error:.*bad5.*
.*8: L Error:.*bad6.*
.*9: L Error:.*bad7.*
.*10: L Error:.*bad8.*
.*11: L Error:.*bad9.*
.*12: L Error:.*bad10.*
.*13: L Error:.*bad11.*
.*14: L Error:.*bad12.*
.*15: L Error:.*bad13.*
.*16: L Error:.*bad14.*
.*17: L Error:.*bad15.*
}

test typecheck-9.4.3 {call-by-name type errors} -body {
#lang L -nowarn
typedef int arr_t[];
typedef int hash_t{int};
typedef struct { int i,j; } struc_t;
void t943(int &i, string &s, float &f, arr_t &a, hash_t &h, struc_t &st) {}

void typecheck_9_4_3()
{
	int	i;
	string	s;
	float	f;
	arr_t	a;
	hash_t	h;
	struc_t	st;

	t943( i, &s, &f, &a, &h, &st);
	t943(&i,  s, &f, &a, &h, &st);
	t943(&i, &s,  f, &a, &h, &st);
	t943(&i, &s, &f,  a, &h, &st);
	t943(&i, &s, &f, &a,  h, &st);
	t943(&i, &s, &f, &a, &h,  st);
	t943( i,  s,  f,  a,  h,  st);
}
} -returnCodes error -match regexp -result {.*15: L Error:.*incompatible type.*
.*16: L Error:.*incompatible type.*
.*17: L Error:.*incompatible type.*
.*18: L Error:.*incompatible type.*
.*19: L Error:.*incompatible type.*
.*20: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
.*21: L Error:.*incompatible type.*
}

test fnptr-1 {function pointers 1} -body {
#lang L
typedef string &fnptr1_t(int);

string fnptr1_doit(int x)
{
	return ("doit got ${x}");
}
string fnptr1_foo(string &f(int))
{
	return (f(33));
}
string fnptr1_foo2(fnptr1_t f)
{
	return (f(44));
}
void fnptr_1()
{
	unless (fnptr1_foo(&fnptr1_doit) eq "doit got 33") puts("bad 1");
	unless (fnptr1_foo2(&fnptr1_doit) eq "doit got 44") puts("bad 2");
}
#lang tcl
fnptr_1
} -output {}

test fnptr-2 {function pointers 2} -body {
#lang L
typedef int &fnptr2_t(poly,poly);

/* Integer comparison. */
int icmp(int a, int b)
{
	if (a < b) {
		return -1;
	} else if (a > b) {
		return 1;
	} else {
		return 0;
	}
}

/* Unary comparison. */
int ucmp(string a, string b)
{
	int	al = strlen(a);
	int	bl = strlen(b);

	if (al < bl) {
		return -1;
	} else if (al > bl) {
		return 1;
	} else {
		return 0;
	}
}

int length(poly[] a)
{
	int	n = 0;
	poly	p;

	foreach(p in a) ++n;
	return (n);
}

string fnptr2_sort(poly[] a, fnptr2_t compar)
{
	int	i, swapped;

	do {
		swapped = 0;
		for (i = 0; i < length(a)-1; ++i) {
			if (compar(a[i], a[i+1]) > 0) {
				poly t = a[i];
				a[i]   = a[i+1];
				a[i+1] = t;
				swapped = 1;
			}
		}
	} while (swapped);

	return ((string)a);
}

void fnptr_2()
{
	unless (fnptr2_sort((int[])"3 1 4 1 5 9", &icmp) eq "1 1 3 4 5 9") {
		puts("bad 1");
	}
	unless (fnptr2_sort((string[])"111 1 1 11 111111111 11111", &ucmp) eq
		"1 1 11 111 11111 111111111") {
		puts("bad 2");
	}
}
#lang tcl
fnptr_2
} -output {}

test fnptr-3 {function pointer type errors} -body {
#lang L -nowarn
typedef void &fp3_v_v_t(void);
typedef void &fp3_v_i_t(int);
typedef int  &fp3_i_v_t(void);
typedef int  &fp3_i_i_t(int);
typedef void &fp3_v_is_t(int, string);

void fp3_v_v(void)  {}
void fp3_v_i(int i) {}
int  fp3_i_v(void)  { return (0); }
int  fp3_i_i(int i) { return (i); }
void fp3_v_is(int i, string s) {}

void fp3f_vv (fp3_v_v_t f)   { f();  }
void fp3f_vi (fp3_v_i_t f)   { f(1); }
void fp3f_iv (fp3_i_v_t f)   { f();  }
void fp3f_ii (fp3_i_i_t f)   { f(1); }
void fp3f_vis(fp3_v_is_t f) { f(1,"s"); }

void fnptr_3()
{
	fp3f_vv(1);
	fp3f_vv(1.1);
	fp3f_vv((int[])"1 2 3");
	fp3f_vv((hash)"1 2 3 4");
	fp3f_vv((struct { int i,j; })"1 2");

	/* Try all the various error combinations, given the above types. */

	fp3f_vv(fp3_v_v);
	fp3f_vv(&fp3_v_i);
	fp3f_vv(&fp3_i_v);
	fp3f_vv(&fp3_i_i);
	fp3f_vv(&fp3_v_is);

	fp3f_vi(fp3_v_i);
	fp3f_vi(&fp3_v_v);
	fp3f_vi(&fp3_i_v);
	fp3f_vi(&fp3_i_i);
	fp3f_vi(&fp3_v_is);

	fp3f_iv(fp3_i_v);
	fp3f_iv(&fp3_v_v);
	fp3f_iv(&fp3_v_i);
	fp3f_iv(&fp3_i_i);
	fp3f_iv(&fp3_v_is);

	fp3f_ii(fp3_i_i);
	fp3f_ii(&fp3_v_v);
	fp3f_ii(&fp3_v_i);
	fp3f_ii(&fp3_i_v);
	fp3f_ii(&fp3_v_is);

	fp3f_vis(fp3_v_is);
	fp3f_vis(&fp3_v_v);
	fp3f_vis(&fp3_v_i);
	fp3f_vis(&fp3_i_v);
	fp3f_vis(&fp3_i_i);
}
} -returnCodes error -match regexp -result {.*21: L Error:.*incompatible type.*
.*22: L Error:.*incompatible type.*
.*23: L Error:.*incompatible type.*
.*24: L Error:.*incompatible type.*
.*25: L Error:.*incompatible type.*
.*29: L Error:.*incompatible type.*
.*30: L Error:.*incompatible type.*
.*31: L Error:.*incompatible type.*
.*32: L Error:.*incompatible type.*
.*33: L Error:.*incompatible type.*
.*35: L Error:.*incompatible type.*
.*36: L Error:.*incompatible type.*
.*37: L Error:.*incompatible type.*
.*38: L Error:.*incompatible type.*
.*39: L Error:.*incompatible type.*
.*41: L Error:.*incompatible type.*
.*42: L Error:.*incompatible type.*
.*43: L Error:.*incompatible type.*
.*44: L Error:.*incompatible type.*
.*45: L Error:.*incompatible type.*
.*47: L Error:.*incompatible type.*
.*48: L Error:.*incompatible type.*
.*49: L Error:.*incompatible type.*
.*50: L Error:.*incompatible type.*
.*51: L Error:.*incompatible type.*
.*53: L Error:.*incompatible type.*
.*54: L Error:.*incompatible type.*
.*55: L Error:.*incompatible type.*
.*56: L Error:.*incompatible type.*
.*57: L Error:.*incompatible type.*
}

test assign-1 {check assignment statement value and type} -body {
#lang L
void
assign_1()
{
	/*
	 * Check type and value of "lhs = rhs".  Rhs should be
	 * evaluated before lhs.  The type of (lhs = rhs) should be
	 * the type of lhs and have the value of lhs.
	 */

	int	i, j, k;
	float	f, g;
	string	s1, s2;
	int	a1[], a2[], a3[];
	int	h1{int}, h2{int}, h3{int};

	i = (j = 13);
	unless ((i == 13) && (j == 13)) puts("bad 1");

	i = (j = (k = 14));
	unless ((i == 14) && (j == 14) && (k == 14)) puts("bad 2");

	i = j = k = 14;  // = should be right associative
	unless ((i == 14) && (j == 14) && (k == 14)) puts("bad 2.1");

	/* Note: exact comparisons against floats don't always work. */
	f = (g = (i = 1));
	unless ((f == 1.0) && (g == 1.0)) puts("bad 3");

	s1 = (s2 = "ok");
	unless ((s1 eq "ok") && (s2 eq "ok")) puts("bad 4");

	a1[0] = 3;
	a3 = (a2 = a1);
	unless ((a1[0] == 3) && !defined(a1[1])) puts("bad 5.1");
	unless ((a2[0] == 3) && !defined(a2[1])) puts("bad 5.2");
	unless ((a3[0] == 3) && !defined(a3[1])) puts("bad 5.3");

	h1{1} = 4;
	h3 = (h2 = h1);
	unless ((h1{1} == 4) && (h2{1} == 4) && (h3{1} == 4)) puts("bad 6.1");
	foreach (i in h1) unless (i == 1) puts("bad 6.2");
	foreach (i in h2) unless (i == 1) puts("bad 6.3");
	foreach (i in h3) unless (i == 1) puts("bad 6.4");

	/* Check that rhs is evaluated *before* lhs. */

	i = 0;
	a1[i] = (i = 2);
	unless (a1[2] == 2) puts("bad 7");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] = ++i;
	unless ((a1[3] == 1) && (a1[4] == 4)) puts("bad 8");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] = i++;
	unless ((a1[3] == 1) && (a1[4] == 3)) puts("bad 9");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] += ++i;
	unless ((a1[3] == 1) && (a1[4] == 6)) puts("bad 10");

	i = 3;
	a1[3] = 1;
	a1[4] = 2;
	a1[i] += i++;
	unless ((a1[3] == 1) && (a1[4] == 5)) puts("bad 11");
}
#lang tcl
assign_1
} -output {}

test backtrace-1.0 {backtracing in L} -setup {
	set fname [makeFile {
void foo()
{
	puts("foo", "bar");
}

void bar()
{
	foo();
}

int
main(int ac, string av[])
{
	bar();
}

	} backtrace-1.0.l]
} -constraints {
	exec
} -body {
	exec [interpreter] $fname
} -cleanup {
	removeFile backtrace-1.0.l
} -returnCodes {error} -match regexp -result {.*line 4.*line 9.*line 15}

test pattern-1.0 {L pattern functions} -body {
#lang L
poly Pattern_()
{
	// This is NOT a pattern function (because the _ is trailing).
	puts("Pattern_");
}
poly Pattern_foo(int a, int b)
{
	puts("Pattern_foo special case ${a} ${b}");
}
poly Pattern_*(int a, int b)
{
	puts("Pattern_* ${$1} ${a} ${b}");
}
void pattern2(string f, string s, int a)
{
	puts("Pattern2 ${f} ${s} ${a}");
}
void p1_0_widget(string f, int a)
{
	puts("widget ${f} ${a}");
}
void pattern_1_0()
{
	string	s = "notwidget";
	widget	w = "p1_0_widget";

	Pattern_foo(1, 2);  // calls Pattern_foo(1, 2)
	Pattern_bar(3, 4);  // calls Pattern_*(3, 4) where $1 gets "bar"
	Pattern_baz(5, 6);  // calls Pattern_*(5, 6) where $1 gets "baz"
	Pattern_();	    // calls Pattern_()
	Pattern2_bar(s, 1); // calls pattern2("bar", s, 1)
	Pattern2_bar(w, 1); // calls p1_0_widget("bar", 1)
}
pattern_1_0();
#lang tcl
} -output {Pattern_foo special case 1 2
Pattern_* bar 3 4
Pattern_* baz 5 6
Pattern_
Pattern2 bar notwidget 1
widget bar 1
}

test include-1.0 {include files} -setup {
	set fname [makeFile {++include_1_0;} foo.l ../tests]
} -body {
#lang L
int include_1_0 = 0;
puts(include_1_0);
include("foo.l");
puts(include_1_0);
// Check variations in spacing and punctation.
include("foo.l") ;
include ("foo.l");
include ("foo.l") ;
include ( "foo.l") ;
include ( "foo.l" ) ;
include("foo.l");;
puts(include_1_0);
} -cleanup {
	removeFile $fname
} -output {0
1
7
}

test include-1.1 {nested include files} -setup {
	set fname1 [makeFile {include("foo2.l");} foo1.l ../tests]
	set fname2 [makeFile {int include_1_1a = 3;
include("foo3.l");} foo2.l ../tests]
	set fname3 [makeFile {int include_1_1b = 4;} foo3.l ../tests]
} -body {
#lang L
include("foo1.l");
puts(include_1_1a);
puts(include_1_1b);
} -cleanup {
	removeFile $fname1
	removeFile $fname2
	removeFile $fname3
} -output {3
4
}

test include-1.2 {malformed includes} -body {
#lang L
include("   // bad
include(""  // bad
include("") // bad
} -returnCodes {error} -match regexp -result {.*1: L Error: malformed include
.*2: L Error: malformed include
.*3: L Error: malformed include
}

test include-1.3 {test line number tracking with include files} -setup {
	set fname1 [makeFile {int include_1_3a = "bad1";
include("foo2.l");} foo1.l ../tests]
	set fname2 [makeFile {int include_1_3b = "bad2";
include("foo3.l");
int include_1_3c = "bad3";} foo2.l ../tests]
	set fname3 [makeFile {int include_1_3d = "bad4";} foo3.l ../tests]
} -body {
#lang L
int include_1_3 = "bad0";
include("foo1.l");
int include_1_3last = "badn";
} -cleanup {
	removeFile $fname1
	removeFile $fname2
	removeFile $fname3
} -returnCodes {error} -match regexp -result {.*1: L Error: assignment of incompatible types
.*foo1.l:1: L Error: assignment of incompatible types
.*foo2.l:1: L Error: assignment of incompatible types
.*foo3.l:1: L Error: assignment of incompatible types
.*foo2.l:3: L Error: assignment of incompatible types
.*3: L Error: assignment of incompatible types
}

# This test creates two slave interps that declare global symbols
# with the same names as those declared in the master interp.
# If the L global state is properly kept per-interp, there
# should be no multiple-declaration errors.

test interp-1 {test per-interp global state} -body {
#lang L
int interp_1_g;
void interp_1_foo() {}

#lang tcl
interp create interp_1_1
interp eval interp_1_1 {
#lang L
int interp_1_g;
void interp_1_foo() {}
}
interp create interp_1_2
interp eval interp_1_2 {
#lang L
int interp_1_g;
void interp_1_foo() {}
}
interp delete interp_1_2
interp delete interp_1_1
} -output {}

test split-1.0 {test split function} -body {
#lang L
void
split_1_0()
{
	int	m;
	string	s;
	string	r[];

	/* These are all white space. */
	string	allspace[] = {
		"",
		" ",
		"  ",
		"   ",
		"    ",
		"\n",
		"\t",
		"\n\n" };

	foreach (s in allspace) {
		r = split(s);
		if (defined(r[0])) printf("bad 1: '%s'\n", s);
	}

	/*
	 * A split followed by a join should give the string back
	 * (modulo a trailing delimeter).
	 */

	s = "This is not a test. This is really not a test.";
	r = split(s);
	unless (s eq join(r, " ")) puts("bad 2.1");

	s = " This is not a test. This is really not a test.";
	r = split(s);
	unless (s eq join(r, " ")) puts("bad 2.2");

	s = "This:is:not:a:test.:This:is:really:not:a:test.";
	r = split(s, ":");
	unless (s eq join(r, ":")) puts("bad 2.3");

	s = ":This:is:not:a:test.:This:is:really:not:a:test.";
	r = split(s, ":");
	unless (s eq join(r, ":")) puts("bad 2.4");

	/*
	 * A split on ' ' should split on white space but return
	 * no null field for any initial white space.
	 */

	r = split("has none", " ");
	unless ((r[0] eq "has") && (r[1] eq "none")) puts("bad 3.1");
	if (defined(r[2])) puts("bad 3.2");

	r = split(" has one", " ");
	unless ((r[0] eq "has") && (r[1] eq "one")) puts("bad 3.3");
	if (defined(r[2])) puts("bad 3.4");

	r = split(" has one");
	unless ((r[0] eq "") && (r[1] eq "has") && (r[2] eq "one")) {
		puts("bad 3.5");
	}
	if (defined(r[3])) puts("bad 3.6");

	/* Trailing white space never produces a null field. */

	r = split("trail ");
	unless (r[0] eq "trail") puts("bad 4.1");
	if (defined(r[1])) puts("bad 4.2");

	r = split("trail ", " ");
	unless (r[0] eq "trail") puts("bad 4.3");
	if (defined(r[1])) puts("bad 4.4");

	/* Check split on a regexp. */

	r = split("XaXbXcX", "[abc]");
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 5.1");
	}
	if (defined(r[4])) puts("bad 5.2");

	r = split("XaXbXcX", /[abc]/);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 5.3");
	}
	if (defined(r[4])) puts("bad 5.4");

	r = split("XaaXbXcX", "[abc]");
	unless ((r[0] eq "X") && (r[1] eq "") && (r[2] eq "X") &&
	        (r[3] eq "X") && (r[4] eq "X")) {
		puts("bad 5.5");
	}
	if (defined(r[5])) puts("bad 5.6");

	/* A regexp match on the last char never produces a null field. */

	r = split("abcd", /[d]/);
	unless (r[0] eq "abc") puts("bad 5.7");
	if (defined(r[1])) puts("bad 5.8");

	/* A regexp match on the first char produces a  null field. */

	r = split("abcd", /[a]/);
	unless ((r[0] eq "") && (r[1] eq "bcd")) puts("bad 5.9");
	if (defined(r[2])) puts("bad 5.10");

	/* Test interpolated regexp. */

	s = "abc";
	r = split("XaXbXcX", /[${s}]/);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 6.1");
	}
	if (defined(r[4])) puts("bad 6.2");

	/* Test limits. */

	r = split("1 2 3 4", " ", 5);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.1");
	}
	if (defined(r[4])) puts("bad 7.2");

	r = split("1 2 3 4", " ", 4);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.3");
	}
	if (defined(r[4])) puts("bad 7.4");

	r = split("1 2 3 4", " ", 3);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 7.5");
	}
	if (defined(r[3])) puts("bad 7.6");

	r = split("1 2 3 4", " ", 2);
	unless ((r[0] eq "1") && (r[1] eq "2 3 4")) puts("bad 7.7");
	if (defined(r[2])) puts("bad 7.8");

	r = split("1 2 3 4", " ", 1);
	unless (r[0] eq "1 2 3 4") puts("bad 7.9");
	if (defined(r[1])) puts("bad 7.10");

	r = split("1 2 3 4", " ", 0);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.11");
	}
	if (defined(r[4])) puts("bad 7.12");

	r = split("1 2 3 4", " ", -1);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3") &&
	        (r[3] eq "4")) {
		puts("bad 7.13");
	}
	if (defined(r[4])) puts("bad 7.14");

	/* Test that an escape of the regexp delimeter works. */

	r = split("/this/is/a/pathname", /\//);
	unless ((r[0] eq "") && (r[1] eq "this") && (r[2] eq "is") &&
		(r[3] eq "a") && (r[4] eq "pathname")) {
		puts("bad 8.1");
	}
	if (defined(r[5])) puts("bad 8.2");

	/* Test alternate form of regexp. */

	r = split("/this/is/a/pathname", m|/|);
	unless ((r[0] eq "") && (r[1] eq "this") && (r[2] eq "is") &&
		(r[3] eq "a") && (r[4] eq "pathname")) {
		puts("bad 9.1");
	}
	if (defined(r[5])) puts("bad 9.2");

	s = "abc";
	r = split("XaXbXcX", m|[${s}]|);
	unless ((r[0] eq "X") && (r[1] eq "X") && (r[2] eq "X") &&
		(r[3] eq "X")) {
		puts("bad 9.3");
	}
	if (defined(r[4])) puts("bad 9.4");

	r = split("1 2 3 4", m| |, 3);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 9.5");
	}
	if (defined(r[3])) puts("bad 9.6");

	/* Ensure third arg is not parsed as a regexp. */

	m = 3;
	r = split("1 2 3 4", m| |, m);
	unless ((r[0] eq "1") && (r[1] eq "2") && (r[2] eq "3 4")) {
		puts("bad 9.7");
	}
	if (defined(r[3])) puts("bad 9.8");
}
#lang tcl
split_1_0
} -output ""

test consts-1.0 {test constants function} -body {
#lang L
void
constants_1_0()
{
	int	i;
	float	f;

	i = 1234;
	printf("%u\n", i);
	i = 0xdeadbeef;
	printf("%x\n", i);
	i = 0o755;
	printf("%o\n", i);

	f = 1234.5678;
	printf("%.4f\n", f);
}
#lang tcl
constants_1_0
} -output "1234\ndeadbeef\n755\n1234.5678\n"

# These tests check the L compiler's mapping between the source-file
# offsets of each "command" and the tcl bytecodes generated for it.
# Generally speaking, a command is a statement or expression, although
# some statements don't generate a mapping per-se (like "if"
# statements).  This is tested by generating a bytecode disassembly
# and checking that the text of the commands were identified properly
# in various syntactic contexts.  This seems like the only way to get
# at the mappings easily for testing.

test src-mappings-1 {test bytecode <-> source-file-offset mappings 1} -body {
#lang L -nowarn
struct sm1 {
	int	i;
};
void
src_mappings_1()
{
	/*
	 * This test checks the mappings for declarations.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i1;
	int i2 = 2;
	int i3, i4;
	int i5, i6 = 6, i7;
	string s1;
	string s2 = "str2";
	string s3, s4;
	string s5, s6 = "str6", s7;
	float f1;
	float f2 = 2.0;
	float f3, f4;
	float f5, f6 = 6.0, f7;
	/* The hash ones test typedef names (hash is a typedef). */
	hash h1;
	hash h2 = {2=>2};
	hash h3, h4;
	hash h5, h6 = {6=>6}, h7;
	struct sm1 st1;
	struct sm1 st2 = {2};
	struct sm1 st3, st4;
	struct sm1 st5, st6 = {6}, st7;
	poly p1;
	poly p2 = 2;
	poly p3, p4;
	poly p5, p6 = 6, p7;
	widget w1;
	widget w2 = "w2";
	widget w3, w4;
	widget w5, w6 = "w6", w7;
	int ai1[];
	int ai2[2];
	int ai3[] = {3};
	int ai4[], ai5[5];
	int ai6[], ai7[] = {7}, ai8[];
	string as1[];
	string as2[2];
	string as3[] = {"3"};
	string as4[], as5[5];
	string as6[], as7[] = {"7"}, as8[];
	float af1[];
	float af2[2];
	float af3[] = {3.0};
	float af4[], af5[5];
	float af6[], af7[] = {7.0}, af8[];
	hash ah1[];
	hash ah2[2];
	hash ah3[], ah4[4], ah5[];
	struct s ast1[];
	struct s ast2[2];
	struct s ast3[], ast4[4], ast5[];

	puts(::tcl::unsupported::disassemble("proc", "src_mappings_1"));
	return;
}
#lang tcl
src_mappings_1
} -match regexp -output {.*Command \d+: "i1"
.*Command \d+: "i2 = 2"
.*Command \d+: "i3"
.*Command \d+: "i4"
.*Command \d+: "i5"
.*Command \d+: "i6 = 6"
.*Command \d+: "i7"
.*Command \d+: "s1"
.*Command \d+: "s2 = \\"str2\\""
.*Command \d+: "s3"
.*Command \d+: "s4"
.*Command \d+: "s5"
.*Command \d+: "s6 = \\"str6\\""
.*Command \d+: "s7"
.*Command \d+: "f1"
.*Command \d+: "f2 = 2.0"
.*Command \d+: "f3"
.*Command \d+: "f4"
.*Command \d+: "f5"
.*Command \d+: "f6 = 6.0"
.*Command \d+: "f7"
.*Command \d+: "h1"
.*Command \d+: "h2 = \{2=>2\}"
.*Command \d+: "h3"
.*Command \d+: "h4"
.*Command \d+: "h5"
.*Command \d+: "h6 = \{6=>6\}"
.*Command \d+: "h7"
.*Command \d+: "st1"
.*Command \d+: "st2 = \{2\}"
.*Command \d+: "st3"
.*Command \d+: "st4"
.*Command \d+: "st5"
.*Command \d+: "st6 = \{6\}"
.*Command \d+: "st7"
.*Command \d+: "p1"
.*Command \d+: "p2 = 2"
.*Command \d+: "p3"
.*Command \d+: "p4"
.*Command \d+: "p5"
.*Command \d+: "p6 = 6"
.*Command \d+: "p7"
.*Command \d+: "w1"
.*Command \d+: "w2 = \\"w2\\""
.*Command \d+: "w3"
.*Command \d+: "w4"
.*Command \d+: "w5"
.*Command \d+: "w6 = \\"w6\\""
.*Command \d+: "w7"
.*Command \d+: "ai1\[\]"
.*Command \d+: "ai2\[2\]"
.*Command \d+: "ai3\[\] = \{3\}"
.*Command \d+: "ai4\[\]"
.*Command \d+: "ai5\[5\]"
.*Command \d+: "ai6\[\]"
.*Command \d+: "ai7\[\] = \{7\}"
.*Command \d+: "ai8\[\]"
.*Command \d+: "as1\[\]"
.*Command \d+: "as2\[2\]"
.*Command \d+: "as3\[\] = \{\\"3\\"\}"
.*Command \d+: "as4\[\]"
.*Command \d+: "as5\[5\]"
.*Command \d+: "as6\[\]"
.*Command \d+: "as7\[\] = \{\\"7\\"\}"
.*Command \d+: "as8\[\]"
.*Command \d+: "af1\[\]"
.*Command \d+: "af2\[2\]"
.*Command \d+: "af3\[\] = \{3.0\}"
.*Command \d+: "af4\[\]"
.*Command \d+: "af5\[5\]"
.*Command \d+: "af6\[\]"
.*Command \d+: "af7\[\] = \{7.0\}"
.*Command \d+: "af8\[\]"
.*Command \d+: "ah1\[\]"
.*Command \d+: "ah2\[2\]"
.*Command \d+: "ah3\[\]"
.*Command \d+: "ah4\[4\]"
.*Command \d+: "ah5\[\]"
.*Command \d+: "ast1\[\]"
.*Command \d+: "ast2\[2\]"
.*Command \d+: "ast3\[\]"
.*Command \d+: "ast4\[4\]"
.*Command \d+: "ast5\[\]"
}

test src-mappings-2 {test bytecode <-> source-file-offset mappings 2} -body {
#lang L -nowarn
int f0() { return (0); }
int f1(int i) { return (1); }
int f2(int i, int j) { return (2); }
void
src_mappings_2()
{
	/*
	 * This test checks the mappings for expressions.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i, j;
	int i1 = 1+2;
	int i2 = i1+2*3;
	int i3, i4, i5;
	string s, t;
	float f;
	int ai[];
	int aii[][];
	int ah{int};
	int ahh{int}{int};

	puts(::tcl::unsupported::disassemble("proc", "src_mappings_2"));
	return;

	/* Check assignments. */
	i1 = 1;
	f = 3.14;
	s = "str";

	/* Check array and hash subscripts. */
	i = ai[i1 - i2 - i3];
	i = aii[i1][i2];
	i = ah{i3 - i4};
	i = ahh{i3}{i4 - i5};

	/* Check that each sub-expression has a mapping. */
	i3 = 3;
	i4 = 4 + 3;
	i5 = i3 + i4 * i5 - 5;

	/* Check parameters. */
	f0();
	f1(i1);
	f2(i1, i2);
	f2(i1, i2 + f1(2));

	/* Check that each binary and unary operator gets a mapping. */
	(tcl)i;
	(string)i;
	(widget)i;
	(float)i;
	!i;
	~i;
	+i;
	-i;
	&i;
	defined(i);
	i = j;
	i += j;
	i -= j;
	i *= j;
	i /= j;
	i %= j;
	i &= j;
	i |= j;
	i <<= j;
	i >>= j;
	i && j;
	i || j;
	s eq t;
	s ne t;
	s gt t;
	s ge t;
	s lt t;
	s le t;
	i == j;
	i != j;
	i > j;
	i >= j;
	i < j;
	i <= j;
	i + j;
	i - j;
	i * j;
	i / j;
	i % j;
	i & j;
	i | j;
	i ^ j;
	i << j;
	i >> j;
	s =~ /x/;
	s =~ /x/i;
	s =~ /x/g;
	s =~ /x/ig;
	s =~ m|x|;
	s =~ m|x|i;
	s =~ m|x|g;
	s =~ m|x|ig;
	s =~ s/x/y/;
	s =~ s/x/y/i;
	s =~ s/x/y/g;
	s =~ s/x/y/ig;

	/* Check interpolated strings. */
	s = "abc${t}";
	s = "${t}xyz";
	s = "abc${t}xyz";
	s = "abc${"${t}"}xyz";
}
#lang tcl
src_mappings_2
} -match regexp -output {.*Command \d+: "1\+2"
.*Command \d+: "i1 = 1\+2"
.*Command \d+: "i1\+2\*3"
.*Command \d+: "i2 = i1\+2\*3"
.*Command \d+: "2\*3"
.*Command \d+: "i1 = 1"
.*Command \d+: "f = 3.14"
.*Command \d+: "s = \\"str\\""
.*Command \d+: "ai\[i1 - i2 - i3\]"
.*Command \d+: "i = ai\[i1 - i2 - i3\]"
.*Command \d+: "i1 - i2"
.*Command \d+: "i1 - i2 - i3"
.*Command \d+: "aii\[i1\]\[i2\]"
.*Command \d+: "i = aii\[i1\]\[i2\]"
.*Command \d+: "ah\{i3 - i4\}"
.*Command \d+: "i = ah\{i3 - i4\}"
.*Command \d+: "i3 - i4"
.*Command \d+: "ahh\{i3\}\{i4 - i5\}"
.*Command \d+: "i = ahh\{i3\}\{i4 - i5\}"
.*Command \d+: "i4 - i5"
.*Command \d+: "i3 = 3"
.*Command \d+: "4 \+ 3"
.*Command \d+: "i4 = 4 \+ 3"
.*Command \d+: "i3 \+ i4 \* i5"
.*Command \d+: "i3 \+ i4 \* i5 - 5"
.*Command \d+: "i5 = i3 \+ i4 \* i5 - 5"
.*Command \d+: "i4 \* i5"
.*Command \d+: "f0\(\)"
.*Command \d+: "f1\(i1\)"
.*Command \d+: "f2\(i1, i2\)"
.*Command \d+: "f2\(i1, i2 \+ f1\(2\)\)"
.*Command \d+: "i2 \+ f1\(2\)"
.*Command \d+: "f1\(2\)"
.*Command \d+: "\(tcl\)i"
.*Command \d+: "\(string\)i"
.*Command \d+: "\(widget\)i"
.*Command \d+: "\(float\)i"
.*Command \d+: "!i"
.*Command \d+: "~i"
.*Command \d+: "\+i"
.*Command \d+: "-i"
.*Command \d+: "&i"
.*Command \d+: "defined\(i\)"
.*Command \d+: "i = j"
.*Command \d+: "i \+= j"
.*Command \d+: "i -= j"
.*Command \d+: "i \*= j"
.*Command \d+: "i /= j"
.*Command \d+: "i %= j"
.*Command \d+: "i <<= j"
.*Command \d+: "i >>= j"
.*Command \d+: "i && j"
.*Command \d+: "i \|\| j"
.*Command \d+: "s eq t"
.*Command \d+: "s ne t"
.*Command \d+: "s gt t"
.*Command \d+: "s ge t"
.*Command \d+: "s lt t"
.*Command \d+: "s le t"
.*Command \d+: "i == j"
.*Command \d+: "i != j"
.*Command \d+: "i > j"
.*Command \d+: "i >= j"
.*Command \d+: "i < j"
.*Command \d+: "i <= j"
.*Command \d+: "i \+ j"
.*Command \d+: "i - j"
.*Command \d+: "i \* j"
.*Command \d+: "i / j"
.*Command \d+: "i % j"
.*Command \d+: "i & j"
.*Command \d+: "i \| j"
.*Command \d+: "i \^ j"
.*Command \d+: "i << j"
.*Command \d+: "i >> j"
.*Command \d+: "s =~ /x/"
.*Command \d+: "s =~ /x/i"
.*Command \d+: "s =~ /x/g"
.*Command \d+: "s =~ /x/ig"
.*Command \d+: "s =~ m\|x\|"
.*Command \d+: "s =~ m\|x\|i"
.*Command \d+: "s =~ m\|x\|g"
.*Command \d+: "s =~ m\|x\|ig"
.*Command \d+: "s =~ s/x/y/"
.*Command \d+: "s =~ s/x/y/i"
.*Command \d+: "s =~ s/x/y/g"
.*Command \d+: "s =~ s/x/y/ig"
.*Command \d+: "\\"abc\$\{t\}\\""
.*Command \d+: "s = \\"abc\$\{t\}\\""
.*Command \d+: "\\"\$\{t\}xyz\\""
.*Command \d+: "s = \\"\$\{t\}xyz\\""
.*Command \d+: "\\"abc\$\{t\}xyz\\""
.*Command \d+: "s = \\"abc\$\{t\}xyz\\""
.*Command \d+: "\\"abc\$\{\\"\$\{t\}\\"\}xyz\\""
.*Command \d+: "s = \\"abc\$\{\\"\$\{t\}\\"\}xyz\\""
.*Command \d+: "\\"\$\{t\}\\""
}

test src-mappings-3 {test bytecode <-> source-file-offset mappings 3} -body {
#lang L -nowarn
int
f()
{
	return (0);
}
void
fv()
{
	return;
}
int{int}
fh()
{
	int h{int};
	return (h);
}
int[]
fa()
{
	int a[5];
	return (a);
}
int
src_mappings_3()
{
	/*
	 * This test checks the mappings for statements.
	 * Note: avoid tabs in the source to make the test regexp clearer.
	 */

	int i, j, k, v;
	int a[5];
	int h{int};

	/* Disassemble fv() to get its "return" stmt w/no arg. */
	puts(::tcl::unsupported::disassemble("proc", "fv"));
	puts(::tcl::unsupported::disassemble("proc", "src_mappings_3"));
	return(0);

	while (0) f();
	do f(); while (0);
	for (i = 0; i < 10;) f();
	for (i = 0; i < 10; ++i) f();
	foreach (k => v in fh()) f();
	foreach (i,j in fa()) f();
	push (&a, f());
	/* Check break and continue. */
	do {
		break;
		continue;
	} while (0);
}
#lang tcl
src_mappings_3
} -match regexp -output {.*Command \d+: "return"
.*Command \d+: "return\(0\)"
.*Command \d+: "while \(0\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "do f\(\); while \(0\);"
.*Command \d+: "i = 0"
.*Command \d+: "for \(i = 0; i < 10;\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "i < 10"
.*Command \d+: "i = 0"
.*Command \d+: "for \(i = 0; i < 10; \+\+i\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "\+\+i"
.*Command \d+: "i < 10"
.*Command \d+: "fh\(\)"
.*Command \d+: "foreach \(k => v in fh\(\)\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "fa\(\)"
.*Command \d+: "foreach \(i,j in fa\(\)\) f\(\);"
.*Command \d+: "f\(\)"
.*Command \d+: "push \(&a, f\(\)\)"
.*Command \d+: "f\(\)"
.*Command \d+: "break"
.*Command \d+: "continue"
}

test function-1.0 {check function call rules} -body {
#lang L
void function_1_0_foo() { puts("foo"); }
void function_1_0_f()   { puts("f"); }
void
function_1_0()
{
	string	s = "function_1_0_foo";
	poly	p = "function_1_0_foo";

	/*
	 * "s" and "p" are string or poly variables that contain the
	 * function name.
	 */
	s();			// calls function_1_0_foo
	function_1_0_foo();
	function_1_0_f();
	p();			// calls function_1_0_foo

	/*
	 * Calling an undeclared function is not an error, we just get
	 * no arg type checking, so passing anything should be allowed.
	 */
	if (0) {
		not_defined1();
		not_defined1(s);
		not_defined1(s, p);
		not_defined2(1, 2, 3, 4);
	}
}
#lang tcl
function_1_0
} -output {foo
foo
f
foo
}

test function-1.1 {check function call rules error cases} -body {
#lang L
int function_1_1_f1;
int function_1_1_f1() { return (0); }	// err -- already declared as variable
int function_1_1_f2() { return (0); }
int function_1_1_f2;			// err -- already declared as function
int function_1_1_f3() { return (0); }
int function_1_1_f3() { return (0); }	// err -- multiply declared function
void
function_1_1()
{
	int	i;
	float	f;
	int	a[];
	int	h{int};
	struct { int i,j; } st;

	/* All illegal because the var isn't a string or poly. */
	i();
	f();
	a();
	h();
	st();
}
#lang tcl
function_1_1
} -returnCodes {error} -match regexp -result {.*2: L Error: function_1_1_f1 already declared as a variable
.*4: L Error: multiple declaration of global function_1_1_f2
.*6: L Error: function function_1_1_f3 already declared
.*:17: L Error: function name is a non-string variable
.*:18: L Error: function name is a non-string variable
.*:19: L Error: function name is a non-string variable
.*:20: L Error: function name is a non-string variable
.*:21: L Error: function name is a non-string variable
}

test function-1.2 {check function prototypes} -body {
#lang L -nowarn
int function_1_2_f1();
int function_1_2_f1() { return (1); }

int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2();
int function_1_2_f2() { return (1); }

int function_1_2_f3() { return (1); }
int function_1_2_f3();

string function_1_2_f4(int a, string b, float c, int d[], hash e);
string function_1_2_f4(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_2_f5(int a, string b, float c, int d[], hash e){ return (b); }
string function_1_2_f5(int a, string b, float c, int d[], hash e);

void
function_1_2()
{
	int	a;
	string	s;
	float	c;
	int	d[];
	hash	e;

	s = function_1_2_f4(a, "f4", c, d, e);
	unless (s eq "f4") puts("bad 1");

	s = function_1_2_f5(a, "f5", c, d, e);
	unless (s eq "f5") puts("bad 2");
}
#lang tcl
function_1_2
} -output {}

test function-1.3 {check function prototypes 2} -body {
#lang L
void
function_1_3()
{
	/* Call some libl functions correctly.  There should be no type errs. */

	unless (streq("testing", "testing")) puts("bad 1");
	unless (strlen("three") == 5) puts("bad 2");
	unless (strneq("test", "testing", 4)) puts("bad 3");
}
#lang tcl
function_1_3
} -output {}

test function-1.4 {check function prototype errors} -body {
#lang L
void
function_1_4()
{
	/* Call a libl function with incorrect args. */

	streq();
	streq("a");
	streq("a", 2);
	streq("a", "b", 2);
}
} -returnCodes {error} -match regexp -result {.*6: L Error: not enough arguments for function streq
.*7: L Error: not enough arguments for function streq
.*8: L Error: parameter 2 has incompatible type
.*9: L Error: too many arguments for function streq
}

test function-1.5 {check function prototype errors 2} -body {
#lang L
void function_1_5_f1();
int function_1_5_f1() { return (0); }

int function_1_5_f2() { return (0); }
void function_1_5_f2();

void function_1_5_f3(int a);
void function_1_5_f3() { }

void function_1_5_f4() { }
void function_1_5_f4(int a);

int function_1_5_f5(int a);
void function_1_5_f5() { }

void function_1_5_f6() { }
int function_1_5_f6(int a);

string function_1_5_f7(int a, string b, float c, int d[]);
string function_1_5_f7(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_5_f8(string b, float c, int d[], hash e);
string function_1_5_f8(int a, string b, float c, int d[], hash e){ return (b); }

string function_1_5_f9(string b, float c, int d[], hash e);
string function_1_5_f9(string b, ...rest){ return (b); }
} -returnCodes {error} -match regexp -result {.*2: L Error: does not match prior declaration of function_1_5_f1
.*5: L Error: does not match prior declaration of function_1_5_f2
.*8: L Error: does not match prior declaration of function_1_5_f3
.*11: L Error: does not match prior declaration of function_1_5_f4
.*14: L Error: does not match prior declaration of function_1_5_f5
.*17: L Error: does not match prior declaration of function_1_5_f6
.*20: L Error: does not match prior declaration of function_1_5_f7
.*23: L Error: does not match prior declaration of function_1_5_f8
.*26: L Error: does not match prior declaration of function_1_5_f9
}

test initializers-1 {check variable initializer error cases} -body {
#lang L
extern int g = 0;
void initializers_1() {
	/*
	 * Externs in local scopes are illegal as well as extern
	 * initializers, so this is error on two counts.
	 */
	extern int l = 0;
}
} -returnCodes {error} -match regexp -result {.*1: L Error: extern initializers illegal
.*7: L Error: extern.*
}

test initializers-2 {check variable initializers} -body {
#lang L
struct initializers_2_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};
struct initializers_2_s2 {
	int	i, j;
};
typedef struct initializers_2_s2 h_of_s2{int};

void initializers_2()
{
	int	i;
	int	i1 = 11;
	int	i2, i3 = 33;
	int	i4, i5 = 55, i6;
	int	i7, i8 = 88, i9 = 99, i10 = 111;
	string	s = "s";
	float	f = 3.1, f2 = 3;
	string	ai[] = { "a", "b", "c" };
	string	hs{int} = { 1=>"one", 2=>"two", 3=>"three" };
	struct initializers_2_s1 st = {
		1,
		2, 3,
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" },   // note the trailing comma (legal)
	};
	string	aempty[] = {};
	h_of_s2	h2 = { 1 => {2,3}, 2 => {4,5} };

	unless (i1 == 11) puts("bad 1");
	unless (!i2 && !i4 && !i6 && !i7) puts("bad 2");
	unless (i3 == 33) puts("bad 3");
	unless (i5 == 55) puts("bad 4");
	unless (i8 == 88) puts("bad 5");
	unless (i9 == 99) puts("bad 6");
	unless (i10 == 111) puts("bad 7");
	unless (s eq "s") puts("bad 8");
	unless (f == 3.1) puts("bad 9");
	unless (f2 == 3) puts("bad 9.1");
	unless ((ai[0] eq "a") && (ai[1] eq "b")) puts("bad 10");
	unless ((ai[2] eq "c") && !defined(ai[3])) puts("bad 11");
	i = 0;
	foreach (s in ai) ++i;
	unless (i == 3) puts("bad 12");
	unless ((hs{1} eq "one") && (hs{2} eq "two")) puts("bad 13");
	unless ((hs{3} eq "three")) puts("bad 14");
	i = 0;
	foreach (i1 in hs) ++i;
	unless (i == 3) puts("bad 15");

	unless ((st.i == 1) && (st.j == 2) && (st.k == 3)) puts("bad 16");
	unless ((st.s eq "s") && (st.as[0] eq "x")) puts("bad 17");
	unless ((st.as[1] eq "y") && (st.as[2] eq "z")) puts("bad 18");
	i = 0;
	foreach (s in st.as) ++i;
	unless (i == 3) puts("bad 19");
	unless ((st.hs{3} eq "t") && (st.hs{6} eq "s")) puts("bad 20");
	i = 0;
	foreach (i1 in st.hs) ++i;
	unless (i == 2) puts("bad 21");

	if (defined(aempty[0])) puts("bad 30");
	unless ((h2{1}.i == 2) && (h2{1}.j == 3)) puts("bad 31");
	unless ((h2{2}.i == 4) && (h2{2}.j == 5)) puts("bad 32");
}
#lang tcl
initializers_2
} -output {}

test initializers-3 {check variable initializer type errors} -body {
#lang L
struct initializers_3_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};

void initializers_3()
{
	int	i1 = 1.0;
	int	i2, i3 = "s";
	int	i4, i5 = {3}, i6;
	string	s = 3.1;
	float	f = "3.1";
	string	ai[] = {"a", 2, "c"};
	string	hs{int} = { 1=>"one", "2"=>"two", 3=>"three" };
	struct initializers_2_s1 st = {
		1,
		2,  // err -- omitted initializer for "k"
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" }
	};
	string	hs2{int} = { 1=>"one", 3 };
}
} -returnCodes {error} -match regexp -result {.*11: L Error: assignment of incompatible types
.*12: L Error: assignment of incompatible types
.*13: L Error: assignment of incompatible types
.*14: L Error: assignment of incompatible types
.*15: L Error: assignment of incompatible types
.*16: L Error: assignment of incompatible types
.*17: L Error: hash elements must all be of same type
.*18: L Error: assignment of incompatible types
.*25: L Error: cannot mix hash and non-hash elements
}

test initializers-4 {check expressions in variable initializers} -body {
#lang L
int init_4_g = 33;
void initializers_4()
{
	/*
	 * Initializers are full-blown expressions, so they can contain
	 * variables etc.
	 */
	int	e1 = 11;
	int	e2 = e1*2;
	int	a[] = { init_4_g, init_4_g*2, e1, e2, 3 };

	unless ((e1 == 11) && (e2 == 22)) puts("bad 1");
	unless ((a[0] == 33) && (a[1] == 66) && (a[2] == 11) &&
		(a[3] == 22) && (a[4] == 3)) puts("bad 2");
	if (defined(a[5])) puts("bad 3");
}
#lang tcl
initializers_4
} -output {}

test composite-1 {check composite values in expressions 1} -body {
#lang L
struct composite_1_s1 {
	int	i;
	int	j, k;
	string	s;
	string	as[];
	string	hs{int};
};
int composite_1_g = 33;
void composite_1()
{
	/*
	 * These are taken from the initializer-* tests above but
	 * are used in the rhs of expressions instead of in initializers.
	 */

	int	i, i1;
	int	e1 = 11;
	int	e2 = e1*2;
	string	s;
	int	a[];
	string	ai[];
	string	hs{int};
	struct composite_1_s1 st;
	string	aempty[];
	h_of_s2	h2;

	a = { composite_1_g, composite_1_g*2, e1, e2, 3 };

	unless ((e1 == 11) && (e2 == 22)) puts("bad 1");
	unless ((a[0] == 33) && (a[1] == 66) && (a[2] == 11) &&
		(a[3] == 22) && (a[4] == 3)) puts("bad 2");
	if (defined(a[5])) puts("bad 3");

	ai = { "a", "b", "c" };
	hs = { 1=>"one", 2=>"two", 3=>"three" };
	st = {
		1,
		2, 3,
		"s",
		{ "x", "y", "z" },
		{ 3=>"t", 6=>"s" },   // note the trailing comma (legal)
	};
	aempty = {};
	h2 = { 1 => {2,3}, 2 => {4,5} };

	unless ((ai[0] eq "a") && (ai[1] eq "b")) puts("bad 10");
	unless ((ai[2] eq "c") && !defined(ai[3])) puts("bad 11");
	i = 0;
	foreach (s in ai) ++i;
	unless (i == 3) puts("bad 12");
	unless ((hs{1} eq "one") && (hs{2} eq "two")) puts("bad 13");
	unless ((hs{3} eq "three")) puts("bad 14");
	i = 0;
	foreach (i1 in hs) ++i;
	unless (i == 3) puts("bad 15");

	unless ((st.i == 1) && (st.j == 2) && (st.k == 3)) puts("bad 16");
	unless ((st.s eq "s") && (st.as[0] eq "x")) puts("bad 17");
	unless ((st.as[1] eq "y") && (st.as[2] eq "z")) puts("bad 18");
	i = 0;
	foreach (s in st.as) ++i;
	unless (i == 3) puts("bad 19");
	unless ((st.hs{3} eq "t") && (st.hs{6} eq "s")) puts("bad 20");
	i = 0;
	foreach (i1 in st.hs) ++i;
	unless (i == 2) puts("bad 21");

	if (defined(aempty[0])) puts("bad 30");
	unless ((h2{1}.i == 2) && (h2{1}.j == 3)) puts("bad 31");
	unless ((h2{2}.i == 4) && (h2{2}.j == 5)) puts("bad 32");
}
#lang tcl
composite_1
} -output {}

test composite-2 {check composite values in expressions 2} -body {
#lang L
string composite_2_join(string[] a)
{
	string	s;
	string	ret = "";

	foreach (s in a) ret = sprintf("%s%s", ret, s);
	return (ret);
}
void composite_2()
{
	/*
	 * Try more operations with composite values.
	 */

	int	i;
	int	ai[];

	unless (composite_2_join({"a","b","c"}) eq "abc") puts("bad 1");

	for (i = 0; i < 5; ++i) {
		unless ({0,1,2,3,4}[i] == i) printf("bad 2 %d\n", i);
	}
	if (defined({0,1,2,3,4}[5])) puts("bad 3");

	unless ({1=>"one", 2=>"two", 3=>"three"}{1} eq "one") puts("bad 4");
	unless ({1=>"one", 2=>"two", 3=>"three"}{2} eq "two") puts("bad 5");
	unless ({1=>"one", 2=>"two", 3=>"three"}{3} eq "three") puts("bad 6");

	unless (((struct { int i,j,k; }){1,2,3}).i == 1) puts("bad 10");
	unless (((struct { int i,j,k; }){1,2,3}).j == 2) puts("bad 11");
	unless (((struct { int i,j,k; }){1,2,3}).k == 3) puts("bad 12");

	unless ({{1,2},{3,4},{4,5}}[1][0] == 3) puts("bad 20");
}
#lang tcl
composite_2
} -output {}

test composite-3 {check type errors with composite values} -body {
#lang L -nowarn
void composite_3_as(string[] a) {}
void composite_3_ai(int[] a) {}
void composite_3_his(int{string} a) {}
void composite_3_hsi(string{int} a) {}
void composite_3_hss(string{string} a) {}
void composite_3_hii(int{int} a) {}

void composite_3()
{
	composite_3_as({1,2,3});
	composite_3_ai({"a","b","c"});
	composite_3_his({1,2,3});
	composite_3_his({1=>2,3=>4});
	composite_3_hsi({1=>2,3=>4});
	composite_3_hss({1=>2,3=>4});
	composite_3_hii({"1"=>2,"3"=>4});
}
} -returnCodes {error} -match regexp -result {.*10: L Error:.*incompatible type.*
.*11: L Error:.*incompatible type.*
.*12: L Error:.*incompatible type.*
.*13: L Error:.*incompatible type.*
.*14: L Error:.*incompatible type.*
.*15: L Error:.*incompatible type.*
.*16: L Error:.*incompatible type.*
}

test lvalue-1 {check indexing hash/struct/array expressions} -body {
#lang L
void lvalue_1()
{
	/*
	 * This checks deep-dive of an expression rather than a
	 * variable.  There are only two ways an expression can have
	 * an array/struct/hash value: a function return value, and an
	 * assignment.
	 */
	string	a1[] = { "1", "2", "3" };
	string	a2[];

	unless (split("a b c")[0] eq "a") puts("bad 1");
	unless (split("a b c")[1] eq "b") puts("bad 2");
	unless (split("a b c")[2] eq "c") puts("bad 3");

	if (defined(a2[0])) puts("bad 4");
	unless ((a2 = a1)[0] eq "1") puts("bad 5");
	unless ((a2 = a1)[1] eq "2") puts("bad 6");
	unless ((a2 = a1)[2] eq "3") puts("bad 7");
	unless ((a2[0] eq "1") && (a2[1] eq "2") && (a2[2] eq "3")) {
		puts("bad 8");
	}
	if (defined(a2[3])) puts("bad 9");
}
#lang tcl
lvalue_1
} -output {}

test lvalue-2 {illegal l-value in deep-dive assignments} -body {
#lang L
int[] lvalue_2_ints()
{
	int	a[] = { 1, 2, 3 };
	return (a);
}
void lvalue_2()
{
	int	a1[], a2[];
	string	s1[], s2[];

	lvalue_2_ints()[0] = 0;
	lvalue_2_ints()[0] += 1;
	++lvalue_2_ints()[0];
	lvalue_2_ints()[0]--;
	split("a","b","c")[0] =~ s/a/b/;

	(a2 = a1)[0] = 0;
	(a2 = a1)[0] += 1;
	++(a2 = a1)[0];
	(a2 = a1)[0]--;
	(s2 = s1)[0] =~ s/bad/yes-its-still-bad/;
}
#lang tcl
lvalue_2
} -returnCodes {error} -match regexp -result {.*11: L Error: target of assignment is not an l-value
.*12: L Error: target of assignment is not an l-value
.*13: L Error: target of assignment is not an l-value
.*14: L Error: target of assignment is not an l-value
.*15: L Error: target of assignment is not an l-value
.*17: L Error: target of assignment is not an l-value
.*18: L Error: target of assignment is not an l-value
.*19: L Error: target of assignment is not an l-value
.*20: L Error: target of assignment is not an l-value
.*21: L Error: target of assignment is not an l-value
}

test lvalue-3 {invalid l-value in inc/dec operators} -body {
#lang L
void lvalue_3()
{
	int	i = 0;

	i----;
	i++++;
	(i++)++;
	(i++)--;
	(i--)++;
	(i--)--;
	++++i;
	----i;
	++(++i);
	++(--i);
	--(++i);
	--(--i);
	--(i--);
	--(i++);
	++(i--);
	++(i++);
	(--i)--;
	(--i)++;
	(++i)--;
	(++i)++;
}
#lang tcl
lvalue_3
} -returnCodes {error} -match regexp -result {.*5: L Error: invalid l-value in inc/dec
.*6: L Error: invalid l-value in inc/dec
.*7: L Error: invalid l-value in inc/dec
.*8: L Error: invalid l-value in inc/dec
.*9: L Error: invalid l-value in inc/dec
.*10: L Error: invalid l-value in inc/dec
.*11: L Error: invalid l-value in inc/dec
.*12: L Error: invalid l-value in inc/dec
.*13: L Error: invalid l-value in inc/dec
.*14: L Error: invalid l-value in inc/dec
.*15: L Error: invalid l-value in inc/dec
.*16: L Error: invalid l-value in inc/dec
.*17: L Error: invalid l-value in inc/dec
.*18: L Error: invalid l-value in inc/dec
.*19: L Error: invalid l-value in inc/dec
.*20: L Error: invalid l-value in inc/dec
.*21: L Error: invalid l-value in inc/dec
.*22: L Error: invalid l-value in inc/dec
.*23: L Error: invalid l-value in inc/dec
.*24: L Error: invalid l-value in inc/dec
}

test lvalue-4 {invalid l-value in assignments} -body {
#lang L
int lvalue_4_foo() { return (1); }
void lvalue_4()
{
	int	i;

	lvalue_4_foo() = i;
	lvalue_4_foo() += i;
	lvalue_4_foo() -= i;
	lvalue_4_foo() *= i;
	lvalue_4_foo() /= i;
	lvalue_4_foo() %= i;
	lvalue_4_foo() &= i;
	lvalue_4_foo() |= i;
	lvalue_4_foo() ^= i;
	lvalue_4_foo() >>= i;
	lvalue_4_foo() <<= i;
	lvalue_4_foo() =~ s/bad/dab/;
}
#lang tcl
lvalue_4
} -returnCodes {error} -match regexp -result {.*6: L Error: invalid l-value in assignment
.*7: L Error: invalid l-value in assignment
.*8: L Error: invalid l-value in assignment
.*9: L Error: invalid l-value in assignment
.*10: L Error: invalid l-value in assignment
.*11: L Error: invalid l-value in assignment
.*12: L Error: invalid l-value in assignment
.*13: L Error: invalid l-value in assignment
.*14: L Error: invalid l-value in assignment
.*15: L Error: invalid l-value in assignment
.*16: L Error: invalid l-value in assignment
.*17: L Error: invalid l-value in =~
}

test lvalue-5 {invalid l-value in & operator} -body {
#lang L -nowarn
int lvalue_5_foo() { return (1); }
void lvalue_5_bar(int &i) {}
void lvalue_5()
{
	lvalue_5_bar(&lvalue_4_foo());
	lvalue_5_bar(&1);
}
#lang tcl
lvalue_5
} -returnCodes {error} -match regexp -result {.*5: L Error: invalid argument to &
.*6: L Error: invalid argument to &
}

# cleanup
::tcltest::cleanupTests
return
