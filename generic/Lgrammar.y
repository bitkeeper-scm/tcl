%{
#include <stdio.h>
#include "Lcompile.h"
#include "tclInt.h"
#include "tclCompile.h"

/* L_lex is generated by lex */
int L_lex (void);

extern int L_interactive;

#define YYERROR_VERBOSE
%}

%token T_LPAREN "("
%token T_RPAREN ")"
%token T_LBRACE "{"
%token T_RBRACE "}"
%token T_LBRACKET "["
%token T_RBRACKET "]"
%token T_ANDAND "&&"
%token T_OROR "||"
%token T_SEMI ";"
%token T_BANGTWID "!~"
%token T_EQTWID "=~"
%token T_IF "if"
%token T_UNLESS "unless"
%nonassoc T_ELSE "else"
%token T_RETURN "return"

%token T_COMMA ","

%right T_EQUALS "="

%token T_EQ "eq"
%token T_NE "ne"
%token T_LT "lt"
%token T_LE "le"
%token T_GT "gt"
%token T_GE "ge"
%token T_ARROW "=>"
%token T_EQUALEQUAL "=="
%token T_NOTEQUAL "!="
%token T_GREATER ">"
%token T_GREATEREQ ">="
%token T_LESSTHAN "<"
%token T_LESSTHANEQ "<="

%token T_ID T_STR_LITERAL T_RE T_INT_LITERAL T_FLOAT_LITERAL
%token T_HASH T_POLY T_VOID T_VAR T_STRING T_INT T_FLOAT

%left T_OROR
%left T_ANDAND
%nonassoc T_EQ T_NE T_EQUALEQUAL T_NOTEQUAL T_EQTWID T_BANGTWID
%nonassoc T_GT T_GE T_LT T_LE T_GREATER T_GREATEREQ T_LESSTHAN T_LESSTHANEQ
%left T_PLUS T_MINUS
%left T_STAR T_SLASH T_PERC
%right T_BANG T_PLUSPLUS T_MINUSMINUS UMINUS

%%

start:	  funclist	{ }
	;

funclist: funclist function_declaration	{ }
	|		{ }
	;

function_declaration:
          return_type_specifier T_ID {  } "(" parameter_list ")"
                compound_statement {  }
	;

stmt:
          single_statement		{if (L_interactive) YYACCEPT;}
        | compound_statement		{if (L_interactive) YYACCEPT;}
        ;

single_statement:
          selection_statement
	| expr ";"
        | T_RETURN ";"                  {  }
        | T_RETURN expr ";"             {  }
	;

selection_statement:
          T_IF "(" expr ")"             {  }
                compound_statement      {  }
                optional_else           {  }
        /* if you have no curly braces, you get no else. */
        | T_IF "(" expr ")"             {  }
                single_statement        {  }
        /* analogous to the if statements. the unless statements
           differ only by the true value passed to L_if_condition */
        | T_UNLESS "(" expr ")"         { }
                compound_statement      { }
                optional_else           { }
        | T_UNLESS "(" expr ")"         { }
                single_statement        { }
        ;

optional_else:
        /* else clauses must either have curly braces or be another
           if/unless */
          T_ELSE                {
                                  }
                compound_statement
        | T_ELSE                {
                                  }
                selection_statement
        | /* epsilon */         { }
        ;

stmt_list:
          stmt
 	| stmt_list stmt
	;


parameter_list:
          parameter_declaration_list
        | T_VOID
        | /* epsilon */
        ;

parameter_declaration_list:
          parameter_declaration
        | parameter_declaration_list "," parameter_declaration
        ;

parameter_declaration:
          type_specifier declarator
                { }
        ;

argument_expression_list:
          argument_expression_list "," expr     { }
	| expr			{ }
	| /* epsilon */         { }
        ;

expr:
          "(" expr ")"          { }
/* 	| "!" expr		{ } */
/* 	| "-" expr %prec UMINUS	{ } */
        | T_PLUSPLUS T_ID       { }
	| T_MINUSMINUS T_ID     { }
	| T_ID T_PLUSPLUS       { }
	| T_ID T_MINUSMINUS     { }
	| expr T_STAR expr      { }
	| expr T_SLASH expr     { }
	| expr T_PERC expr      { }
	| expr T_PLUS expr      { }
	| expr T_MINUS expr     { }

/* 	| expr "lt" expr	{ } */
/* 	| expr "le" expr	{ } */
/* 	| expr "gt" expr	{ } */
/* 	| expr "ge" expr	{ } */
/* 	| expr "eq" expr	{ } */
/* 	| expr "ne" expr	{ } */
/* 	| expr "==" expr	{ } */
/* 	| expr "!=" expr	{ } */
/* 	| expr ">" expr		{ } */
/* 	| expr ">=" expr	{ } */
/* 	| expr "<" expr		{ } */
/* 	| expr "<=" expr	{ } */
/* 	| expr "=~" T_RE	{ } */
/* 	| expr "!~" T_RE	{ } */
/* 	| expr "&&" expr	{ } */
/* 	| expr "||" expr	{ } */
/*         |  */
        | T_STR_LITERAL         { }
        | T_INT_LITERAL         { }
        | T_FLOAT_LITERAL       { }
	| T_ID                  { }
        | T_ID                  { }
                "(" argument_expression_list ")"
                                { }
	| T_ID T_EQUALS expr    { }
	;


compound_statement:
	  "{" "}"
	| "{" stmt_list "}"
	| "{" declaration_list "}"
	| "{" declaration_list stmt_list "}"
	;

declaration_list:
	  declaration
	| declaration_list declaration
	;

declaration:
	  init_declarator_list ";"
	;

init_declarator_list:
	  type_specifier init_declarator
                { }
	| init_declarator_list "," init_declarator
                { }
	;

init_declarator:
	  declarator
                { }
	| declarator T_EQUALS initializer
                { }
	;

declarator:
          T_ID
	| declarator "[" constant_expression "]"
                {

                }
	| declarator "[" "]"
                {

                }
        ;

return_type_specifier:
          type_specifier
        | T_VOID        { }
        | /* epsilon */ { }
        ;

type_specifier:
	  T_STRING      { }
	| T_INT         { }
	| T_FLOAT       { }
	| T_HASH        { }
	| T_POLY        { }
	| T_VAR         { }
	;

initializer:
          expr
        | "(" hash_initializer_list ")"
        ;

hash_initializer_list:
          hash_initializer
        | hash_initializer_list "," hash_initializer
        ;

hash_initializer:
          constant_expression "=>" constant_expression
        ;

constant_expression:
          expr
        ;
%%


/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
