%{
#include <stdio.h>
#include "Lcompile.h"
#include "tclInt.h"
#include "tclCompile.h"

/* L_lex is generated by lex */
int L_lex (void);

extern int L_interactive;

#define YYERROR_VERBOSE
%}

%token T_LPAREN "("
%token T_RPAREN ")"
%token T_LBRACE "{"
%token T_RBRACE "}"
%token T_LBRACKET "["
%token T_RBRACKET "]"
%token T_ANDAND "&&"
%token T_OROR "||"
%token T_SEMI ";"
%token T_BANGTWID "!~"
%token T_EQTWID "=~"
%token T_IF "if"
%token T_UNLESS "unless"
%nonassoc T_ELSE "else"
%token T_RETURN "return"

%token T_COMMA ","

%right T_EQUALS "="

%token T_EQ "eq"
%token T_NE "ne"
%token T_LT "lt"
%token T_LE "le"
%token T_GT "gt"
%token T_GE "ge"
%token T_ARROW "=>"
%token T_EQUALEQUAL "=="
%token T_NOTEQUAL "!="
%token T_GREATER ">"
%token T_GREATEREQ ">="
%token T_LESSTHAN "<"
%token T_LESSTHANEQ "<="

%token T_ID T_STR_LITERAL T_RE T_INT_LITERAL T_FLOAT_LITERAL
%token T_HASH T_POLY T_VOID T_VAR T_STRING T_INT T_FLOAT

%left T_OROR
%left T_ANDAND
%nonassoc T_EQ T_NE T_EQUALEQUAL T_NOTEQUAL T_EQTWID T_BANGTWID
%nonassoc T_GT T_GE T_LT T_LE T_GREATER T_GREATEREQ T_LESSTHAN T_LESSTHANEQ
%left T_PLUS T_MINUS
%left T_STAR T_SLASH T_PERC
%right T_BANG T_PLUSPLUS T_MINUSMINUS UMINUS

%%

start:	  funclist	{ }
	;

funclist: 
          funclist function_declaration	
        { 
                ((L_function_declaration*)$2)->next = $1; 
                $$ = $2;
        }
	| /* epsilon */         { $$ = NULL; }
	;

function_declaration:
          return_type_specifier T_ID "(" parameter_list ")" compound_statement 
        {  
                $$ = mk_function_declaration($2, $1, $4, $6, NULL);
        }
	;

stmt:
          single_statement      { $$ = $1; if (L_interactive) YYACCEPT; }
        | compound_statement    { $$ = $1; if (L_interactive) YYACCEPT; }
        ;

single_statement:
          selection_statement   
        {
                $$ = mk_statement(NULL); 
                ((L_statement *)$$)->kind = L_STATEMENT_IF_UNLESS;
                ((L_statement *)$$)->u.cond = $1;
        }
	| expr ";"              
        { 
                $$ = mk_statement(NULL);
                ((L_statement *)$$)->kind = L_STATEMENT_EXPR;
                ((L_statement *)$$)->u.expr = $1;
        }
        | T_RETURN ";"                  
        {  
                $$ = mk_statement(NULL);        
                ((L_statement *)$$)->kind = L_STATEMENT_RETURN_STMT;
                ((L_statement *)$$)->u.expr = NULL;
        }
        | T_RETURN expr ";"
        {  
                $$ = mk_statement(NULL);        
                ((L_statement *)$$)->kind = L_STATEMENT_RETURN_STMT;
                ((L_statement *)$$)->u.expr = $2;
        }
	;

selection_statement:
          T_IF "(" expr ")" compound_statement optional_else
        {  
                $$ = mk_if_unless($3, $5, $6);
        }
        /* if you have no curly braces, you get no else. */
        | T_IF "(" expr ")" single_statement
        {
                $$ = mk_if_unless($3, $5, NULL);
        }
        /* analogous to the if statements. the unless statements
           differ only by the true value passed to L_if_condition */
        | T_UNLESS "(" expr ")" compound_statement optional_else 
        {  
                $$ = mk_if_unless($3, $6, $5);
        }
        | T_UNLESS "(" expr ")" single_statement        
        {  
                $$ = mk_if_unless($3, NULL, $5);
        }
        ;

optional_else:
        /* else clauses must either have curly braces or be another
           if/unless */
          T_ELSE compound_statement     { $$ = $2; }
        | T_ELSE selection_statement    { $$ = $2; }
        | /* epsilon */                 
        ;

stmt_list:
          stmt
 	| stmt_list stmt        { ((L_statement *)$1)->next = $2; }
	;


parameter_list:
          parameter_declaration_list
        | T_VOID                        { $$ = NULL; }
        | /* epsilon */                 { $$ = NULL; }
        ;

parameter_declaration_list:
          parameter_declaration
        | parameter_declaration_list "," parameter_declaration
        {
                ((L_variable_declaration *)$1)->next = $3;
                $$ = $1;
        }
        ;

parameter_declaration:
          type_specifier declarator
        { 
                ((L_variable_declaration *)$2)->type = $1;
                $$ = $2;
        }
        ;

argument_expression_list:
          argument_expression_list "," expr
        { 
                ((L_expression *)$1)->next = $3;
                $$ = $1;
        }
	| expr
	| /* epsilon */
        ;

expr:
          "(" expr ")"          { $$ = $2; }
/* 	| "!" expr		{ } */
/* 	| "-" expr %prec UMINUS	{ } */
        | T_PLUSPLUS T_ID
        {   
                $$ = mk_expression(T_PLUSPLUS, $2, NULL, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_PRE;
        }
	| T_MINUSMINUS T_ID
        {   
                $$ = mk_expression(T_MINUSMINUS, $2, NULL, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_PRE;
        }
	| T_ID T_PLUSPLUS
        {
                $$ = mk_expression(T_PLUSPLUS, $2, NULL, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_POST;
        }
	| T_ID T_MINUSMINUS
        {
                $$ = mk_expression(T_PLUSPLUS, $2, NULL, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_POST;
        }
	| expr T_STAR expr
        {
                $$ = mk_expression(T_STAR, $1, $3, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_BINARY;
        }
	| expr T_SLASH expr
        {
                $$ = mk_expression(T_STAR, $1, $3, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_BINARY;
        }
	| expr T_PERC expr
        {
                $$ = mk_expression(T_PERC, $1, $3, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_BINARY;
        }
	| expr T_PLUS expr
        {
                $$ = mk_expression(T_PLUS, $1, $3, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_BINARY;
        }
	| expr T_MINUS expr
        {
                $$ = mk_expression(T_MINUS, $1, $3, NULL, NULL);
                ((L_expression *)$$)->kind = L_EXPRESSION_BINARY;
        }

/* 	| expr "lt" expr	{ } */
/* 	| expr "le" expr	{ } */
/* 	| expr "gt" expr	{ } */
/* 	| expr "ge" expr	{ } */
/* 	| expr "eq" expr	{ } */
/* 	| expr "ne" expr	{ } */
/* 	| expr "==" expr	{ } */
/* 	| expr "!=" expr	{ } */
/* 	| expr ">" expr		{ } */
/* 	| expr ">=" expr	{ } */
/* 	| expr "<" expr		{ } */
/* 	| expr "<=" expr	{ } */
/* 	| expr "=~" T_RE	{ } */
/* 	| expr "!~" T_RE	{ } */
/* 	| expr "&&" expr	{ } */
/* 	| expr "||" expr	{ } */
/*         |  */
        | T_STR_LITERAL
        | T_INT_LITERAL
        | T_FLOAT_LITERAL
	| T_ID
        | T_ID "(" argument_expression_list ")"         
        { 
                $$ = mk_expression(L_EXPRESSION_FUNCALL, $1, $3, NULL, NULL);
                ((L_expression*)$$)->kind = L_EXPRESSION_FUNCALL;
        }
	| T_ID T_EQUALS expr
        { 
                $$ = mk_expression(T_EQUALS, $1, $3, NULL, NULL); 
                ((L_expression*)$$)->kind = L_EXPRESSION_BINARY;
        }
	;


compound_statement:
	  "{" "}"                               { $$ = NULL; }
	| "{" stmt_list "}"                     { $$ = $2; }
	| "{" declaration_list "}"              
        { $$ = $2; 
        }
	| "{" declaration_list stmt_list "}"
        {
                ((L_statement *)$2)->next = $3;
                $$ = $2;
        }
	;

declaration_list:
	  declaration
	| declaration_list declaration
        {
                ((L_variable_declaration *)$1)->next = $2;
        }
	;

declaration:
	  init_declarator_list ";"
	;

init_declarator_list:
	  type_specifier init_declarator
        {
                $$ = mk_variable_declaration($1, NULL, NULL, $2);
        }
	| init_declarator_list "," init_declarator
        {
                L_type *type = ((L_variable_declaration *)$1)->type;
                L_variable_declaration *decl = 
                        mk_variable_declaration(type, NULL, NULL, $3);
                ((L_variable_declaration *)$1)->next = decl;
                $$ = $1;
        }
	;

init_declarator:
	  declarator
	| declarator T_EQUALS initializer
        {
                ((L_variable_declaration *)$1)->expr = $3;
        }
	;

declarator:
          T_ID
        {

        }
	| declarator "[" constant_expression "]"
        {
                ((L_variable_declaration *)$1)->expr = $3;
        }
	| declarator "[" "]"
        {

        }
        ;

return_type_specifier:
          type_specifier
        | T_VOID        { }
        | /* epsilon */ { }
        ;

type_specifier:
	  T_STRING      { }
	| T_INT         { }
	| T_FLOAT       { }
	| T_HASH        { }
	| T_POLY        { }
	| T_VAR         { }
	;

initializer:
          expr
        | "(" hash_initializer_list ")"
        ;

hash_initializer_list:
          hash_initializer
        | hash_initializer_list "," hash_initializer
        ;

hash_initializer:
          constant_expression "=>" constant_expression
        ;

constant_expression:
          expr
        ;
%%


/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
