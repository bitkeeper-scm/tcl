#include <stdio.h>
#include "tclInt.h"
#include "Lscanner.h"           /* Lscanner.h is generated by flex.  It has
                                   the prototypes for L__scan_bytes and
                                   L__delete_buffer. */
#include "Lcompile.h"
#include "Ltokens.h"

static L_compile_frame *lframe = NULL;

/* LCompileScript() is the main entry point into the land of L. */
void
LCompileScript(
	Tcl_Interp *interp,
	CONST char *str,
	int numBytes,
	CompileEnv *envPtr
)
{
    void    *lex_buffer = (void *)L__scan_bytes(str, numBytes);

    L_frame_push(interp, envPtr);
    lframe->originalCodeNext = envPtr->codeNext;
    L_parse();        
    L__delete_buffer(lex_buffer);
    maybeFixupEmptyCode(lframe);
    L_frame_pop();
}

/**
 * These next functions are the bulk of the parser's semantic actions.
 * Right now they attempt to compile straight to bytecode.  We may
 * want to first generate an AST so we can chew on it a little harder,
 * and don't have to mess with global variables.
 */

void 
L_begin_function_decl(ltoken *name) 
{
    CompileEnv *envPtr;

    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr);
    TclInitCompileEnv(lframe->interp, envPtr, "L Compiler", 
                      strlen("L Compiler"));
    lframe->originalCodeNext = envPtr->codeNext;
    TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                 lframe->envPtr);
}

void 
L_end_function_decl(ltoken *name) 
{
    Interp *iPtr = (Interp *)lframe->interp;
    Proc *procPtr;
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    procPtr = (Proc *) ckalloc(sizeof(Proc));
    procPtr->iPtr = iPtr;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;

    TclEmitOpcode(INST_DONE, lframe->envPtr);

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, name->v.s,
        TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;

    TclFreeCompileEnv(lframe->envPtr);
    L_frame_pop();
}


void 
L_begin_function_call(ltoken *name) 
{
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, name->v.s, 
                                      strlen(name->v.s)), 
                lframe->envPtr);
}

void 
L_end_function_call(ltoken *name, int param_count) 
{
    TclEmitInstInt4(INST_INVOKE_STK4, param_count+1, lframe->envPtr);
}

void 
L_if_condition() {
    int jumpIndex;
    JumpFixupArray *jumpFalsePtr;

    jumpFalsePtr = (JumpFixupArray *)ckalloc(sizeof(JumpFixupArray));
    /* save the fixup array in a compile frame so that we can do the fixups at
       the end of this if statement. */
    L_frame_push(lframe->interp, lframe->envPtr);
    lframe->jumpFalseFixupArrayPtr = jumpFalsePtr;

    TclInitJumpFixupArray(jumpFalsePtr);
    if (jumpFalsePtr->next >= jumpFalsePtr->end) {
        TclExpandJumpFixupArray(jumpFalsePtr);
    }
    jumpIndex = jumpFalsePtr->next;
    jumpFalsePtr->next++;
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, 
                       jumpFalsePtr->fixup + jumpIndex);
}

void 
L_if_end() 
{
    if (TclFixupForwardJumpToHere(lframe->envPtr,
                                  /* this should actually be more like:
                                     lframe->jumpFalseFixupArrayPtr->fixup+jumpIndex,  */
                                  lframe->jumpFalseFixupArrayPtr->fixup, 
                                  127)) {
    }

    TclFreeJumpFixupArray(lframe->jumpFalseFixupArrayPtr);
    ckfree(lframe->jumpFalseFixupArrayPtr);
    L_frame_pop();
}

void
L_push_str(ltoken *str)
{
    TclEmitPush(TclRegisterNewNSLiteral(lframe->envPtr, 
                                        str->v.s, strlen(str->v.s)), 
                lframe->envPtr);
}

void
L_push_int(ltoken *i)
{
    TclEmitPush(TclAddLiteralObj(lframe->envPtr, 
                                 Tcl_NewIntObj(i->v.i), NULL), 
                lframe->envPtr);
}

void
L_push_id(ltoken *id)
{
    TclEmitPush(TclRegisterNewNSLiteral(lframe->envPtr, 
                                        id->v.s, strlen(id->v.s)), 
                lframe->envPtr);
    TclEmitOpcode(INST_LOAD_SCALAR_STK, lframe->envPtr);
}

void 
L_pass_parameter(ltoken *parameter) 
{
}

void
L_lhs_assignment(ltoken *lvalue)
{
    TclEmitPush(TclRegisterNewNSLiteral(lframe->envPtr, lvalue->v.s,
                                        strlen(lvalue->v.s)), 
                lframe->envPtr);
}

void
L_rhs_assignment(ltoken *rvalue)
{
    TclEmitOpcode(INST_STORE_SCALAR_STK, lframe->envPtr);
}

/* void */
/* L_end_stmt() { */
/*     TclEmitOpcode(INST_POP, lframe->envPtr); */
/* } */

/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void 
maybeFixupEmptyCode(L_compile_frame *frame) 
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        TclEmitPush( TclAddLiteralObj(frame->envPtr, Tcl_NewObj(), NULL),
            frame->envPtr);
    }
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    ckfree((char *)lframe);
    lframe = prev;
}


/* Give up the ghost. */
void 
L_bomb(const char *msg) 
{
    fprintf(stderr, msg);
    fprintf(stderr, "\n");
    exit(1);
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
