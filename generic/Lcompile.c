#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"

static L_compile_frame *lframe = NULL;
static Tcl_HashTable *L_struct_types = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
void *L_current_ast = NULL;
int L_interactive = 0;

#define CALL_MAIN 1             /* call main automatically */
#define CALL_MAIN_WITH_ARGS 2   /* call main and pass argc and argv */
static int post_compile_action = 0; /* what's left to do after compiling an L
                                       script successfully */

static int gensym_counter = 0;  /* used to create unique names */

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_free_ast(L_ast_node *ast);
static int global_symbol_p(L_symbol *symbol);
static Tcl_Obj *create_array_or_struct(L_type *array_type, L_type *base_type);
static Tcl_Obj *create_struct(L_type *type);
static int array_p(L_type *t);
static L_type *lookup_struct_type(char *tag);
static void emit_call_to_main(CompileEnv *envPtr, int with_args_p);

static L_expression *L_write_hash_index_chunk(int varIndex, L_expression *i,
                                              L_expression *rval);
static L_expression *L_write_array_index_chunk(int varIndex, L_expression *i,
                                               L_type *base_type,
                                               L_expression *rval);
static L_expression *L_read_array_index_chunk(int varIndex, L_expression *i,
                                              L_type *base_type);
static L_expression *L_read_hash_index_chunk(L_expression *i);
static Tcl_Obj *literal_to_TclObj(L_expression *expr);
static Tcl_Obj *blank_initial_value(L_type *type);
static L_symbol *import_global_symbol(L_symbol *var);
/* static void link_upvar(L_expression *name, L_symbol *var); */
static int pointer_p(L_type *t);
static L_expression *pointer_mangle(char *name);
static L_expression *array_mangle(char *name);
static void emit_pointer_new(L_expression *name, int offset);
static char *gensym(char *name);
static char *initializer_code(L_type *type, char *name, int prev_dimension,
                              int *needs_eval);

/* we keep track of each AST node we allocate and free them all at once */
L_ast_node *ast_trace_root = NULL;

/* If TCL encounters an L pragma while evaluating code directly, e.g., from an
   upvar, it will enter the L compiler via L_PragmaObjCmd(). */
int 
L_PragmaObjCmd(
    ClientData clientData,
    Tcl_Interp *interp, 
    int objc,
    Tcl_Obj *CONST objv[])
{ 
    int stringLen; 
    char *stringPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via L_PragmaObjCmd");
    if (objc != 2) {
        L_bomb("Assertion failed in L_PragmaObjCmd: we expected 1 "
               "argument but got %d.", objc - 1);
    }
    stringPtr = Tcl_GetStringFromObj(objv [1], &stringLen);
    if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    return LCompileScript(interp, stringPtr, stringLen, NULL, ast);
}


/* If TCL encounters an L pragma while compiling TCL code, for example when
   processing an entire file in TclCompileScript(), it will enter L via
   LCompilePragmaCmd().  In that case, we get a pointer to the toplevel
   compilation environment, so we have the option of emitting global code.

   If there is an error during L compilation, we return TCL_ERROR.  However,
   the error only causes TCL to defer evaluation of the L pragma until
   runtime, at which point L_PragmaObjCmd() will recompile the L code and hit
   the same error.  */
int
LCompilePragmaCmd(
    Tcl_Interp *interp,
    Tcl_Parse *parsePtr,
    CompileEnv *envPtr)
{
    int retval;
    Tcl_Token *lTokenPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via LCompilePragmaCmd");
    if (parsePtr->numWords != 2) {
        L_bomb("Assertion failed in LCompilePragmaCmd: we expected 2 "
               "words but got %d.", parsePtr->numWords);
    }
    // advance to the second token
    lTokenPtr = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
    // the first component of the second token contains the code
    if (LParseScript(interp, lTokenPtr[1].start,
                     lTokenPtr[1].size, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    post_compile_action = 0;
    retval = LCompileScript(interp, lTokenPtr[1].start, lTokenPtr[1].size,
                            envPtr, ast);
    if (post_compile_action && (retval == TCL_OK)) {
        switch (post_compile_action) {
        case CALL_MAIN_WITH_ARGS:
            emit_call_to_main(envPtr, TRUE);
            break;
        case CALL_MAIN:
            emit_call_to_main(envPtr, FALSE);
            break;
        default:
            L_bomb("unsupported post compile action %d", post_compile_action);
        }
    }
    return retval;
}

/* Parse an L script into an AST.  Parsing and compiling are broken into two
   stages in order to support an interactive mode that parses many times
   before finally compiling.  */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer;

    L_start_lexer();
    lex_buffer = (void *)L__scan_bytes(str, numBytes);
    /* L_trace("Parsing: %.*s", numBytes, str); */
    L_trace("parsing");
    L_line_number = 0;
    L_errors = NULL;
    L_parse();
    if (L_ast == NULL) {
        L_free_ast(L_current_ast);
    } else {
        *L_ast = L_current_ast;
    }
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.");
            return TCL_ERROR;
    }
    L_trace("Done parsing.");
    return TCL_OK;
}


/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
int
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr,
    void *ast)
{
/*     L_trace("Compiling: \n %.*s", numBytes, str); */
    L_trace("compiling");
    L_frame_push(interp, envPtr);
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;

    switch(((L_ast_node*)ast)->type) {
    case L_NODE_TOPLEVEL_STATEMENT:
        L_compile_toplevel_statements(ast);
        break;
    default:
        L_bomb("LCompileScript error, expecting a toplevel statement, "
               "got: %s", L_node_type_tostr[((L_ast_node*)ast)->type]);
    }
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();

    L_free_ast(ast);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to compile.");
            return TCL_ERROR;
    }
    L_trace("Done compiling");
    return TCL_OK;
}

void
L_compile_toplevel_statements(L_toplevel_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_TOPLEVEL_STATEMENT_FUNCTION_DECLARATION:
        L_compile_function_decl(stmt->u.fun);
        break;
    case L_TOPLEVEL_STATEMENT_TYPE:
        L_compile_struct_decl(stmt->u.type);
        break;
    case L_TOPLEVEL_STATEMENT_GLOBAL:
        L_compile_global_decls(stmt->u.global);
        break;
    default:
        L_bomb("Unexpected toplevel statement type %d", stmt->kind);
    }
    L_compile_toplevel_statements(stmt->next);
}

void
L_compile_function_decl(L_function_declaration *fun)
{
    Proc *procPtr;
    CompileEnv *envPtr;
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    if (!fun) return;
    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr);

    procPtr = (Proc *)ckalloc(sizeof(Proc));
    procPtr->iPtr = (struct Interp *)lframe->interp;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;

    TclInitCompileEnv(lframe->interp, envPtr, "L Compiler",
                      strlen("L Compiler"));
    lframe->originalCodeNext = envPtr->codeNext;
    envPtr->procPtr = procPtr;

    L_compile_parameters(fun->params);
    L_compile_block(fun->body);
    
    /* This is the "fall off the end" implicit return. We return "". */
    L_return(FALSE);

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, fun->name->u.s,
        TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;

    /* Check if we're compiling main() or main(int argc, string argv[]) */
    if (!strncmp("main", fun->name->u.s, strlen("main"))) {
        if (!fun->params) {
            post_compile_action = CALL_MAIN;
        } else {
            if (!fun->params->next) {
                /* XXX we don't bother to check the parameter types */
                L_errorf(fun->params, "main() takes only zero or two "
                         "arguments");
            }
            post_compile_action = CALL_MAIN_WITH_ARGS;
        }
    }

    TclFreeCompileEnv(lframe->envPtr);
    ckfree((char *)lframe->envPtr);
    L_frame_pop();
}

void
L_compile_struct_decl(L_type *decl)
{
    Tcl_HashEntry *hPtr;
    int freshp;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    if (!decl->struct_tag ||
        !(decl->struct_tag->kind == L_EXPRESSION_STRING)) {
        L_errorf(decl, "Untagged struct types are not supported yet");
        return;
    }
    hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.s, &freshp);
    Tcl_SetHashValue(hPtr, decl);
    L_trace("Declared struct type %s", decl->struct_tag->u.s);
}

void
L_compile_global_decls(L_variable_declaration *decl)
{
    L_symbol *symbol;
    Tcl_Obj *initial_value;
    char *init_code;
    int needs_eval;

    if (!decl) return;
    init_code = initializer_code(decl->type, decl->name->u.s, 0, &needs_eval);
    L_trace("Global variable named %s\n", decl->name->u.s);
    if (decl->initial_value) {
        initial_value = literal_to_TclObj(decl->initial_value);
    } else {
        initial_value = blank_initial_value(decl->type);
    }
    symbol = L_make_symbol(decl->name, decl->type, -1);
    symbol->global_p = TRUE;
    if (lframe->envPtr) {

        L_trace("init code is \n%s\n", init_code);
        if (needs_eval) {
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "eval",
                                              strlen("eval")),
                        lframe->envPtr);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, init_code,
                                              strlen(init_code)),
                        lframe->envPtr);
            TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
            TclEmitOpcode(INST_POP, lframe->envPtr);
        } else {
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, init_code,
                                              strlen(init_code)),
                        lframe->envPtr);
            TclEmitOpcode(INST_STORE_SCALAR_STK, lframe->envPtr);
        }
    } else {
        /* interpreted case */
        if (needs_eval) {
            Tcl_Eval(lframe->interp, init_code);
            Tcl_SetVar2Ex(lframe->interp, decl->name->u.s, NULL,
                          Tcl_GetObjResult(lframe->interp),
                          TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG);

        } else {
            Tcl_SetVar2Ex(lframe->interp, decl->name->u.s, NULL,
/*                           Tcl_NewStringObj(init_code, strlen(init_code)), */
                          initial_value,
                          TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG);
        }
    }
    L_compile_global_decls(decl->next);
}

/* Initialize the struct types table and lookup a type in it.  Returns the
   type, or NULL if none was found.  */
L_type *
lookup_struct_type(char *tag)
{
    Tcl_HashEntry *hPtr = NULL;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    hPtr = Tcl_FindHashEntry(L_struct_types, tag);

    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}

void 
L_compile_variable_decls(L_variable_declaration *var)
{
    L_symbol *symbol;
    int localIndex;

    if (!var) return;
    L_trace("declaring variable %s", var->name->u.s);
    localIndex = TclFindCompiledLocal(var->name->u.s, strlen(var->name->u.s),
                                      1, 0, lframe->envPtr->procPtr);
    if ((symbol = L_get_symbol(var->name, FALSE)) &&
        !global_symbol_p(symbol))
    {
        L_errorf(var, "Illegal redeclaration of local variable %s",
                 var->name->u.s);
    }
    symbol = L_make_symbol(var->name, var->type, localIndex);
    if (array_p(var->type) || (var->type->kind == L_TYPE_STRUCT)) {
        /* We don't support literal initializers for structs and arrays yet.
           Just always initialize to a blank TCL list. */
        var->initial_value = NULL;
    }
    if (var->initial_value) {
        L_compile_expressions(var->initial_value);
        L_STORE_SCALAR(localIndex);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    } else {
        /* create the initial value and emit code to push it on the
           stack */
        int needs_eval;
        char *init_code = initializer_code(var->type, var->name->u.s, 0, &needs_eval);
        if (needs_eval) {
            L_trace("init code is \n%s\n", init_code);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "eval",
                                              strlen("eval")),
                        lframe->envPtr);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, init_code,
                                              strlen(init_code)),
                        lframe->envPtr);
            TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
/*             TclEmitOpcode(INST_POP, lframe->envPtr); */
        } else {
/*             TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, init_code, */
/*                                               strlen(init_code)), */
/*                         lframe->envPtr); */
            Tcl_Obj *initial_value = blank_initial_value(var->type);
            TclEmitPush(TclAddLiteralObj(lframe->envPtr, initial_value, NULL),
                        lframe->envPtr);
            L_STORE_SCALAR(localIndex);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        }
    }
    L_compile_variable_decls(var->next);
}


/* Emit code to create a new pointer and leave it on the stack. */
static void
emit_pointer_new(
    L_expression *name,         /* the name of the variable to point
                                   at */
    int offset)                 /* the offset into the variable, or
                                   LPOINTER_NO_OFFSET */
{
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                      strlen("pointer")),
                lframe->envPtr);
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "new",
                                      strlen("new")),
                lframe->envPtr);
    L_compile_expressions(name);
    if (offset == LPOINTER_NO_OFFSET) {
        TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
    } else {
        TclEmitPush(TclAddLiteralObj(lframe->envPtr, Tcl_NewIntObj(offset),
                                     NULL),
                    lframe->envPtr);
        TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
    }
}

static Tcl_Obj *blank_initial_value(L_type *type) {
    return Tcl_NewObj();
}

static char *
initializer_code(
    L_type *type,
    char *name,
    int prev_dimension,
    int *needs_eval)
{
    L_type *array_type = type->next_dim;
    Tcl_Obj *code = Tcl_NewObj();
    char *counterName = gensym("counter");
    char *nameName = gensym(name);
    L_expression *retval;
    int dimension;

    while (array_type && (array_type->kind == L_TYPE_POINTER)) {
        /* XXX we likely shouldn't be ignoring this... */
        array_type = array_type->next_dim;
    }
    if (!array_type || (array_type->array_dim->u.i == 0)) {
        TclObjPrintf(NULL, code, "{}");
        *needs_eval = FALSE;
    } else {
        dimension = array_type->array_dim->u.i;
        Tcl_IncrRefCount(code);
        TclObjPrintf(NULL, code, "set %s 0\n", counterName);
        if (prev_dimension) {
            TclObjPrintf(NULL, code, "while {$%s < %d} {\n",
                         counterName, prev_dimension);
        }
        TclObjPrintf(NULL, code, "set %s {}\n", nameName);
        TclObjPrintf(NULL, code, "append %s %s $%s\n", nameName, nameName,
                     counterName);
        TclObjPrintf(NULL, code, "set $%s [lrepeat %d {}]\n", nameName,
                     dimension);
        if (prev_dimension) {
            TclObjPrintf(NULL, code, "lset $%s $%s [pointer new $%s 0]\n",
                         name, counterName, nameName);

        } else {
            TclObjPrintf(NULL, code, "set %s [pointer new $%s 0]\n",
                         name, nameName);
        }
        if (array_type->next_dim) {
            Tcl_AppendToObj(code,
                            initializer_code(array_type, nameName, dimension,
                                             needs_eval),
                            -1);
        }
        if (prev_dimension) {
            TclObjPrintf(NULL, code, "incr %s\n}\n", counterName);
        }
        *needs_eval = TRUE;
    }
    MK_STRING_NODE(retval, Tcl_GetString(code));
    Tcl_DecrRefCount(code);
    return retval->u.s;
}


static Tcl_Obj *create_array_or_struct(L_type *array_type, L_type *base_type) {
    return Tcl_NewObj();
}

Tcl_Obj *
create_struct(L_type *type)
{
    Tcl_Obj *val = NULL;
    int i;
    L_type *struct_type = type;
    L_variable_declaration *member;

    /* if we have a struct tag without the struct definition, lookup the
       definition. */
    if (!struct_type->members) {
        if (!struct_type->struct_tag) {
            L_bomb("Assertion failed: a struct must either have a tag or "
                   "members");
        }
        struct_type = lookup_struct_type(struct_type->struct_tag->u.s);
        if (!struct_type) {
            L_errorf(type, "Undefined structure type: %s",
                     struct_type->struct_tag->u.s);
            return NULL;
        }
        /* Fixup the original type so that it also has the member
           information.  This allows all the other code to skip the
           lookup. */
        type->members = struct_type->members;
    }
    val = Tcl_NewListObj(0, NULL);
    /* initialize the struct fields */
    for (member = type->members; member; member = member->next, i++) {
        Tcl_Obj *el =
            create_array_or_struct(member->type->next_dim, member->type);
        if (!el) return NULL;
        Tcl_ListObjAppendElement(NULL, val, el);
    }
    return val;
}

int
array_p(L_type *t)
{
    if (t->next_dim) {
        if (t->next_dim->kind == L_TYPE_ARRAY) {
            return TRUE;
        } else {
            return array_p(t->next_dim);
        }
    } else {
        return FALSE;
    }
}

int
pointer_p(L_type *t)
{
    /* just check for simple pointers for now, ignoring, e.g., arrays
       of pointers */
    if (t->next_dim) {
        return pointer_p(t->next_dim);
    } else if (t->kind == L_TYPE_POINTER) {
        return TRUE;
    } else {
        return FALSE;
    }
}

int
global_symbol_p(L_symbol *symbol)
{
    return symbol->global_p;
}

void
L_compile_statements(L_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_STATEMENT_BLOCK:
        L_compile_block(stmt->u.block);
        break;
    case L_STATEMENT_EXPR:
        L_compile_expressions(stmt->u.expr);
        /* Expressions leave a value on the evaluation stack, but statements
           don't. So pop the value. */
        TclEmitOpcode(INST_POP, lframe->envPtr);
        break;
    case L_STATEMENT_IF_UNLESS:
        L_compile_if_unless(stmt->u.cond);
        break;
    case L_STATEMENT_LOOP:
        L_compile_loop(stmt->u.loop);
        break;
    case L_STATEMENT_RETURN:
        L_trace("compiling return statement");
        if (stmt->u.expr) {
            L_trace("    with return value");
            /* compile the return value */
            L_compile_expressions(stmt->u.expr);
        } else {
            L_trace("    without return value");
            /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
            TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                         lframe->envPtr );
        }
        /* INST_RETURN_STK involves a little more magic that I haven't wangled out
           yet... but I think it lets us pass back error codes and such that could
           be useful. --timjr 2006.3.31  */
        /* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
        TclEmitOpcode(INST_DONE, lframe->envPtr);
        break;
    }
    L_compile_statements(stmt->next);
}

void
L_compile_block(L_block *block) {
    L_compile_variable_decls(block->decls);
    L_compile_statements(block->body);
}

void 
L_compile_parameters(L_variable_declaration *param)
{
    Proc *procPtr = lframe->envPtr->procPtr;
    CompiledLocal *localPtr;
    int i;
    
    for (i = 0; param; param = param->next, i++) {
        L_symbol *symbol;

        L_trace("Compiling parameter %d (%s)", i, param->name->u.s);
        /* Formal parameters are stored in local variable slots. */
        procPtr->numArgs = i + 1;
        procPtr->numCompiledLocals = i + 1;
        localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
                                             sizeof(localPtr->name) +
                                             strlen(param->name->u.s) + 1);
        if (procPtr->firstLocalPtr == NULL) {
            procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr;
        } else {
            procPtr->lastLocalPtr->nextPtr = localPtr;
            procPtr->lastLocalPtr = localPtr;
        }
        localPtr->nextPtr = NULL;
        localPtr->nameLength = strlen(param->name->u.s);
        localPtr->frameIndex = i;
        localPtr->flags = VAR_SCALAR | VAR_ARGUMENT;
        localPtr->resolveInfo = NULL;
        localPtr->defValuePtr = NULL;
        strcpy(localPtr->name, param->name->u.s);
        symbol = L_make_symbol(param->name, param->type, i);
        /* treat parameters with a * in the type as upvars */
/*         if (pointer_p(param->type)) { */
/*             link_upvar(param->name, symbol); */
/*         } */
    }
}

void 
L_compile_expressions(L_expression *expr)
{
    int i = 0;
    L_expression *tmp;

    if (!expr) return;
/*     L_trace("Compiling an expression of type %s", */
/*             L_expression_tostr[expr->kind]); */
    switch (expr->kind) {
    case L_EXPRESSION_FUNCALL:
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, expr->a->u.s, -1),
                    lframe->envPtr);
        L_compile_expressions(expr->b);
        /* count the parameters */
        for (tmp = expr->b; tmp; tmp = tmp->next, i++);
        TclEmitInstInt4(INST_INVOKE_STK4, i+1, lframe->envPtr);
        break;
    case L_EXPRESSION_PRE:
    case L_EXPRESSION_POST:
        L_compile_incdec(expr);
        break;
    case L_EXPRESSION_UNARY:
        L_compile_unop(expr);
        break;
    case L_EXPRESSION_BINARY:
        L_trace("Binary expression");
        L_compile_binop(expr);
        break;
    case L_EXPRESSION_INT:
    case L_EXPRESSION_STRING:
    case L_EXPRESSION_DOUBLE:
/*         obj = Tcl_NewDoubleObj(expr->u.d); */
        TclEmitPush(TclAddLiteralObj(lframe->envPtr,
                                     literal_to_TclObj(expr),
                                     NULL),
                    lframe->envPtr);
        break;
    case L_EXPRESSION_INTERPOLATED_STRING:
        L_compile_interpolated_string(expr);
        break;
    case L_EXPRESSION_VARIABLE:
        L_push_variable(expr);
        break;
    default:
        L_bomb("Unknown expression type %d", expr->kind);
    }
    L_compile_expressions(expr->next);
}

/* Create a Tcl Obj containing the value of a constant literal L AST
   node. */
Tcl_Obj *literal_to_TclObj(L_expression *expr)
{
    Tcl_Obj *obj = NULL;

    switch (expr->kind) {
    case L_EXPRESSION_INT:
        obj = Tcl_NewIntObj(expr->u.i);
        break;
    case L_EXPRESSION_STRING:
        obj = Tcl_NewStringObj(expr->u.s, strlen(expr->u.s));
        break;
    case L_EXPRESSION_DOUBLE:
        obj = Tcl_NewDoubleObj(expr->u.d);
        break;
    default:
        L_bomb("literal_to_TclObj can't handle expressions of type %d\n",
               expr->kind);
    }
    return obj;
}

void L_compile_unop(L_expression *expr)
{
    switch (expr->op) {
    case T_BANG:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
        break;
    case T_BITNOT:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_BITNOT, lframe->envPtr);
        break;
    case T_PLUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UPLUS, lframe->envPtr);
        break;
    case T_MINUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UMINUS, lframe->envPtr);
        break;
    case T_STAR:
        /* *, dereference operator */
        if (expr->a->kind != L_EXPRESSION_VARIABLE) {
            L_bomb("Dereference is only supported for simple variables, %s", L_expression_tostr[expr->a->kind]);
        } else {
/*             L_expression *mangled_name = pointer_mangle(expr->a->a->u.s); */
/*             L_symbol *symbol; */
/*             if ((symbol = L_get_symbol(mangled_name, TRUE))) { */
/*                 L_LOAD_SCALAR(symbol->localIndex); */
/*             } */
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                              strlen("pointer")),
                        lframe->envPtr);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "get",
                                              strlen("get")),
                        lframe->envPtr);
            L_compile_expressions(expr->a);
            TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
        }
        break;
    case T_BITAND:
        /* &, address-of operator */
        if (expr->a->kind != L_EXPRESSION_VARIABLE) {
            L_bomb("Address-of is only supported on variable names.");
        } else {
            L_expression *variable_name = expr->a->a;
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                              strlen("pointer")),
                        lframe->envPtr);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "new",
                                              strlen("new")),
                        lframe->envPtr);
            L_compile_expressions(variable_name);
            TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
        }
        break;
    default:
        L_bomb("Unknown unary operator %d", expr->op);
    }
}

void L_compile_binop(L_expression *expr)
{
    int instruction = 0;

    if (expr->op == T_EQUALS) {
        L_compile_assignment(expr);
    } else if ((expr->op == T_ANDAND) ||
               (expr->op == T_OROR)) {
        L_compile_short_circuit_op(expr);
    } else if ((expr->op == T_EQTWID) ||
               (expr->op == T_BANGTWID)) {
        L_compile_twiddle(expr);
    } else {
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        switch (expr->op) {
        case T_PLUS:
            instruction = INST_ADD;
            break;
        case T_MINUS:
            instruction = INST_SUB;
            break;
        case T_STAR:
            instruction = INST_MULT;
            break;
        case T_SLASH:
            instruction = INST_DIV;
            break;
        case T_PERC:
            instruction = INST_MOD;
            break;
        case T_EQ:
        case T_EQUALEQUAL:
            instruction = INST_EQ;
            break;
        case T_NE:
        case T_NOTEQUAL:
            instruction = INST_NEQ;
            break;
        case T_GT:
        case T_GREATER:
            instruction = INST_GT;
            break;
        case T_GE:
        case T_GREATEREQ:
            instruction = INST_GE;
            break;
        case T_LT:
        case T_LESSTHAN:
            instruction = INST_LT;
            break;
        case T_LE:
        case T_LESSTHANEQ:
            instruction = INST_LE;
            break;
        case T_LSHIFT:
            instruction = INST_LSHIFT;
            break;
        case T_RSHIFT:
            instruction = INST_RSHIFT;
            break;
        case T_BITOR:
            instruction = INST_BITOR;
            break;
        case T_BITXOR:
            instruction = INST_BITXOR;
            break;
        case T_BITAND:
            instruction = INST_BITAND;
            break;
        default:
            L_bomb("Undefined operator %d", expr->op);
        }
        TclEmitOpcode(instruction, lframe->envPtr);
    }
}

void
L_compile_interpolated_string(L_expression *expr)
{
    int tempVar;

    /* XXX is there really no better way to concatenate 3 strings
       using TCL bytecode? */
    L_compile_expressions(expr->a);
    tempVar = TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR,
                                   lframe->envPtr->procPtr);
    L_STORE_SCALAR(tempVar);
    L_compile_expressions(expr->b);
    TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    if (expr->c) {
        L_compile_expressions(expr->c);
        TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        L_LOAD_SCALAR(tempVar);
    } else {
        /* Currently, an interpolated string node will always be
           followed by another one, or by a regular string node, so
           there's no way to test this branch.  */
        L_bomb("Malformed AST");
    }
}

void
L_compile_twiddle(L_expression *expr)
{
    Tcl_Obj *regexp = Tcl_NewStringObj(expr->b->u.s, strlen(expr->b->u.s));
    Tcl_RegExp compiled;
    int submatchCount = 0, i;

    /* compile the regular expression so we can figure out how many
       submatches there are */
    compiled = Tcl_GetRegExpFromObj(lframe->interp, regexp, TCL_REG_ADVANCED);
    if (compiled == NULL) {
        L_errorf(expr, "Bad regular expression");
    } else {
        submatchCount = ((TclRegexp *)compiled)->re.re_nsub;
    }
    L_trace("The submatch count in %s is %d\n", expr->b->u.s, submatchCount);
    /* create the submatch variables */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        L_expression *name;

        snprintf(buf, 128, "$%d", i);
        MK_STRING_NODE(name, buf);
        if (!L_get_symbol(name, FALSE)) {
            int localIndex =
                TclFindCompiledLocal(name->u.s, strlen(name->u.s),
                                     1, 0, lframe->envPtr->procPtr);
            L_make_symbol(name,
                          mk_type(L_TYPE_STRING, NULL, NULL, NULL, NULL),
                          localIndex);
        }
    }
    /* emit code to call the regexp object command */
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "regexp",
                                      strlen("regexp")),
                lframe->envPtr);
    TclEmitPush(TclAddLiteralObj(lframe->envPtr, regexp, NULL), 
                lframe->envPtr);
    L_compile_expressions(expr->a);
    /* match/submatch vars */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        snprintf(buf, 128, "$%d", i);
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, buf, strlen(buf)),
                    lframe->envPtr);
    }
    TclEmitInstInt1(INST_INVOKE_STK1, 4 + submatchCount, lframe->envPtr);
    if (expr->op == T_BANGTWID) {
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
    }
}

void
L_compile_short_circuit_op(L_expression *expr)
{
    JumpFixup fixup;

    L_compile_expressions(expr->a);
    /* In case the operator short-circuits, we need one value on the
       evaluation stack for the jump and one for the value of the
       expression. */
    TclEmitOpcode(INST_DUP, lframe->envPtr);
    if (expr->op == T_ANDAND) {
        TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &fixup);
    } else {
        TclEmitForwardJump(lframe->envPtr, TCL_TRUE_JUMP, &fixup);
    }
    /* If the operator doesn't short-circuit, we want to leave the value of
       the second expression on the stack, so remove the value that we DUPed
       above. */
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_compile_expressions(expr->b);
    TclFixupForwardJumpToHere(lframe->envPtr, &fixup, 127);
}

void
L_compile_if_unless(L_if_unless *cond)
{
    JumpFixup jumpFalse, jumpEnd;

    L_compile_expressions(cond->condition);
    /* emit a jump which will skip the consequent if the top value on the
       stack is false. */
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &jumpFalse);
    L_frame_push(lframe->interp, lframe->envPtr);
    /* consequent */
    if (cond->if_body != NULL) {
        L_compile_statements(cond->if_body);
    }
    /* alternate */
    if (cond->else_body != NULL) {
        /* End the scope that was started for the consequent and start a new
           one, copying the jump fixup pointers. */
        L_frame_pop();
        L_frame_push(lframe->interp, lframe->envPtr);
        TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpEnd);
        if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127)) {
            /* The TCL_FALSE_JUMP that we emitted expanded, so the beginning
               code offset saved in the jump fixup for the
               TCL_UNCONDITIONAL_JUMP needs to be adjusted. */
            jumpEnd.codeOffset += 3;
        }
        L_compile_statements(cond->else_body);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpEnd, 127);
    } else {
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
    }
    L_frame_pop();
}

void
L_compile_loop(L_loop *loop)
{
    JumpFixup jumpToCond;
    int bodyCodeOffset, jumpDist;

    TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpToCond);
    L_frame_push(lframe->interp, lframe->envPtr);
    bodyCodeOffset = lframe->envPtr->codeNext - lframe->envPtr->codeStart;
    L_compile_statements(loop->body);
    L_frame_pop(lframe->interp, lframe->envPtr);
    if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpToCond, 127)) {
        bodyCodeOffset += 3;
    }
    L_compile_expressions(loop->condition);
    jumpDist = lframe->envPtr->codeNext - lframe->envPtr->codeStart -
        bodyCodeOffset;
    if (jumpDist > 127) {
        TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
    } else {
        TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
    }
}

void
L_push_variable(L_expression *expr)
{
    L_symbol *var;
    L_expression *name = expr->a;

    if (!(var = L_get_symbol(name, TRUE))) return;
    if (global_symbol_p(var)) {
        var = import_global_symbol(var);
    }
    if (expr->indices) {
        if (expr->indices->kind == L_EXPRESSION_HASH_INDEX) {
            L_LOAD_SCALAR(var->localIndex);
            L_read_hash_index_chunk(expr->indices);
        } else {
            L_read_array_index_chunk(var->localIndex, expr->indices, var->type);
        }
    } else {
        L_LOAD_SCALAR(var->localIndex);
    }
}

/* Import a global variable into a procedure's table of locals and
   create an L symbol that shadows the global one. Return the new L
   symbol. */
L_symbol *
import_global_symbol(L_symbol *var)
{
    L_symbol *local;
    int localIndex;
    L_expression *name;  // eugh

    L_trace("importing global variable %s", var->name);
    /* create a new local variable that shadows the global in our
       symbol table */
    localIndex = TclFindCompiledLocal(var->name, strlen(var->name),
                                      1, 0, lframe->envPtr->procPtr);
    MK_STRING_NODE(name, var->name);
    local = L_make_symbol(name, var->type, localIndex);
    /* link the global variable with our new local using tcl's
       ``global'' command. */
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "global",
                                      strlen("global")),
                lframe->envPtr);
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, var->name, -1),
                lframe->envPtr);
    TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    return local;
}


/* Stick a _ on the front of name and return the result as an L AST
   node. */
L_expression *
pointer_mangle(char *name) {
    L_expression *node;
    char *mangled_name = ckalloc(strlen(name) + 2);
    sprintf(mangled_name, "_%s", name);
    MK_STRING_NODE(node, mangled_name);
    ckfree(mangled_name);
    return node;
}

/* Stick a __ on the front of name and return the result as an L AST
   node. */
L_expression *
array_mangle(char *name) {
    L_expression *node;
    char *mangled_name = ckalloc(strlen(name) + 3);
    sprintf(mangled_name, "__%s", name);
    MK_STRING_NODE(node, mangled_name);
    ckfree(mangled_name);
    return node;
/*     return gensym(name); */
}

void
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                     lframe->envPtr);
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

void
L_compile_assignment(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a;
    L_expression *rval = expr->b;
    int pointer_p = FALSE;

    if (lval->kind == L_EXPRESSION_UNARY) {
        L_trace("assigning into a pointer, kind of a: %s, a->a: %s",
                L_expression_tostr[lval->a->kind],
                L_expression_tostr[lval->a->a->kind]);
        /* pointer */
/*         lval = mk_expression(L_EXPRESSION_VARIABLE, -1, */
/*                              pointer_mangle(lval->a->a->u.s), NULL, NULL, */
/*                              lval->a->indices, NULL); */
        lval = lval->a;
        pointer_p = TRUE;
    }
    L_trace("COMPILING ASSIGNMENT: %s, %s", L_expression_tostr[lval->a->kind],
            lval->a->u.s);
    if (!(var = L_get_symbol(lval->a, TRUE))) return;
    if (global_symbol_p(var)) {
        L_trace("it's a global");
        var = import_global_symbol(var);
    }
    if (lval->indices) {
        if (lval->indices->kind == L_EXPRESSION_HASH_INDEX) {
            L_write_hash_index_chunk(var->localIndex, lval->indices, rval);
        } else {
            L_write_array_index_chunk(var->localIndex, lval->indices,
                                      var->type, rval);
        }
    } else {
        if (pointer_p) {
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                              strlen("pointer")),
                        lframe->envPtr);
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "set",
                                              strlen("set")),
                        lframe->envPtr);
            L_compile_expressions(lval);
            L_compile_expressions(rval);
            TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
        } else {
            /* no array indices */
            L_compile_expressions(rval);
            L_STORE_SCALAR(var->localIndex);
        }
    }
}

/* Read a value from an array or struct.  We expect the array/struct
   to be on top of the stack.  Returns the next non-array/struct
   index. */
static L_expression *
L_read_array_index_chunk(
    int varIndex,
    L_expression *index,
    L_type *base_type)
{
    L_type *index_type = base_type;
    L_expression *i;

    for (i = index; i && (i->kind != L_EXPRESSION_HASH_INDEX);
         i = i->indices)
    {
        L_trace("[pointer get [pointer add ");
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                          strlen("pointer")),
                    lframe->envPtr);
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "get",
                                          strlen("get")),
                    lframe->envPtr);

        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                          strlen("pointer")),
                    lframe->envPtr);
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "add",
                                          strlen("add")),
                    lframe->envPtr);
    }
    L_LOAD_SCALAR(varIndex);
    for (i = index; i && (i->kind != L_EXPRESSION_HASH_INDEX);
         i = i->indices)
    {
        index_type = L_compile_index(base_type, index_type, i);
        L_trace(" %d ] ]", i->a->u.i);
        /* pointer add */
        TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
        /* pointer get */
        TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);

    }
    return i;
}

static L_expression *
L_write_array_index_chunk(
    int varIndex,
    L_expression *index,
    L_type *base_type,
    L_expression *rval)
{
    L_type *index_type = base_type;
    L_expression *i;
    int emit_set = TRUE;


    for (i = index; i && (i->kind != L_EXPRESSION_HASH_INDEX);
         i = i->indices)
    {
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                          strlen("pointer")),
                    lframe->envPtr);
        if (emit_set) {
            L_trace("[pointer set [pointer add ");
            /* only emit set the first time */
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "set",
                                              strlen("set")),
                        lframe->envPtr);
            emit_set = FALSE;
        } else {
            L_trace("[pointer get [pointer add ");
            TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "get",
                                              strlen("get")),
                        lframe->envPtr);
        }

        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "pointer",
                                          strlen("pointer")),
                    lframe->envPtr);
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, "add",
                                          strlen("add")),
                    lframe->envPtr);
    }
    L_LOAD_SCALAR(varIndex);
    for (i = index; i && (i->kind != L_EXPRESSION_HASH_INDEX);
         i = i->indices)
    {
        index_type = L_compile_index(base_type, index_type, i);
        L_trace(" %d ] ]", i->a->u.i);
        /* pointer add */
        TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
        if (i->indices && (i->indices->kind != L_EXPRESSION_HASH_INDEX)) {
            /* pointer get */
            TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
        } else {
            /* the last time around, pointer set */
            L_compile_expressions(rval);
            TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
        }

    }
    return i;
}

/* Read a value out of a hashtable and leave it on the stack.  We
   expect the hashtable to be on top of the stack.  Return the next
   non-hashtable index.*/
static L_expression *
L_read_hash_index_chunk(
    L_expression *i)            /* the keys */
{
    int index_count = 0;
    /* push the indices onto the stack */
    while (i && (i->kind == L_EXPRESSION_HASH_INDEX)) {
        L_compile_index(NULL, NULL, i);
        i = i->indices;
        index_count++;
    }
    TclEmitInstInt4(INST_DICT_GET, index_count, lframe->envPtr);
    return i;
}

/* Make a copy of the dictionary in varIndex, add a key->value pair to
   it, and write it back into varIndex.  Return the next non-hashtable
   index. */
static L_expression *
L_write_hash_index_chunk(
    int varIndex,               /* the variable holding the dictionary */
    L_expression *i,            /* the keys */
    L_expression *rval)         /* the value to store */
{
    int index_count = 0;
    /* push the indices onto the stack */
    while (i && (i->kind == L_EXPRESSION_HASH_INDEX)) {
        L_compile_index(NULL, NULL, i);
        i = i->indices;
        index_count++;
    }
    /* push the value to store */
    L_compile_expressions(rval);
    TclEmitInstInt4(INST_DICT_SET, index_count, lframe->envPtr);
    /* the second operand to the dict_set instruction is the dict. */
    TclEmitInt4(varIndex, lframe->envPtr);
    return i;
}

/* Emit code to push an index onto the stack and return the type to use for
   compiling the next index.  We do some minimal type checking on the way. */
L_type *
L_compile_index(
    L_type *base_type,          /* The complete type of the object we're
                                   indexing into. */
    L_type *index_type,         /* The type of the index. */
    L_expression *index)        /* The index expression to compile. */
{
    L_type *t = index_type;

    switch (index->kind) {
    case L_EXPRESSION_STRUCT_INDEX:
        if (index->a->kind == L_EXPRESSION_STRING) {
            /* structure member */
            L_variable_declaration *member;
            int memberOffset;

            if (!t->kind == L_TYPE_STRUCT) {
                L_errorf(index, "Not a structure");
                return t;
            }
            for (memberOffset = 0, member = t->members;
                 member && strcmp(member->name->u.s, index->a->u.s);
                 memberOffset++, member = member->next);
            if (!member) {
                L_errorf(index, "Structure field not found, %s", index->a->u.s);
                return t;
            }
            TclEmitPush(TclAddLiteralObj(lframe->envPtr,
                                         Tcl_NewIntObj(memberOffset),
                                         NULL),
                        lframe->envPtr);
            t = member->type;
        } else {
            L_bomb("Bad struct index");
        }
        break;
    case L_EXPRESSION_ARRAY_INDEX:
        /* array index */
        if (!(array_p(t) || pointer_p(t))) {
            L_errorf(index, "Index into something that's not an array");
            return t;
        }
        L_compile_expressions(index->a);
        if (array_p(t->next_dim)) {
            t = t->next_dim;
        } else {
            t = base_type;
        }
        break;
    case L_EXPRESSION_HASH_INDEX:
        L_trace("Spitting out a hash index\n");
        L_compile_expressions(index->a);
        break;
    default:
        L_bomb("Invalid kind of index, %d", index->kind);
    }
    return t;
}

void
L_compile_incdec(L_expression *expr)
{
    L_symbol *var;

    /* XXX note that this implementation doesn't allow us to increment array
       or structure lvalues. --timjr 2006.5.29 */
    if (!(var = L_get_symbol(expr->a, TRUE))) return;
    if (expr->kind == L_EXPRESSION_PRE) {
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
    } else {
        /* we push the value of the variable, do the increment, and then pop
           the result of the increment, leaving the old value on top. */
        L_push_variable(expr);
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
}

/* Output bytecode to invoke main() or main(int argc, string argv[]). */
void
emit_call_to_main(CompileEnv *envPtr, int with_args_p)
{
    TclEmitPush(TclRegisterNewLiteral(envPtr, "main", strlen("main")),
                envPtr);
    if (!with_args_p) {
        TclEmitInstInt4(INST_INVOKE_STK4, 1, envPtr);
    } else {
        /* TCL's argv is missing argv[0], which they've placed in argv0.  We
           stick the two together and pass that to L.  So, first push argc and
           add one to it: */
        TclEmitPush(TclRegisterNewLiteral(envPtr, "argc", strlen("argc")),
                    envPtr);
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        TclEmitPush(TclRegisterNewLiteral(envPtr, "1", strlen("1")),
                    envPtr);
        TclEmitOpcode(INST_ADD, envPtr);
        /* Now push argv0 and argv and concatenate them:  */
        TclEmitPush(TclRegisterNewLiteral(envPtr, "concat", strlen("concat")),
                    envPtr);
        TclEmitPush(TclRegisterNewLiteral(envPtr, "argv0", strlen("argv0")),
                    envPtr);
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        TclEmitPush(TclRegisterNewLiteral(envPtr, "argv", strlen("argv")),
                    envPtr);
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        /* invoke concat */
        TclEmitInstInt4(INST_INVOKE_STK4, 3, envPtr);
        /* invoke main */
        TclEmitInstInt4(INST_INVOKE_STK4, 3, envPtr);
    }
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(
    L_expression *name,
    L_type *type,
    int localIndex)
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name->u.s, &new);
    if (!new) {
        L_errorf(name, "Duplicate definition of symbol %s", name->u.s);
    }
    symbol->name = name->u.s;
    symbol->type = type;
    symbol->localIndex = localIndex;
    symbol->global_p = FALSE;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
    return (L_symbol*)0;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(L_expression *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name->u.s);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared variable: %s", name->u.s);
        }
        return NULL;
    }
}


/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void
maybeFixupEmptyCode(L_compile_frame *frame)
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        TclEmitPush( TclAddLiteralObj(frame->envPtr, Tcl_NewObj(), NULL),
            frame->envPtr);
    }
}

/* Make a new unique name.  It will be freed when the current AST is freed. */
static char *
gensym(char *name)
{
    L_expression *node;
    char *gensym = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
    sprintf(gensym, "%d%s", gensym_counter++, name);
    /* exploit the property of AST nodes that they'll free the string after
       compilation has finished. */
    MK_STRING_NODE(node, gensym);
    ckfree(gensym);
    return node->u.s;
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        fprintf(stderr, "***: ");
        vfprintf(stderr, format, ap);
        fprintf(stderr, "\n");
    }
    va_end(ap);
    fflush(stderr);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", s, L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", buf,
                 node ? ((L_ast_node *)node)->line_no : -1);
    ckfree(buf);
}

static void 
L_free_ast(L_ast_node *ast) {
    while(ast_trace_root) {
        L_ast_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_EXPRESSION &&
            ((L_expression *)node)->kind == L_EXPRESSION_STRING) {
            ckfree(((L_expression *)node)->u.s);
        }
        ckfree((char *)node);
    }
    ast_trace_root = NULL;
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
