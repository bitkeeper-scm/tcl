#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"

static L_compile_frame *lframe = NULL;
static Tcl_HashTable *L_struct_types = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
void *L_current_ast = NULL;
int L_interactive = 0;

#define CALL_MAIN 1             /* call main automatically */
#define CALL_MAIN_WITH_ARGS 2   /* call main and pass argc and argv */
static int post_compile_action = 0; /* what's left to do after compiling an L
                                       script successfully */

static int gensym_counter = 0;  /* used to create unique names */

/* The table we store typedef information in.  Use L_typedef_table() to access
   it. */
Tcl_HashTable *__L_typedef_table = NULL;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_free_ast(L_ast_node *ast);
static int global_symbol_p(L_symbol *symbol);
static void fixup_struct_type(L_type *type);
static int array_p(L_type *t);
static L_type *lookup_struct_type(char *tag);
static void emit_call_to_main(CompileEnv *envPtr, int with_args_p);

static L_type *L_write_hash_index_chunk(int varIndex, L_expression *index,
                                        L_expression *rval, int leave_lval_p);
static L_type *L_write_array_index_chunk(int varIndex, L_expression *index,
                                         L_type *type, L_type *base_type,
                                         L_expression *rval);

static L_expression *L_read_array_index_chunk(int varIndex, L_expression *i,
                                              L_type **type,
                                              L_type *base_type);
static L_expression *L_read_hash_index_chunk(L_expression *i);
static L_expression *L_read_struct_index_chunk(L_expression *index,
                                               L_type **type);
static L_type *L_write_struct_index_chunk(int varIndex, L_expression *index,
                                          L_type *type, L_expression *rval);

static Tcl_Obj *literal_to_TclObj(L_expression *expr);
static Tcl_Obj *blank_initial_value(L_type *type);
static L_symbol *import_global_symbol(L_symbol *var);
static void emit_upvar(L_symbol *var, char *upvarName);
static char *gensym(char *name);
static char *array_initializer_code(L_type *type, char *name,
                                    int *needs_eval);
static int store_in_tempvar(int pop_p);
static void L_write_index(L_symbol *var, L_type *type, L_expression *index,
                          L_expression *rval);
static Tcl_HashTable *L_typedef_table();
static L_expression *reference_mangle(char *name);
static int type_passed_by_name_p(L_type *type);


/* we keep track of each AST node we allocate and free them all at once */
L_ast_node *ast_trace_root = NULL;

/* If TCL encounters an L pragma while evaluating code directly, e.g., from an
   upvar, it will enter the L compiler via L_PragmaObjCmd(). */
int 
L_PragmaObjCmd(
    ClientData clientData,
    Tcl_Interp *interp, 
    int objc,
    Tcl_Obj *CONST objv[])
{ 
    int stringLen; 
    char *stringPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via L_PragmaObjCmd");
    if (objc != 2) {
        L_bomb("Assertion failed in L_PragmaObjCmd: we expected 1 "
               "argument but got %d.", objc - 1);
    }
    stringPtr = Tcl_GetStringFromObj(objv [1], &stringLen);
    if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    return LCompileScript(interp, stringPtr, stringLen, NULL, ast);
}


/* If TCL encounters an L pragma while compiling TCL code, for example when
   processing an entire file in TclCompileScript(), it will enter L via
   LCompilePragmaCmd().  In that case, we get a pointer to the toplevel
   compilation environment, so we have the option of emitting global code.

   If there is an error during L compilation, we return TCL_ERROR.  However,
   the error only causes TCL to defer evaluation of the L pragma until
   runtime, at which point L_PragmaObjCmd() will recompile the L code and hit
   the same error.  */
int
LCompilePragmaCmd(
    Tcl_Interp *interp,
    Tcl_Parse *parsePtr,
    CompileEnv *envPtr)
{
    int retval;
    Tcl_Token *lTokenPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via LCompilePragmaCmd");
    if (parsePtr->numWords != 2) {
        L_bomb("Assertion failed in LCompilePragmaCmd: we expected 2 "
               "words but got %d.", parsePtr->numWords);
    }
    // advance to the second token
    lTokenPtr = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
    // the first component of the second token contains the code
    if (LParseScript(interp, lTokenPtr[1].start,
                     lTokenPtr[1].size, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    post_compile_action = 0;
    retval = LCompileScript(interp, lTokenPtr[1].start, lTokenPtr[1].size,
                            envPtr, ast);
    if (post_compile_action && (retval == TCL_OK)) {
        switch (post_compile_action) {
        case CALL_MAIN_WITH_ARGS:
            emit_call_to_main(envPtr, TRUE);
            break;
        case CALL_MAIN:
            emit_call_to_main(envPtr, FALSE);
            break;
        default:
            L_bomb("unsupported post compile action %d", post_compile_action);
        }
    }
    return retval;
}

/* Parse an L script into an AST.  Parsing and compiling are broken into two
   stages in order to support an interactive mode that parses many times
   before finally compiling.  */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer;

    L_start_lexer();
    lex_buffer = (void *)L__scan_bytes(str, numBytes);
    /* L_trace("Parsing: %.*s", numBytes, str); */
    L_trace("parsing");
    L_line_number = 0;
    L_errors = NULL;
    L_parse();
    if (L_ast == NULL) {
        L_free_ast(L_current_ast);
    } else {
        *L_ast = L_current_ast;
    }
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.");
            return TCL_ERROR;
    }
    L_trace("Done parsing.");
    return TCL_OK;
}


/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
int
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr,
    void *ast)
{
/*     L_trace("Compiling: \n %.*s", numBytes, str); */
    L_trace("compiling");
    L_frame_push(interp, envPtr);
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;

    switch(((L_ast_node*)ast)->type) {
    case L_NODE_TOPLEVEL_STATEMENT:
        L_compile_toplevel_statements(ast);
        break;
    default:
        L_bomb("LCompileScript error, expecting a toplevel statement, "
               "got: %s", L_node_type_tostr[((L_ast_node*)ast)->type]);
    }
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();

    L_free_ast(ast);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to compile.");
            return TCL_ERROR;
    }
    L_trace("Done compiling");
    return TCL_OK;
}

void
L_compile_toplevel_statements(L_toplevel_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_TOPLEVEL_STATEMENT_FUNCTION_DECLARATION:
        L_compile_function_decl(stmt->u.fun);
        break;
    case L_TOPLEVEL_STATEMENT_TYPE:
        L_compile_struct_decl(stmt->u.type);
        break;
    case L_TOPLEVEL_STATEMENT_TYPEDEF:
        /* ignore */
        break;
    case L_TOPLEVEL_STATEMENT_GLOBAL:
        L_compile_global_decls(stmt->u.global);
        break;
    default:
        L_bomb("Unexpected toplevel statement type %d", stmt->kind);
    }
    L_compile_toplevel_statements(stmt->next);
}

void
L_compile_function_decl(L_function_declaration *fun)
{
    Proc *procPtr;
    CompileEnv *envPtr;
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    if (!fun) return;
    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr);

    procPtr = (Proc *)ckalloc(sizeof(Proc));
    procPtr->iPtr = (struct Interp *)lframe->interp;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;

    TclInitCompileEnv(lframe->interp, envPtr, "L Compiler",
                      strlen("L Compiler"));
    lframe->originalCodeNext = envPtr->codeNext;
    envPtr->procPtr = procPtr;

    L_compile_parameters(fun->params);
    L_compile_block(fun->body);
    
    /* This is the "fall off the end" implicit return. We return "". */
    L_return(FALSE);

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, fun->name->u.s,
        TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;

    /* Check if we're compiling main() or main(int argc, string argv[]) */
    if (!strncmp("main", fun->name->u.s, strlen("main"))) {
        if (!fun->params) {
            post_compile_action = CALL_MAIN;
        } else {
            if (!fun->params->next) {
                /* XXX we don't bother to check the parameter types */
                L_errorf(fun->params, "main() takes only zero or two "
                         "arguments");
            }
            post_compile_action = CALL_MAIN_WITH_ARGS;
        }
    }

    TclFreeCompileEnv(lframe->envPtr);
    ckfree((char *)lframe->envPtr);
    L_frame_pop();
}

void
L_compile_struct_decl(L_type *decl)
{
    Tcl_HashEntry *hPtr;
    int freshp;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    if (!decl->struct_tag ||
        !(decl->struct_tag->kind == L_EXPRESSION_STRING)) {
        L_errorf(decl, "Untagged struct types are not supported yet");
        return;
    }
    hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.s, &freshp);
    Tcl_SetHashValue(hPtr, decl);
    L_trace("Declared struct type %s", decl->struct_tag->u.s);
}

void
L_compile_global_decls(L_variable_declaration *decl)
{
    L_symbol *symbol;
    Tcl_Obj *initial_value;
    char *init_code;
    int needs_eval;

    if (!decl) return;
    if (decl->type->kind == L_TYPE_STRUCT) {
        fixup_struct_type(decl->type);
    }
    init_code = array_initializer_code(decl->type, decl->name->u.s,
                                       &needs_eval);
    L_trace("Global variable named %s\n", decl->name->u.s);
    if (decl->initial_value) {
        L_trace("took this path");
        initial_value = literal_to_TclObj(decl->initial_value);
    } else {
        initial_value = blank_initial_value(decl->type);
    }
    symbol = L_make_symbol(decl->name, decl->type, -1);
    symbol->global_p = TRUE;
    if (lframe->envPtr) {
        L_trace("init code is:\n%s\nneeds_eval is : %d",
                init_code, needs_eval);
        if (needs_eval) {
            L_PUSH_STR("eval");
            L_PUSH_STR(init_code);
            TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
        } else {
            L_PUSH_STR(decl->name->u.s);
            L_PUSH_OBJ(initial_value);
            TclEmitOpcode(INST_STORE_SCALAR_STK, lframe->envPtr);
        }
    } else {
        /* interpreted case */
        if (needs_eval) {
            L_trace("interpreted init code is \n\%s\n", init_code);
            Tcl_EvalEx(lframe->interp, init_code, -1, 0);
        } else {
            Tcl_SetVar2Ex(lframe->interp, decl->name->u.s, NULL,
                          initial_value,
                          TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG);
        }
    }
    L_compile_global_decls(decl->next);
}

/* Initialize the struct types table and lookup a type in it.  Returns the
   type, or NULL if none was found.  */
L_type *
lookup_struct_type(char *tag)
{
    Tcl_HashEntry *hPtr = NULL;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    hPtr = Tcl_FindHashEntry(L_struct_types, tag);

    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}

void 
L_compile_variable_decls(L_variable_declaration *var)
{
    L_symbol *symbol;
    int localIndex;

    if (!var) return;
    L_trace("declaring variable %s", var->name->u.s);
    if (var->type->kind == L_TYPE_STRUCT) {
        fixup_struct_type(var->type);
    }
    localIndex = TclFindCompiledLocal(var->name->u.s, strlen(var->name->u.s),
                                      1, 0, lframe->envPtr->procPtr);
    if ((symbol = L_get_symbol(var->name, FALSE)) &&
        !global_symbol_p(symbol))
    {
        L_errorf(var, "Illegal redeclaration of local variable %s",
                 var->name->u.s);
    }
    symbol = L_make_symbol(var->name, var->type, localIndex);
    if (array_p(var->type) || (var->type->kind == L_TYPE_STRUCT)) {
        /* We don't support literal initializers for structs and arrays yet.
           Just always initialize to a blank TCL list. */
        var->initial_value = NULL;
    }
    if (var->initial_value) {
        L_compile_expressions(var->initial_value);
        L_STORE_SCALAR(localIndex);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    } else {
        /* create the initial value and emit code to push it on the
           stack */
        int needs_eval;
        char *init_code = array_initializer_code(var->type, var->name->u.s,
                                                 &needs_eval);
        if (needs_eval) {
            L_trace("init code is \n%s\n", init_code);
            L_PUSH_STR("eval");
            L_PUSH_STR(init_code);
            TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
/*             TclEmitOpcode(INST_POP, lframe->envPtr); */
        } else {
            Tcl_Obj *initial_value = blank_initial_value(var->type);
            L_PUSH_OBJ(initial_value);
            L_STORE_SCALAR(localIndex);
            TclEmitOpcode(INST_POP, lframe->envPtr);
        }
    }
    L_compile_variable_decls(var->next);
}

static Tcl_Obj *blank_initial_value(L_type *type) {
    return Tcl_NewObj();
}

/* Generate code to initialize an array or struct.  If name is passed,
   generate a set into a variable of that name.  needs_eval will be set to
   true if the code must be evaluated, false if the code is constant.  */
static char *
array_initializer_code(
    L_type *type,
    char *name,
    int *needs_eval)
{
    L_type *array_type = type ? type->next_dim : NULL;
    Tcl_Obj *code = Tcl_NewObj();
    int close_brackets = 0, i;
    L_expression *retval;

    Tcl_IncrRefCount(code);
    /* XXX: Our two call sites know to disregard the value of this function if
       needs_eval is false.  That's a somewhat funky state of affairs.
       --timjr 2006.9.24 */
    *needs_eval = FALSE;
    if (name) {
        TclObjPrintf(NULL, code, "set %s ", name);
    }
    while (array_type) {
        if (array_type->array_dim->kind != L_EXPRESSION_INT) {
            L_errorf(array_type->array_dim,
                     "Bad dimension for an array: must be an int.");
            break;
        }
        if (array_type->array_dim->u.i > 0) {
            close_brackets++;
            *needs_eval = TRUE;
            TclObjPrintf(NULL, code, "[lrepeat %d ",
                         array_type->array_dim->u.i);
            array_type = array_type->next_dim;
        } else {
            break;
        }
    }
    /* the base type */
    if (type->kind == L_TYPE_STRUCT) {
        L_variable_declaration *mem;

        *needs_eval = TRUE;
        TclObjPrintf(NULL, code, "[list ");
        for (mem = type->members; mem; mem = mem->next) {
            if (array_p(mem->type)) {
                int dummy;
                TclObjPrintf(NULL, code, "%s ",
                             array_initializer_code(mem->type, NULL, &dummy));
            } else {
                TclObjPrintf(NULL, code, "{} ");
            }
        }
        TclObjPrintf(NULL, code, "]");
    } else {
        TclObjPrintf(NULL, code, "{} ");
    }
    for (i = 0; i < close_brackets; i++) {
        TclObjPrintf(NULL, code, "]");
    }
    MK_STRING_NODE(retval, Tcl_GetString(code));
    Tcl_DecrRefCount(code);
    return retval->u.s;
}

void
fixup_struct_type(L_type *type)
{
/*     Tcl_Obj *val = NULL; */
/*     int i; */
    L_type *struct_type = type;
/*     L_variable_declaration *member; */

    /* if we have a struct tag without the struct definition, lookup the
       definition. */
    if (!struct_type->members) {
        if (!struct_type->struct_tag) {
            L_bomb("Assertion failed: a struct must either have a tag or "
                   "members");
        }
        struct_type = lookup_struct_type(struct_type->struct_tag->u.s);
        if (!struct_type) {
            L_errorf(type, "Undefined structure type: %s",
                     struct_type->struct_tag->u.s);
            return;
        }
        /* Fixup the original type so that it also has the member
           information.  This allows all the other code to skip the
           lookup. */
        type->members = struct_type->members;
    }
/*     val = Tcl_NewListObj(0, NULL); */
/*     /\* initialize the struct fields *\/ */
/*     for (member = type->members; member; member = member->next, i++) { */
/*         Tcl_Obj *el = */
/*             create_array_or_struct(member->type->next_dim, member->type); */
/*         if (!el) return NULL; */
/*         Tcl_ListObjAppendElement(NULL, val, el); */
/*     } */
/*     return val; */
}

int
array_p(L_type *t)
{
    if (t->next_dim) {
        if (t->next_dim->kind == L_TYPE_ARRAY) {
            return TRUE;
        } else {
            return array_p(t->next_dim);
        }
    } else {
        return FALSE;
    }
}

int
global_symbol_p(L_symbol *symbol)
{
    return symbol->global_p;
}

void
L_compile_statements(L_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_STATEMENT_BLOCK:
        L_compile_block(stmt->u.block);
        break;
    case L_STATEMENT_EXPR:
        L_compile_expressions(stmt->u.expr);
        /* Expressions leave a value on the evaluation stack, but statements
           don't. So pop the value. */
        TclEmitOpcode(INST_POP, lframe->envPtr);
        break;
    case L_STATEMENT_IF_UNLESS:
        L_compile_if_unless(stmt->u.cond);
        break;
    case L_STATEMENT_LOOP:
        L_compile_loop(stmt->u.loop);
        break;
    case L_STATEMENT_RETURN:
        L_trace("compiling return statement");
        if (stmt->u.expr) {
            L_trace("    with return value");
            /* compile the return value */
            L_compile_expressions(stmt->u.expr);
        } else {
            L_trace("    without return value");
            /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
            L_PUSH_OBJ(Tcl_NewObj());
        }
        /* INST_RETURN_STK involves a little more magic that I haven't wangled out
           yet... but I think it lets us pass back error codes and such that could
           be useful. --timjr 2006.3.31  */
        /* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
        TclEmitOpcode(INST_DONE, lframe->envPtr);
        break;
    }
    L_compile_statements(stmt->next);
}

void
L_compile_block(L_block *block) {
    L_compile_variable_decls(block->decls);
    L_compile_statements(block->body);
}

void 
L_compile_parameters(L_variable_declaration *param)
{
    Proc *procPtr = lframe->envPtr->procPtr;
    CompiledLocal *localPtr;
    L_expression *name;
    int i;
    
    for (i = 0; param; param = param->next, i++) {
        L_symbol *symbol;
        int by_name = (param->by_name || type_passed_by_name_p(param->type));
        if (by_name) {
            /* if the parameter is pass by name, we use a mangled name for it
               so that we can define an upvar using the original name */
            name = reference_mangle(param->name->u.s);
        } else {
            name = param->name;
        }
        L_trace("Compiling parameter %d (%s)", i, name->u.s);
        /* Formal parameters are stored in local variable slots. */
        procPtr->numArgs = i + 1;
        procPtr->numCompiledLocals = i + 1;
        localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
                                             sizeof(localPtr->name) +
                                             strlen(name->u.s) + 1);
        if (procPtr->firstLocalPtr == NULL) {
            procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr;
        } else {
            procPtr->lastLocalPtr->nextPtr = localPtr;
            procPtr->lastLocalPtr = localPtr;
        }
        localPtr->nextPtr = NULL;
        localPtr->nameLength = strlen(name->u.s);
        localPtr->frameIndex = i;
        localPtr->flags = VAR_SCALAR | VAR_ARGUMENT;
        localPtr->resolveInfo = NULL;
        localPtr->defValuePtr = NULL;
        strcpy(localPtr->name, name->u.s);
        symbol = L_make_symbol(name, param->type, i);
        if (by_name) {
            int localIndex =
                TclFindCompiledLocal(param->name->u.s, strlen(param->name->u.s),
                                     1, 0, procPtr);
            emit_upvar(symbol, param->name->u.s);
            L_make_symbol(param->name, param->type, localIndex);
        }
    }
}

/* arrays, and hashes are all passed by name.  array_p() is too general to use
   here. */
static int
type_passed_by_name_p(L_type *type)
{
/*     return ((type->next_dim && */
/*              type->next_dim->kind == L_TYPE_ARRAY) || */
/*             type->kind == L_TYPE_HASH); */
    /* XXX: this is disabled for the moment because it looks like it might be
       a problem... --timjr 2009.9.24 */
    return FALSE;
}

void
L_compile_expressions(L_expression *expr)
{
    int i = 0;
    L_expression *tmp;

    if (!expr) return;
/*     L_trace("Compiling an expression of type %s", */
/*             L_expression_tostr[expr->kind]); */
    switch (expr->kind) {
    case L_EXPRESSION_FUNCALL:
        L_PUSH_STR(expr->a->u.s);
        L_compile_expressions(expr->b);
        /* count the parameters */
        for (tmp = expr->b; tmp; tmp = tmp->next, i++);
        TclEmitInstInt4(INST_INVOKE_STK4, i+1, lframe->envPtr);
        break;
    case L_EXPRESSION_PRE:
    case L_EXPRESSION_POST:
        L_compile_incdec(expr);
        break;
    case L_EXPRESSION_UNARY:
        L_compile_unop(expr);
        break;
    case L_EXPRESSION_BINARY:
        L_trace("Binary expression");
        L_compile_binop(expr);
        break;
    case L_EXPRESSION_INT:
    case L_EXPRESSION_STRING:
    case L_EXPRESSION_DOUBLE:
        L_PUSH_OBJ(literal_to_TclObj(expr));
        break;
    case L_EXPRESSION_INTERPOLATED_STRING:
        L_compile_interpolated_string(expr);
        break;
    case L_EXPRESSION_VARIABLE:
        L_push_variable(expr);
        break;
    default:
        L_bomb("Unknown expression type %d", expr->kind);
    }
    L_compile_expressions(expr->next);
}

/* Create a Tcl Obj containing the value of a constant literal L AST
   node. */
Tcl_Obj *literal_to_TclObj(L_expression *expr)
{
    Tcl_Obj *obj = NULL;

    switch (expr->kind) {
    case L_EXPRESSION_INT:
        obj = Tcl_NewIntObj(expr->u.i);
        break;
    case L_EXPRESSION_STRING:
        obj = Tcl_NewStringObj(expr->u.s, strlen(expr->u.s));
        break;
    case L_EXPRESSION_DOUBLE:
        obj = Tcl_NewDoubleObj(expr->u.d);
        break;
    default:
        L_bomb("literal_to_TclObj can't handle expressions of type %d\n",
               expr->kind);
    }
    return obj;
}

void L_compile_unop(L_expression *expr)
{
    switch (expr->op) {
    case T_BANG:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
        break;
    case T_BITNOT:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_BITNOT, lframe->envPtr);
        break;
    case T_PLUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UPLUS, lframe->envPtr);
        break;
    case T_MINUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UMINUS, lframe->envPtr);
        break;
    case T_BITAND:
        /* &, address-of operator */
        if (expr->a->kind != L_EXPRESSION_STRING) {
            L_bomb("Address-of is only supported on variable names.");
        } else {
            L_compile_expressions(expr->a);
        }
        break;
    case T_DEFINED:
        L_compile_defined(expr->a);;
        break;
    default:
        L_bomb("Unknown unary operator %d", expr->op);
    }
}

void L_compile_binop(L_expression *expr)
{
    int instruction = 0;

    if (expr->op == T_EQUALS) {
        L_compile_assignment(expr);
    } else if ((expr->op == T_ANDAND) ||
               (expr->op == T_OROR)) {
        L_compile_short_circuit_op(expr);
    } else if ((expr->op == T_EQTWID) ||
               (expr->op == T_BANGTWID)) {
        L_compile_twiddle(expr);
    } else {
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        switch (expr->op) {
        case T_PLUS:
            instruction = INST_ADD;
            break;
        case T_MINUS:
            instruction = INST_SUB;
            break;
        case T_STAR:
            instruction = INST_MULT;
            break;
        case T_SLASH:
            instruction = INST_DIV;
            break;
        case T_PERC:
            instruction = INST_MOD;
            break;
        case T_EQ:
        case T_EQUALEQUAL:
            instruction = INST_EQ;
            break;
        case T_NE:
        case T_NOTEQUAL:
            instruction = INST_NEQ;
            break;
        case T_GT:
        case T_GREATER:
            instruction = INST_GT;
            break;
        case T_GE:
        case T_GREATEREQ:
            instruction = INST_GE;
            break;
        case T_LT:
        case T_LESSTHAN:
            instruction = INST_LT;
            break;
        case T_LE:
        case T_LESSTHANEQ:
            instruction = INST_LE;
            break;
        case T_LSHIFT:
            instruction = INST_LSHIFT;
            break;
        case T_RSHIFT:
            instruction = INST_RSHIFT;
            break;
        case T_BITOR:
            instruction = INST_BITOR;
            break;
        case T_BITXOR:
            instruction = INST_BITXOR;
            break;
        case T_BITAND:
            instruction = INST_BITAND;
            break;
        default:
            L_bomb("Undefined operator %d", expr->op);
        }
        TclEmitOpcode(instruction, lframe->envPtr);
    }
}

void
L_compile_interpolated_string(L_expression *expr)
{
    int tempVar;

    /* XXX is there really no better way to concatenate 3 strings
       using TCL bytecode? */
    L_compile_expressions(expr->a);
    tempVar = TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR,
                                   lframe->envPtr->procPtr);
    L_STORE_SCALAR(tempVar);
    L_compile_expressions(expr->b);
    TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    if (expr->c) {
        L_compile_expressions(expr->c);
        TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        L_LOAD_SCALAR(tempVar);
    } else {
        /* Currently, an interpolated string node will always be
           followed by another one, or by a regular string node, so
           there's no way to test this branch.  */
        L_bomb("L_compile_interpolated_string: Malformed AST");
    }
}

void
L_compile_twiddle(L_expression *expr)
{
    Tcl_Obj *const_regexp = Tcl_NewObj();
    Tcl_RegExp compiled;
    int submatchCount = 0, i;
    L_expression *runner;

    /* put together the parts of the regexp that we know at compile time */
    Tcl_IncrRefCount(const_regexp);
    for (runner = expr->b; runner; runner = runner->c) {
        switch (runner->kind) {
        case L_EXPRESSION_INTERPOLATED_STRING:
            Tcl_AppendToObj(const_regexp, runner->a->u.s, -1);
            /* if we ever find a spot where the regexp breaks, we could try
               adding a space to replace the runner->b interpolated part.
               (see the XXX comment below) */
            //            Tcl_AppendToObj(const_regexp, " ", 1);
            break;
        case L_EXPRESSION_STRING:
            Tcl_AppendToObj(const_regexp, runner->u.s, -1);
            break;
        default:
            L_bomb("L_compile_twiddle: Malformed AST");
        }
    }
    /* now try to compile the regexp, just to figure out how many submatches
       there are. */
    compiled = Tcl_GetRegExpFromObj(lframe->interp, const_regexp,
                                    TCL_REG_ADVANCED);
    if (compiled == NULL) {
        /* XXX: does a regexp really have to be correct sans interpolated
           parts?  If not, this error might happen at the wrong time.  To
           support such regexps, we would have to count submatches at
           runtime. */
        L_errorf(expr, "Bad regular expression");
    } else {
        submatchCount = ((TclRegexp *)compiled)->re.re_nsub;
    }
    L_trace("The submatch count in %s is %d\n",
            Tcl_GetString(const_regexp), submatchCount);
    /* create the submatch variables */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        L_expression *name;

        snprintf(buf, 128, "$%d", i);
        MK_STRING_NODE(name, buf);
        if (!L_get_symbol(name, FALSE)) {
            int localIndex =
                TclFindCompiledLocal(name->u.s, strlen(name->u.s),
                                     1, 0, lframe->envPtr->procPtr);
            L_make_symbol(name,
                          mk_type(L_TYPE_STRING, NULL, NULL, NULL, NULL),
                          localIndex);
        }
    }
    /* emit code to call the regexp object command */
    L_PUSH_STR("regexp");
    /* the regexp */
    L_compile_expressions(expr->b);
    /* the target string */
    L_compile_expressions(expr->a);
    /* match/submatch vars */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        snprintf(buf, 128, "$%d", i);
        L_PUSH_STR(buf);
    }
    TclEmitInstInt1(INST_INVOKE_STK1, 4 + submatchCount, lframe->envPtr);
    if (expr->op == T_BANGTWID) {
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
    }
}

void
L_compile_short_circuit_op(L_expression *expr)
{
    JumpFixup fixup;

    L_compile_expressions(expr->a);
    /* In case the operator short-circuits, we need one value on the
       evaluation stack for the jump and one for the value of the
       expression. */
    TclEmitOpcode(INST_DUP, lframe->envPtr);
    if (expr->op == T_ANDAND) {
        TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &fixup);
    } else {
        TclEmitForwardJump(lframe->envPtr, TCL_TRUE_JUMP, &fixup);
    }
    /* If the operator doesn't short-circuit, we want to leave the value of
       the second expression on the stack, so remove the value that we DUPed
       above. */
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_compile_expressions(expr->b);
    TclFixupForwardJumpToHere(lframe->envPtr, &fixup, 127);
}

void
L_compile_if_unless(L_if_unless *cond)
{
    JumpFixup jumpFalse, jumpEnd;

    L_compile_expressions(cond->condition);
    L_PUSH_STR("0");
    TclEmitOpcode(INST_NEQ, lframe->envPtr);
    /* emit a jump which will skip the consequent if the top value on the
       stack is false. */
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &jumpFalse);
    L_frame_push(lframe->interp, lframe->envPtr);
    /* consequent */
    if (cond->if_body != NULL) {
        L_compile_statements(cond->if_body);
    }
    /* alternate */
    if (cond->else_body != NULL) {
        /* End the scope that was started for the consequent and start a new
           one, copying the jump fixup pointers. */
        L_frame_pop();
        L_frame_push(lframe->interp, lframe->envPtr);
        TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpEnd);
        if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127)) {
            /* The TCL_FALSE_JUMP that we emitted expanded, so the beginning
               code offset saved in the jump fixup for the
               TCL_UNCONDITIONAL_JUMP needs to be adjusted. */
            jumpEnd.codeOffset += 3;
        }
        L_compile_statements(cond->else_body);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpEnd, 127);
    } else {
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
    }
    L_frame_pop();
}

void
L_compile_loop(L_loop *loop)
{
    JumpFixup jumpToCond;
    int bodyCodeOffset, jumpDist;

    if ((loop->kind == L_LOOP_FOR) && loop->pre) {
        L_compile_expressions(loop->pre);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpToCond);
    L_frame_push(lframe->interp, lframe->envPtr);
    bodyCodeOffset = lframe->envPtr->codeNext - lframe->envPtr->codeStart;
    L_compile_statements(loop->body);
    L_frame_pop(lframe->interp, lframe->envPtr);
    if ((loop->kind == L_LOOP_FOR) && loop->post) {
        L_compile_expressions(loop->post);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpToCond, 127)) {
        bodyCodeOffset += 3;
    }
    L_compile_expressions(loop->condition);
    L_PUSH_STR("0");
    TclEmitOpcode(INST_NEQ, lframe->envPtr);
    jumpDist = lframe->envPtr->codeNext - lframe->envPtr->codeStart -
        bodyCodeOffset;
    if (jumpDist > 127) {
        TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
    } else {
        TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
    }
}

void
L_push_variable(L_expression *expr)
{
    L_symbol *var;
    L_expression *name = expr->a;

    if (!(var = L_get_symbol(name, TRUE))) return;
    if (global_symbol_p(var)) {
        var = import_global_symbol(var);
    }
    if (expr->indices) {
        L_expression *index = expr->indices;
        L_type *type = var->type;
        int first_chunk = TRUE;
        while (index) {
            switch (index->kind) {
            case L_EXPRESSION_HASH_INDEX:
                if (first_chunk) {
                    L_LOAD_SCALAR(var->localIndex);
                }
                index = L_read_hash_index_chunk(index);
                /* we have no more information about the type after reading
                   from a hash */
                L_trace("read a hash index, %p", index);
                type = NULL;
                break;
            case L_EXPRESSION_STRUCT_INDEX:
                if (first_chunk) {
                    L_LOAD_SCALAR(var->localIndex);
                }
                index = L_read_struct_index_chunk(index, &type);
                L_trace("read a struct index, %p", index);
                break;
            case L_EXPRESSION_ARRAY_INDEX: {
                /* read_array_index_chunk wants to read the value from a local
                   variable, so ensure it's in one. */
                int varIndex;
                L_type *base_type;
                if (first_chunk) {
                    varIndex = var->localIndex;
                    base_type = type;
                } else {
                    varIndex = store_in_tempvar(TRUE);
                    base_type = NULL;
                }
                index = L_read_array_index_chunk(varIndex, index, &type,
                                                 base_type);
                L_trace("read an array index, %p", index);
                break;
            }
            default:
                L_bomb("corrupt AST, unknown index type");
            }
            first_chunk = FALSE;
        }
    } else {
        if (type_passed_by_name_p(var->type)) {
            /* behave as if there was an & here */
            L_PUSH_STR(var->name);
        } else {
            L_LOAD_SCALAR(var->localIndex);
        }
    }
}

/* Import a global variable into a procedure's table of locals and
   create an L symbol that shadows the global one. Return the new L
   symbol. */
L_symbol *
import_global_symbol(L_symbol *var)
{
    L_symbol *local;
    int localIndex;
    L_expression *name;  // eugh

    L_trace("importing global variable %s", var->name);
    /* create a new local variable that shadows the global in our
       symbol table */
    localIndex = TclFindCompiledLocal(var->name, strlen(var->name),
                                      1, 0, lframe->envPtr->procPtr);
    MK_STRING_NODE(name, var->name);
    local = L_make_symbol(name, var->type, localIndex);
    /* link the global variable with our new local using tcl's
       ``global'' command. */
    L_PUSH_STR("global");
    L_PUSH_STR(var->name);
    TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    return local;
}

/* Make an upvar named upvarName that references the variable named by var. */
static void
emit_upvar(L_symbol *var, char *upvarName)
{
    L_PUSH_STR("upvar");
    L_LOAD_SCALAR(var->localIndex);
    L_PUSH_STR(upvarName);
    TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
}

void
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        L_PUSH_OBJ(Tcl_NewObj());
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

/* Emit code to pop the top of the stack and store it in a temporary local
   variable.  Return the varIndex of the new local variable. */
static int
store_in_tempvar(int pop_p)
{
    int tempVar =
        TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR, lframe->envPtr->procPtr);
    L_STORE_SCALAR(tempVar);
    if (pop_p) {
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    return tempVar;
}

void
L_compile_defined(L_expression *lval)
{
    /* XXX: Going to have to think about how to implement this... it used to
       just say "pointer defined foo".  --timjr 2006.9.24 */
    L_PUSH_STR("0");
}

void
L_compile_assignment(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a;
    L_expression *rval = expr->b;

    L_trace("COMPILING ASSIGNMENT: %s, %s", L_expression_tostr[lval->a->kind],
            lval->a->u.s);
    if (!(var = L_get_symbol(lval->a, TRUE))) return;
    if (global_symbol_p(var)) {
        L_trace("it's a global");
        var = import_global_symbol(var);
    }
    if (lval->indices) {
        L_write_index(var, var->type, lval->indices, rval);
    } else {
        L_compile_expressions(rval);
        L_STORE_SCALAR(var->localIndex);
    }
}

static void
L_write_index(
    L_symbol *var,              /* variable to write into, or null if the
                                   value should be left on the stack */
    L_type *type,               /* the type of value that we're modifying  */
    L_expression *index,        /* the indices */
    L_expression *rval)         /* the ultimate value to store */
{
    int leave_lval_p = !var;

    switch (index->kind) {
    case L_EXPRESSION_HASH_INDEX: {
        int varIndex;
        if (var) {
            varIndex = var->localIndex;
        } else {
            varIndex = store_in_tempvar(TRUE);
        }
        L_trace("write a hash index");
        type = L_write_hash_index_chunk(varIndex, index, rval,
                                        leave_lval_p);
        break;
    }
    case L_EXPRESSION_STRUCT_INDEX: {
        int varIndex;
        if (var) {
            varIndex = var->localIndex;
        } else {
            varIndex = store_in_tempvar(TRUE);
        }
        L_trace("write a struct index");
        type = L_write_struct_index_chunk(varIndex, index, type, rval);
        if (leave_lval_p) {
            TclEmitOpcode(INST_POP, lframe->envPtr);
            L_LOAD_SCALAR(varIndex);
        }
        break;
    }
    case L_EXPRESSION_ARRAY_INDEX: {
        /* write_array_index_chunk wants to read the value from a local
           variable, so ensure it's in one. */
        int varIndex;
        L_type *base_type;
        if (var) {
            varIndex = var->localIndex;
            base_type = type;
        } else {
            varIndex = store_in_tempvar(TRUE);
            base_type = NULL;
        }
        L_trace("write an array index");
        type = L_write_array_index_chunk(varIndex, index, type, base_type,
                                         rval);
        if (leave_lval_p) {
            /* if we should leave the modified array on the stack, do that */
            TclEmitOpcode(INST_POP, lframe->envPtr);
            L_LOAD_SCALAR(varIndex);
        }
        break;
    }
    default:
        L_bomb("corrupt AST, unknown index type");
    }
}

static L_expression *
L_read_struct_index_chunk(
    L_expression *index,
    L_type **type)
{
    *type = L_compile_index(*type, index);
    TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
    return index->indices;
}

static L_type *
L_write_struct_index_chunk(
    int varIndex,
    L_expression *index,
    L_type *type,
    L_expression *rval)
{
    int indexVar, rvalVar;
    if (index->indices) {
        L_trace("the branch less taken");
        L_LOAD_SCALAR(varIndex);
        type = L_compile_index(type, index);
        indexVar = store_in_tempvar(FALSE);
        TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
        L_write_index(NULL, type, index->indices, rval);
        rvalVar = store_in_tempvar(TRUE);
        L_LOAD_SCALAR(indexVar);
        L_LOAD_SCALAR(rvalVar);
    } else {
        type = L_compile_index(type, index);
        L_compile_expressions(rval);
    }
    L_LOAD_SCALAR(varIndex);
    TclEmitOpcode(INST_LSET_LIST, lframe->envPtr);
    L_STORE_SCALAR(varIndex);
    return type;
}

/* Read a value from an array. Returns the next non-array index. */
static L_expression *
L_read_array_index_chunk(
    int varIndex,
    L_expression *index,
    L_type **type,
    L_type *base_type)
{
    L_expression *i;
    int index_count = 0;

    L_LOAD_SCALAR(varIndex);
    for (i = index; i && (i->kind == L_EXPRESSION_ARRAY_INDEX);
         i = i->indices)
    {
        *type = L_compile_index(*type, i);
        index_count++;
    }
    if (index_count == 1) {
        TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
    } else {
        TclEmitInstInt4(INST_LIST_INDEX_MULTI, index_count + 1,
                        lframe->envPtr);
    }
    /*     *type = base_type; */
    return i;
}

static L_type *
L_write_array_index_chunk(
    int varIndex,
    L_expression *index,
    L_type *type,               /* the array type */
    L_type *base_type,          /* the type of the array elements */
    L_expression *rval)

{
    L_expression *i;
    int index_count = 0;

    /* walk to the end of the list of indices so we can check if anything
       comes after that */
    for (i = index; i && (i->kind == L_EXPRESSION_ARRAY_INDEX);
         i = i->indices);
    if (i) {
        int indexVar, rvalVar;
        /* there are struct or hash indices following the array indices, so
           we'll have to read out the array and store it back. */
        L_LOAD_SCALAR(varIndex);
        type = L_compile_index(type, index);
        indexVar = store_in_tempvar(FALSE);
        TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
        L_write_index(NULL, type, index->indices, rval);
        rvalVar = store_in_tempvar(TRUE);
        L_LOAD_SCALAR(indexVar);
        L_LOAD_SCALAR(rvalVar);
        L_LOAD_SCALAR(varIndex);
        TclEmitOpcode(INST_LSET_LIST, lframe->envPtr);
        L_STORE_SCALAR(varIndex);
    } else {
        for (i = index; i && (i->kind == L_EXPRESSION_ARRAY_INDEX);
             i = i->indices)
        {
            type = L_compile_index(type, i);
            index_count++;
        }
        L_compile_expressions(rval);
        L_LOAD_SCALAR(varIndex);
        if (index_count == 1) {
            TclEmitOpcode(INST_LSET_LIST, lframe->envPtr);
        } else {
            TclEmitInstInt4(INST_LSET_FLAT, index_count + 2, lframe->envPtr);
        }
        L_STORE_SCALAR(varIndex);
    }
    return type;
}

/* Read a value out of a hashtable and leave it on the stack.  We
   expect the hashtable to be on top of the stack.  Return the next
   non-hashtable index.*/
static L_expression *
L_read_hash_index_chunk(
    L_expression *i)            /* the keys */
{
    int index_count = 0;
    /* push the indices onto the stack */
    while (i && (i->kind == L_EXPRESSION_HASH_INDEX)) {
        L_compile_index(NULL, i);
        i = i->indices;
        index_count++;
    }
    TclEmitInstInt4(INST_DICT_GET, index_count, lframe->envPtr);
    return i;
}

/* Make a copy of the dictionary in varIndex, add a key->value pair to
   it, and write it back into varIndex.  Return the next non-hashtable
   index. */
static L_type *
L_write_hash_index_chunk(
    int varIndex,               /* the variable holding the dictionary */
    L_expression *index,        /* the keys */
    L_expression *rval,         /* the value to store */
    int leave_lval_p)           /* whether to leave the dict on the stack or
                                   the rval */
{
    int index_count = 0, tempVar;
    /* push the indices onto the stack */
    while (index && (index->kind == L_EXPRESSION_HASH_INDEX)) {
        L_compile_index(NULL, index);
        index = index->indices;
        index_count++;
    }
    if (index) {
        L_write_index(NULL, NULL, index, rval);
    }
    /* push the value to store */
    L_compile_expressions(rval);
    if (!leave_lval_p) {
        tempVar = store_in_tempvar(FALSE);
    }
    TclEmitInstInt4(INST_DICT_SET, index_count, lframe->envPtr);
    /* the second operand to the dict_set instruction is the dict. */
    TclEmitInt4(varIndex, lframe->envPtr);
    /* it leaves the new dictionary on the stack, which we sometimes don't
       want.  in case we'd rather have the rval, switch them around. */
    if (!leave_lval_p) {
        TclEmitOpcode(INST_POP, lframe->envPtr);
        L_LOAD_SCALAR(tempVar);
    }
    return NULL;
}

/* Emit code to push an index onto the stack and return the type to use for
   compiling the next index.  We do some minimal type checking on the way. */
L_type *
L_compile_index(
/*     L_type *base_type,          /\* The complete type of the object we're */
/*                                    indexing into. *\/ */
    L_type *index_type,         /* The type of the index. */
    L_expression *index)        /* The index expression to compile. */
{
    L_type *t = index_type;

    switch (index->kind) {
    case L_EXPRESSION_STRUCT_INDEX:
        if (index->a->kind == L_EXPRESSION_STRING) {
            /* structure member */
            L_variable_declaration *member;
            int memberOffset;

            if (!(t->kind == L_TYPE_STRUCT)) {
                L_errorf(index, "Not a structure");
                return t;
            }
            for (memberOffset = 0, member = t->members;
                 member && strcmp(member->name->u.s, index->a->u.s);
                 memberOffset++, member = member->next);
            if (!member) {
                L_errorf(index, "Structure field not found, %s", index->a->u.s);
                return t;
            }
            L_PUSH_OBJ(Tcl_NewIntObj(memberOffset));
            t = member->type;
        } else {
            L_bomb("Bad struct index");
        }
        break;
    case L_EXPRESSION_ARRAY_INDEX:
        /* array index */
/*         if (!(array_p(t) || pointer_p(t))) { */
        if (!array_p(t)) {
            L_errorf(index, "Index into something that's not an array");
            return t;
        }
        L_compile_expressions(index->a);
        if (array_p(t->next_dim)) {
            t = t->next_dim;
        } /* else { */
/*             t = base_type; */
/*         } */
        break;
    case L_EXPRESSION_HASH_INDEX:
        L_trace("Spitting out a hash index\n");
        L_compile_expressions(index->a);
        break;
    default:
        L_bomb("Invalid kind of index, %d", index->kind);
    }
    return t;
}

void
L_compile_incdec(L_expression *expr)
{
    L_symbol *var;

    /* XXX note that this implementation doesn't allow us to increment array
       or structure lvalues. --timjr 2006.5.29 */
    if (!(var = L_get_symbol(expr->a, TRUE))) return;
    if (expr->kind == L_EXPRESSION_PRE) {
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
    } else {
        /* we push the value of the variable, do the increment, and then pop
           the result of the increment, leaving the old value on top. */
        L_push_variable(expr);
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
}

/* Output bytecode to invoke main() or main(int argc, string argv[]). */
void
emit_call_to_main(CompileEnv *envPtr, int with_args_p)
{
    /* ugly: mock up lframe->envPtr for the L_PUSH_* macros */
    L_compile_frame dummy_frame, *lframe;
    lframe = &dummy_frame;
    lframe->envPtr = envPtr;

    L_PUSH_STR("main");
    if (!with_args_p) {
        TclEmitInstInt4(INST_INVOKE_STK4, 1, envPtr);
    } else {
        char *argvName = gensym("L_argv");
        /* TCL's argv is missing argv[0], which they've placed in argv0.  We
           stick the two together and pass that to L.  So, first push argc and
           add one to it: */
        L_PUSH_STR("argc");
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        L_PUSH_STR("1");
        TclEmitOpcode(INST_ADD, envPtr);
        /* Use append to stick argv0 and argv together and store them in a new
           variable. */
        L_PUSH_STR("append");
        L_PUSH_STR(argvName);
        L_PUSH_STR("argv0");
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        L_PUSH_STR(" ");
        L_PUSH_STR("argv");
        TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
        /* invoke append */
        TclEmitInstInt4(INST_INVOKE_STK4, 5, envPtr);
/*         TclEmitOpcode(INST_POP, envPtr); */
/*         /\* Create a pointer to that variable and leave it on the stack. *\/ */
/*         L_PUSH_STR("pointer"); */
/*         L_PUSH_STR("new"); */
/*         L_PUSH_STR(argvName); */
/*         L_PUSH_STR("0"); */
/*         TclEmitInstInt4(INST_INVOKE_STK4, 4, envPtr); */
        /* invoke main */
        TclEmitInstInt4(INST_INVOKE_STK4, 3, envPtr);
    }
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(
    L_expression *name,
    L_type *type,
    int localIndex)
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name->u.s, &new);
    if (!new) {
        L_errorf(name, "Duplicate definition of symbol %s", name->u.s);
    }
    symbol->name = name->u.s;
    symbol->type = type;
    symbol->localIndex = localIndex;
    symbol->global_p = FALSE;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
    return (L_symbol*)0;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(L_expression *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name->u.s);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared variable: %s", name->u.s);
        }
        return NULL;
    }
}

/* Stick an & on the front of name and return the result as an L AST node. */
static L_expression *
reference_mangle(char *name) {
    L_expression *node;
    char *mangled_name = ckalloc(strlen(name) + 2);
    sprintf(mangled_name, "&%s", name);
    MK_STRING_NODE(node, mangled_name);
    ckfree(mangled_name);
    return node;
}

/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void
maybeFixupEmptyCode(L_compile_frame *frame)
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        L_PUSH_OBJ(Tcl_NewObj());
    }
}

/* Make a new unique name.  It will be freed when the current AST is freed. */
static char *
gensym(char *name)
{
    L_expression *node;
    char *gensym = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
    sprintf(gensym, "%d%s", gensym_counter++, name);
    /* exploit the property of AST nodes that they'll free the string after
       compilation has finished. */
    MK_STRING_NODE(node, gensym);
    ckfree(gensym);
    return node->u.s;
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        fprintf(stderr, "***: ");
        vfprintf(stderr, format, ap);
        fprintf(stderr, "\n");
    }
    va_end(ap);
    fflush(stderr);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", s, L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", buf,
                 node ? ((L_ast_node *)node)->line_no : -1);
    ckfree(buf);
}

static void 
L_free_ast(L_ast_node *ast) {
    while(ast_trace_root) {
        L_ast_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_EXPRESSION &&
            ((L_expression *)node)->kind == L_EXPRESSION_STRING) {
            ckfree(((L_expression *)node)->u.s);
        }
        ckfree((char *)node);
    }
    ast_trace_root = NULL;
    /* clean up the typedef table too */
    Tcl_DeleteHashTable(__L_typedef_table);
    ckfree((char *)__L_typedef_table);
    __L_typedef_table = NULL;
}

/* Typedefs are handled at "parse time".  When the compiler walks the AST it
   can ignore them, since the types get copied into the AST by the parser. */

/* return the typedef table.  initialize it if it hasn't been initialized
   yet. */
static Tcl_HashTable *L_typedef_table() {
    if (!__L_typedef_table) {
        __L_typedef_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(__L_typedef_table, TCL_STRING_KEYS);
    }
    return __L_typedef_table;
}

L_type *L_lookup_typedef(L_expression *name, int error_p) {
    Tcl_HashEntry *hPtr = NULL;
    hPtr = Tcl_FindHashEntry(L_typedef_table(), name->u.s);
    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared type: %s", name->u.s);
        }
        return NULL;
    }
}

void L_store_typedef(L_expression *name, L_type *type) {
    int new;
    Tcl_HashEntry *hPtr =
        Tcl_CreateHashEntry(L_typedef_table(), name->u.s, &new);
    if (!new) {
        // XXX: emit a redefinition warning?
    }
    Tcl_SetHashValue(hPtr, type);

}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
