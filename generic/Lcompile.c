#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"

static L_compile_frame *lframe = NULL;
static Tcl_HashTable *L_struct_types = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
void *L_current_ast = NULL;
int L_interactive = 0;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_free_ast(L_ast_node *ast);
static int global_symbol_p(L_symbol *symbol);
static Tcl_Obj *create_array_or_struct(L_type *array_type, L_type *base_type);
static Tcl_Obj *create_struct(L_type *type);
static int array_or_struct_p(L_variable_declaration *var);
static L_type *lookup_struct_type(char *tag);


/* we keep track of each AST node we allocate and free them all at once */
L_ast_node *ast_trace_root = NULL;

int 
L_PragmaObjCmd(
    ClientData clientData,
    Tcl_Interp *interp, 
    int objc,
    Tcl_Obj *CONST objv[])
{ 
    int stringLen; 
    char *stringPtr;
    L_ast_node *ast;

    if (objc != 2) {
        L_bomb("Assertion failed in L_PragmaObjCmd: we expected only 1 argument but got %d.",
               objc - 1);
    }
    stringPtr = Tcl_GetStringFromObj(objv [1], &stringLen);
    if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    return LCompileScript(interp, stringPtr, stringLen, NULL, ast);
}

/* Parse an L script into an AST */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer = (void *)L__scan_bytes(str, numBytes);

    L_trace("Parsing: %.*s", numBytes, str);
    L_line_number = 0;
    L_errors = NULL;
    L_parse();
    if (L_ast == NULL) {
        L_free_ast(L_current_ast);
    } else {
        *L_ast = L_current_ast;
    }
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.");
            return TCL_ERROR;
    }
    L_trace("Done parsing.");
    return TCL_OK;
}


/* Compile an AST into Tcl ByteCodes */
int
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr,
    void *ast)
{
    L_trace("Compiling: \n %.*s", numBytes, str);

    L_frame_push(interp, envPtr);
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;

    switch(((L_ast_node*)ast)->type) {
    case L_NODE_TOPLEVEL_STATEMENT:
        L_compile_toplevel_statements(ast);
        break;
    default:
        L_bomb("LCompileScript error, expecting a toplevel statement, "
               "got: %s", L_node_type_tostr[((L_ast_node*)ast)->type]);
    }
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();

    L_free_ast(ast);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to compile.");
            return TCL_ERROR;
    }
    L_trace("Done compiling");
    return TCL_OK;
}

void
L_compile_toplevel_statements(L_toplevel_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_TOPLEVEL_STATEMENT_FUNCTION_DECLARATION:
        L_compile_function_decl(stmt->u.fun);
        break;
    case L_TOPLEVEL_STATEMENT_TYPE:
        L_compile_struct_decl(stmt->u.type);
        break;
    default:
        L_bomb("Unexpected toplevel statement type %d", stmt->kind);
    }
    L_compile_toplevel_statements(stmt->next);
}

void
L_compile_function_decl(L_function_declaration *fun)
{
    Proc *procPtr;
    CompileEnv *envPtr;
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    if (!fun) return;
    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr);

    procPtr = (Proc *)ckalloc(sizeof(Proc));
    procPtr->iPtr = (struct Interp *)lframe->interp;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;

    TclInitCompileEnv(lframe->interp, envPtr, "L Compiler",
                      strlen("L Compiler"));
    lframe->originalCodeNext = envPtr->codeNext;
    envPtr->procPtr = procPtr;

    L_compile_parameters(fun->params);
    L_compile_block(fun->body);
    
    /* This is the "fall off the end" implicit return. We return "". */
    L_return(FALSE);

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, fun->name->u.s,
        TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;


    TclFreeCompileEnv(lframe->envPtr);
    ckfree((char *)lframe->envPtr);
    L_frame_pop();
}

void
L_compile_struct_decl(L_type *decl)
{
    Tcl_HashEntry *hPtr;
    int freshp;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    if (!decl->struct_tag ||
        !(decl->struct_tag->kind == L_EXPRESSION_STRING)) {
        L_errorf(decl, "Untagged struct types are not supported yet");
        return;
    }
    hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.s, &freshp);
    Tcl_SetHashValue(hPtr, decl);
    L_trace("Declared struct type %s", decl->struct_tag->u.s);
}

/* Initialize the struct types table and lookup a type in it.  Returns the
   type, or NULL if none was found.  */
L_type *
lookup_struct_type(char *tag)
{
    Tcl_HashEntry *hPtr = NULL;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    hPtr = Tcl_FindHashEntry(L_struct_types, tag);

    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}

void 
L_compile_variable_decls(L_variable_declaration *var)
{
    L_symbol *symbol;
    int localIndex;

    if (!var) return;
    L_trace("declaring variable %s", var->name->u.s);
    localIndex = TclFindCompiledLocal(var->name->u.s, strlen(var->name->u.s),
                                      1, 0, lframe->envPtr->procPtr);
    if ((symbol = L_get_symbol(var->name, FALSE)) &&
        !global_symbol_p(symbol))
    {
        L_errorf(var, "Illegal redeclaration of local variable %s",
                 var->name->u.s);
    }
    symbol = L_make_symbol(var->name, var->type, localIndex);
    if (array_or_struct_p(var)) {
        Tcl_Obj *initial_value =
            create_array_or_struct(var->type->next_dim, var->type);
        /* We don't support literal initializers for structs and arrays yet.
           Just always initialize to a blank TCL list. */
        if (initial_value) {
            TclEmitPush(TclAddLiteralObj(lframe->envPtr, initial_value, NULL),
                        lframe->envPtr);
            L_STORE_SCALAR(localIndex);
            TclEmitOpcode(INST_POP, lframe->envPtr);
        }
    } else if (var->initial_value) {
        L_compile_expressions(var->initial_value);
        L_STORE_SCALAR(localIndex);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    L_compile_variable_decls(var->next);
}

/* Variables of array or struct types will be initialized to TCL lists of the
   appropriate size.  Here we interpret a declaration's type and instantiate
   it.  We check the declaration's semantics while interpreting it. */
Tcl_Obj *
create_array_or_struct(L_type *array_type, L_type *base_type)
{
    Tcl_Obj *val = NULL;
    int i;

    if (array_type) {
        if (!(array_type->array_dim->kind == L_EXPRESSION_INT)) {
            L_errorf(array_type, "Invalid array dimension for a declaration, %s",
                     L_expression_tostr[array_type->array_dim->kind]);
            return NULL;
        }
        if (array_type->array_dim->u.i < 0) {
            L_errorf(array_type, "Negative array dimension: %d",
                     array_type->array_dim->u.i);
            return NULL;
        }
        /* initialize the array */
        val = Tcl_NewListObj(0, NULL);
        for (i = 0; i < array_type->array_dim->u.i; i++) {
            /* the array is multi-dimensional, so initialize it with
               sub-arrays  */
            Tcl_Obj *el = create_array_or_struct(array_type->next_dim, base_type);
            if (!el) return NULL;
            Tcl_ListObjAppendElement(NULL, val, el);
        }
    } else if (base_type->kind == L_TYPE_STRUCT) {
        val = create_struct(base_type);
    } else {
        return Tcl_NewObj();
    }
    return val;
}

Tcl_Obj *
create_struct(L_type *type)
{
    Tcl_Obj *val = NULL;
    Tcl_Obj *nullobj = Tcl_NewObj();
    int i;
    L_type *struct_type = type;
    L_variable_declaration *member;

    /* if we have a struct tag without the struct definition, lookup the
       definition. */
    if (!struct_type->members) {
        if (!struct_type->struct_tag) {
            L_bomb("Assertion failed: a struct must either have a tag or "
                   "members");
        }
        struct_type = lookup_struct_type(struct_type->struct_tag->u.s);
        if (!struct_type) {
            L_errorf(type, "Undefined structure type: %s",
                     struct_type->struct_tag->u.s);
            return NULL;
        }
        /* Fixup the original type so that it also has the member
           information.  This allows all the other code to skip the
           lookup. */
        type->members = struct_type->members;
    }
    val = Tcl_NewListObj(0, NULL);
    /* initialize the struct fields */
    for (member = type->members; member; member = member->next, i++) {
        Tcl_Obj *el =
            create_array_or_struct(member->type->next_dim, member->type);
        if (!el) return NULL;
        Tcl_ListObjAppendElement(NULL, val, el);
    }
    return val;
}

int
array_or_struct_p(L_variable_declaration *var)
{
    if (var->type->next_dim || (var->type->kind == L_TYPE_STRUCT)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


int
global_symbol_p(L_symbol *symbol)
{
    /* XXX implement me once we have globals.  --timjr 2006.5.7 */
    return FALSE;
}

void
L_compile_statements(L_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_STATEMENT_BLOCK:
        L_compile_block(stmt->u.block);
        break;
    case L_STATEMENT_EXPR:
        L_compile_expressions(stmt->u.expr);
        /* Expressions leave a value on the evaluation stack, but statements
           don't. So pop the value. */
        TclEmitOpcode(INST_POP, lframe->envPtr);
        break;
    case L_STATEMENT_IF_UNLESS:
        L_compile_if_unless(stmt->u.cond);
        break;
    case L_STATEMENT_LOOP:
        L_compile_loop(stmt->u.loop);
        break;
    case L_STATEMENT_RETURN:
        L_trace("compiling return statement");
        if (stmt->u.expr) {
            L_trace("    with return value");
            /* compile the return value */
            L_compile_expressions(stmt->u.expr);
        } else {
            L_trace("    without return value");
            /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
            TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                         lframe->envPtr );
        }
        /* INST_RETURN_STK involves a little more magic that I haven't wangled out
           yet... but I think it lets us pass back error codes and such that could
           be useful. --timjr 2006.3.31  */
        /* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
        TclEmitOpcode(INST_DONE, lframe->envPtr);
        break;
    }
    L_compile_statements(stmt->next);
}

void
L_compile_block(L_block *block) {
    L_compile_variable_decls(block->decls);
    L_compile_statements(block->body);
}

void 
L_compile_parameters(L_variable_declaration *param)
{
    Proc *procPtr = lframe->envPtr->procPtr;
    CompiledLocal *localPtr;
    int i;
    
    for (i = 0; param; param = param->next, i++) {
        L_trace("Compiling parameter %d (%s)", i, param->name->u.s);
        /* Formal parameters are stored in local variable slots. */
        procPtr->numArgs = i + 1;
        procPtr->numCompiledLocals = i + 1;
        localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
                                             sizeof(localPtr->name) +
                                             strlen(param->name->u.s) + 1);
        if (procPtr->firstLocalPtr == NULL) {
            procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr;
        } else {
            procPtr->lastLocalPtr->nextPtr = localPtr;
            procPtr->lastLocalPtr = localPtr;
        }
        localPtr->nextPtr = NULL;
        localPtr->nameLength = strlen(param->name->u.s);
        localPtr->frameIndex = i;
        localPtr->flags = VAR_SCALAR | VAR_ARGUMENT;
        localPtr->resolveInfo = NULL;
        localPtr->defValuePtr = NULL;
        strcpy(localPtr->name, param->name->u.s);
        
        L_make_symbol(param->name, param->type, i);
    }
}

void 
L_compile_expressions(L_expression *expr)
{
    Tcl_Obj *obj;
    int i = 0;
    L_expression *tmp;

    if (!expr) return;
/*     L_trace("Compiling an expression of type %s", */
/*             L_expression_tostr[expr->kind]); */
    switch (expr->kind) {
    case L_EXPRESSION_FUNCALL:
        TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, expr->a->u.s,
                                          strlen(expr->a->u.s)),
                    lframe->envPtr);
        L_compile_expressions(expr->b);
        /* count the parameters */
        for (tmp = expr->b; tmp; tmp = tmp->next, i++);
        TclEmitInstInt4(INST_INVOKE_STK4, i+1, lframe->envPtr);
        break;
    case L_EXPRESSION_PRE:
    case L_EXPRESSION_POST:
        L_compile_incdec(expr);
        break;
    case L_EXPRESSION_UNARY:
        L_compile_unop(expr);
        break;
    case L_EXPRESSION_BINARY:
        L_compile_binop(expr);
        break;
    case L_EXPRESSION_INT:
        obj = Tcl_NewIntObj(expr->u.i);
        TclEmitPush(TclAddLiteralObj(lframe->envPtr, obj, NULL),
                    lframe->envPtr);
        break;
    case L_EXPRESSION_STRING:
        obj = Tcl_NewStringObj(expr->u.s, strlen(expr->u.s));
        TclEmitPush(TclAddLiteralObj(lframe->envPtr, obj, NULL),
                    lframe->envPtr);
        break;
    case L_EXPRESSION_DOUBLE:
        obj = Tcl_NewDoubleObj(expr->u.d);
        TclEmitPush(TclAddLiteralObj(lframe->envPtr, obj, NULL),
                    lframe->envPtr);
        break;
    case L_EXPRESSION_VARIABLE:
        L_push_variable(expr);
        break;
    default:
        L_bomb("Unknown expression type %d", expr->kind);
    }
    L_compile_expressions(expr->next);
}

void L_compile_unop(L_expression *expr)
{
    L_compile_expressions(expr->a);
    switch (expr->op) {
    case T_BANG:
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
        break;
    case T_BITNOT:
        TclEmitOpcode(INST_BITNOT, lframe->envPtr);
        break;
    case T_PLUS:
        TclEmitOpcode(INST_UPLUS, lframe->envPtr);
        break;
    case T_MINUS:
        TclEmitOpcode(INST_UMINUS, lframe->envPtr);
        break;
    default:
        L_bomb("Unknown unary operator %d", expr->op);
    }
}

void L_compile_binop(L_expression *expr)
{
    int instruction = 0;

    if (expr->op == T_EQUALS) {
        L_compile_assignment(expr);
    } else if ((expr->op == T_ANDAND) ||
               (expr->op == T_OROR)) {
        L_compile_short_circuit_op(expr);
    } else {
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        switch (expr->op) {
        case T_PLUS:
            instruction = INST_ADD;
            break;
        case T_MINUS:
            instruction = INST_SUB;
            break;
        case T_STAR:
            instruction = INST_MULT;
            break;
        case T_SLASH:
            instruction = INST_DIV;
            break;
        case T_PERC:
            instruction = INST_MOD;
            break;
        case T_EQ:
        case T_EQUALEQUAL:
            instruction = INST_EQ;
            break;
        case T_NE:
        case T_NOTEQUAL:
            instruction = INST_NEQ;
            break;
        case T_GT:
        case T_GREATER:
            instruction = INST_GT;
            break;
        case T_GE:
        case T_GREATEREQ:
            instruction = INST_GE;
            break;
        case T_LT:
        case T_LESSTHAN:
            instruction = INST_LT;
            break;
        case T_LE:
        case T_LESSTHANEQ:
            instruction = INST_LE;
            break;
        case T_LSHIFT:
            instruction = INST_LSHIFT;
            break;
        case T_RSHIFT:
            instruction = INST_RSHIFT;
            break;
        case T_BITOR:
            instruction = INST_BITOR;
            break;
        case T_BITXOR:
            instruction = INST_BITXOR;
            break;
        case T_BITAND:
            instruction = INST_BITAND;
            break;
        default:
            L_bomb("Undefined operator %d", expr->op);
        }
        TclEmitOpcode(instruction, lframe->envPtr);
    }
}

void
L_compile_short_circuit_op(L_expression *expr)
{
    JumpFixup fixup;

    L_compile_expressions(expr->a);
    /* In case the operator short-circuits, we need one value on the
       evaluation stack for the jump and one for the value of the
       expression. */
    TclEmitOpcode(INST_DUP, lframe->envPtr);
    if (expr->op == T_ANDAND) {
        TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &fixup);
    } else {
        TclEmitForwardJump(lframe->envPtr, TCL_TRUE_JUMP, &fixup);
    }
    /* If the operator doesn't short-circuit, we want to leave the value of
       the second expression on the stack, so remove the value that we DUPed
       above. */
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_compile_expressions(expr->b);
    TclFixupForwardJumpToHere(lframe->envPtr, &fixup, 127);
}

void
L_compile_if_unless(L_if_unless *cond)
{
    JumpFixup jumpFalse, jumpEnd;

    L_compile_expressions(cond->condition);
    /* emit a jump which will skip the consequent if the top value on the
       stack is false. */
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &jumpFalse);

    L_frame_push(lframe->interp, lframe->envPtr);
    /* consequent */
    if (cond->if_body != NULL) {
        L_compile_statements(cond->if_body);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
    }
    /* alternate */
    if (cond->else_body != NULL) {
        /* End the scope that was started for the consequent and start a new
           one, copying the jump fixup pointers. */
        L_frame_pop();
        L_frame_push(lframe->interp, lframe->envPtr);
        TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpEnd);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
        L_compile_statements(cond->else_body);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpEnd, 127);

    } else {
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
    }
    L_frame_pop();
}

void
L_compile_loop(L_loop *loop)
{
    JumpFixup jumpToCond;
    int bodyCodeOffset, jumpDist;

    TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpToCond);
    L_frame_push(lframe->interp, lframe->envPtr);
    bodyCodeOffset = lframe->envPtr->codeNext - lframe->envPtr->codeStart;
    L_compile_statements(loop->body);
    L_frame_pop(lframe->interp, lframe->envPtr);
    if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpToCond, 127)) {
        bodyCodeOffset += 3;
    }
    L_compile_expressions(loop->condition);
    jumpDist = lframe->envPtr->codeNext - lframe->envPtr->codeStart -
        bodyCodeOffset;
    if (jumpDist > 127) {
        TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
    } else {
        TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
    }
}

void
L_push_variable(L_expression *expr)
{
    L_symbol *var;
    L_expression *name = expr->a;

    if (!(var = L_get_symbol(name, TRUE))) return;
    L_LOAD_SCALAR(var->localIndex);
    if (expr->indices) {
        int index_count = L_compile_indices(var->type, expr->indices);
/*         for (i = expr->indices; i; i = i->indices, index_count++) { */
/*             L_compile_expressions(i->a); */
/*         } */
/*         L_trace("INDICES: %d\n", index_count); */

        if (index_count == 1) {
            TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
        } else {
            TclEmitInstInt4(INST_LIST_INDEX_MULTI, index_count + 1,
                            lframe->envPtr);
        }
    }
}

void 
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                     lframe->envPtr);
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

void
L_compile_assignment(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a;
    L_expression *rval = expr->b;

    L_trace("COMPILING ASSIGNMENT: %s, %s", L_expression_tostr[lval->a->kind],
            lval->a->u.s);
    if (!(var = L_get_symbol(lval->a, TRUE))) return;
    if (lval->indices) {
        int index_count = L_compile_indices(var->type, lval->indices);
        L_compile_expressions(rval);
        L_LOAD_SCALAR(var->localIndex);
        if (index_count == 1) {
            TclEmitOpcode(INST_LSET_LIST, lframe->envPtr);
        } else {
            TclEmitInstInt4(INST_LSET_FLAT, index_count + 2, lframe->envPtr);
        }
        /* store the modified array back in the variable */
        L_STORE_SCALAR(var->localIndex);
    } else {
        /* no array indices */
        L_compile_expressions(rval);
        L_STORE_SCALAR(var->localIndex);
    }
}

/* Push the indices of an array or struct on the stack.  Returns the count of
   indices that were pushed.  */
int
L_compile_indices(L_type *type, L_expression *indices)
{
    /* we have array indices */
    int index_count = 0;
    L_type *base_type = type;
    L_type *t = type;
    L_expression *i;
    for (i = indices; i; i = i->indices, index_count++) {
        if (i->a->kind == L_EXPRESSION_STRING) {
            /* structure member */
            L_variable_declaration *member;
            int memberOffset;

            if (!t->kind == L_TYPE_STRUCT) {
                L_errorf(i, "Not a structure");
                return index_count;
            }
            for (memberOffset = 0, member = t->members;
                 member && strcmp(member->name->u.s, i->a->u.s);
                 memberOffset++, member = member->next);
            if (!member) {
                L_errorf(i, "Structure field not found, %s", i->a->u.s);
                return index_count;
            }
            TclEmitPush(TclAddLiteralObj(lframe->envPtr,
                                         Tcl_NewIntObj(memberOffset),
                                         NULL),
                        lframe->envPtr);
            t = member->type;
        } else {
            /* array index */
            if (!t->next_dim) {
                L_errorf(i, "Index into something that's not an array");
                return index_count;
            }
            L_compile_expressions(i->a);
            if (t->next_dim->next_dim) {
                t = t->next_dim;
            } else {
                t = base_type;
            }
        }
    }
    return index_count;
}

void
L_compile_incdec(L_expression *expr)
{
    L_symbol *var;

    /* XXX note that this implementation doesn't allow us to increment array
       or structure lvalues. --timjr 2006.5.29 */
    if (!(var = L_get_symbol(expr->a, TRUE))) return;
    if (expr->kind == L_EXPRESSION_PRE) {
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
    } else {
        /* we push the value of the variable, do the increment, and then pop
           the result of the increment, leaving the old value on top. */
        L_push_variable(expr);
        TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                        lframe->envPtr);
        TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(
    L_expression *name,
    L_type *type,
    int localIndex)
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name->u.s, &new);
    if (!new) {
        L_errorf(name, "Duplicate definition of symbol %s", name->u.s);
    }
    symbol->name = name->u.s;
    symbol->type = type;
    symbol->localIndex = localIndex;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
    return (L_symbol*)0;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(L_expression *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name->u.s);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared variable: %s", name->u.s);
        }
        return NULL;
    }
}


/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void
maybeFixupEmptyCode(L_compile_frame *frame)
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        TclEmitPush( TclAddLiteralObj(frame->envPtr, Tcl_NewObj(), NULL),
            frame->envPtr);
    }
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        fprintf(stderr, "***: ");
        vfprintf(stderr, format, ap);
        fprintf(stderr, "\n");
    }
    va_end(ap);
    fflush(stderr);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", s, L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", buf,
                 node ? ((L_ast_node *)node)->line_no : -1);
    ckfree(buf);
}

static void 
L_free_ast(L_ast_node *ast) {
    while(ast_trace_root) {
        L_ast_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_EXPRESSION &&
            ((L_expression *)node)->kind == L_EXPRESSION_STRING) {
            ckfree(((L_expression *)node)->u.s);
        }
        ckfree((char *)node);
    }
    ast_trace_root = NULL;
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */


