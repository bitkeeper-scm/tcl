#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "Lcompile.h"

static L_compile_frame *lframe = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_dump_ast_nodes(L_node *node);
/* we keep track of each AST node we allocate and free them all at once */
static L_node *ast_trace_root = NULL;
static void L_free_ast();

int 
L_PragmaObjCmd(
    ClientData clientData,
    Tcl_Interp *interp, 
    int objc,
    Tcl_Obj *CONST objv[])
{ 
    int stringLen; 
    char *stringPtr;

    if (objc != 2) {
        L_bomb("Assertion failed in L_PragmaObjCmd: we expected only 1 argument but got %d.",
               objc - 1);
    }
    stringPtr = Tcl_GetStringFromObj(objv [1], &stringLen);
    return LCompileScript(interp, stringPtr, stringLen, NULL);
}

/* LCompileScript() is the main entry point into the land of L. */
int
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr)
{
    void    *lex_buffer = (void *)L__scan_bytes(str, numBytes);

    L_trace("Beginning L Compilation\n");
    L_line_number = 0;
    L_errors = NULL;
    L_frame_push(interp, envPtr);
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;
    L_parse();
    L__delete_buffer(lex_buffer);
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();
    L_free_ast();
    /* In case there were any errors, store them in interp and return
       TCL_ERROR. */
    if (L_errors) {
        Tcl_SetObjResult(interp, L_errors);
        return TCL_ERROR;
    }
    return TCL_OK;
}

/**
 * These next functions are the bulk of the parser's semantic actions.
 * Right now they attempt to compile straight to bytecode.  We may
 * want to first generate an AST so we can chew on it a little harder,
 * and don't have to mess with global variables.
 */

void 
L_begin_function_decl(L_node *name) 
{
    Interp *iPtr = (Interp *)lframe->interp;
    Proc *procPtr;
    CompileEnv *envPtr;

    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr);

    procPtr = (Proc *) ckalloc(sizeof(Proc));
    procPtr->iPtr = iPtr;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;

    TclInitCompileEnv(lframe->interp, envPtr, "L Compiler", 
                      strlen("L Compiler"));
    lframe->originalCodeNext = envPtr->codeNext;
/*     TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL), */
/*                  lframe->envPtr); */

    envPtr->procPtr = procPtr;
}

void 
L_end_function_decl(L_node *name) 
{
    Tcl_Obj *bodyObjPtr;
    Proc *procPtr = lframe->envPtr->procPtr;
    Tcl_Command cmd;

    TclEmitOpcode(INST_DONE, lframe->envPtr);

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, name->v.s,
        TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;


    TclFreeCompileEnv(lframe->envPtr);
    ckfree(lframe->envPtr);
    L_frame_pop();
}


void 
L_begin_function_call(L_node *name) 
{
    TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, name->v.s, 
                                      strlen(name->v.s)), 
                lframe->envPtr);
}

void 
L_end_function_call(L_node *name, int param_count) 
{
    TclEmitInstInt4(INST_INVOKE_STK4, param_count+1, lframe->envPtr);
}


#define JUMP_IF_FALSE_INDEX 0
#define JUMP_IF_END_INDEX 1

void 
L_if_condition() 
{
/*     int jumpIndex; */
    JumpFixupArray *jumpFalsePtr;

    jumpFalsePtr = (JumpFixupArray *)ckalloc(sizeof(JumpFixupArray));
    /* save the fixup array in a compile frame so that we can do the fixups at
       the end of this if statement. */
    L_frame_push(lframe->interp, lframe->envPtr);
    lframe->jumpFalseFixupArrayPtr = jumpFalsePtr;

    TclInitJumpFixupArray(jumpFalsePtr);
    /* allocate space for two jump fixups, one for the skipping the consequent
       and one for skipping the alternate. */
/*     if ((jumpFalsePtr->next + 2) >= jumpFalsePtr->end) { */
    if (2 >= jumpFalsePtr->end) {
        TclExpandJumpFixupArray(jumpFalsePtr);
    }
/*     jumpIndex = jumpFalsePtr->next; */
/*     jumpFalsePtr->next++; */
    jumpFalsePtr->next += 2;
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, 
                       jumpFalsePtr->fixup + JUMP_IF_FALSE_INDEX);
}

void 
L_if_statements_end(int finalBlock) 
{
    if (finalBlock) {
        TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP,
                           lframe->jumpFalseFixupArrayPtr->fixup + JUMP_IF_END_INDEX);
        
        

/*     fprintf(stderr, "fixing up false jump\n"); */
        if (TclFixupForwardJumpToHere(lframe->envPtr,
                                      lframe->jumpFalseFixupArrayPtr->fixup + JUMP_IF_FALSE_INDEX,
                                      127))
            {
            }
    }
    /* if we're ending the final block of the if, there's no else clause to
       jump over. */ 
        
/*         TclFreeJumpFixupArray(lframe->jumpFalseFixupArrayPtr); */
/*         ckfree(lframe->jumpFalseFixupArrayPtr); */
/*         L_frame_pop(); */
/*     } */
}

void 
L_if_end(int elseClause) 
{
/*     fprintf(stderr, "also fixing up false jump\n"); */
    if (elseClause) {
        TclFixupForwardJumpToHere(lframe->envPtr,
                                  /* this should actually be more like:
                                     lframe->jumpFalseFixupArrayPtr->fixup+jumpIndex,  */
                                  lframe->jumpFalseFixupArrayPtr->fixup + JUMP_IF_END_INDEX,
                                  127);
    } else {
        TclFixupForwardJumpToHere(lframe->envPtr,
                                  /* this should actually be more like:
                                     lframe->jumpFalseFixupArrayPtr->fixup+jumpIndex,  */
                                  lframe->jumpFalseFixupArrayPtr->fixup + JUMP_IF_FALSE_INDEX,
                                  127);
    }


    TclFreeJumpFixupArray(lframe->jumpFalseFixupArrayPtr);
    ckfree((char *)lframe->jumpFalseFixupArrayPtr);
    L_frame_pop();
}

void
L_push_str(L_node *str)
{
    TclEmitPush(TclRegisterNewNSLiteral(lframe->envPtr, 
                                        str->v.s, strlen(str->v.s)), 
                lframe->envPtr);
}

void
L_push_int(L_node *i)
{
    TclEmitPush(TclAddLiteralObj(lframe->envPtr, 
                                 Tcl_NewIntObj(i->v.i), NULL), 
                lframe->envPtr);
}

void
L_push_id(L_node *id)
{
    int localIndex;
    if (!L_get_symbol(id->v.s)) {
        L_errorf("Undeclared variable: %s", id->v.s);
    }

    localIndex = TclFindCompiledLocal(id->v.s, strlen(id->v.s),
                                      0, 0, lframe->envPtr->procPtr);
    if (localIndex <= 255) {
        TclEmitInstInt1(INST_LOAD_SCALAR1, localIndex, lframe->envPtr);
    } else {
        TclEmitInstInt4(INST_LOAD_SCALAR4, localIndex, lframe->envPtr);
    }
}

void
L_assignment(L_node *lvalue)
{
    int localIndex;

    if (!L_get_symbol(lvalue->v.s)) {
        L_errorf("Undeclared variable: %s", lvalue->v.s);
    }
    /* TclRegisterNewNSLiteral is what we'll need for global vars, I think */
/*     localIndex = TclRegisterNewNSLiteral(lframe->envPtr, lvalue->v.s,  */
/*                                          strlen(lvalue->v.s)); */
    localIndex = TclFindCompiledLocal(lvalue->v.s, strlen(lvalue->v.s), 
                                      0, 0, lframe->envPtr->procPtr);
/*     localIndex = TclFindCompiledLocal(lvalue->v.s, strlen(lvalue->v.s),  */
/*                                       1, 0, lframe->envPtr->procPtr); */
    if (localIndex <= 255) {
        TclEmitInstInt1(INST_STORE_SCALAR1, localIndex, lframe->envPtr);
    } else {
        TclEmitInstInt4(INST_STORE_SCALAR4, localIndex, lframe->envPtr);
    }
}

void 
L_declare_variable(L_node *name, int base_type, int initialize_p)
{
    L_symbol *symbol;
    L_node *array_type = NULL;
    int localIndex;

    /* If the name consists of more than one element, the variable is an
       array.  Separate the name from the array type info prior to creating
       the symbol.  */
    if (name->next) {
        L_node *tmp = name;
        array_type = name;
        
        while (tmp->next && tmp->next->next) {
            tmp = tmp->next;
        }
        name = tmp->next;
        tmp->next = LNIL;
    }
    symbol = L_make_symbol(name->v.s, base_type, array_type);
/*     localIndex = TclRegisterNewNSLiteral(lframe->envPtr, name->v.s,  */
/*                                          strlen(name->v.s)); */
    localIndex = TclFindCompiledLocal(name->v.s, strlen(name->v.s), 
                                      1, 0, lframe->envPtr->procPtr);
    if (initialize_p) {
        /* initialize the variable */
        if (localIndex <= 255) {
            TclEmitInstInt1(INST_STORE_SCALAR1, localIndex, lframe->envPtr);
        } else {
            TclEmitInstInt4(INST_STORE_SCALAR4, localIndex, lframe->envPtr);
        }
    }
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(char *name, int base_type, L_node *array_type) 
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name, &new);
    if (!new) {
        L_errorf("Duplicate definition of symbol %s", name);
    }
    symbol->name = name;
    symbol->base_type = base_type;
    symbol->array_type = array_type;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
}

/* Look up a symbol in the current symbol table, return NULL if not found */
L_symbol *
L_get_symbol(char *name) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}


/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void 
maybeFixupEmptyCode(L_compile_frame *frame) 
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        TclEmitPush( TclAddLiteralObj(frame->envPtr, Tcl_NewObj(), NULL),
            frame->envPtr);
    }
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        vfprintf(stderr, format, ap);
    }
    va_end(ap);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", s, L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    L_error(buf);
    ckfree(buf);
}


/* Create an AST node.  If the value is a string, it will be copied. */
L_node *
L_make_node(L_node_type type, L_node *next, ...)
{
    va_list ap;
    
    va_start(ap, next);
    L_node *nodePtr = (L_node *)ckalloc(sizeof(L_node));
    nodePtr->type = type;
    nodePtr->next = next;
    switch (type) {
    case L_NODE_INT:
        nodePtr->v.i = va_arg(ap, int);
        break;
    case L_NODE_FLOAT:
        nodePtr->v.f = va_arg(ap, double);
        break;
    case L_NODE_STRING: {
        char *s = va_arg(ap, char *);
        nodePtr->v.s = ckalloc(strlen(s)+1);
        strcpy(nodePtr->v.s, s);
        break;
    }
    case L_NODE_SYMBOL:
        nodePtr->v.sym = va_arg(ap, L_symbol *);
        break;
    case L_NODE_NODE:
        nodePtr->v.child = va_arg(ap, L_node *);
        break;
    default:
        L_bomb("AST node type error: %d", type);
    }
    nodePtr->_trace = ast_trace_root;
    ast_trace_root = nodePtr;
    return nodePtr;
}


/* Print an AST on stdout.  The AST nodes are listed in parentheses. Each
   interior node (node of type L_NODE_NODE) adds a new nesting level. */
void
L_dump_ast(L_node *ast)
{
    L_trace("AST: (");
    L_dump_ast_nodes(ast);
    L_trace(")\n");
}

/* Auxiliary of L_dump_ast */
static void
L_dump_ast_nodes(L_node *node) 
{
    switch(node->type) {
    case L_NODE_INT:
        L_trace("%d", node->v.i);
        break;
    case L_NODE_FLOAT:
        L_trace("%f", node->v.f);
        break;
    case L_NODE_STRING:
        L_trace("%s", node->v.s);
        break;
    case L_NODE_SYMBOL:
        L_trace(":%s", node->v.sym->name);
        break;
    case L_NODE_NODE:
        L_trace("(");
        L_dump_ast_nodes(node->v.child);
        L_trace(")");
        break;
    default:
        L_bomb("AST node type error: %d", node->type);
    }
    if (node->next) {
        L_trace(" ");
        L_dump_ast_nodes(node->next);
    }
}

static void 
L_free_ast() {
    while(ast_trace_root) {
        L_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_STRING) {
            ckfree(node->v.s);
        }
        ckfree(node);
    }
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */


