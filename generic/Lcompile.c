#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"


/* Grab the offset of the next instruction to be issued.  Stolen from
   tclCompCmds.c. */
#define CurrentOffset(envPtr) \
    ((envPtr)->codeNext - (envPtr)->codeStart)


static L_compile_frame *lframe = NULL;
static Tcl_HashTable *L_struct_types = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
void *L_current_ast = NULL;
int L_interactive = 0;

/* The source of the script that we're compiling. */
static char *L_script = NULL;
static int L_scriptLen = 0;

/* The token offset is the number of bytes between the beginning of the input
 * string and the beginning of a token.  It's tracked by the lexer, but we
 * declare it here so that it can be reset before lexing begins. */
int L_token_offset = 0;
int L_prev_token_len = 0;


static int gensym_counter = 0;  /* used to create unique names */

/* The table we store typedef information in.  Use L_typedef_table() to access
   it. */
Tcl_HashTable *__L_typedef_table = NULL;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_free_ast(L_ast_node *ast);
static int global_symbol_p(L_symbol *symbol);
static void fixup_struct_type(L_type *type);
static int auto_extending_array_p(L_type *t);
static L_type *lookup_struct_type(char *tag);
static L_expression *L_read_array_index_chunk(int varIndex, L_expression *i,
                                              L_type **type,
                                              L_type *base_type);
static L_expression *L_read_hash_index_chunk(L_expression *i);
static L_expression *L_read_struct_index_chunk(L_expression *index,
                                               L_type **type);
static Tcl_Obj *literal_to_TclObj(L_expression *expr);
static Tcl_Obj *atomic_initial_value(L_type *type);
static L_symbol *import_global_symbol(L_symbol *var);
static void emit_upvar(L_symbol *var, char *upvarName);
static char *gensym(char *name);
static int store_in_tempvar(int pop_p);
static void L_write_index(L_symbol *var, L_expression *index,
  L_expression *expr, L_expression *rval, int post_incr_p);
static void L_write_index_aux(L_expression *index, L_type *type,
  L_expression *expr, int rvalVar, int post_incr_p);
static Tcl_HashTable *L_typedef_table();
static L_expression *reference_mangle(char *name);
static int type_passed_by_name_p(L_type *type);
static L_symbol *L_get_local_symbol(L_expression *name, int error_p);
static void compile_initializer(L_initializer *init, L_type *type);
static void compile_blank_initializer(L_type *type);
static char *blank_initializer_code(L_type *type, int *needs_eval);
static int LDumpAstNodes(L_ast_node *node, void *data, int order);
static int push_parameters(char *funcname, L_expression *parameters);
static void L_push_pointer(L_expression *lval);
static L_compile_frame *enclosing_loop_frame();
static void fixup_jumps(CompileEnv *envPtr, JumpOffsetList *jumps,
			int targetOffset);
static Proc *Begin_Proc();
static void Finish_Proc(Proc *procPtr, char *name);
static int instruction_for_l_op(int op);
static void regsub_for_assignment(int lvalIndex, int rvalIndex,
  int compile_rval_p, L_expression *expr);
static void track_lineInfo(int codeOffset, int srcOffset, int len);

/* we keep track of each AST node we allocate and free them all at once */
L_ast_node *ast_trace_root = NULL;

/* If TCL encounters an lang(L) directive while evaluating code directly,
 * e.g., from an upvar, it will enter the L compiler via L_LObjCmd(). */
int
Tcl_LObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])
{
    int stringLen;
    char *stringPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via Tcl_LObjCmd");
    if (objc != 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "l-program");
	return TCL_ERROR;
    }
    stringPtr = Tcl_GetStringFromObj(objv [1], &stringLen);
    if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    if (ast == NULL) return TCL_OK;	/* empty script */
    return LCompileScript(interp, stringPtr, stringLen, NULL, ast);
}

/* If TCL encounters an L pragma while compiling TCL code, for example when
   processing an entire file in TclCompileScript(), it will enter L via
   TclCompileLCmd().  In that case, we get a pointer to the toplevel
   compilation environment, so we have the option of emitting global code.

   If there is an error during L compilation, we return TCL_ERROR.  However,
   the error only causes TCL to defer evaluation of the L pragma until
   runtime, at which point Tcl_LObjCmd() will recompile the L code and hit
   the same error.  */
int
TclCompileLCmd(
    Tcl_Interp *interp,
    Tcl_Parse *parsePtr,
    CompileEnv *envPtr)
{
    Tcl_Token *lTokenPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via TclCompileLCmd");
    if (parsePtr->numWords != 2) {

/*         L_bomb("Assertion failed in TclCompileLCmd: we expected 2 " */
/*                "words but got %d.", parsePtr->numWords); */

	return TCL_ERROR;
    }
    // advance to the second token
    lTokenPtr = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
    // the first component of the second token contains the code
    if (LParseScript(interp, lTokenPtr[1].start,
                     lTokenPtr[1].size, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    if (ast == NULL) {
	/* empty script, which is fine, but Tcl expects us to leave a value on
           the stack. */
        L_trace("empty script");
        L_frame_push(interp, envPtr, NULL);
        L_PUSH_OBJ(Tcl_NewObj());
        L_frame_pop();
	return TCL_OK;
    }
    return LCompileScript(interp, lTokenPtr[1].start, lTokenPtr[1].size,
	      envPtr, ast);
}

/* Parse an L script into an AST.  Parsing and compiling are broken into two
   stages in order to support an interactive mode that parses many times
   before finally compiling.  */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer;

    L_line_number = 1;
    L_token_offset = L_prev_token_len = 0;
    L_script = (char *)str;
    L_scriptLen = numBytes;
    L_start_lexer();
    lex_buffer = (void *)L__scan_bytes(str, numBytes);
    /* L_trace("Parsing: %.*s", numBytes, str); */
    L_trace("parsing");
    L_errors = NULL;
    L_parse();
    if (getenv("L_DUMP_AST") && L_current_ast) {
        if (L_WALK_ERROR ==
	    L_walk_ast(L_current_ast, L_WALK_PRE, LDumpAstNodes, NULL)) 
	{
	    L_trace("Error walking AST");
	}    
        fprintf(stderr, "\n");
    }
    if (L_ast == NULL) {
        L_free_ast(L_current_ast);
    } else {
        *L_ast = L_current_ast;
    }
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.");
            return TCL_ERROR;
    }
    L_trace("Done parsing.");
    return TCL_OK;
}


/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
int
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr,
    void *ast)
{
/*     L_trace("Compiling: \n %.*s", numBytes, str); */
    L_trace("compiling");
    L_frame_push(interp, envPtr, ast);
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;

    switch(((L_ast_node*)ast)->type) {
    case L_NODE_TOPLEVEL_STATEMENT:
        L_compile_toplevel_statements(ast);
        break;
    default:
        L_bomb("LCompileScript error, expecting a toplevel statement, "
               "got: %s", L_node_type_tostr[((L_ast_node*)ast)->type]);
    }
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();
    L_finish_typechecks();
    L_free_ast(ast);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to compile.");
            return TCL_ERROR;
    }
    L_trace("Done compiling");
    return TCL_OK;
}

void
L_compile_toplevel_statements(L_toplevel_statement *stmt)
{
    L_toplevel_statement *s;
    char *name;
    Proc *toplevelProcPtr;
    int	 has_toplevel_stmt = 0;

    /* first compile the declarations */
    for (s = stmt; s; s = s->next) {
	switch (s->kind) {
	case L_TOPLEVEL_STATEMENT_FUN:
	    L_compile_function_decl(s->u.fun);
	    break;
	case L_TOPLEVEL_STATEMENT_TYPE:
	    L_compile_struct_decl(s->u.type);
	    break;
	case L_TOPLEVEL_STATEMENT_TYPEDEF:
	    /* ignore -- handled at parse time */
	    break;
	case L_TOPLEVEL_STATEMENT_GLOBAL:
	    L_compile_global_decls(s->u.global);
	    /* The initalizers of the globals are toplevel code. */
	    has_toplevel_stmt = 1;
	    break;
	case L_TOPLEVEL_STATEMENT_STMT:
	    has_toplevel_stmt = 1;
	    /* handled below */
	    break;
	default:
	    L_bomb("Unexpected toplevel statement type %d", s->kind);
	}
    }
    if (has_toplevel_stmt == 0) return;
    /* Now compile the toplevel code.  It all goes into a Tcl proc that we
       call as soon as we're done building it. */
    name = gensym("%%l_toplevel");
    toplevelProcPtr = Begin_Proc();
    /* Mark the frame so that we can treat things specially */
    lframe->toplevel_p = TRUE;
    for (s = stmt; s; s = s->next) {
	switch (s->kind) {
	case L_TOPLEVEL_STATEMENT_STMT:
	    L_compile_statements(s->u.stmt);
	    break;
	case L_TOPLEVEL_STATEMENT_GLOBAL:
	    L_compile_variable_decls(s->u.global);
	    break;
	default:
	    break;
	}
    }

    L_return(FALSE);
    Finish_Proc(toplevelProcPtr, name);
    /* This actually invokes the toplevel code that we just compiled */
    if (lframe->envPtr) {
	L_PUSH_STR(name);
	TclEmitInstInt4(INST_INVOKE_STK4, 1, lframe->envPtr);
    } else {
	Tcl_Eval(lframe->interp, name);
    }
}

void
L_compile_function_decl(L_function_declaration *fun)
{
    Proc *procPtr;

    if (!fun) return;
    L_trace("compiling a function decl");

    L_store_fun_type(fun);

    procPtr = Begin_Proc();
    lframe->block = (L_ast_node *)fun;

    L_compile_parameters(fun->params);
    L_compile_block(fun->body);

    /* This is the "fall off the end" implicit return. We return "". */
    L_return(FALSE);
    Finish_Proc(procPtr, fun->name->u.string);
}

static Proc *
Begin_Proc()
{
    Proc *procPtr;
    CompileEnv *envPtr;
    char *scriptCopy;

    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr, NULL);

    scriptCopy = ckalloc(L_scriptLen + 1);
    strncpy(scriptCopy, L_script, L_scriptLen);
    *(scriptCopy + L_scriptLen) = '\0';

    procPtr = (Proc *)ckalloc(sizeof(Proc));
    procPtr->iPtr = (struct Interp *)lframe->interp;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;
    TclInitCompileEnv(lframe->interp, envPtr, scriptCopy, L_scriptLen,
	NULL, 0);
    lframe->originalCodeNext = envPtr->codeNext;
    envPtr->procPtr = procPtr;

    return procPtr;
}

static void
Finish_Proc(
    Proc *procPtr,
    char *name)
{
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
        L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);

    cmd = Tcl_CreateObjCommand(lframe->interp, name, TclObjInterpProc,
			       (ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;

    TclFreeCompileEnv(lframe->envPtr);
    ckfree((char *)lframe->envPtr);
    L_frame_pop();
}

void
L_compile_struct_decl(L_type *decl)
{
    Tcl_HashEntry *hPtr;
    int freshp;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    if (!decl->struct_tag ||
        !(decl->struct_tag->kind == L_EXPRESSION_STRING)) {
        L_errorf(decl, "Untagged struct types are not supported yet");
        return;
    }
    hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.string,
                               &freshp);
    Tcl_SetHashValue(hPtr, decl);
    L_trace("Declared struct type %s", decl->struct_tag->u.string);
}

void
L_compile_global_decls(L_variable_declaration *decl)
{
    L_symbol *symbol;

    if (!decl) return;
    /* just create the symbol, but don't initialize the Tcl variable.  The
       toplevel code function will initialize it. */
    symbol = L_make_symbol(decl->name, decl->type, -1);
    symbol->global_p = TRUE;
    L_compile_global_decls(decl->next);
}

/* Initialize the struct types table and lookup a type in it.  Returns the
   type, or NULL if none was found.  */
L_type *
lookup_struct_type(char *tag)
{
    Tcl_HashEntry *hPtr = NULL;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    hPtr = Tcl_FindHashEntry(L_struct_types, tag);

    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}

void 
L_compile_variable_decls(L_variable_declaration *var)
{
    L_symbol *symbol;

    if (!var) return;
    L_trace("declaring variable %s", var->name->u.string);

    if ((symbol = L_get_symbol(var->name, FALSE)) &&
        !global_symbol_p(symbol))
    {
        L_errorf(var, "Illegal redeclaration of local variable %s",
                 var->name->u.string);
    }

    if (var->extern_p) {
	L_compile_frame *old_frame = lframe;
	L_symbol *symbol;
	L_trace("Extern var %s", var->name->u.string);
	/* stuff the extern in the uppermost symbol table as if we'd seen a
	   global declaration for it */
	if (!(symbol = L_get_local_symbol(var->name, FALSE))) {
	    while (lframe->prevFrame) lframe = lframe->prevFrame;
	    symbol = L_make_symbol(var->name, var->type, -1);
	    symbol->global_p = TRUE;
	    lframe = old_frame;
	}
    } else {
	/* if the variable isn't extern, then we must create it, so we emit
	   code to initialize it */
	if (lframe->toplevel_p) {
	    if (!(symbol = L_get_local_symbol(var->name, FALSE))) {
		L_bomb("assertion failed, global variable not declared");
	    }
	} else {
	    int localIndex;
	    localIndex = TclFindCompiledLocal(var->name->u.string,
					      strlen(var->name->u.string),
					      1, 0, lframe->envPtr->procPtr);
	    symbol = L_make_symbol(var->name, var->type, localIndex);
	}

	if (var->initial_value) {
	    compile_initializer(var->initial_value, var->type);
	} else {
	    compile_blank_initializer(var->type);
	}
	L_STORE_SCALAR(symbol->localIndex);
	TclEmitOpcode(INST_POP, lframe->envPtr);
    }

    L_compile_variable_decls(var->next);
}

/* Compile an initializer and stack the value */
static void
compile_initializer(
    L_initializer *init,
    L_type *type)
{
    L_initializer *i;
    int count;

    /* XXX: this is not finished.  We only handle a single dimension, and we
       don't check the field count for structs. */
    switch (type->kind) {
    case L_TYPE_STRUCT:
    case L_TYPE_ARRAY:
	if (init->value && ((L_ast_node *)init->value)->type == L_NODE_INITIALIZER) {
	    L_PUSH_STR("list");
	    for (i = (L_initializer *)init->value, count = 0;
		 i;
		 i = i->next, count++)
	    {
		if (i->key) {
		    L_errorf(i, "Keys are not allowed in array initializers.");
		}
		L_compile_expressions(i->value);
	    }
	    TclEmitInstInt4(INST_INVOKE_STK4, count + 1, lframe->envPtr);
	} else {
	    L_compile_expressions(init->value);
	}
	break;
    case L_TYPE_HASH:
	if (init->value && ((L_ast_node *)init->value)->type == L_NODE_INITIALIZER) {
	    L_PUSH_STR("list");
	    for (i = (L_initializer *)init->value, count = 0;
		 i;
		 i = i->next, count++)
	    {
		if (!i->key) {
		    L_errorf(i, "Keys are required for hash initializers.");
		} else {
		    L_compile_expressions(i->key);
		}
		L_compile_expressions(i->next_dim->value);
	    }
	    TclEmitInstInt4(INST_INVOKE_STK4, (count * 2) + 1, lframe->envPtr);
	} else {
	    L_compile_expressions(init->value);
	}
	break;
    default:
        /* atomic type */
        L_compile_expressions(init->value);
    }
}

/* Stack a suitable empty value for variable's type. */
static void
compile_blank_initializer(
    L_type *type)
{
    char *code;
    int needs_eval;

    /* array or struct */
    code = blank_initializer_code(type, &needs_eval);
    if (needs_eval) {
        L_PUSH_STR("eval");
        L_PUSH_STR(code);
        TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
    } else {
        L_PUSH_STR(code);
    }
}

/* Return the default value for an atomic type, such as 0 for an int or "" for
   a string.  If the type is not atomic or has no special default initial
   value, defaults to a Tcl_Obj with an empty string rep and no type.  The
   reference count on the return value is 0. */
static Tcl_Obj *
atomic_initial_value(L_type *type) {
    switch (type->kind) {
    case L_TYPE_INT:
        return Tcl_NewIntObj(0);
    case L_TYPE_FLOAT:
        return Tcl_NewDoubleObj(0.0);
    case L_TYPE_STRING:
        return Tcl_NewStringObj("", 0);
    default:
        return Tcl_NewObj();
    }
}

/* Generate code to initialize an array or struct.  If name is passed,
   generate a set into a variable of that name.  needs_eval will be set to
   true if the code must be evaluated, false if the code is constant.  */
static char *
blank_initializer_code(
    L_type *type,
    int *needs_eval)
{
    Tcl_Obj *code = Tcl_NewObj();
    int brackets = 0, i;
    L_expression *retval;

    *needs_eval = FALSE;
    if (auto_extending_array_p(type)) {
	MK_STRING_NODE(retval, "");
	return retval->u.string;
    }
    Tcl_IncrRefCount(code);
    while (type->kind == L_TYPE_ARRAY) {
        if (type->array_dim->kind != L_EXPRESSION_INTEGER) {
            L_errorf(type->array_dim,
                     "Bad dimension for an array: must be an int.");
            break;
        }
        if (type->array_dim->u.integer > 0) {
            *needs_eval = TRUE;
            /* skip the outermost set of brackets  */
            if (brackets > 0) {
		Tcl_AppendPrintfToObj(code, "[");
            }
            brackets++;
	    Tcl_AppendPrintfToObj(code, "lrepeat %d ",
		type->array_dim->u.integer);
            type = type->next_dim;
        } else {
            break;
        }
    }
    /* the base type */
    if (type->kind != L_TYPE_STRUCT) {
	if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "{%s}",
		Tcl_GetString(atomic_initial_value(type)));
        } else {
	    Tcl_AppendPrintfToObj(code, "%s",
		Tcl_GetString(atomic_initial_value(type)));
        }
    } else {
        L_variable_declaration *mem;

	fixup_struct_type(type);
        *needs_eval = TRUE;
        if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "[");
        }
	Tcl_AppendPrintfToObj(code, "list ");
        for (mem = type->members; mem; mem = mem->next) {
            if (mem->type->kind == L_TYPE_ARRAY) {
                int needs_eval1;
                char *code1 = blank_initializer_code(mem->type, &needs_eval1);
                if (needs_eval1) {
		    Tcl_AppendPrintfToObj(code, "[%s] ", code1);
                } else {
		    Tcl_AppendPrintfToObj(code, "%s ", code1);
                }
            } else {
		Tcl_AppendPrintfToObj(code, " {%s} ",
		    Tcl_GetString(atomic_initial_value(mem->type)));
            }
        }
        if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "]");
        }
    }
    for (i = 1; i < brackets; i++) {
	Tcl_AppendPrintfToObj(code, "]");
    }
    MK_STRING_NODE(retval, Tcl_GetString(code));
    Tcl_DecrRefCount(code);
    L_trace("blank value: %s", retval->u.string);
    return retval->u.string;
}

void
fixup_struct_type(L_type *type)
{
/*     Tcl_Obj *val = NULL; */
/*     int i; */
    L_type *struct_type = type;
/*     L_variable_declaration *member; */

    /* if we have a struct tag without the struct definition, lookup the
       definition. */
    if (!struct_type->members) {
        if (!struct_type->struct_tag) {
            L_bomb("Assertion failed: a struct must either have a tag or "
                   "members");
        }
        struct_type = lookup_struct_type(struct_type->struct_tag->u.string);
        if (!struct_type) {
            L_errorf(type, "Undefined structure type: %s",
                     type->struct_tag->u.string);
            return;
        }
        /* Fixup the original type so that it also has the member
           information.  This allows all the other code to skip the
           lookup. */
        type->members = struct_type->members;
    }
/*     val = Tcl_NewListObj(0, NULL); */
/*     /\* initialize the struct fields *\/ */
/*     for (member = type->members; member; member = member->next, i++) { */
/*         Tcl_Obj *el = */
/*             create_array_or_struct(member->type->next_dim, member->type); */
/*         if (!el) return NULL; */
/*         Tcl_ListObjAppendElement(NULL, val, el); */
/*     } */
/*     return val; */
}

static int
auto_extending_array_p(L_type *t)
{

    return (t->kind == L_TYPE_ARRAY) &&
	(t->array_dim->kind == L_EXPRESSION_INTEGER) &&
	(t->array_dim->u.integer == 0);
}

int
global_symbol_p(L_symbol *symbol)
{
    return symbol->global_p;
}

void
L_compile_statements(L_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_STATEMENT_BLOCK:
        L_compile_block(stmt->u.block);
        break;
    case L_STATEMENT_EXPR:
        L_compile_expressions(stmt->u.expr);
        /* Expressions leave a value on the evaluation stack, but statements
           don't. So pop the value. */
        TclEmitOpcode(INST_POP, lframe->envPtr);
        break;
    case L_STATEMENT_COND:
        L_compile_if_unless(stmt->u.cond);
        break;
    case L_STATEMENT_LOOP:
	L_compile_loop(stmt->u.loop);
        break;
    case L_STATEMENT_FOREACH:
	L_compile_foreach_loop(stmt->u.foreach);
	break;
    case L_STATEMENT_RETURN:
        L_trace("compiling return statement");
        if (stmt->u.expr) {
            L_trace("    with return value");
            /* compile the return value */
            L_compile_expressions(stmt->u.expr);
        } else {
            L_trace("    without return value");
            /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
            L_PUSH_OBJ(Tcl_NewObj());
        }
        /* INST_RETURN_STK involves a little more magic that I haven't wangled out
           yet... but I think it lets us pass back error codes and such that could
           be useful. --timjr 2006.3.31  */
        /* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
        TclEmitOpcode(INST_DONE, lframe->envPtr);
        break;
    case L_STATEMENT_DECL:
	    L_bomb("Found L_STATEMENT_DECL where it's not supposed to be");
	    break;
    case L_STATEMENT_BREAK:
	L_compile_break(stmt);
	break;
    case L_STATEMENT_CONTINUE:
	L_compile_continue(stmt);
	break;
    default:
	L_bomb("Malformed AST in L_compile_statements");
    }
    L_compile_statements(stmt->next);
}

void
L_compile_block(L_block *block) {
    L_compile_variable_decls(block->decls);
    L_compile_statements(block->body);
}

void 
L_compile_parameters(L_variable_declaration *param)
{
    Proc *procPtr = lframe->envPtr->procPtr;
    CompiledLocal *localPtr;
    L_expression *name;
    int i;
    L_variable_declaration *p;

    for (p = param, i = 0; p; p = p->next, i++) {
        int by_name = (p->by_name || type_passed_by_name_p(p->type));
        if (by_name) {
            /* if the parameter is pass by name, we use a mangled name for it
               so that we can define an upvar using the original name */
            name = reference_mangle(p->name->u.string);
        } else {
            name = p->name;
        }
        L_trace("Compiling parameter %d (%s)", i, name->u.string);
        /* Formal parameters are stored in local variable slots. */
        procPtr->numArgs = i + 1;
        procPtr->numCompiledLocals = i + 1;
        localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
                                             sizeof(localPtr->name) +
                                             strlen(name->u.string) + 1);
        if (procPtr->firstLocalPtr == NULL) {
            procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr;
        } else {
            procPtr->lastLocalPtr->nextPtr = localPtr;
            procPtr->lastLocalPtr = localPtr;
        }
        localPtr->nextPtr = NULL;
        localPtr->nameLength = strlen(name->u.string);
        localPtr->frameIndex = i;
        localPtr->flags = VAR_SCALAR | VAR_ARGUMENT;
        localPtr->resolveInfo = NULL;
        localPtr->defValuePtr = NULL;
        strcpy(localPtr->name, name->u.string);
        L_make_symbol(name, p->type, i);
    }
    /* we have to loop over them again, otherwise TclFindCompiledLocal somehow
       screws up the compiled locals for us, such that L code with args after
       a by-name arg will segfault.  I haven't 100% understood what's going
       on.  --timjr 2006.9.26*/
    for (p = param, i = 0; p; p = p->next, i++) {
        int by_name = (p->by_name || type_passed_by_name_p(p->type));
        if (by_name) {
            L_symbol *symbol;
            int localIndex;

            /* if the parameter is pass by name, we use a mangled name for it
               so that we can define an upvar using the original name */
            name = reference_mangle(p->name->u.string);
            symbol = L_get_symbol(name, TRUE);

            localIndex =
                TclFindCompiledLocal(p->name->u.string, strlen(p->name->u.string),
                                     1, VAR_SCALAR, procPtr);
            L_make_symbol(p->name, p->type, localIndex);
            emit_upvar(symbol, p->name->u.string);
        }
    }
}

/* arrays, and hashes are all passed by name.  array_p() is too general to use
   here. */
static int
type_passed_by_name_p(L_type *type)
{
    return (type->kind == L_TYPE_ARRAY || type->kind == L_TYPE_HASH);
}

void
L_compile_expressions(L_expression *expr)
{
    int param_count, startOffset;
    L_symbol *symbol;

    if (!expr) return;
    switch (expr->kind) {
    case L_EXPRESSION_FUNCALL:
	L_trace("compiling a call to %s", expr->a->u.string);
	startOffset = CurrentOffset(lframe->envPtr);
        if ((symbol = L_get_local_symbol(expr->a, FALSE))) {
	    /* looks like the function name is in a variable */
	    L_push_variable(expr);
	} else {
	    L_PUSH_STR(expr->a->u.string);
	}
        param_count =
	    push_parameters(symbol ? NULL : expr->a->u.string, expr->b);
        TclEmitInstInt4(INST_INVOKE_STK4, param_count+1, lframe->envPtr);
	if (!symbol) {
	    L_check_arg_count(expr->a->u.string, param_count, expr);
	}
	L_trace("tracking lineinfo for call to %s", expr->a->u.string);
	/* Since the function call node is created after all of its child
	 * nodes have been created, its offset is at the end of the complete
	 * expression. Hence subtracting the offset of the first child gives
	 * you the length of the whole expression. */
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset) + 1);
        break;
    case L_EXPRESSION_PRE:
    case L_EXPRESSION_POST:
        L_compile_incdec(expr);
        break;
    case L_EXPRESSION_UNARY:
        L_compile_unop(expr);
        break;
    case L_EXPRESSION_BINARY:
        L_trace("Binary expression");
        L_compile_binop(expr);
        break;
    case L_EXPRESSION_INTEGER:
    case L_EXPRESSION_STRING:
    case L_EXPRESSION_FLOTE:
        L_PUSH_OBJ(literal_to_TclObj(expr));
        break;
    case L_EXPRESSION_INTERPOLATED_STRING:
        L_compile_interpolated_string(expr);
        break;
    case L_EXPRESSION_VARIABLE:
        L_push_variable(expr);
        break;
    default:
        L_bomb("Unknown expression type %d", expr->kind);
    }
    L_compile_expressions(expr->next);
}

/* Push the parameters of a function call on the evaluation stack and return
   the number of parameters pushed.  This is complicated because we need to
   make arrays and hashtables be implicit references, and check for
   "-foovariable, &foo", in which case we make an L pointer for foo. */
static int
push_parameters(
    char *funcname,		/* if non-null, used to check param types */
    L_expression *parameters)
{
    L_expression *p;
    int i = 0;
    int widget_flag = FALSE;

    /* push the function's name */

    /* count the parameters stack them, checking for implicit references
       and L pointers. */
    for (i = 0, p = parameters; p; p = p->next, i++)
    {
        L_symbol *var = NULL;

	if (funcname) {
	    L_check_arg_type(funcname, i, p);
	}
        if ((p->kind == L_EXPRESSION_VARIABLE) && !p->indices) {
            var = L_get_local_symbol(p->a, FALSE);
        }
        /* if the previous parameter was -foovariable and there's an &,
           then we need to make an L pointer */
        if (widget_flag && (p->kind == L_EXPRESSION_UNARY) &&
            (p->op == T_BITAND))
        {
            L_trace("making an L pointer for %s\n", p->a->a->u.string);
            L_push_pointer(p->a);
        } else if (var && type_passed_by_name_p(var->type)) {
            /* the parameter needs to be passed by name */
            L_PUSH_STR(var->name);
        } else {
            /* compile just one parameter for its value */
            L_expression *next = p->next;
            p->next = NULL;
            L_compile_expressions(p);
            p->next = next;
        }
        /* if we see a parameter that looks like -foovariable, we set the
           widget flag to true so we know that the next parameter might be an
           L pointer. */
	widget_flag = FALSE;
        if (p->kind == L_EXPRESSION_STRING) {
            widget_flag =
		/* has at least the minimum length */
                (strlen(p->u.string) >= strlen("-variable")) &&
		/* starts with '-' */
                (p->u.string[0] == '-') &&
		/* ends with "variable" */
                (0 == strcmp("variable",
                             p->u.string +
                             (strlen(p->u.string) - strlen("variable"))));
        }
    }
    return i;
}

static void
L_push_pointer(L_expression *lval)
{
    L_PUSH_STR("pointer");
    L_PUSH_STR("new");
    L_PUSH_STR(lval->a->u.string);
    if (!lval->indices) {
        TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
    } else {
        L_symbol *var;
        if (lval->indices->indices) {
            L_errorf(lval, "more than one index is not supported yet");
        }
        if (lval->indices->kind== L_EXPRESSION_HASH_INDEX) {
            L_errorf(lval, "hash keys are not yet supported by pointers");
        }
        if (!(var = L_get_local_symbol(lval->a, TRUE))) return;
        L_compile_index(var->type, lval->indices);
        TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
    }
}

/* Create a Tcl Obj containing the value of a constant literal L AST
   node. */
Tcl_Obj *literal_to_TclObj(L_expression *expr)
{
    Tcl_Obj *objPtr = NULL;

    switch (expr->kind) {
    case L_EXPRESSION_INTEGER:
        objPtr = Tcl_NewIntObj(expr->u.integer);
        break;
    case L_EXPRESSION_STRING:
        objPtr = Tcl_NewStringObj(expr->u.string, strlen(expr->u.string));
        break;
    case L_EXPRESSION_FLOTE:
        objPtr = Tcl_NewDoubleObj(expr->u.flote);
        break;
    case L_EXPRESSION_UNARY:
        if (expr->op == T_PLUS) {
            objPtr = Tcl_NewIntObj(expr->a->u.integer);
        } else if (expr->op == T_MINUS) {
            objPtr = Tcl_NewIntObj(-expr->a->u.integer);
        } else {
            L_errorf(expr, "Illegal initializer");
        }
        break;
    default:
        return NULL;
/*         L_bomb("literal_to_TclObj can't handle expressions of type %d\n", */
/*                expr->kind); */
    }
    return objPtr;
}

void L_compile_unop(L_expression *expr)
{
    switch (expr->op) {
    case T_TCL_CAST:
        if ((expr->a->kind == L_EXPRESSION_VARIABLE) && !expr->a->indices) {
            /* XXX: this duplicates some code from L_push_variable... maybe
               'twould be better to parameterize L_push_variable? */
            L_symbol *var;
            L_expression *name = expr->a->a;
            if (!(var = L_get_local_symbol(name, TRUE))) return;
            L_LOAD_SCALAR(var->localIndex);
        } else {
            /* we don't do anything special if it's not a plain jane
               variable */
            L_compile_expressions(expr->a);
        }
        break;
    case T_STRING_CAST:
        /* no conversion -- it's all a string. However, we might have to do
           something here to make the future type checker happy. */
        L_compile_expressions(expr->a);
        break;
    case T_INT_CAST:
        L_PUSH_STR("::tcl::mathfunc::int");
        L_compile_expressions(expr->a);
        TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
        break;
    case T_FLOAT_CAST:
        L_PUSH_STR("::tcl::mathfunc::double");
        L_compile_expressions(expr->a);
        TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
        break;
    case T_BANG:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
        break;
    case T_BITNOT:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_BITNOT, lframe->envPtr);
        break;
    case T_PLUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UPLUS, lframe->envPtr);
        break;
    case T_MINUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UMINUS, lframe->envPtr);
        break;
    case T_BITAND:
        /* &, address-of operator */
        L_compile_expressions(expr->a->a);
        break;
    case T_DEFINED:
        L_compile_defined(expr->a);;
        break;
    default:
        L_bomb("Unknown unary operator %d", expr->op);
    }
}

void L_compile_binop(L_expression *expr)
{
    L_type *type;

    switch (expr->op) {
    case T_EQUALS:
	if ((type = L_expression_type(expr->a))) {
	    L_check_type(type, expr->b);
	}
        L_compile_assignment(expr);
	break;
    case T_EQPLUS:
    case T_EQMINUS:
    case T_EQSTAR:
    case T_EQSLASH:
    case T_EQPERC:
    case T_EQBITAND:
    case T_EQBITOR:
    case T_EQBITXOR:
    case T_EQLSHIFT:
    case T_EQRSHIFT:
	L_check_kind(L_TYPE_NUMBER, expr->a);
	L_check_kind(L_TYPE_NUMBER, expr->b);
        L_compile_assignment(expr);
	break;
    case T_ANDAND:
    case T_OROR:
        L_compile_short_circuit_op(expr);
	break;
    case T_EQTWID:
	L_check_kind(L_TYPE_STRING, expr->a);
        L_compile_twiddle(expr);
	break;
    case T_EQ:
    case T_NE:
    case T_GT:
    case T_GE:
    case T_LT:
    case T_LE:
	L_check_kind(L_TYPE_STRING, expr->a);
	L_check_kind(L_TYPE_STRING, expr->b);
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    case T_EQUALEQUAL:
    case T_NOTEQUAL:
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    case T_GREATER:
    case T_GREATEREQ:
    case T_LESSTHAN:
    case T_LESSTHANEQ:
    case T_PLUS:
    case T_MINUS:
    case T_STAR:
    case T_SLASH:
    case T_PERC:
    case T_BITAND:
    case T_BITOR:
    case T_BITXOR:
    case T_LSHIFT:
    case T_RSHIFT:
	L_check_kind(L_TYPE_NUMBER, expr->a);
	L_check_kind(L_TYPE_NUMBER, expr->b);
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    default:
	L_bomb("L_compile_binop: malformed AST");
    }
}

void
L_compile_interpolated_string(L_expression *expr)
{
    int tempVar;

    /* XXX is there really no better way to concatenate 3 strings
       using TCL bytecode? */
    L_compile_expressions(expr->a);
    tempVar = TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR,
                                   lframe->envPtr->procPtr);
    L_STORE_SCALAR(tempVar);
    L_compile_expressions(expr->b);
    TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    if (expr->c) {
        L_compile_expressions(expr->c);
        TclEmitInstInt1(INST_APPEND_SCALAR1, tempVar, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        TclEmitOpcode(INST_POP, lframe->envPtr);
        L_LOAD_SCALAR(tempVar);
    } else {
        /* Currently, an interpolated string node will always be
           followed by another one, or by a regular string node, so
           there's no way to test this branch.  */
        L_bomb("L_compile_interpolated_string: Malformed AST");
    }
}

void
L_compile_twiddle(L_expression *expr)
{
    Tcl_Obj *const_regexp = Tcl_NewObj();
    Tcl_RegExp compiled;
    int submatchCount = 0, i;
    L_expression *runner;

    if (expr->c) {
	/* it's a substitution, so let L_compile_assignment do the hard
	 * stuff */
	L_compile_assignment(expr);
	return;
    }
    /* put together the parts of the regexp that we know at compile time */
    Tcl_IncrRefCount(const_regexp);
    for (runner = expr->b; runner; runner = runner->c) {
        switch (runner->kind) {
        case L_EXPRESSION_INTERPOLATED_STRING:
            Tcl_AppendToObj(const_regexp, runner->a->u.string, -1);
            /* if we ever find a spot where the regexp breaks, we could try
               adding a space to replace the runner->b interpolated part.
               (see the XXX comment below) */
            //            Tcl_AppendToObj(const_regexp, " ", 1);
            break;
        case L_EXPRESSION_STRING:
            Tcl_AppendToObj(const_regexp, runner->u.string, -1);
            break;
        default:
            L_bomb("L_compile_twiddle: Malformed AST");
        }
    }
    /* now try to compile the regexp, just to figure out how many submatches
       there are. */
    compiled = Tcl_GetRegExpFromObj(lframe->interp, const_regexp,
                                    TCL_REG_ADVANCED);
    if (compiled == NULL) {
        /* XXX: does a regexp really have to be correct sans interpolated
           parts?  If not, this error might happen at the wrong time.  To
           support such regexps, we would have to count submatches at
           runtime. */
        L_errorf(expr, "Bad regular expression");
    } else {
        submatchCount = ((TclRegexp *)compiled)->re.re_nsub;
    }
    L_trace("The submatch count in %s is %d\n",
            Tcl_GetString(const_regexp), submatchCount);
    /* create the submatch variables */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        L_expression *name;

        snprintf(buf, 128, "$%d", i);
        MK_STRING_NODE(name, buf);
        if (!L_get_symbol(name, FALSE)) {
            int localIndex =
                TclFindCompiledLocal(name->u.string, strlen(name->u.string),
                                     1, 0, lframe->envPtr->procPtr);
            L_make_symbol(name,
                          mk_type(L_TYPE_STRING, NULL, NULL, NULL, NULL,
                                  FALSE),
                          localIndex);
        }
    }
    /* emit code to call the regexp object command */
    L_PUSH_STR("regexp");
    /* the regexp */
    L_compile_expressions(expr->b);
    /* the target string */
    L_compile_expressions(expr->a);
    /* match/submatch vars. NB: this loop always goes around at least once. */
    for (i = 0; i <= submatchCount; i++) {
	char buf[128];
	snprintf(buf, 128, "$%d", i);
	L_PUSH_STR(buf);
    }
    L_trace("submatch count is %d\n", submatchCount);
    TclEmitInstInt1(INST_INVOKE_STK1, 4 + submatchCount, lframe->envPtr);
}

void
L_compile_short_circuit_op(L_expression *expr)
{
    JumpFixup fixup;

    L_compile_expressions(expr->a);
    /* In case the operator short-circuits, we need one value on the
       evaluation stack for the jump and one for the value of the
       expression. */
    TclEmitOpcode(INST_DUP, lframe->envPtr);
    if (expr->op == T_ANDAND) {
        TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &fixup);
    } else {
        TclEmitForwardJump(lframe->envPtr, TCL_TRUE_JUMP, &fixup);
    }
    /* If the operator doesn't short-circuit, we want to leave the value of
       the second expression on the stack, so remove the value that we DUPed
       above. */
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_compile_expressions(expr->b);
    TclFixupForwardJumpToHere(lframe->envPtr, &fixup, 127);
}

void
L_compile_if_unless(L_if_unless *cond)
{
    JumpFixup jumpFalse, jumpEnd;

    L_compile_expressions(cond->condition);
    L_PUSH_STR("0");
    TclEmitOpcode(INST_NEQ, lframe->envPtr);
    /* emit a jump which will skip the consequent if the top value on the
       stack is false. */
    TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &jumpFalse);
    L_frame_push(lframe->interp, lframe->envPtr, cond);
    /* consequent */
    if (cond->if_body != NULL) {
        L_compile_statements(cond->if_body);
    }
    /* alternate */
    if (cond->else_body != NULL) {
        /* End the scope that was started for the consequent and start a new
           one, copying the jump fixup pointers. */
        L_frame_pop();
        L_frame_push(lframe->interp, lframe->envPtr, cond);
        TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpEnd);
        if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127)) {
            /* The TCL_FALSE_JUMP that we emitted expanded, so the beginning
               code offset saved in the jump fixup for the
               TCL_UNCONDITIONAL_JUMP needs to be adjusted. */
            jumpEnd.codeOffset += 3;
        }
        L_compile_statements(cond->else_body);
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpEnd, 127);
    } else {
        TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalse, 127);
    }
    L_frame_pop();
}

void
L_compile_loop(L_loop *loop)
{
    JumpFixup jumpToCond;
    JumpOffsetList *break_jumps, *continue_jumps;
    int bodyCodeOffset, jumpDist;

    if ((loop->kind == L_LOOP_FOR) && loop->pre) {
        L_compile_expressions(loop->pre);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    /* XXX: need optimization for null conditions and infinite loops
     * See TclCompileWhileComd() for the stuff Tcl does.
     */
    TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP, &jumpToCond);
    L_frame_push(lframe->interp, lframe->envPtr, loop);
    bodyCodeOffset = CurrentOffset(lframe->envPtr);
    L_compile_statements(loop->body);
    /* grab the jump offsets out of the frame before popping it */
    break_jumps = lframe->break_jumps;
    continue_jumps = lframe->continue_jumps;
    L_frame_pop(lframe->interp, lframe->envPtr);
    fixup_jumps(lframe->envPtr, continue_jumps, CurrentOffset(lframe->envPtr));
    if ((loop->kind == L_LOOP_FOR) && loop->post) {
        L_compile_expressions(loop->post);
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpToCond, 127)) {
        bodyCodeOffset += 3;
    }
    L_compile_expressions(loop->condition);
    L_PUSH_STR("0");
    TclEmitOpcode(INST_NEQ, lframe->envPtr);
    jumpDist = CurrentOffset(lframe->envPtr) - bodyCodeOffset;
    if (jumpDist > 127) {
        TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
    } else {
        TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
    }
    fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
}

/* Fix the jump target for a list of INST_JUMP4 jumps and free the
   JumpOffsetList entries. */
static void
fixup_jumps(
    CompileEnv *envPtr,		/* The envPtr that the jump is in. */
    JumpOffsetList *jumps,	/* The list of jumps to adjust. */
    int targetOffset)		/* The target to jump to, relative to the
				   beginning of the code array. */
{
    JumpOffsetList *j;
    for (j = jumps; j; jumps = j->next, ckfree((char *)j), j = jumps) {
	TclUpdateInstInt4AtPc(INST_JUMP4, targetOffset - j->offset,
			      envPtr->codeStart + j->offset);
    }
}

void
L_compile_foreach_loop(L_foreach_loop *loop)
{
    L_symbol *keyVar, *valueVar = NULL;
    int jumpWhenEmptyOffset, bodyTargetOffset, iteratorIndex, jumpDisplacement;
    JumpOffsetList *break_jumps, *continue_jumps;

    if (!(keyVar = L_get_local_symbol(loop->key, TRUE))) return;
    if (loop->value) {
	if (!(valueVar = L_get_local_symbol(loop->value, TRUE))) return;
    }
    L_compile_expressions(loop->hash);
    /* A temporary variable to hold the iterator state.*/
    iteratorIndex = TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR,
					 lframe->envPtr->procPtr);
    /* Both DICT_FIRST and DICT_NEXT leave value, key, and done-p on the
       stack.  Check done-p and jump out of the loop if it's true. (We fixup
       the jump target once we know the size of the loop body.) */
    TclEmitInstInt4(INST_DICT_FIRST, iteratorIndex, lframe->envPtr);
    jumpWhenEmptyOffset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP_TRUE4, 0, lframe->envPtr);
    /* Update the key and value variables. We save the offset of this code so
       we can jump back to it after DICT_NEXT. */
    bodyTargetOffset = CurrentOffset(lframe->envPtr);
    L_STORE_SCALAR(keyVar->localIndex);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    if (loop->value) {
	L_STORE_SCALAR(valueVar->localIndex);
    }
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_frame_push(lframe->interp, lframe->envPtr, loop);
    L_compile_statements(loop->body);
    /* grab the jump offsets out of the frame before popping it */
    break_jumps = lframe->break_jumps;
    continue_jumps = lframe->continue_jumps;
    L_frame_pop();
    fixup_jumps(lframe->envPtr, continue_jumps, CurrentOffset(lframe->envPtr));
    TclEmitInstInt4(INST_DICT_NEXT, iteratorIndex, lframe->envPtr);
    /* If there's another entry in the hash, go around the loop again. */
    jumpDisplacement = bodyTargetOffset - CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP_FALSE4, jumpDisplacement, lframe->envPtr);
    /* This is the end of the loop.  Point the jump after the DICT_FIRST to
       here. */
    jumpDisplacement = CurrentOffset(lframe->envPtr) - jumpWhenEmptyOffset;
    TclUpdateInstInt4AtPc(INST_JUMP_TRUE4, jumpDisplacement,
			  lframe->envPtr->codeStart + jumpWhenEmptyOffset);
    /* All done.  Cleanup the bogus values that DICT_FIRST/DICT_NEXT pushed
       and emit DICT_DONE. */
    TclEmitOpcode(INST_POP, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
    /* XXX We need to ensure that DICT_DONE happens in the face of exceptions,
       so that the refcount on the dict will be decremented, and the iterator
       freed.  See the implementation of "dict for" in tclCompCmds.c.
       --timjr 2006.11.3 */
    TclEmitInstInt4(INST_DICT_DONE, iteratorIndex, lframe->envPtr);
}

void
L_push_variable(L_expression *expr)
{
    L_symbol *var;
    L_expression *name = expr->a;

    if (!(var = L_get_local_symbol(name, TRUE))) {
	L_PUSH_STR("");
	return;
    }
    if (expr->indices) {
        L_expression *index = expr->indices;
        L_type *type = var->type;
        int first_chunk = TRUE;
        while (index) {
            switch (index->kind) {
            case L_EXPRESSION_HASH_INDEX:
                if (first_chunk) {
                    L_LOAD_SCALAR(var->localIndex);
                }
                index = L_read_hash_index_chunk(index);
                /* we have no more information about the type after reading
                   from a hash */
                L_trace("read a hash index, %p", index);
                type = NULL;
                break;
            case L_EXPRESSION_STRUCT_INDEX:
                if (first_chunk) {
                    L_LOAD_SCALAR(var->localIndex);
                }
                index = L_read_struct_index_chunk(index, &type);
                L_trace("read a struct index, %p", index);
                break;
            case L_EXPRESSION_ARRAY_INDEX: {
                /* read_array_index_chunk wants to read the value from a local
                   variable, so ensure it's in one. */
                int varIndex;
                L_type *base_type;
                if (first_chunk) {
                    varIndex = var->localIndex;
                    base_type = type;
                } else {
                    varIndex = store_in_tempvar(TRUE);
                    base_type = NULL;
                }
                index = L_read_array_index_chunk(varIndex, index, &type,
                                                 base_type);
                L_trace("read an array index, %p", index);
                break;
            }
            default:
                L_bomb("corrupt AST, unknown index type");
            }
            first_chunk = FALSE;
        }
    } else {
        L_LOAD_SCALAR(var->localIndex);
    }
}

/* Import a global variable into a procedure's table of locals and
   create an L symbol that shadows the global one. Return the new L
   symbol. */
L_symbol *
import_global_symbol(L_symbol *var)
{
    L_symbol *local;
    int localIndex;
    L_expression *name;  // eugh

    L_trace("importing global variable %s", var->name);
    /* create a new local variable that shadows the global in our
       symbol table */
    localIndex = TclFindCompiledLocal(var->name, strlen(var->name),
                                      1, 0, lframe->envPtr->procPtr);
    MK_STRING_NODE(name, var->name);
    local = L_make_symbol(name, var->type, localIndex);
    /* XXX: This might be bogus.  We attempt to detect whether L global
       variables should be true globals, or should be shared with the calling
       proc, by checking if the current variable frame pointer in interp is
       the same as the global frame pointer.  (Sharing variables with the
       calling proc is useful if you want to use L as an expr replacement). */
    if (((Interp *)lframe->interp)->rootFramePtr ==
	((Interp *)lframe->interp)->varFramePtr)
    {
	L_PUSH_STR("global");
	L_PUSH_STR(var->name);
	TclEmitInstInt4(INST_INVOKE_STK4, 2, lframe->envPtr);
    } else {
	L_PUSH_STR("upvar");
	L_PUSH_STR("1");
	L_PUSH_STR(var->name);
	L_PUSH_STR(var->name);
	TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
    }
    TclEmitOpcode(INST_POP, lframe->envPtr);
    return local;
}

/* Make an upvar named upvarName that references the variable named by var. */
static void
emit_upvar(L_symbol *var, char *upvarName)
{
    L_PUSH_STR("upvar");
    L_LOAD_SCALAR(var->localIndex);
    L_PUSH_STR(upvarName);
    TclEmitInstInt4(INST_INVOKE_STK4, 3, lframe->envPtr);
    TclEmitOpcode(INST_POP, lframe->envPtr);
}

void
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        L_PUSH_OBJ(Tcl_NewObj());
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

/* Emit code to pop the top of the stack and store it in a temporary local
   variable.  Return the varIndex of the new local variable. */
static int
store_in_tempvar(int pop_p)
{
    int tempVar =
        TclFindCompiledLocal(NULL, 0, 1, VAR_SCALAR, lframe->envPtr->procPtr);
    L_STORE_SCALAR(tempVar);
    if (pop_p) {
        TclEmitOpcode(INST_POP, lframe->envPtr);
    }
    return tempVar;
}

void
L_compile_defined(L_expression *lval)
{
    int tempVar = 0;

    L_expression *idx, *last_index;
    if ((lval->kind != L_EXPRESSION_VARIABLE) || !lval->indices) {
        L_errorf(lval, "defined is only defined for array and hash entries");
        return;
    }
    /* walk idx down to the second-to-last index */
    for (idx = lval; idx->indices && idx->indices->indices; idx = idx->indices);
    /* trim the last index off and save it in last_index */
    last_index = idx->indices;
    idx->indices = NULL;
    /* now check for the presence of the last index in the list or dict */
    if (last_index->kind == L_EXPRESSION_HASH_INDEX) {
	L_PUSH_STR("dict");
	L_PUSH_STR("exists");
	L_compile_expressions(lval);
	L_compile_expressions(last_index->a);
	TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
    } else {
	/* grab the length of the list */
	L_compile_expressions(lval);
	TclEmitOpcode(INST_LIST_LENGTH, lframe->envPtr);
	/* check if the index is within bounds */
	L_compile_expressions(last_index->a);
	tempVar = store_in_tempvar(FALSE);
	TclEmitOpcode(INST_GT, lframe->envPtr);
	L_PUSH_STR("0");
	L_LOAD_SCALAR(tempVar);
	TclEmitOpcode(INST_LE, lframe->envPtr);
	TclEmitOpcode(INST_LAND, lframe->envPtr);
    }
    /* put the AST back the way it was */
    idx->indices = last_index;
}

void
L_compile_assignment(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a;
    L_expression *rval = expr->b;

    if (!(var = L_get_local_symbol(lval->a, TRUE))) {
	L_PUSH_STR("");
	return;
    }
    L_trace("COMPILING ASSIGNMENT: %s", L_expression_tostr[lval->a->kind],
            lval->a->u.string);
    if (lval->indices) {
        L_write_index(var, lval->indices, expr, rval, FALSE);
    } else if (expr->op == T_EQTWID) {
	regsub_for_assignment(var->localIndex, -1, TRUE, expr);
    } else {
	if (expr->op != T_EQUALS) {
	    L_LOAD_SCALAR(var->localIndex);
	}
        L_compile_expressions(rval);
	if (expr->op != T_EQUALS) {
	    TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	}
        L_STORE_SCALAR(var->localIndex);
    }
}

/* Compile an expression like ``baz.bar[3][4]{"asdf"} *= 2''.
   L_write_index_aux() does all the work; here we just do a little setup and
   cleanup. */
static void
L_write_index(
    L_symbol *var,              /* the lvalue */
    L_expression *index,	/* the indices into the lvalue */
    L_expression *expr,		/* the whole assignment expression */
    L_expression *rval,		/* the rvalue to use. */
    int post_incr_p)		/* whether we're doing a post-increment */
{
    int rvalVar;

    /* auto-extending array special case */
    if (auto_extending_array_p(var->type) && (expr->op == T_EQUALS)) {
	if (index->indices) {
	    L_errorf(index->indices,
	      "Autoextending in multiple dimensions is not implemented yet");
	}
	L_PUSH_STR("extendingLset");
	L_PUSH_STR(var->name);
	L_compile_index(var->type, index);
	L_compile_expressions(rval);
	TclEmitInstInt4(INST_INVOKE_STK4, 4, lframe->envPtr);
	return;
    }
    /* regular case */
    L_compile_expressions(rval);
    rvalVar = store_in_tempvar(TRUE);

    L_LOAD_SCALAR(var->localIndex);
    L_write_index_aux(index, var->type, expr, rvalVar, post_incr_p);
    L_STORE_SCALAR(var->localIndex);

    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_LOAD_SCALAR(rvalVar);
}

static void
L_write_index_aux(
    L_expression *index,	/* the indices */
    L_type *type,		/* the type of the lvalue (used to lookup
				   struct indices) */
    L_expression *expr,		/* the whole expression */
    int rvalVar,		/* a local variable that holds the rval.  When
				   we're done, this variable will hold the
				   value of the expression as a whole.  */
    int post_incr_p)		/* whether we're doing a post-increment */
{
    L_expression *idx = index;
    int idx_count = 0, hash_idx_p, i, tempVar;

    /* Push a contiguous sequence of hash or non-hash indices. */
    hash_idx_p = (idx->kind == L_EXPRESSION_HASH_INDEX);
    while (idx && (hash_idx_p == (idx->kind == L_EXPRESSION_HASH_INDEX))) {
	type = L_compile_index(type, idx);
	idx_count++;
	idx = idx->indices;
    }
    /* In case we need to read value before writing it, (either because it's
       further indexed, or because we're going to do some arithmetic with it),
       copy the relevant portion of the stack and read the value. */
    if (idx || (expr->op != T_EQUALS)) {
	for (i = 0; i < idx_count + 1; i++) {
	    TclEmitInstInt4(INST_OVER, idx_count, lframe->envPtr);
	}
	if (hash_idx_p) {
	    TclEmitInstInt4(INST_DICT_GET, idx_count, lframe->envPtr);
	} else {
	    TclEmitInstInt4(INST_LIST_INDEX_MULTI, idx_count + 1,
			    lframe->envPtr);
	}
    }
    /* Leave the value to store on top of the stack.  The value is either a
       sub-list/dict or, in the base case, the rval.  This section also takes
       care to store the value of the expression as a whole in rvalVar, so it
       can be left atop the stack. */
    if (idx) {
	/* There are more indices, so leave a sub-list or sub-dict on the
	   stack. */
	L_write_index_aux(idx, type, expr, rvalVar, post_incr_p);
    } else if (post_incr_p) {
	/* We're doing a post-increment, so take care to store the prior value
	   in rvalVar. */
	tempVar = store_in_tempvar(FALSE);
	L_LOAD_SCALAR(rvalVar);
	if (expr->op != T_EQUALS) {
	    TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	}
	L_LOAD_SCALAR(tempVar);
	L_STORE_SCALAR(rvalVar);
	TclEmitOpcode(INST_POP, lframe->envPtr);
    } else if (expr->op == T_EQTWID) {
	/* regexp substitution */
	tempVar = store_in_tempvar(TRUE);
	regsub_for_assignment(tempVar, rvalVar, FALSE, expr);
	L_STORE_SCALAR(rvalVar);
	TclEmitOpcode(INST_POP, lframe->envPtr);
	L_LOAD_SCALAR(tempVar);
    } else {
	/* Put the rval on the stack.  If we're doing a compound assignment,
	   calculate the actual rval and save it back into rvalVar. */
	L_LOAD_SCALAR(rvalVar);
	if (expr->op != T_EQUALS) {
	    TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	    L_STORE_SCALAR(rvalVar);
	}
    }
    /* Copy the dict/list up to the top of the stack and do the set. */
    TclEmitInstInt4(INST_OVER, idx_count + 1, lframe->envPtr);
    if (hash_idx_p) {
	int dictVar = store_in_tempvar(TRUE);
	TclEmitInstInt4(INST_DICT_SET, idx_count, lframe->envPtr);
	TclEmitInt4(dictVar, lframe->envPtr);
    } else {
	TclEmitInstInt4(INST_LSET_FLAT, idx_count + 2, lframe->envPtr);
    }
    /* We want to leave the new dict/list atop the stack, but we need to get
       the old one out from under it.  So we juggle a bit. */
    tempVar = store_in_tempvar(TRUE);
    TclEmitOpcode(INST_POP, lframe->envPtr);
    L_LOAD_SCALAR(tempVar);
}

/* Do a regexp substitution on lvalIndex and store the result back into
 * it. Leave a boolean indicating match success/failure on the stack top. */
static void
regsub_for_assignment(
    int lvalIndex,		/* the subject string */
    int rvalIndex,		/* the regexp (perhaps) */
    int compile_rval_p,		/* whether to push the rval ourselves, or use
				 * rvalIndex */
    L_expression *expr)		/* the operator, the replacement, etc. */
{
    char *tempVarName = gensym("%%matchedp");

    L_PUSH_STR("regsub");
    L_PUSH_STR("-line");
    /* the regexp */
    if (compile_rval_p) {
	L_compile_expressions(expr->b);
    } else {
	L_LOAD_SCALAR(rvalIndex);
    }
    /* the target string */
    L_LOAD_SCALAR(lvalIndex);
    /* the substitution */
    L_compile_expressions(expr->c);
    L_PUSH_STR(tempVarName);
    TclEmitInstInt1(INST_INVOKE_STK1, 6, lframe->envPtr);
    /* move the result of substitution into lvalIndex and leave the matched_p
     * value on stack top */
    L_PUSH_STR(tempVarName);
    TclEmitOpcode(INST_LOAD_SCALAR_STK, lframe->envPtr);
    L_STORE_SCALAR(lvalIndex);
    TclEmitOpcode(INST_POP, lframe->envPtr);
}

static int
instruction_for_l_op(
    int op)
{
    int instruction = 0;
    switch (op) {
    case T_EQ:
    case T_EQUALEQUAL:
	instruction = INST_EQ;
	break;
    case T_NE:
    case T_NOTEQUAL:
	instruction = INST_NEQ;
	break;
    case T_GT:
    case T_GREATER:
	instruction = INST_GT;
	break;
    case T_GE:
    case T_GREATEREQ:
	instruction = INST_GE;
	break;
    case T_LT:
    case T_LESSTHAN:
	instruction = INST_LT;
	break;
    case T_LE:
    case T_LESSTHANEQ:
	instruction = INST_LE;
	break;
    case T_PLUS:
    case T_PLUSPLUS:
    case T_EQPLUS:
	instruction = INST_ADD;
	break;
    case T_MINUS:
    case T_MINUSMINUS:
    case T_EQMINUS:
	instruction = INST_SUB;
	break;
    case T_STAR:
    case T_EQSTAR:
	instruction = INST_MULT;
	break;
    case T_SLASH:
    case T_EQSLASH:
	instruction = INST_DIV;
	break;
    case T_PERC:
    case T_EQPERC:
	instruction = INST_MOD;
	break;
    case T_BITAND:
    case T_EQBITAND:
	instruction = INST_BITAND;
	break;
    case T_BITOR:
    case T_EQBITOR:
	instruction = INST_BITOR;
	break;
    case T_BITXOR:
    case T_EQBITXOR:
	instruction = INST_BITXOR;
	break;
    case T_LSHIFT:
    case T_EQLSHIFT:
	instruction = INST_LSHIFT;
	break;
    case T_RSHIFT:
    case T_EQRSHIFT:
	instruction = INST_RSHIFT;
	break;
    default:
	L_bomb("Unable to map operator %d to an instruction", op);
    }
    return instruction;
}

static L_expression *
L_read_struct_index_chunk(
    L_expression *index,
    L_type **type)
{
    *type = L_compile_index(*type, index);
    TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
    return index->indices;
}


/* Read a value from an array. Returns the next non-array index. */
static L_expression *
L_read_array_index_chunk(
    int varIndex,
    L_expression *index,
    L_type **type,
    L_type *base_type)
{
    L_expression *i;
    int index_count = 0;

    L_LOAD_SCALAR(varIndex);
    for (i = index; i && (i->kind == L_EXPRESSION_ARRAY_INDEX);
         i = i->indices)
    {
        *type = L_compile_index(*type, i);
        index_count++;
    }
    if (index_count == 1) {
        TclEmitOpcode(INST_LIST_INDEX, lframe->envPtr);
    } else {
        TclEmitInstInt4(INST_LIST_INDEX_MULTI, index_count + 1,
                        lframe->envPtr);
    }
    /*     *type = base_type; */
    return i;
}

/* Read a value out of a hashtable and leave it on the stack.  We
   expect the hashtable to be on top of the stack.  Return the next
   non-hashtable index.*/
static L_expression *
L_read_hash_index_chunk(
    L_expression *i)            /* the keys */
{
    int index_count = 0;
    /* push the indices onto the stack */
    while (i && (i->kind == L_EXPRESSION_HASH_INDEX)) {
        L_compile_index(NULL, i);
        i = i->indices;
        index_count++;
    }
    TclEmitInstInt4(INST_DICT_GET, index_count, lframe->envPtr);
    return i;
}

/* Emit code to push an index onto the stack and return the type to use for
   compiling the next index.  We do some minimal type checking on the way. */
L_type *
L_compile_index(
    L_type *index_type,         /* The type of the index. */
    L_expression *index)        /* The index expression to compile. */
{
    L_type *t = index_type;

    switch (index->kind) {
    case L_EXPRESSION_STRUCT_INDEX: {
	/* structure member */
	L_variable_declaration *member;
	int memberOffset;

	member = L_get_struct_member(t, index, &memberOffset);

	if (!member) {
	    L_errorf(index, "Structure field not found, %s", index->a->u.string);
	    return t;
	}
	L_PUSH_OBJ(Tcl_NewIntObj(memberOffset));
	t = member->type;
        break;
    }
    case L_EXPRESSION_ARRAY_INDEX:
        /* array index */
        if (t->kind != L_TYPE_ARRAY) {
            L_errorf(index, "Index into something that's not an array");
            return t;
        }
        L_compile_expressions(index->a);
	t = t->next_dim ? t->next_dim :
	    mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE);
        break;
    case L_EXPRESSION_HASH_INDEX:
        L_trace("Spitting out a hash index\n");
        L_compile_expressions(index->a);
/* 	XXX return L_EXPRESSION_HASH_INDEX again?!  strange decision.  let's
 * 	fix this when we change around the hash declarations. */
	t = mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE);
        break;
    default:
        L_bomb("Invalid kind of index, %d", index->kind);
    }
    return t;
}

L_variable_declaration *
L_get_struct_member(
    L_type *t,
    L_expression *index,
    int *memberOffset)
{
    L_variable_declaration *member;
    char *memberName;

    if (index->a->kind == L_EXPRESSION_STRING) {
	memberName = index->a->u.string;
    } else {
	L_bomb("Bad struct index");
	return (L_variable_declaration *)NULL;
    }
    if (!(t->kind == L_TYPE_STRUCT)) {
	L_errorf(index, "Not a structure: %s", L_type_tostr[t->kind]);
	return (L_variable_declaration *)NULL;
    }
    fixup_struct_type(t);
    L_trace("membername is %s", memberName);
    for (*memberOffset = 0, member = t->members;
	 member && strcmp(member->name->u.string, memberName);
	 (*memberOffset)++, member = member->next) {
	L_trace("member is %s", member->name->u.string);
    }
    return member;
}

void
L_compile_incdec(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a, *rval;

    if (!(var = L_get_local_symbol(lval->a, TRUE))) return;
    if (lval->indices) {
	MK_INT_NODE(rval, 1);
        L_write_index(var, lval->indices, expr, rval,
		      (expr->kind == L_EXPRESSION_POST));
    } else {
        if (expr->kind == L_EXPRESSION_PRE) {
            TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                            lframe->envPtr);
            TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
        } else {
            /* we push the value of the variable, do the increment, and then pop
               the result of the increment, leaving the old value on top. */
            L_push_variable(lval);
            TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                            lframe->envPtr);
            TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
            TclEmitOpcode(INST_POP, lframe->envPtr);
        }
    }
}

void
L_compile_continue(L_statement *stmt)
{
    JumpOffsetList *j = (JumpOffsetList *)ckalloc(sizeof(JumpOffsetList));
    L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

    if (!loop_frame) {
	L_errorf(stmt,
		 "Continue may only be used inside loops");

	return;
    }
    j->offset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
    j->next = loop_frame->continue_jumps;
    loop_frame->continue_jumps = j;
}

void
L_compile_break(L_statement *stmt)
{
    JumpOffsetList *j = (JumpOffsetList *)ckalloc(sizeof(JumpOffsetList));
    L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

    if (!loop_frame) {
	L_errorf(stmt,
		 "Break may only be used inside loops and switch statements");

	return;
    }
    j->offset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
    j->next = loop_frame->break_jumps;
    loop_frame->break_jumps = j;
}


/* Walk up the compile_frame stack and return the first one that corresponds
   to a loop.  If include_switch_p is true, match switch frames too.  Returns
   NULL if no matching frames were found. */
static L_compile_frame *
enclosing_loop_frame(int include_switch_p)
{
    L_compile_frame *f = NULL;

    /* XXX we're ignoring include_switch_p because there are no switch
       statements yet... */
    for (f = lframe; f; f = f->prevFrame) {
	if (f->block &&
	    ((((L_ast_node *)f->block)->type == L_NODE_LOOP) ||
	     (((L_ast_node *)f->block)->type == L_NODE_FOREACH_LOOP)))
	{
	    break;
	}
    }
    return f;
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(
    L_expression *name,
    L_type *type,
    int localIndex)
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name->u.string, &new);
    if (!new) {
        L_errorf(name, "Duplicate definition of symbol %s", name->u.string);
    }
    symbol->name = name->u.string;
    symbol->type = type;
    symbol->localIndex = localIndex;
    symbol->global_p = FALSE;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
    return (L_symbol*)0;
}

/* Look up a symbol in the current symbol table.  If the symbol is a global,
   import the global.  Return NULL and optionally emit an error if symbol is
   not found. */
static L_symbol *
L_get_local_symbol(L_expression *name, int error_p)
{
    L_symbol *var;

    if (!(var = L_get_symbol(name, error_p))) return NULL;
    if (global_symbol_p(var)) {
        L_trace("it's a global");
        var = import_global_symbol(var);
    }
    return var;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(L_expression *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name->u.string);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
	L_trace("Unable to find symbol %s", name->u.string);
/* 	if (Tcl_GetVar(lframe->interp, name->u.string, 0)) { */

/* 	} */
        if (error_p) {
            L_errorf(name, "Undeclared variable: %s", name->u.string);
        }
        return NULL;
    }
}

/* Stick an & on the front of name and return the result as an L AST node. */
static L_expression *
reference_mangle(char *name) {
    L_expression *node;
    char *mangled_name = ckalloc(strlen(name) + 2);
    sprintf(mangled_name, "&%s", name);
    MK_STRING_NODE(node, mangled_name);
    ckfree(mangled_name);
    return node;
}

/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void
maybeFixupEmptyCode(L_compile_frame *frame)
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        L_PUSH_OBJ(Tcl_NewObj());
    }
}

/* Make a new unique name.  It will be freed when the current AST is freed. */
static char *
gensym(char *name)
{
    L_expression *node;
    char *gensym = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
    sprintf(gensym, "%d%s", gensym_counter++, name);
    /* exploit the property of AST nodes that they'll free the string after
       compilation has finished. */
    MK_STRING_NODE(node, gensym);
    ckfree(gensym);
    return node->u.string;
}

/* Push and Pop the L_compile_frames. */
void 
L_frame_push(
    Tcl_Interp *interp,
    CompileEnv *envPtr,
    void *block)		/* The AST node of the current block, or NULL
				   if none. */
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->block = block;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->continue_jumps = NULL;
    new_frame->break_jumps = NULL;
    new_frame->toplevel_p = FALSE;
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        fprintf(stderr, "***: ");
        vfprintf(stderr, format, ap);
        fprintf(stderr, "\n");
    }
    va_end(ap);
    fflush(stderr);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    Tcl_AppendPrintfToObj(L_errors, "L Error: %s on line %d\n", s,
	L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    Tcl_AppendPrintfToObj(L_errors, "L Error: %s on line %d\n", buf,
	node ? ((L_ast_node *)node)->line_no : -1);
    ckfree(buf);
}

/* /\* */
/*  * Example of an AST dumper... needs work */
/*  *\/ */
/* int LCountNodes(void *node, void *data, int order) */
/* { */
/*     int i; */
/*     int *indent = (int *)data; */

/*     if (indent == NULL) { */
/* 	fprintf(stderr, "FOO!\n"); */
/* 	return L_WALK_ERROR; */
/*     } */
/*     if (order & L_WALK_PRE) { */
/* 	for (i = 0; i < (*indent); i++) fprintf(stderr, " "); */
/* 	fprintf(stderr, "%s: ", */
/* 	  L_node_type_tostr[((L_ast_node *)node)->type]); */
/* 	if (((L_ast_node *)node)->type == L_NODE_EXPRESSION) { */
/* 	    L_expression *e = (L_expression *)node; */
/* 	    switch (e->kind) { */
/* 		case L_EXPRESSION_STRING: */
/* 			fprintf(stderr, "%s\n", e->u.string); */
/* 			break; */
/* 		case L_EXPRESSION_INTEGER: */
/* 			fprintf(stderr, "%d\n", e->u.integer); */
/* 			break; */
/* 		default: */
/* 			fprintf(stderr, "\n"); */
/* 			break; */
/* 	    } */
/* 	} else { */
/* 	    fprintf(stderr, "\n"); */
/* 	} */
/* 	(*indent)++; */
/*     } */
/*     if (order & L_WALK_POST) { */
/* 	(*indent)--; */
/*     } */

/*     return L_WALK_CONTINUE; */
/* } */

/* An AST walker that dumps an AST with parens around it. */
static int
LDumpAstNodes(L_ast_node *node, void *data, int order)
{
    if (order & L_WALK_PRE) {
        fprintf(stderr, "(%s", L_node_type_tostr[node->type]);
        switch (node->type) {
        case L_NODE_STATEMENT:
            fprintf(stderr, " :kind %s",
                    L_statement_tostr[((L_statement *)node)->kind]);
            break;
        case L_NODE_TYPE:
            fprintf(stderr, " :kind %s",
                    L_type_tostr[((L_type *)node)->kind]);
            break;
        case L_NODE_LOOP:
            fprintf(stderr, " :kind %s",
                    L_loop_tostr[((L_loop *)node)->kind]);
            break;
        case L_NODE_TOPLEVEL_STATEMENT:
            fprintf(stderr, " :kind %s",
                    L_toplevel_statement_tostr[((L_toplevel_statement *)
                                                node)->kind]);
            break;
        case L_NODE_FUNCTION_DECLARATION:
            break;
        case L_NODE_VARIABLE_DECLARATION:
            break;
        case L_NODE_BLOCK:
            break;
        case L_NODE_INITIALIZER:
            break;
        case L_NODE_EXPRESSION: {
            L_expression *expr = (L_expression *)node;
            fprintf(stderr, " :kind %s", L_expression_tostr[expr->kind]);
            switch (expr->kind) {
            case L_EXPRESSION_INTEGER:
                fprintf(stderr, " :value %d", expr->u.integer);
                break;
            case L_EXPRESSION_STRING:
                /* XXX if there's a double-quote in the string, escape it by
                   hand */
                fprintf(stderr, " :value \"%s\"", expr->u.string);
                break;
            case L_EXPRESSION_FLOTE:
                fprintf(stderr, " :value %e", expr->u.flote);
                break;
            default:
                break;
            }
        }
            break;
        case L_NODE_IF_UNLESS:
            break;
        default:
            L_bomb("undefined node type in LDumpAstNodes");
        }
    }
    if (order & L_WALK_POST) {
        fprintf(stderr, ")");
    }
    return L_WALK_CONTINUE;
}

static void 
L_free_ast(L_ast_node *ast) {
    L_trace("Freeing L AST");
    while(ast_trace_root) {
        L_ast_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_EXPRESSION &&
            ((L_expression *)node)->kind == L_EXPRESSION_STRING) {
            ckfree(((L_expression *)node)->u.string);
        }
        ckfree((char *)node);
    }
    ast_trace_root = NULL;
    /* clean up the typedef table too */
    Tcl_DeleteHashTable(__L_typedef_table);
    ckfree((char *)__L_typedef_table);
    __L_typedef_table = NULL;
}

/* Typedefs are handled at "parse time".  When the compiler walks the AST it
   can ignore them, since the types get copied into the AST by the parser. */

/* return the typedef table.  initialize it if it hasn't been initialized
   yet. */
static Tcl_HashTable *L_typedef_table() {
    if (!__L_typedef_table) {
        __L_typedef_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(__L_typedef_table, TCL_STRING_KEYS);
    }
    return __L_typedef_table;
}

L_type *L_lookup_typedef(L_expression *name, int error_p) {
    Tcl_HashEntry *hPtr = NULL;
    hPtr = Tcl_FindHashEntry(L_typedef_table(), name->u.string);
    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared type: %s", name->u.string);
        }
        return NULL;
    }
}

/* side effects: modifies the type so that typedef_p is true, maps name to
   type in the typedef table so that type will will be returned by
   L_lookup_typedef of name. */
void L_store_typedef(L_expression *name, L_type *type) {
    int new;
    Tcl_HashEntry *hPtr;
    L_type *t;

    /* mark all dimensions of the type as belonging to a typedef */
    for (t = type; t; t->typedef_p = TRUE, t = t->next_dim);

    hPtr = Tcl_CreateHashEntry(L_typedef_table(), name->u.string, &new);
    if (!new) {
        // XXX: emit a redefinition warning?
    }
    Tcl_SetHashValue(hPtr, type);

}

/* XXX this is basically a whacked version of EnterCmdStartData int
 * tclCompile.c. */
static void
track_lineInfo(
    int codeOffset,		/* Where this command's bytecode starts */
    int srcOffset,		/* Where the source of the command starts (in
				 * L_script) */
    int len)			/* The length of the source of the command. */
{
    CmdLocation *cmdLocPtr;
    CompileEnv *envPtr = lframe->envPtr;
    int cmdIndex = lframe->envPtr->numCommands++;

    if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
	Tcl_Panic("track_lineInfo: bad command index %d", cmdIndex);
    }
    
    if (cmdIndex >= envPtr->cmdMapEnd) {
	/*
	 * Expand the command location array by allocating more storage from
	 * the heap. The currently allocated CmdLocation entries are stored
	 * from cmdMapPtr[0] up to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
	 */

	size_t currElems = envPtr->cmdMapEnd;
	size_t newElems = 2*currElems;
	size_t currBytes = currElems * sizeof(CmdLocation);
	size_t newBytes = newElems * sizeof(CmdLocation);
	CmdLocation *newPtr = (CmdLocation *) ckalloc((unsigned) newBytes);

	/*
	 * Copy from old command location array to new, free old command
	 * location array if needed, and mark new array as malloced.
	 */

	memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
	if (envPtr->mallocedCmdMap) {
	    ckfree((char *) envPtr->cmdMapPtr);
	}
	envPtr->cmdMapPtr = (CmdLocation *) newPtr;
	envPtr->cmdMapEnd = newElems;
	envPtr->mallocedCmdMap = 1;
    }

    cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
    cmdLocPtr->codeOffset = codeOffset;
    cmdLocPtr->srcOffset = srcOffset;
    cmdLocPtr->numSrcBytes = len;
    cmdLocPtr->numCodeBytes = CurrentOffset(envPtr) - codeOffset;

    /* The command locations have to be sorted in ascending order by
     * codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(), if nothing
     * else). However, when L compiles nested function calls, the outer one
     * will get tracked second, even though it begins first.  So we walk the
     * new CmdLocation entry back from the end until it lands where it
     * belongs. */
    while ((cmdIndex > 0) &&
	(envPtr->cmdMapPtr[cmdIndex-1].codeOffset > 
	    envPtr->cmdMapPtr[cmdIndex].codeOffset))
    {
	CmdLocation cmdLoc;

	cmdLoc = envPtr->cmdMapPtr[cmdIndex];
	envPtr->cmdMapPtr[cmdIndex] = envPtr->cmdMapPtr[cmdIndex-1];
	envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
	cmdIndex--;
    }
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */

