/*
 * Copyright (c) 2006-2009 BitMover, Inc.
 */
#include <stdio.h>
#include <stdarg.h>
#include <setjmp.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"

/*
 * As of March 2009, we use a bit in the Tcl_Obj structure to
 * represent when an object has the L undefined value.  This avoids
 * the problems we had when Tcl would shimmer undef away into another
 * type, making it look defined.  But we also need an undef object, as
 * the value of array, hash, and struct members when they dynamically
 * are brought into life.  This is also the value of the "undef"
 * pre-defined constant.  We create one object of this type and dup it
 * whenever undef is requested.
 */

private void
undef_freeInternalRep(Tcl_Obj *o)
{
}

/*
 * Return an error if someone tries to convert something to undef
 * type.
 */
private int
undef_setFromAny(Tcl_Interp *interp, Tcl_Obj *o)
{
	Tcl_SetObjResult(interp,
			 Tcl_NewStringObj("cannot convert to undefined value",
					  -1));
	return (TCL_ERROR);
}

/*
 * Get a pointer to the "undefined" object pointer, allocating it the
 * first time it is needed.  Keep the refCount high because we want
 * the one-and-only undef object to never be freed.
 */
Tcl_Obj **
L_undefObjPtrPtr()
{
	static Tcl_Obj *undef_obj = NULL;

	unless (undef_obj) {
		undef_obj = Tcl_NewObj();
		undef_obj->bytes   = tclEmptyStringRep;
		undef_obj->typePtr = &L_undefType;
		undef_obj->undef   = 1;
	}
	ASSERT(undef_obj->undef);
	undef_obj->refCount = 1234;  // arbitrary; chosen to be recognizable
	return (&undef_obj);
}

int
L_isUndef(Tcl_Obj *o)
{
	return (o->undef);
}

Tcl_ObjType L_undefType = {
	"undef",
	undef_freeInternalRep,
	NULL,
	NULL,
	undef_setFromAny
};

/* The next two functions are generated by flex. */
extern void	*L__scan_bytes (const char *bytes, int len);
extern void	L__delete_buffer(void *buf);

private int	L_ParseScript(CONST char *str, Ast **L_ast);
private int	L_CompileScript(void *ast);
private void	ast_free(Ast *ast_list);
private int	compile_assert(Expr *expr);
private void	compile_assign(Expr *expr);
private void	compile_assignComposite(Expr *expr);
private void	compile_assignFromStack(Expr *lhs, Expr *rhs, Expr *expr);
private int	compile_binOp(Expr *expr, Expr_f flags);
private void	compile_block(Block *block);
private void	compile_break(Stmt *stmt);
private void	compile_clsDecl(ClsDecl *class);
private int	compile_clsDeref(Expr *expr, Expr_f flags);
private int	compile_clsInstDeref(Expr *expr, Expr_f flags);
private void	compile_condition(Expr *cond);
private void	compile_continue(Stmt *stmt);
private void	compile_do(Loop *loop);
private void	compile_for_while(Loop *loop);
private int	compile_idxOp(Expr *expr, Expr_f flags);
private int	compile_expr(Expr *expr, Expr_f flags);
private int	compile_exprs(Expr *expr, Expr_f flags);
private int	compile_fnCall(Expr *expr);
private void	compile_fnDecl(FnDecl *fun, Decl_f flags);
private void	compile_fnDecls(FnDecl *fun, Decl_f flags);
private void	compile_foreach(ForEach *loop);
private void	compile_foreachArray(ForEach *loop);
private void	compile_foreachHash(ForEach *loop);
private void	compile_foreachString(ForEach *loop);
private void	compile_goto(Stmt *stmt);
private void	compile_ifUnless(Cond *cond);
private void	compile_incdec(Expr *expr);
private int	compile_join(Expr *expr);
private int	compile_keys(Expr *expr);
private void	compile_label(Stmt *stmt);
private int	compile_length(Expr *expr);
private void	compile_loop(Loop *loop);
private void	compile_fnParms(VarDecl *decl);
private int	compile_push(Expr *expr);
private int	compile_rename(Expr *expr);
private void	compile_return(Stmt *stmt);
private void	compile_shortCircuit(Expr *expr);
private int	compile_sort(Expr *expr);
private int	compile_split(Expr *expr);
private void	compile_stmt(Stmt *stmt);
private void	compile_stmts(Stmt *stmt);
private int	compile_trinOp(Expr *expr);
private void	compile_twiddle(Expr *expr);
private void	compile_twiddleSubst(Expr *expr);
private int	compile_undef(Expr *expr);
private int	compile_unOp(Expr *expr);
private int	compile_var(Expr *expr, Expr_f flags);
private void	compile_varDecl(VarDecl *decl);
private void	compile_varDecls(VarDecl *decls);
private void	emit_globalUpvar(Sym *sym);
private void	emit_instrForLOp(Expr *expr);
private void	emit_jmp_back(TclJumpType jmp_type, int offset);
private Jmp	*emit_jmp_fwd(int op);
private void	fixup_jmps(Jmp *jumps);
private Frame	*frame_find(Frame_f flags);
private void	frame_pop(void);
private void	frame_push(void *node, char *name, Frame_f flags);
private void	frame_resumeBody();
private void	frame_resumePrologue();
private char	*get_text(Expr *expr);
private Type	*iscallbyname(VarDecl *formal);
private int	ispatternfn(char *name, Expr **foo, Expr **Foo_star,
			    Expr **opts, int *nopts);
private Label	*label_lookup(Stmt *stmt, Label_f flags);
private void	list_mapReverse(Expr *l, int (*fn)(Expr *, Expr_f), int arg);
private int	parse_options(int ac, Tcl_Obj **av);
private void	proc_mkArg(Proc *proc, VarDecl *decl);
private int	push_index(Expr *expr);
private int	push_lit(Expr *expr);
private int	push_parms(Expr *actuals);
private void	push_pointer(Expr *lval);
private int	push_regexpModifiers(Expr *regexp);
private int	re_submatchCnt(Expr *re);
private VarDecl	*struct_lookupMember(Type *t, Expr *idx, int *offset);
private Sym	*sym_lookup(Expr *id, Expr_f flags);
private Sym	*sym_store(VarDecl *decl);
private int	tmp_getFree(char **s);
private int	tmp_getSingle(char **s);
private void	track_cmd(int codeOffset, void *node);
private void	type_free(Type *type_list);

Linterp	*L;		// per-interp L state
Type	*L_int;		// pre-defined types
Type	*L_float;
Type	*L_string;
Type	*L_void;
Type	*L_var;
Type	*L_poly;
Type	*L_widget;

/*
 * L built-in functions.
 */
static struct {
	char	*name;
	int	(*fn)(Expr *);
} builtins[] = {
	{ "assert",	compile_assert },
	{ "join",	compile_join },
	{ "keys",	compile_keys },
	{ "length",	compile_length },
	{ "push",	compile_push },
	{ "rename",	compile_rename },
	{ "sort",	compile_sort },
	{ "split",	compile_split },
	{ "undef",	compile_undef },
};

/*
 * L compiler entry point.
 */
int
Tcl_LObjCmd(ClientData clientData, Tcl_Interp *interp, int objc,
	    Tcl_Obj *CONST objv[])
{
	int	argc, len;
	int	ret = TCL_OK;
	char	*str;
	Ast	*ast;
	Tcl_Obj	**argvList;

	/* Extract the L state from the interp. */
	L = Tcl_GetAssocData(interp, "L", NULL);

	if (objc < 2) {
		Tcl_WrongNumArgs(interp, 1, objv, "?options? l-program");
		return (TCL_ERROR);
	}

	/* Parse options from both the Tcl command and the tclsh cmd line. */
	L->options = parse_options(objc-1, (Tcl_Obj **)objv);
	if (L->global->argv &&
	    Tcl_ListObjGetElements(L->interp, L->global->argv, &argc,
				   &argvList) == TCL_OK) {
		L->options |= parse_options(argc-1, argvList);
	}

	L->script = Tcl_NewObj();
	Tcl_IncrRefCount(L->script);
	L->script_len = 0;

	/* L_synerr() longjmps back here on a parser syntax error. */
	if (setjmp(L->jmp)) {
		Tcl_SetObjResult(interp, L->errs);
		return (TCL_ERROR);
	}

	str = Tcl_GetStringFromObj(objv[objc - 1], &len);
	ret = L_ParseScript(str, &ast);

	if ((ret == TCL_OK) && ast) {
		ret = L_CompileScript(ast);
	}

#ifdef TCL_COMPILE_DEBUG
	if (getenv("L_TRACE")) {
		extern int tclTraceExec;
		tclTraceExec = atoi(getenv("L_TRACE"));
	}
#endif

	return (ret);
}

private int
parse_options(int ac, Tcl_Obj **av)
{
	int	i, index;
	int	opts = 0;
	static	CONST char *options[] = {
		"--norun",
		"-norun",
		"-n",
		"--nowarn",
		"-nowarn",
		"-w",
		"--poly",
		"-poly",
		"-P",
		NULL
	};
	enum	options {
		L_NORUN_1, L_NORUN_2, L_NORUN_3,
		L_NOWARN_1, L_NOWARN_2, L_NOWARN_3,
		L_POLY_1, L_POLY_2, L_POLY_3,
	};

	for (i = 1; i < ac; ++i) {
		unless (Tcl_GetIndexFromObj(NULL, av[i], options, NULL, 0,
					    &index) == TCL_OK) {
			continue;
		}
		switch ((enum options)index) {
		    case L_NORUN_1: case L_NORUN_2: case L_NORUN_3:
			opts |= L_OPT_NORUN;
			break;
		    case L_NOWARN_1: case L_NOWARN_2: case L_NOWARN_3:
			opts |= L_OPT_NOWARN;
			break;
		    case L_POLY_1: case L_POLY_2: case L_POLY_3:
			opts |= L_OPT_POLY;
			break;
		    default:
			ASSERT(0);
		}
	}
	return (opts);
}

/*
 * Parse an L script into an AST.  Parsing and compiling are broken into two
 * stages in order to support an interactive mode that parses many times
 * before finally compiling.
 */
private int
L_ParseScript(CONST char *str, Ast **ast_p)
{
	int	len = strlen(str);
	void	*lex_buffer;

	L_typeck_init();

	if (((Interp *)L->interp)->scriptFile) {
		char *f = Tcl_GetString(((Interp *)L->interp)->scriptFile);
		L->file = ckstrdup(f);
	} else {
		L->file = ckstrdup("<stdin>");
	}

	L->line		  = 1;
	L->token_off      = 0;
	L->prev_token_off = 0;
	L->prev_token_len = 0;
	L->errs		  = NULL;
	L_lex_start();
	lex_buffer	  = (void *)L__scan_bytes(str, len);

	L_parse();
	ASSERT(ast_p);
	*ast_p = L->ast;

	L__delete_buffer(lex_buffer);

	if (L->errs) {
		Tcl_SetObjResult(L->interp, L->errs);
		return (TCL_ERROR);
	}
	return (TCL_OK);
}

/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
private int
L_CompileScript(void *ast)
{
	int	ret = TCL_OK;
	TopLev	*toplev;
	static int ctr = 0;

	ASSERT(((Ast *)ast)->type == L_NODE_TOPLEVEL);

	L->toplev = cksprintf("%d%%l_toplevel", ctr++);

	/*
	 * Two frames get pushed, one for private globals that exist
	 * at file scope, and one for the top-level code.  See the
	 * comment in sym_store().
	 */
	frame_push(NULL, NULL, SCRIPT|SEARCH);
	frame_push(NULL, L->toplev, FUNC|TOPLEV|SKIP);

	/*
	 * Before compiling, enter prototypes for all functions into
	 * the global symbol table.
	 */
	for (toplev = (TopLev *)ast; toplev; toplev = toplev->next) {
		switch (toplev->kind) {
		    case L_TOPLEVEL_FUN:
			compile_fnDecl(toplev->u.fun, FN_PROTO_ONLY);
			break;
		    default:
			break;
		}
	}

	for (toplev = (TopLev *)ast; toplev; toplev = toplev->next) {
		switch (toplev->kind) {
		    case L_TOPLEVEL_CLASS:
			compile_clsDecl(toplev->u.class);
			break;
		    case L_TOPLEVEL_FUN:
			compile_fnDecl(toplev->u.fun, FN_PROTO_AND_BODY);
			break;
		    case L_TOPLEVEL_GLOBAL:
			compile_varDecls(toplev->u.global);
			break;
		    case L_TOPLEVEL_STMT:
			compile_stmts(toplev->u.stmt);
			break;
		    default:
			L_bomb("Unexpected toplevel stmt type %d", toplev->kind);
		}
	}

	push_str("");
	TclEmitOpcode(INST_DONE, L->frame->envPtr);
	frame_pop();
	frame_pop();

	if (L->errs) {
		Tcl_SetObjResult(L->interp, L->errs);
		return (TCL_ERROR);
	}

	if (L->options & L_OPT_NORUN) return (TCL_OK);

	/* Invoke the top-level code that was just compiled. */
	if (L->frame->envPtr) {
		push_str(L->toplev);
		emit_invoke(1);
	} else {
		ret = Tcl_Eval(L->interp, L->toplev);
	}
	return (ret);
}

private void
compile_clsDecl(ClsDecl *clsdecl)
{
	ASSERT(clsdecl->constructor);
	ASSERT(clsdecl->destructor);

	/*
	 * A class creates two scopes, one for the class symbols and
	 * the other for its top-level code (class variable
	 * initializers).  See the comments in sym_store().  The class
	 * symtab is persisted so it can be later retrieved from the
	 * class type to support obj->var or classname->var lookups.
	 */
	frame_push(NULL, NULL, CLS_OUTER|SEARCH|KEEPSYMS);
	clsdecl->symtab = L->frame->symtab;
	frame_push(NULL, NULL, CLS_TOPLEV|SKIP);

	frame_resumePrologue();
	push_str("::namespace");
	push_str("eval");
	push_str("::L::_class_%s", clsdecl->decl->id->u.string);
	push_str("variable __num 0");
	emit_invoke(4);
	emit_pop();
	frame_resumeBody();

	compile_varDecls(clsdecl->clsvars);
	/* Process function decls first, then compile the bodies. */
	compile_fnDecls(clsdecl->fns, FN_PROTO_ONLY);
	compile_fnDecl(clsdecl->constructor, FN_PROTO_ONLY);
	compile_fnDecl(clsdecl->destructor, FN_PROTO_ONLY);
	compile_fnDecl(clsdecl->constructor, FN_PROTO_AND_BODY);
	compile_fnDecl(clsdecl->destructor, FN_PROTO_AND_BODY);
	compile_fnDecls(clsdecl->fns, FN_PROTO_AND_BODY);

	frame_pop();
	frame_pop();
}

private void
compile_fnDecls(FnDecl *fun, Decl_f flags)
{
	for (; fun; fun = fun->next) {
		compile_fnDecl(fun, flags);
	}
}

private void
compile_fnDecl(FnDecl *fun, Decl_f flags)
{
	int	i, ismain;
	Expr	*self_id;
	VarDecl	*self_decl;
	VarDecl	*decl = fun->decl;
	char	*name = decl->id->u.string;
	char	*clsname = NULL;
	ClsDecl	*clsdecl = NULL;
	Sym	*self_sym = NULL;
	Sym	*sym;

	flags |= decl->flags;
	ismain = !strcmp(name, "main");

	ASSERT(fun && decl);
	ASSERT(!(flags & SCOPE_LOCAL));
	ASSERT(flags & (SCOPE_CLASS | SCOPE_GLOBAL | SCOPE_SCRIPT));
	ASSERT(flags & (DECL_FN | DECL_CLASS_FN));
	// DECL_CLASS_FN ==> DECL_PUBLIC | DECL_PRIVATE
	ASSERT(!(flags & DECL_CLASS_FN) ||
	       (flags & (DECL_PUBLIC | DECL_PRIVATE)));
	ASSERT(flags & (FN_PROTO_ONLY | FN_PROTO_AND_BODY));

	/*
	 * Sort out the possible error cases:
	 *
	 * - name illegal
	 * - name already declared as a variable
	 * - proto already declared and doesn't match this decl
	 * - this decl declares function body but body already declared
	 *
	 * with the exception that "main" is allowed to be re-declared.
	 */
	if (name[0] == '_') {
		L_errf(decl->id, "function names cannot begin with _");
	}
	if (!strcmp(name, "END")) {
		L_errf(decl->id, "cannot use END for function name");
	} else if (!strcmp(name, "undef")) {
		L_errf(decl->id, "cannot use undef for function name");
	}
	for (i = 0; i < sizeof(builtins)/sizeof(builtins[0]); ++i) {
		if (!strcmp(builtins[i].name, name)) {
			L_errf(decl->id,
			       "function '%s' conflicts with built-in",
			       name);
			return;
		}
	}
	sym = sym_lookup(decl->id, L_NOWARN|L_NOTUSED);
	if (sym && !ismain) {
		unless (sym->kind & L_SYM_FN) {
			L_errf(fun, "%s already declared as a variable",name);
			return;
		} else if ((sym->kind & L_SYM_FNBODY) && fun->body) {
			L_errf(fun, "function %s already declared", name);
			return;
		} else unless (L_typeck_same(decl->type, sym->type)) {
			L_errf(fun, "does not match other declaration of %s",
			       name);
			return;
		}
	} else unless (ismain && (flags & FN_PROTO_ONLY)) {
		sym = sym_store(decl);
		unless (sym) return;
	}

	/* Check arg and return types for legality. */
	L_typeck_declType(decl);

	if (!fun->body || (flags & FN_PROTO_ONLY)) return;

	frame_push(fun, sym->tclname, FUNC|SEARCH);
	sym->kind |= L_SYM_FNBODY;
	L->frame->block = (Ast *)fun;

	compile_fnParms(decl);

	/* Gather class decl and name, for class member functions. */
	clsdecl = fun->decl->clsdecl;
	if (clsdecl) clsname = clsdecl->decl->id->u.string;

	/*
	 * For private class member fns and the constructor, declare
	 * the local variable "self".  For public member fns, lookup
	 * "self" which is required to be the first parameter (and is
	 * added by compile_fnParms if not present).
	 */
	if (isClsConstructor(decl) || isClsFnPrivate(decl)) {
		self_id   = ast_mkId("self", 0, 0);
		self_decl = ast_mkVarDecl(clsdecl->decl->type, self_id, 0, 0);
		self_decl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
		self_sym  = sym_store(self_decl);
		ASSERT(self_sym && self_sym->idx >= 0);
		self_sym->used_p = TRUE;
	} else if (isClsFnPublic(decl)) {
		self_sym = sym_lookup(ast_mkId("self", 0, 0), L_NOWARN);
		ASSERT(self_sym && self_sym->idx >= 0);
	}

	/*
	 * For the constructor, before compiling the user's
	 * constructor body, emit code to increment the class instance
	 * #, set "self" to the namespace name of the class instance,
	 * create the namespace, then compile the instance-variable
	 * initializers.  Basically this:
	 *
	 *     incrStkImm ::L::_class_<cls_name>::__num
	 *     set self ::L::_instance_<cls_name>${__num}
	 *     namespace eval $self {}
	 *     ...instance variable initializers...
	 *     ...user's constructor body...
	 */
	if (isClsConstructor(decl)) {
		frame_resumePrologue();
		ASSERT(clsdecl && clsname && self_sym);
		push_str("::L::_class_%s::__num", clsname);
		TclEmitInstInt1(INST_INCR_STK_IMM, 1, L->frame->envPtr);
		emit_pop();
		push_str("::namespace");
		push_str("eval");
		push_str("::L::_instance_%s", clsname);
		push_str("::L::_class_%s::__num", clsname);
		TclEmitOpcode(INST_LOAD_STK, L->frame->envPtr);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		emit_store_scalar(self_sym->idx);
		push_str("");
		emit_invoke(4);
		emit_pop();
		frame_resumeBody();
		compile_varDecls(clsdecl->instvars);
	}

	/*
	 * For private member functions, upvar "self" to the "self" in
	 * the calling frame.  This works because only other class member
	 * functions can call private member functions, and they have "self".
	 */
	if (isClsFnPrivate(decl)) {
		frame_resumePrologue();
		push_str("1");
		push_str("self");
		TclEmitInstInt4(INST_UPVAR, self_sym->idx, L->frame->envPtr);
		emit_pop();
		frame_resumeBody();
	}

	L->enclosing_func = fun;
	compile_block(fun->body);
	L->enclosing_func = NULL;

	/*
	 * For class destructor, delete the instance namespace.
	 */
	if (isClsDestructor(decl)) {
		ASSERT(self_sym);
		push_str("::namespace");
		push_str("delete");
		emit_load_scalar(self_sym->idx);
		emit_invoke(3);
		emit_pop();
	}

	/*
	 * Emit a "fall off the end" implicit return for void
	 * functions.  Class constructors return the value of "self".
	 * Non-void functions throw an exception if you fall
	 * off the end.
	 */
	if (isClsConstructor(decl)) {
		emit_load_scalar(self_sym->idx);
		TclEmitOpcode(INST_DONE, L->frame->envPtr);
	} else if (isvoidtype(decl->type->base_type)) {
		push_str("");
		TclEmitOpcode(INST_DONE, L->frame->envPtr);
	} else {
		push_str("::throw");
		push_str("{FUNCTION NO-RETURN-VALUE "
			 "{no value returned from function}}");
		push_str("no value returned from function");
		emit_invoke(3);
	}

	frame_pop();
}

/*
 * Push a semantic-stack frame.  If flags & FUNC, start a new proc
 * too.  To support the delayed generation of proc prologue code, we
 * allocate two CompileEnv's, one for the proc body and one for its
 * prologue.  You switch between the two with frame_resumePrologue()
 * and frame_resumeBody().  A jump is emitted at the head of the proc
 * that jumps to the end, and when the proc is done being compiled,
 * the prologue code is emitted at the end along with a jump back.
 * This provides a way to lazily output proc initialization code, such
 * as the upvars for accessing globals and class variables.
 */
private void
frame_push(void *node, char *name, Frame_f flags)
{
	Frame	*frame;
	Proc	*proc;
	CompileEnv *bodyEnvPtr, *prologueEnvPtr;

	frame = (Frame *)ckalloc(sizeof(Frame));
	memset(frame, 0, sizeof(*frame));
	frame->flags  = flags;
	frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(frame->symtab, TCL_STRING_KEYS);
	frame->labeltab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(frame->labeltab, TCL_STRING_KEYS);
	frame->prevFrame = L->frame;
	L->frame = frame;

	unless (frame->flags & FUNC) {
		frame->block = node;
		if (frame->prevFrame) {
			frame->envPtr = frame->prevFrame->envPtr;
			frame->bodyEnvPtr = frame->prevFrame->bodyEnvPtr;
			frame->prologueEnvPtr = frame->prevFrame->prologueEnvPtr;
		}
		return;
	}

	bodyEnvPtr     = (CompileEnv *)ckalloc(sizeof(CompileEnv));
	prologueEnvPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
	frame->bodyEnvPtr = bodyEnvPtr;
	frame->prologueEnvPtr = prologueEnvPtr;
	frame->envPtr = bodyEnvPtr;

	proc = (Proc *)ckalloc(sizeof(Proc));
	proc->iPtr		= (struct Interp *)L->interp;
	proc->refCount		= 1;
	proc->numArgs		= 0;
	proc->numCompiledLocals = 0;
	proc->firstLocalPtr     = NULL;
	proc->lastLocalPtr      = NULL;
	proc->bodyPtr		= Tcl_NewObj();
	Tcl_IncrRefCount(proc->bodyPtr);
	TclInitCompileEnv(L->interp, bodyEnvPtr, TclGetString(L->script),
			  L->script_len, NULL, 0);
	bodyEnvPtr->procPtr = proc;

	TclInitCompileEnv(L->interp, prologueEnvPtr, NULL, 0, NULL, 0);

	frame->proc = proc;
	frame->name = name;

	/*
	 * Emit a jump to what will eventually be the prologue code
	 * (output by frame_pop()).
	 */
	frame->end_jmp  = emit_jmp_fwd(INST_JUMP4);
	frame->proc_top = currOffset(frame->envPtr);
}

private void
frame_resumePrologue()
{
	L->frame->envPtr = L->frame->prologueEnvPtr;
}

private void
frame_resumeBody()
{
	L->frame->envPtr = L->frame->bodyEnvPtr;
}

private void
frame_pop()
{
	int	off;
	Frame	*frame = L->frame;
	Proc	*proc  = frame->proc;
	Sym	*sym;
	Label	*label;
	Tcl_HashEntry *hPtr;
	Tcl_HashSearch hSearch;

	/*
	 * Emit proc prologue code and the jump back to the head of
	 * the proc.  Splice in any code in the frame->prologueEnvPtr
	 * CompileEnv.  This is dependent on CompileEnv details.
	 */
	if (frame->flags & FUNC) {
		CompileEnv	*body = frame->bodyEnvPtr;
		CompileEnv	*prologue = frame->prologueEnvPtr;
		int		len = prologue->codeNext - prologue->codeStart;

		ASSERT(frame->envPtr == frame->bodyEnvPtr);

		fixup_jmps(frame->end_jmp);
		while ((body->codeNext + len) >= body->codeEnd) {
			TclExpandCodeArray(body);
		}
		memcpy(body->codeNext, prologue->codeStart, len);
		body->codeNext += len;
		if (prologue->maxStackDepth > body->maxStackDepth) {
			body->maxStackDepth = prologue->maxStackDepth;
		}
		off = currOffset(frame->envPtr);
		TclEmitInstInt4(INST_JUMP4, frame->proc_top-off, frame->envPtr);
	}

	/*
	 * Check for unused local symbols, and free the frame's symbol table.
	 */
	for (hPtr = Tcl_FirstHashEntry(frame->symtab, &hSearch);
	     hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		sym = (Sym *)Tcl_GetHashValue(hPtr);
		unless (sym->used_p || !(sym->kind & L_SYM_LVAR) ||
			(sym->decl->flags & DECL_UNUSED)) {
			L_warnf(sym->decl, "%s unused", sym->name);
		}
		unless (frame->flags & KEEPSYMS) {
			ckfree(sym->name);
			ckfree(sym->tclname);
			ckfree((char *)sym);
		}
	}
	unless (frame->flags & KEEPSYMS) {
		Tcl_DeleteHashTable(frame->symtab);
		ckfree((char *)frame->symtab);
	}

	/*
	 * Check for unresolved labels, and free the frame's label table.
	 */
	for (hPtr = Tcl_FirstHashEntry(frame->labeltab, &hSearch);
	     hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		label = (Label *)Tcl_GetHashValue(hPtr);
		unless (label->offset >= 0) {
			L_err("label %s referenced but not defined",
			      label->name);
		}
		ckfree(label->name);
		ckfree((char *)label);
	}
	Tcl_DeleteHashTable(frame->labeltab);
	ckfree((char *)frame->labeltab);

	/*
	 * Create the Tcl command and free the old frame.
	 */
	if (frame->flags & FUNC) {
		TclInitByteCodeObj(proc->bodyPtr, frame->envPtr);
#ifdef TCL_COMPILE_DEBUG
		if (getenv("L_DISASSEMBLE")) {
			printf("Bytecode for %s:\n", frame->name);
			TclPrintByteCodeObj(L->interp, proc->bodyPtr);
		}
#endif
		proc->cmdPtr = (Command *)Tcl_CreateObjCommand(L->interp,
							frame->name,
							TclObjInterpProc,
							(ClientData)proc,
							TclProcDeleteProc);
		TclFreeCompileEnv(frame->bodyEnvPtr);
		TclFreeCompileEnv(frame->prologueEnvPtr);
		ckfree((char *)frame->bodyEnvPtr);
		ckfree((char *)frame->prologueEnvPtr);
	}

	L->frame = frame->prevFrame;
	ckfree((char *)frame);
}

private Frame *
frame_find(Frame_f flags)
{
	Frame	*f = L->frame;

	ASSERT(f);
	while (!(f->flags & flags)) f = f->prevFrame;
	return (f);
}

private void
compile_varDecl(VarDecl *decl)
{
	int	start_off = currOffset(L->frame->envPtr);
	char	*name;
	Sym	*sym;

	ASSERT(decl->id && decl->type);

	name = decl->id->u.string;

	unless (L_typeck_declType(decl)) return;

	if (decl->flags & DECL_LOCAL_VAR) {
		if (name[0] == '_') {
			L_errf(decl,
			       "local variable names cannot begin with _");
		}
		if (decl->flags & (DECL_PRIVATE | DECL_PUBLIC)) {
			L_errf(decl,
			       "public/private qualifiers illegal for locals");
			decl->flags &= ~(DECL_PRIVATE | DECL_PUBLIC);
		}
	}
	if (!strcmp(name, "END")) {
		L_errf(decl, "cannot use END for variable name");
		return;
	} else if (!strcmp(name, "undef")) {
		L_errf(decl, "cannot use undef for variable name");
		return;
	}
	if ((decl->type->kind == L_CLASS) &&
	    !strcmp(name, decl->type->u.class.clsdecl->decl->id->u.string)) {
		L_errf(decl, "cannot declare object with same name as class");
	}

	sym = sym_store(decl);
	unless (sym) return;  // bail if multiply declared

	if (decl->flags & DECL_EXTERN) {
		if (decl->initializer) {
			L_errf(decl, "extern initializers illegal");
		}
		unless (L->frame->flags & TOPLEV) {
			L_errf(decl, "externs legal only at global scope");
		}
		sym->used_p = TRUE;  // to suppress extraneous warning
		return;
	}

	unless (decl->initializer) {
		decl->initializer = ast_mkBinOp(L_OP_EQUALS,
						decl->id,
						ast_mkId("undef",0,0),
						decl->node.beg,
						decl->node.end);
	}
	compile_expr(decl->initializer, L_DISCARD);
	/* Mark var as unused even though it was just initialized. */
	sym->used_p = FALSE;

	track_cmd(start_off, decl);
}

private void
compile_varDecls(VarDecl *decls)
{
	for (; decls; decls = decls->next) {
		compile_varDecl(decls);
	}
}

private void
compile_stmt(Stmt *stmt)
{
	int	start_off = currOffset(L->frame->envPtr);

	unless (stmt) return;
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
		frame_push(stmt, NULL, SEARCH);
		compile_block(stmt->u.block);
		frame_pop();
		break;
	    case L_STMT_EXPR:
		compile_exprs(stmt->u.expr, L_DISCARD);
		break;
	    case L_STMT_COND:
		compile_ifUnless(stmt->u.cond);
		break;
	    case L_STMT_LOOP:
		compile_loop(stmt->u.loop);
		break;
	    case L_STMT_FOREACH:
		compile_foreach(stmt->u.foreach);
		break;
	    case L_STMT_RETURN:
		compile_return(stmt);
		break;
	    case L_STMT_BREAK:
		compile_break(stmt);
		break;
	    case L_STMT_CONTINUE:
		compile_continue(stmt);
		break;
	    case L_STMT_LABEL:
		compile_label(stmt);
		break;
	    case L_STMT_GOTO:
		compile_goto(stmt);
		break;
	    default:
		L_bomb("Malformed AST in compile_stmt");
	}
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
	    case L_STMT_COND:
	    case L_STMT_EXPR:
		break;
	    default:
		track_cmd(start_off, stmt);
		break;
	}
}

private void
compile_stmts(Stmt *stmts)
{
	for (; stmts; stmts = stmts->next) {
		compile_stmt(stmts);
	}
}

private void
compile_block(Block *block)
{
	compile_varDecls(block->decls);
	compile_stmts(block->body);
}

private void
compile_return(Stmt *stmt)
{
	VarDecl	*decl;
	Type	*ret_type;

	/* Handle return from the top level. */
	unless (L->enclosing_func) {
		if (stmt->u.expr) {
			compile_expr(stmt->u.expr, L_PUSH_VAL);
		} else {
			push_str("");
		}
		TclEmitOpcode(INST_DONE, L->frame->envPtr);
		return;
	}

	decl     = L->enclosing_func->decl;
	ret_type = decl->type->base_type;

	if (isvoidtype(ret_type) && (stmt->u.expr)) {
		L_errf(stmt, "void function cannot return value");
		compile_expr(stmt->u.expr, L_DISCARD);
	} else if (stmt->u.expr) {
		compile_expr(stmt->u.expr, L_PUSH_VAL);  // return value
		unless (L_typeck_compat(ret_type, stmt->u.expr->type)) {
			L_errf(stmt, "incompatible return type");
		} else if (isClsConstructor(decl) &&
			   !isid(stmt->u.expr, "self")) {
			L_errf(stmt, "class constructor must return 'self'");
		}
	} else unless (isvoidtype(ret_type)) {
		L_errf(stmt, "must specify return value");
	} else {
		push_str("");  // no return value -- push a ""
	}

	TclEmitOpcode(INST_DONE, L->frame->envPtr);
}

private void
proc_mkArg(Proc *proc, VarDecl *decl)
{
	int	argnum;
	char	*name = decl->id->u.string;
	CompiledLocal *local;

	argnum = proc->numArgs++;
	++proc->numCompiledLocals;
	local = (CompiledLocal *)ckalloc(sizeof(CompiledLocal) -
					 sizeof(local->name) +
					 strlen(name) + 1);
	if (proc->firstLocalPtr == NULL) {
		proc->firstLocalPtr = local;
		proc->lastLocalPtr  = local;
	} else {
		proc->lastLocalPtr->nextPtr = local;
		proc->lastLocalPtr = local;
	}
	local->nextPtr     = NULL;
	local->resolveInfo = NULL;
	local->defValuePtr = NULL;
	local->frameIndex  = argnum;
	local->nameLength  = strlen(name);
	strcpy(local->name, name);

	local->flags = VAR_ARGUMENT;
	if (decl->flags & DECL_REST_ARG) local->flags |= VAR_IS_ARGS;
}

/*
 * Determine whether the parameter-passing mode for a formal parameter
 * declaration is call-by-reference.  Return NULL or the base type of
 * the parameter (without the name-of).  You get call-by-reference if
 * the parameter was declared with & and is not a function pointer.
 */
private Type *
iscallbyname(VarDecl *formal)
{
	unless (formal) return (NULL);
	if (formal->flags & DECL_REF) {
		if (isfntype(formal->type->base_type)) {
			return (NULL);
		} else {
			return (formal->type->base_type);
		}
	}
	return (NULL);
}

private void
compile_fnParms(VarDecl *decl)
{
	int	i;
	int	name_parms = 0;
	char	*name;
	Proc	*proc = L->frame->envPtr->procPtr;
	VarDecl	*p;
	VarDecl	*new_decl = NULL;
	Sym	*new_sym, *sym;
	Expr	*new_id;
	Type	*type;
	VarDecl	*param = decl->type->u.func.formals;

	proc->numArgs = 0;
	proc->numCompiledLocals = 0;

	/*
	 * Public class member fns (except constructor) must have "self"
	 * as the first arg and it must be of the class type.
	 */
	if (isClsFnPublic(decl) && !isClsConstructor(decl)) {
		Type	*clstype = decl->clsdecl->decl->type;
		Expr	*self_id;
		VarDecl	*self_decl;
		if (!param||!param->id || strcmp(param->id->u.string, "self")) {
			L_errf(decl->id, "class public member function lacks "
			       "'self' as first arg");
			/* Add it so we can keep compiling. */
			self_id   = ast_mkId("self", 0, 0);
			self_decl = ast_mkVarDecl(clstype, self_id, 0, 0);
			self_decl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
			self_decl->next = param;
			param = self_decl;
		} else if (param->type != clstype) {
			L_errf(param, "'self' parameter must be of class type");
		}
	}

	/*
	 * To handle call-by-name formals, make two passes through the
	 * formals list.  In the first pass, mangle any formal name to
	 * "&name".  In the second pass, for formals only, create a
	 * local "name" as an upvar to the variable one frame up whose
	 * name is passed in the arg.  Note that the formal will have
	 * type "name-of <t>" and the local gets type <t>.  This is
	 * needed since Tcl requires the locals to follow the args.
	 */
	for (p = param, i = 0; p; p = p->next, i++) {
		unless (p->id) {
			L_errf(p, "formal parameter #%d lacks a name", i+1);
			name = cksprintf("unnamed-arg-%d", i+1);
			p->id = ast_mkId(name, 0, 0);
		}
		name = p->id->u.string;
		if (isClsConstructor(decl) && !strcmp(name, "self")) {
			L_errf(p,
			       "'self' parameter illegal in class constructor");
			continue;
		}
		if ((p->flags & DECL_REST_ARG) && (p->next)) {
			L_errf(p, "Rest parameter must be last");
		}
		if (iscallbyname(p)) {
			name = cksprintf("&%s", p->id->u.string);
			ckfree(p->id->u.string);
			p->id->u.string = name;
			++name_parms;
		}
		proc_mkArg(proc, p);
		sym = sym_store(p);
		unless (sym) continue;  // multiple declaration
		sym->idx = i;
		/* Suppress unused warning for obj arg to class member fns. */
		if ((p == param) &&
		    isClsFnPublic(decl) && !isClsConstructor(decl)) {
			sym->used_p = TRUE;
		}
	}
	/* For call by name, push a 1 the first time (arg to INST_UPVAR). */
	if (name_parms) push_str("1");
	for (p = param; p; p = p->next) {
		/* If the formal is &p, type gets the type of p. */
		type = iscallbyname(p);
		unless (type) continue;
		ASSERT(p->id->u.string[0] == '&');
		name = ckstrdup(p->id->u.string + 1);  // point past the &
		new_id   = ast_mkId(name, p->id->node.beg, p->id->node.end);
		new_decl = ast_mkVarDecl(type, new_id, p->node.beg,
					 p->node.end);
		new_decl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR | p->flags;
		new_decl->node.line = p->node.line;

		sym = sym_lookup(p->id, L_NOWARN);
		ASSERT(sym);

		new_sym = sym_store(new_decl);
		unless (new_sym) continue;  // multiple declaration

		i = TclFindCompiledLocal(name, strlen(name), 1,
					 L->frame->envPtr);
		emit_load_scalar(sym->idx);
		TclEmitInstInt4(INST_UPVAR, i, L->frame->envPtr);
	}
	/* Pop the 1 pushed for INST_UPVAR. */
	if (name_parms) emit_pop();
}

private int
compile_rename(Expr *expr)
{
	int	n;

	push_str("frename");
	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 2) {
		L_errf(expr, "incorrect # args for rename");
	}
	emit_invoke(3);
	expr->type = L_int;
	return (1);  // stack effect
}

private int
compile_split(Expr *expr)
{
	int n = compile_exprs(expr->b, L_PUSH_VAL);
	if ((n < 1) || (n > 3)) {
		L_errf(expr, "incorrect # args for split");
	}
	TclEmitInstInt1(INST_L_SPLIT, n, L->frame->envPtr);
	expr->type = type_mkArray(0, L_string, PER_INTERP);
	return (1);  // stack effect
}

private int
compile_push(Expr *expr)
{
	int	i, idx;
	Expr	*arg, *array;

	unless (expr->b && expr->b->next) {
		L_errf(expr, "incorrect # arguments to push");
		goto done;
	}
	array = expr->b->a;
	arg   = expr->b->next;
	compile_expr(array, L_DISCARD);
	unless (isaddrof(expr->b) && array && (isarray(array)||ispoly(array))) {
		L_errf(expr, "first arg to push not an array reference (&)");
		goto done;
	}
	unless (array->sym) {
		L_errf(expr, "invalid l-value in push");
		goto done;
	}
	idx = array->sym->idx;  // local slot # for array
	for (i = 2; arg; arg = arg->next, ++i) {
		compile_expr(arg, L_PUSH_VAL);
		unless (L_typeck_compat(array->type->base_type, arg->type)) {
			L_errf(expr,
			 "arg #%d to push has type incompatible with array", i);
		}
		if (idx <= 255) {
			TclEmitInstInt1(INST_LAPPEND_SCALAR1, idx,
					L->frame->envPtr);
		} else {
			TclEmitInstInt4(INST_LAPPEND_SCALAR4, idx,
					L->frame->envPtr);
		}
		emit_pop();
	}
 done:
	expr->type = L_void;
	return (0);  // stack effect
}

private int
compile_keys(Expr *expr)
{
	int	n;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 1) {
		L_errf(expr, "incorrect # args to keys");
		expr->type = L_poly;
		return (0);  // stack effect
	}
	unless (ishash(expr->b) || ispoly(expr->b)) {
		L_errf(expr, "arg to keys is not a hash");
		expr->type = L_poly;
		return (0);  // stack effect
	}
	push_str("::dict");
	push_str("keys");
	TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
	emit_invoke(3);
	if (ispoly(expr->b)) {
		expr->type = L_poly;
	} else {
		expr->type = type_mkArray(0,
					  expr->b->type->u.hash.idx_type,
					  PER_INTERP);
	}
	return (1);  // stack effect
}

private int
compile_length(Expr *expr)
{
	int	n;

	expr->type = L_int;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 1) {
		L_errf(expr, "incorrect # args to length");
		return (0);  // stack effect
	}
	if (isstring(expr->b)) {
		push_str("::string");
		push_str("length");
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		emit_invoke(3);
	} else if (isarray(expr->b) || islist(expr->b) || ispoly(expr->b)) {
		push_str("::llength");
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		emit_invoke(2);
	} else if (ishash(expr->b)) {
		push_str("::dict");
		push_str("size");
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		emit_invoke(3);
	} else {
		L_errf(expr, "arg to length has illegal type");
	}
	return (1);  // stack effect
}

private int
compile_sort(Expr *expr)
{
	int	i, n;
	Expr	*l;
	Type	*t;

	/*
	 * Do some gymnastics to get this on the run-time stack:
	 * ::lsort
	 * <all args except last one>
	 * -integer, -real, or -ascii depending on list type
	 * <last arg (the thing to be sorted)>
	 */

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n >= 1) {
		L_errf(expr, "incorrect # args to sort");
		return (0);  // stack effect
	}
	/* Last argument to sort must be an array, list, or poly. */
	for (i = 0, l = expr->b; i < (n-1); ++i) l = l->next;
	if (isarray(l) || islist(l)) {
		t = l->type->base_type;
	} else if (ispoly(l)) {
		t = L_poly;
	} else {
		L_errf(expr, "last arg to sort not an array or list");
		return (0);  // stack effect
	}
	switch (t->kind) {
	    case L_INT:
		push_str("-integer");
		break;
	    case L_FLOAT:
		push_str("-real");
		break;
	    default:
		push_str("-ascii");
		break;
	}
	TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
	if (n > 255) L_errf(expr, "sort cannot have >255 args");
	push_str("::lsort");
	TclEmitInstInt1(INST_ROT, -(n+1), L->frame->envPtr);
	emit_invoke(n+2);
	expr->type = type_mkArray(0, t, PER_INTERP);
	return (1);  // stack effect
}

private int
compile_join(Expr *expr)
{
	int	n;
	Expr	*array;
	Expr	*sep;

	expr->type = L_string;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 2) {
		L_errf(expr, "incorrect # args to join");
		return (0);  // stack effect
	}
	sep   = expr->b;
	array = expr->b->next;
	unless (isstring(sep) || ispoly(sep)) {
		L_errf(expr, "first arg to join not a string");
		return (0);  // stack effect
	}
	unless (isarray(array) || islist(array) || ispoly(array)) {
		L_errf(expr, "second arg to join not an array or list");
		return (0);  // stack effect
	}
	TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
	push_str("::join");
	TclEmitInstInt1(INST_ROT, -n, L->frame->envPtr);
	emit_invoke(n+1);
	return (1);  // stack effect
}

private int
compile_assert(Expr *expr)
{
	Jmp	*jmp;
	char	*cond_txt;

	unless (expr->b && !expr->b->next) {
		L_errf(expr, "incorrect # args to assert");
		return (0);  // stack effect
	}
	compile_condition(expr->b);
	jmp = emit_jmp_fwd(INST_JUMP_TRUE4);
	cond_txt = get_text(expr->b);
	push_str("die");
	push_str("ASSERTION FAILED %s:%d: %s\n", expr->node.file,
		 expr->node.line, cond_txt);
	emit_invoke(2);
	emit_pop();
	ckfree(cond_txt);
	fixup_jmps(jmp);
	expr->type = L_void;
	return (0);  // stack effect
}

private int
compile_undef(Expr *expr)
{
	int	n;
	Expr	*arg = expr->b;

	n = compile_exprs(arg, L_PUSH_PTR | L_LVALUE);
	unless (n == 1) {
		L_errf(expr, "incorrect # args to undef");
		goto done;
	}
	unless (arg->sym) {
		L_errf(expr, "illegal l-value in undef()");
		goto done;
	}
	if (((arg->op == L_OP_DOT) || (arg->op == L_OP_POINTS)) &&
	    isstruct(arg->a)) {
		L_errf(expr, "cannot undef() a struct field");
		goto done;
	}
	/*
	 * If arg is a deep dive, delete the hash or array element.
	 * If arg is a variable, treat undef(var) like var=undef.
	 */
	if (arg->flags & L_EXPR_DEEP) {
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				arg->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(L_DELETE, L->frame->envPtr);
	} else {
		TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
		emit_store_scalar(arg->sym->idx);
		emit_pop();
	}
 done:
	expr->type = L_void;
	return (0);  // stack effect
}

/*
 * Return a copy of the source text for the given expression.  Caller
 * must free.
 */
private char *
get_text(Expr *expr)
{
	int	beg = expr->node.beg;
	int	end = expr->node.end;
	int	len = end - beg;
	char	*s;

	s = ckalloc(len + 1);
	strncpy(s, Tcl_GetString(L->script)+beg, len);
	s[len] = 0;
	return (s);
}

/*
 * Emit code to compute the value of the given expression.  The flags
 * say in what form the generated code should produce the value.  The
 * caller chooses these flags based on whether
 * 1. expr will be read, written, or both; and whether
 * 2. expr is a deep dive or something else (an object dereference,
 *    a variable, or an expression).
 * The flags are bit-masks (see below) and can be combined.
 *
 * Passing in one of the pointer flags means that IF the expr is a
 * deep dive, leave a deep-ptr to it and possibly also its value on
 * the run-time stack.  If the expr is not, evaluate it (so that
 * expr->sym etc is valid) but don't push anything.  You use this when
 * expr is an l-value.
 *
 * Passing in L_PUSH_VAL and none of the pointer flags means that
 * the expr's value is left on the stack.
 *
 * Passing in both L_PUSH_VAL and one of the pointer flags is done
 * when the caller needs a deep-ptr if expr is a deep dive but
 * just wants the value otherwise.  You use this when expr is
 * an l-value but you also need the r-value, such as when
 * compiling ++/-- or =~.
 *
 * Passing in L_PUSH_NAME means the fully qualified name of the
 * variable is left on the stack and is valid only for certain
 * kinds of variables (globals, locals, class variables, or class
 * instance variables).
 *
 * L_PUSH_VAL		push value onto stack, unless deep dive and
 *			you also request a deep-ptr
 * L_PUSH_PTR		if deep dive, push deep-ptr onto stack
 * L_PUSH_PTRVAL	if deep dive, push deep-ptr then value onto stack
 * L_PUSH_VALPTR	if deep dive, push value then deep-ptr onto stack
 * L_LVALUE		if deep dive, create an un-shared copy for writing
 * L_DISCARD		evaluate expr then discard its value
 * L_PUSH_NAME		push fully qualified name of variable, not the value
 */
private int
compile_expr(Expr *expr, Expr_f flags)
{
	int	n = 0;
	int	start_off = currOffset(L->frame->envPtr);

	/* The compile_xxx returns indicate whether they pushed anything. */
	unless (expr) return (0);
	switch (expr->kind) {
	    case L_EXPR_FUNCALL:
		n = compile_fnCall(expr);
		break;
	    case L_EXPR_CONST:
	    case L_EXPR_RE:
		n = push_lit(expr);
		break;
	    case L_EXPR_ID:
		n = compile_var(expr, flags);
		break;
	    case L_EXPR_UNOP:
		n = compile_unOp(expr);
		break;
	    case L_EXPR_BINOP:
		n = compile_binOp(expr, flags);
		break;
	    case L_EXPR_TRINOP:
		n = compile_trinOp(expr);
		break;
	    default:
		L_bomb("Unknown expression type %d", expr->kind);
	}

	/*
	 * Throw away the value if requested by the caller. This is done
	 * for expressions that are statements, in for-loop pre and
	 * post expressions, etc.
	 */
	if (flags & L_DISCARD) {
		while (n--) emit_pop();
	}

	if ((expr->kind == L_EXPR_UNOP)   || (expr->kind == L_EXPR_BINOP) ||
	    (expr->kind == L_EXPR_TRINOP) || (expr->kind == L_EXPR_FUNCALL)) {
		track_cmd(start_off, expr);
	}

	return (n);
}

/*
 * If a function-call name begins with a cap and has an _ inside, it
 * looks like a pattern call.  From a name like "Foo_barBazBlech"
 * create Expr const nodes "foo", "Foo_*" and a linked list of Expr
 * const nodes for "bar", "baz", and "blech".  Note that the returned
 * Expr's need not be freed explicitly since all AST nodes are
 * deallocated by the compiler.
 */
private int
ispatternfn(char *name, Expr **foo, Expr **Foo_star, Expr **opts, int *nopts)
{
	int	i;
	char	*buf, *p, *under;
	Expr	*e;

	unless ((name[0] >= 'A') && (name[0] <= 'Z') &&
		(p = strchr(name, '_')) && p[1]) {  // _ cannot be last
		return (FALSE);
	}

	under = p;
	*under = '\0';

	/* Build foo from Foo_bar. */
	buf = cksprintf("%s", name);
	buf[0] = tolower(buf[0]);
	*foo = ast_mkId(buf, 0, 0);
	ckfree(buf);

	/* Build Foo_* from Foo_bar. */
	buf = cksprintf("%s_*", name);
	*Foo_star = ast_mkId(buf, 0, 0);
	ckfree(buf);

	/* Build a list of bar,baz,blech nodes from barBazBlech. */
	++p;
	*opts  = NULL;
	*nopts = 0;
	while (*p) {
		*p = tolower(*p);
		buf = ckalloc(strlen(p) + 1);
		for (i = 0; *p && islower(*p); ++p, ++i) {
			buf[i] = *p;
		}
		buf[i] = 0;
		e = ast_mkConst(L_string, 0, 0);
		e->u.string = buf;
		APPEND_OR_SET(Expr, next, *opts, e);
		++(*nopts);
	}

	*under = '_';

	return (TRUE);
}

/*
 * Rules for compiling a function call like "foo(arg)":
 *
 * - If foo is a variable of type name-of function, assume it contains
 *   the name of the function to call.
 *
 * - Otherwise call foo.  If foo isn't declared, that's OK, we just
 *   won't have a prototype to type-check against.
 *
 * For a function call like "Foo_bar(a,b,c)" or "Foo_barBazBlech(a,b,c)",
 * where the name starts with [A-Z] and has an _ in it (except at the
 * end), we have what's called a "pattern function".  The "bar", "baz",
 * and "blech" are the "options", and "a", "b", and "c" are the "arguments".
 *
 * - If Foo_bar happens to be a declared function, handle as above.
 *
 * - If the function Foo_* is defined, change the call to
 *   Foo_*(bar,baz,blech,a,b,c).
 *
 * - If "a" is not of widget type, change the call to
 *   foo(bar,baz,blech,a,b,c).
 *
 * - If "a" is a widget type, change the call to *a(bar,baz,blech,b,c)
 *   where *a means that the value of the argument "a" becomes the
 *   function name.
 */
private int
compile_fnCall(Expr *expr)
{
	int	expand, i, nopts;
	int	num_parms = 0;
	int	typchk = FALSE;
	char	*name;
	Expr	*foo, *Foo_star, *opts, *p;
	Sym	*sym;
	VarDecl	*formals = NULL;

	ASSERT(expr->a->kind == L_EXPR_ID);
	name = expr->a->u.string;

	/* Check for an L built-in function. */
	for (i = 0; i < sizeof(builtins)/sizeof(builtins[0]); ++i) {
		if (!strcmp(builtins[i].name, name)) {
			return (builtins[i].fn(expr));
		}
	}

	/* Check for an (expand) or (expand all) in the arg list. */
	expand = 0;
	for (p = expr->b; p; p = p->next) {
		if (isexpand(p)) {
			TclEmitOpcode(INST_EXPAND_START, L->frame->envPtr);
			expand = 1;
			break;
		}
	}

	sym = sym_lookup(expr->a, L_NOWARN);

	if (sym && isfntype(sym->type)) {
		/* A regular call -- the name is the fn name. */
		push_str(sym->tclname);
		formals = sym->type->u.func.formals;
		typchk = TRUE;
		expr->type = sym->type->base_type;
	} else if (sym && (sym->type->kind == L_NAMEOF) &&
		   (sym->type->base_type->kind == L_FUNCTION)) {
		/*
		 * Name is a function "pointer".  It holds the function
		 * name and its type is the function proto.
		 */
		emit_load_scalar(sym->idx);
		formals = sym->type->base_type->u.func.formals;
		typchk = TRUE;
		expr->type = sym->type->base_type->base_type;
	} else if (sym) {
		/* Name is declared but isn't a function or fn pointer. */
		L_errf(expr, "'%s' is declared but not as a function", name);
		expr->type = L_poly;
	} else if (ispatternfn(name, &foo, &Foo_star, &opts, &nopts)) {
		/* Pattern function.  Figure out which kind. */
		if ((sym = sym_lookup(Foo_star, L_NOWARN))) {
			/* Foo_* is defined -- compile Foo_*(opts,a,b,c). */
			push_str(Foo_star->u.string);
			APPEND(Expr, next, opts, expr->b);
			expr->b = opts;
			formals = sym->type->u.func.formals;
			typchk = TRUE;
			expr->type = sym->type->base_type;
		} else {
			/* Push first arg, then check its type. */
			compile_expr(expr->b, L_PUSH_VAL);
			if (!expr->b) {
				/* No args, compile as foo(opts). */
				push_str(foo->u.string);
				num_parms = push_parms(opts);
			} else if (iswidget(expr->b)) {
				/* Compile as *a(opts,b,c). */
				APPEND(Expr, next, opts, expr->b->next);
				expr->b = opts;
			} else {
				/* Compile as foo(opts,a,b,c). */
				// a
				push_str(foo->u.string);
				num_parms = push_parms(opts);
				ASSERT(num_parms == nopts);
				// a foo <opts>
				TclEmitInstInt1(isexpand(expr->b)?
						    INST_EXPAND_ROT : INST_ROT,
						nopts + 1,
						L->frame->envPtr);
				// foo <opts> a
				expr->b = expr->b->next;
				++num_parms;
			}
			expr->type = L_poly;
		}
	} else {
		/* Call to an undeclared function. */
		push_str(name);
		expr->type = L_poly;
	}
	num_parms += push_parms(expr->b);
	if (expand) {
		emit_invoke_expanded();
	} else {
		emit_invoke(num_parms+1);
	}
	if (typchk) L_typeck_fncall(formals, expr);
	return (1);  // stack effect
}

private int
compile_var(Expr *expr, Expr_f flags)
{
	Sym	*self, *sym;

	ASSERT(expr->op == L_EXPR_ID);

	/* Check for pre-defined identifiers first. */
	if (!strcmp(expr->u.string, "END")) {
		if (L->idx_nesting) {
			TclEmitOpcode(INST_L_READ_SIZE, L->frame->envPtr);
		} else {
			L_errf(expr,
			       "END illegal outside of a string or array index");
		}
		expr->type = L_int;
		return (1);
	} else if (!strcmp(expr->u.string, "undef")) {
		TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
		expr->type = L_poly;
		return (1);
	} else if (!strcmp(expr->u.string, "__FILE__")) {
		push_str(expr->node.file);
		expr->type = L_string;
		return (1);
	} else if (!strcmp(expr->u.string, "__LINE__")) {
		push_str("%d", expr->node.line);
		expr->type = L_int;
		return (1);
	}

	unless ((sym = sym_lookup(expr, flags))) {
		// Undeclared variable.
		expr->type = L_poly;
		return (1);
	}
	expr->type = sym->type;
	if (flags & L_PUSH_VAL) {
		emit_load_scalar(sym->idx);
		return (1);
	} else if (flags & L_PUSH_NAME) {
		switch (canDeref(sym)) {
		    case DECL_GLOBAL_VAR:
			if (sym->decl->flags & DECL_PRIVATE) {
				push_str("::_%s_%s", L->toplev, sym->name);
			} else {
				push_str("::%s", sym->name);
			}
			break;
		    case DECL_LOCAL_VAR:
		    case DECL_FN:
			push_str(sym->tclname);
			break;
		    case DECL_CLASS_VAR:
			push_str("::L::_class_%s::%s",
				 sym->decl->clsdecl->decl->id->u.string,
				 sym->name);
			break;
		    case DECL_CLASS_INST_VAR:
			self = sym_lookup(ast_mkId("self", 0, 0), L_NOWARN);
			ASSERT(self);
			emit_load_scalar(self->idx);
			push_str("::%s", sym->name);
			TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
			break;
		    default:
			ASSERT(0);
		}
		return (1);
	} else {
		/* Push nothing. */
		return (0);
	}
	/* Not reached. */
	ASSERT(0);
	return (1);
}

private int
compile_exprs(Expr *expr, Expr_f flags)
{
	int	num_exprs;

	for (num_exprs = 0; expr; expr = expr->next, ++num_exprs) {
		compile_expr(expr, flags);
	}
	return (num_exprs);
}

/*
 * Emit code to push the parameters to a function call and return the
 * # pushed.  Rules:
 *
 * - For two consecutive parms like "-foovariable, &foo", push "-foovariable"
 *   and then an L pointer.
 *
 * - For everything else, push the value or name as indicated by whether
 *   the parm has the & operator; compile_expr() handles that.  The type
 *   checker sorts out any mis-matches with the declared formals.
 */
private int
push_parms(Expr *actuals)
{
	int	i = 0;
	int	widget_flag = FALSE;
	int	strlen_of_variable = strlen("variable");
	char	*s;
	Expr	*a;

	for (i = 0, a = actuals; a; a = a->next, ++i) {
		if (widget_flag && isaddrof(a)) {
			push_pointer(a);
		} else {
			compile_expr(a, L_PUSH_VAL);
		}
		s = a->u.string;
		widget_flag = ((a->kind == L_EXPR_CONST) &&
		    isstring(a) &&
		    /* has at least the minimum length */
		    (strlen(s) > strlen_of_variable) &&
		    /* starts with '-' */
		    (s[0] == '-') &&
		    /* ends with "variable" */
		    !strcmp("variable", s + (strlen(s) - strlen_of_variable)));
	}
	return (i);
}

private void
push_pointer(Expr *expr)
{
	Expr	*e = expr->a;

	/*
	 * Only the following are legal for an L pointer:
	 *
	 * &global_var
	 * &classname->var
	 * &object->var
	 */
	compile_expr(e, L_PUSH_NAME);
	expr->type = L_poly;
	unless (e->sym) return;  // not a variable, or undeclared variable
	/* can't use local vars or functions from a widget */
	if ((e->sym->decl->flags & (DECL_LOCAL_VAR | DECL_FN)) ||
	    !canDeref(e->sym)) {
		L_errf(expr, "illegal operand to &");
	}
}

private int
push_lit(Expr *expr)
{
	switch (expr->type->kind) {
	    case L_STRING:
	    case L_POLY:
	    case L_CLASS:
		push_str("%s", expr->u.string);
		break;
	    case L_INT:
		push_str("%lu", expr->u.integer);
		break;
	    case L_FLOAT:
		push_str("%f", expr->u.flote);
		break;
	    default:
		ASSERT(0);
		break;
	}
	return (1);  // stack effect
}

private int
compile_unOp(Expr *expr)
{
	switch (expr->op) {
	    case L_OP_BANG:
	    case L_OP_BITNOT:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->a, "in unary ! or ~");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_UPLUS:
	    case L_OP_UMINUS:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_expect(L_INT|L_FLOAT, expr->a, "in unary +/-");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_DEFINED:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_deny(L_VOID, expr->a);
		TclEmitOpcode(INST_L_DEFINED, L->frame->envPtr);
		expr->type = L_int;
		break;
	    case L_OP_ADDROF:
		/*
		 * Compile &var -- push the name of var.  This
		 * works for function names, regular variables, and
		 * class variables (&x, &classname->var, &obj->var).
		 */
		compile_expr(expr->a, L_PUSH_NAME);
		if (!(expr->a->flags & L_EXPR_DEEP) &&
		    (expr->a->sym && canDeref(expr->a->sym))) {
			expr->type = type_mkNameOf(expr->a->type, PER_INTERP);
		} else {
			L_errf(expr, "illegal operand to &");
			expr->type = L_poly;
		}
		break;
	    case L_OP_PLUSPLUS_PRE:
	    case L_OP_PLUSPLUS_POST:
	    case L_OP_MINUSMINUS_PRE:
	    case L_OP_MINUSMINUS_POST:
		compile_incdec(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_EXPAND:
		compile_expr(expr->a, L_PUSH_VAL);
		TclEmitInstInt4(INST_EXPAND_STKTOP,
				L->frame->envPtr->currStackDepth,
				L->frame->envPtr);
		expr->type = L_poly;
		break;
	    case L_OP_EXPAND_ALL:
		compile_expr(expr->a, L_PUSH_VAL);
		TclEmitInstInt4(INST_EXPAND_STKTOP_RECURSE,
				L->frame->envPtr->currStackDepth,
				L->frame->envPtr);
		expr->type = L_poly;
		break;
	    case L_OP_CMDSUBST:
		push_str("::system");
		if (expr->a) {
			compile_expr(expr->a, L_PUSH_VAL);
			push_str(expr->u.string);
			TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		} else {
			push_str(expr->u.string);
		}
		emit_invoke(2);
		expr->type = L_string;
		break;
	    default:
		L_bomb("Unknown unary operator %d", expr->op);
		break;
	}
	return (1);  // stack effect
}

private int
compile_binOp(Expr *expr, Expr_f flags)
{
	int	expand, n;
	Type	*type;
	Expr	*e;

	/* Return the net run-time stack effect (i.e., how much was pushed). */

	switch (expr->op) {
	    case L_OP_EQUALS:
		compile_assign(expr);
		expr->type = expr->a->type;
		return (1);
	    case L_OP_EQPLUS:
	    case L_OP_EQMINUS:
	    case L_OP_EQSTAR:
	    case L_OP_EQSLASH:
		compile_assign(expr);
		L_typeck_expect(L_INT|L_FLOAT, expr->a,
				"in arithmetic assignment");
		expr->type = expr->a->type;
		return (1);
	    case L_OP_EQPERC:
	    case L_OP_EQBITAND:
	    case L_OP_EQBITOR:
	    case L_OP_EQBITXOR:
	    case L_OP_EQLSHIFT:
	    case L_OP_EQRSHIFT:
		compile_assign(expr);
		L_typeck_expect(L_INT, expr->a, "in arithmetic assignment");
		expr->type = expr->a->type;
		return (1);
	    case L_OP_EQDOT:
		compile_assign(expr);
		L_typeck_expect(L_STRING, expr->a, "in .=");
		expr->type = expr->a->type;
		return (1);
	    case L_OP_ANDAND:
	    case L_OP_OROR:
		compile_shortCircuit(expr);
		expr->type = L_int;
		return (1);
	    case L_OP_STR_EQ:
	    case L_OP_STR_NE:
	    case L_OP_STR_GT:
	    case L_OP_STR_GE:
	    case L_OP_STR_LT:
	    case L_OP_STR_LE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_STRING|L_WIDGET, expr->a,
				"in string comparison");
		L_typeck_expect(L_STRING|L_WIDGET, expr->b,
				"in string comparison");
		emit_instrForLOp(expr);
		expr->type = L_int;
		return (1);
	    case L_OP_EQUALEQUAL:
	    case L_OP_NOTEQUAL:
	    case L_OP_GREATER:
	    case L_OP_GREATEREQ:
	    case L_OP_LESSTHAN:
	    case L_OP_LESSTHANEQ:
	    case L_OP_PLUS:
	    case L_OP_MINUS:
	    case L_OP_STAR:
	    case L_OP_SLASH:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT|L_FLOAT, expr->a,
				"in arithmetic operator");
		L_typeck_expect(L_INT|L_FLOAT, expr->b,
				"in arithmetic operator");
		emit_instrForLOp(expr);
		if (isfloat(expr->a) || isfloat(expr->b)) {
			expr->type = L_float;
		} else {
			expr->type = L_int;
		}
		return (1);
	    case L_OP_PERC:
	    case L_OP_BITAND:
	    case L_OP_BITOR:
	    case L_OP_BITXOR:
	    case L_OP_LSHIFT:
	    case L_OP_RSHIFT:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->a, "in arithmetic operator");
		L_typeck_expect(L_INT, expr->b, "in arithmetic operator");
		emit_instrForLOp(expr);
		expr->type = L_int;
		return (1);
	    case L_OP_ARRAY_INDEX:
	    case L_OP_HASH_INDEX:
	    case L_OP_DOT:
	    case L_OP_POINTS:
		return (compile_idxOp(expr, flags));
	    case L_OP_CLASS_INDEX:
		return (compile_clsDeref(expr, flags));
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		expr->type = L_string;
		return (1);
	    case L_OP_LIST:
		for (e = expr, expand = 0; e; e = e->b) {
			if (e->a && isexpand(e->a)) {
				TclEmitOpcode(INST_EXPAND_START,
					      L->frame->envPtr);
				expand = 1;
				break;
			}
		}
		push_str("::list");
		n = compile_expr(expr->a, L_PUSH_VAL);
		if (n == 0) {  // empty list {}
			ASSERT(!expr->a && !expr->b);
			type = L_poly;
		} else if (iskv(expr->a)) {
			ASSERT((n == 2) && ishash(expr->a));
			type = expr->a->type;
		} else {
			type = type_mkList(expr->a->type, PER_INTERP);
		}
		for (e = expr->b; e; e = e->b) {
			ASSERT(e->op == L_OP_LIST);
			n += compile_expr(e->a, L_PUSH_VAL);
			if (ishashtype(type) && iskv(e->a)) {
				unless (L_typeck_same(type, e->a->type)) {
					L_errf(expr, "hash elements must all "
					       "be of same type");
				}
			} else if (islisttype(type) && !iskv(e->a)) {
				/*
				 * The list type is literally a list of all the
				 * individual element types linked together.
				 */
				Type *t = type_mkList(e->a->type, PER_INTERP);
				APPEND(Type, next, type, t);
			} else unless (ispolytype(type)) {
				L_errf(expr, "cannot mix hash and "
				       "non-hash elements");
				type = L_poly;
			}
		}
		if (expand) {
			emit_invoke_expanded();
		} else {
			emit_invoke(n+1);
		}
		expr->type = type;
		return (1);
	    case L_OP_KV:
		n  = compile_expr(expr->a, L_PUSH_VAL);
		n += compile_expr(expr->b, L_PUSH_VAL);
		ASSERT(n == 2);
		unless (isscalar(expr->a)) {
			L_errf(expr->a, "hash keys must be scalar");
		}
		expr->type = type_mkHash(expr->a->type, expr->b->type,
					 PER_INTERP);
		return (n);
	    case L_OP_EQTWID:
		compile_twiddle(expr);
		expr->type = L_int;
		return (1);
	    case L_OP_COMMA:
		compile_expr(expr->a, L_DISCARD);
		compile_expr(expr->b, L_PUSH_VAL);
		expr->type = expr->b->type;
		return (1);
	    case L_OP_CAST:
		type = (Type *)expr->a;
		if (type == L_int) {
			push_str("::tcl::mathfunc::int");
			compile_expr(expr->b, L_PUSH_VAL);
			emit_invoke(2);
		} else if (type == L_float) {
			push_str("::tcl::mathfunc::double");
			compile_expr(expr->b, L_PUSH_VAL);
			emit_invoke(2);
		} else {
			compile_expr(expr->b, L_PUSH_VAL);
		}
		L_typeck_deny(L_VOID|L_FUNCTION, expr->b);
		expr->type = type;
		return (1);
	    case L_OP_CONCAT:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_STRING, expr->a, "in lhs of . operator");
		L_typeck_expect(L_STRING, expr->b, "in rhs of . operator");
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		expr->type = L_string;
		return (1);
	    default:
		L_bomb("compile_binOp: malformed AST");
		return (1);
	}
}

private int
compile_trinOp(Expr *expr)
{
	int	i = 0, n = 0, n2 = 0;
	Jmp	*end_jmp, *false_jmp;

	switch (expr->op) {
	    case L_OP_EQTWID:
		compile_twiddleSubst(expr);
		expr->type = L_int;
		n = 1;
		break;
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		compile_expr(expr->c, L_PUSH_VAL);
		TclEmitInstInt1(INST_CONCAT1, 3, L->frame->envPtr);
		expr->type = L_string;
		n = 1;
		break;
	    case L_OP_ARRAY_SLICE:
		compile_expr(expr->a, L_PUSH_VAL);
		if (isstring(expr->a)) {
			push_str("::string");
			push_str("range");
			TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
			expr->type = L_string;
			i = 5;
		} else if (isarray(expr->a) || islist(expr->a)) {
			push_str("::lrange");
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
			expr->type = expr->a->type;
			i = 4;
		} else {
			L_errf(expr->a, "illegal type for slice");
			expr->type = L_poly;
		}
		if (isstring(expr->a)) {
			TclEmitOpcode(INST_L_PUSH_STR_SIZE, L->frame->envPtr);
		} else if (isarray(expr->a) || islist(expr->a) ||
			   ispoly(expr->a)) {
			TclEmitOpcode(INST_L_PUSH_LIST_SIZE, L->frame->envPtr);
		}
		++L->idx_nesting;
		compile_expr(expr->b, L_PUSH_VAL);
		unless (isint(expr->b)) {
			L_errf(expr->b, "first slice index not an int");
		}
		compile_expr(expr->c, L_PUSH_VAL);
		unless (isint(expr->c)) {
			L_errf(expr->c, "second slice index not an int");
		}
		--L->idx_nesting;
		if (isstring(expr->a) || isarray(expr->a) || islist(expr->a) ||
		    ispoly(expr->a)) {
			TclEmitOpcode(INST_L_POP_SIZE, L->frame->envPtr);
		}
		emit_invoke(i);
		n = 1;
		break;
	    case L_OP_TERNARY_COND:
		compile_condition(expr->a);
		false_jmp = emit_jmp_fwd(INST_JUMP_FALSE4);
		n = compile_expr(expr->b, L_PUSH_VAL);
		end_jmp = emit_jmp_fwd(INST_JUMP4);
		fixup_jmps(false_jmp);
		n2 = compile_expr(expr->c, L_PUSH_VAL);
		fixup_jmps(end_jmp);
		ASSERT(n == n2);
		if (ispoly(expr->b) || ispoly(expr->c)) {
			expr->type = L_poly;
		} else if (L_typeck_same(expr->b->type, expr->c->type)) {
			expr->type = expr->b->type;
		} else if ((expr->b->type->kind & (L_INT|L_FLOAT)) &&
			   (expr->c->type->kind & (L_INT|L_FLOAT))) {
			expr->type = L_float;
		} else {
			L_errf(expr, "incompatible types in ? : expressions");
			expr->type = L_poly;
		}
		break;
	    default:
		L_bomb("compile_trinOp: malformed AST");
	}
	return (n);  // stack effect
}

/*
 * Estimate how many submatches are in the given regexp.  These are
 * the sub-expressions within parens.  If the regexp includes an
 * interpolated string, we can't get this exact, so just assume
 * the maximum (9) in that case.
 */
private int
re_submatchCnt(Expr *re)
{
	int		n = 9;
	Tcl_Obj		*const_regexp;
	Tcl_RegExp	compiled;

	if (re->kind == L_EXPR_RE) {
		const_regexp = Tcl_NewStringObj(re->u.string, -1);
		Tcl_IncrRefCount(const_regexp);
		compiled = Tcl_GetRegExpFromObj(L->interp, const_regexp,
					TCL_REG_ADVANCED);
		Tcl_DecrRefCount(const_regexp);
		if (compiled) n = ((TclRegexp *)compiled)->re.re_nsub;
	}
	return (n);
}

private void
compile_twiddle(Expr *expr)
{
	int	i, mod_cnt, nocase, submatch_cnt;
	int	exact = 0;
	Expr	*regexp = expr->b;
	Sym	*s;
	Expr	*id;
	VarDecl	*v;
	Tcl_DString ds;

	submatch_cnt = re_submatchCnt(regexp);

	/*
	 * Check if the regexp can be compiled (like Tcl's) to a string
	 * comparison, string match, or regexp instruction.  Otherwise
	 * have to call the ::regexp command.
	 */
	unless (submatch_cnt || (regexp->flags & L_EXPR_RE_G)) {
		/*
		 * Can compile it: no match vars, no options (or just -nocase).
		 * If possible, convert regexp to glob so the faster
		 * string comparison or match instructions can be used.
		 * Otherwise, compile to a regexp instruction.
		 */
		nocase = (regexp->flags & L_EXPR_RE_I);
		if (isstring(regexp) &&
		    (TclReToGlob(NULL, regexp->u.string,
				 strlen(regexp->u.string), &ds,
				 &exact) == TCL_OK)) {
			push_cstr(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds));
			Tcl_DStringFree(&ds);
			compile_exprs(expr->a, L_PUSH_VAL);
			if (exact && !nocase) {
				TclEmitOpcode(INST_STR_EQ, L->frame->envPtr);
			} else {
				TclEmitInstInt1(INST_STR_MATCH, nocase,
						L->frame->envPtr);
			}
		} else {
			/*
			 * Pass correct RE compile flags. We use only Int1
			 * (8-bit), but that handles all the flags we want to
			 * pass.
			 * Don't use TCL_REG_NOSUB as we may have backrefs.
			 */
			int cflags = TCL_REG_ADVANCED
			    | (nocase ? TCL_REG_NOCASE : 0);
			compile_exprs(regexp, L_PUSH_VAL);
			compile_exprs(expr->a, L_PUSH_VAL);
			TclEmitInstInt1(INST_REGEXP, cflags, L->frame->envPtr);
		}
	} else {
		/*
		 * Has submatches or /g modifier -- must call ::regexp cmd.
		 */
		push_str("::regexp");
		mod_cnt = push_regexpModifiers(regexp);
		push_str("--");
		compile_exprs(regexp, L_PUSH_VAL);
		compile_exprs(expr->a, L_PUSH_VAL);
		/* Submatch vars.  This loop always iterates at least once. */
		for (i = 0; i <= submatch_cnt; i++) {
			char	buf[32];
			snprintf(buf, 32, "$%d", i);
			id = ast_mkId(buf, 0, 0);
			unless (sym_lookup(id, L_NOWARN)) {
				v = ast_mkVarDecl(L_string, id, 0, 0);
				v->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
				s = sym_store(v);
				s->used_p = TRUE; // suppress unused var warning
			}
			push_str(buf);
		}
		emit_invoke(5 + submatch_cnt + mod_cnt);
	}
	L_typeck_expect(L_STRING, expr->a, "in =~");
	// Note: the match boolean is left on the stack.
}

private void
compile_twiddleSubst(Expr *expr)
{
	Expr	*lhs = expr->a;
	int	modCount, tmpIndex = 0;
	char	*tmpNm;

	push_str("::regsub");
	modCount = push_regexpModifiers(expr->b);
	push_str("-line");
	push_str("--");
	compile_expr(expr->b, L_PUSH_VAL);
	// ::regsub <mods> -line -- <re>
	compile_expr(expr->c, L_PUSH_VAL);
	// ::regsub <mods> -line -- <re> <subst>
	compile_expr(lhs, L_PUSH_VALPTR | L_PUSH_VAL | L_LVALUE);
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in =~");
		return;
	}
	if (isdeepdive(lhs)) {
		tmpIndex = tmp_getSingle(&tmpNm);
		// ::regsub <mods> -line -- <re> <subst> <lhs-val> <lhs-ptr>
		TclEmitInstInt1(INST_ROT, -(6+modCount), L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str("%s", tmpNm);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst> <tmp-name>
	} else {
		// ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str(lhs->sym->tclname);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst> <lhs-name>
	}
	emit_invoke(modCount + 7);
	if (isdeepdive(lhs)) {
		// <lhs-ptr> <match>
		emit_load_scalar(tmpIndex);
		// <lhs-ptr> <match> <new-val>
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		// <match> <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(L_PUSH_NEW, L->frame->envPtr);
		// <match> <new-val>
		emit_pop();
	}
	L_typeck_expect(L_STRING, lhs, "in =~");
	// <match>
}

private void
compile_shortCircuit(Expr *expr)
{
	Jmp	*jmp;
	unsigned char op;

	/*
	 * In case the operator "a op b" short-circuits, we need one
	 * value of "a" on the stack for the test and one for the value of
	 * the expression.  If the operator doesn't short-circuit, we
	 * pop one of these off and move on to evaluating "b".
	 */
	ASSERT((expr->op == L_OP_ANDAND) || (expr->op == L_OP_OROR));
	op = (expr->op == L_OP_ANDAND) ? INST_JUMP_FALSE4 : INST_JUMP_TRUE4;
	compile_condition(expr->a);
	// <a-val>
	TclEmitOpcode(INST_DUP, L->frame->envPtr);
	// <a-val> <a-val>
	jmp = emit_jmp_fwd(op);
	// <a-val>   if short-circuit and we jumped out
	// <a-val>   if did not short-circuit and we're still going
	emit_pop();
	compile_condition(expr->b);
	fixup_jmps(jmp);
	// <a-val>   if short-circuit
	// <b-val>   if did not short-circuit
}

/*
 * Compile an expression that is used as a conditional test.
 * This is compiled like a normal expression except that if it's
 * of string type its value is compared against the string "0".
 */
private void
compile_condition(Expr *cond)
{
	compile_expr(cond, L_PUSH_VAL);
	if (isvoid(cond)) {
		L_errf(cond, "void type illegal in predicate");
	} else if (isstring(cond) || iswidget(cond)) {
		push_str("0");
		TclEmitOpcode(INST_NEQ, L->frame->envPtr);
	} else unless (isscalar(cond)) {
		L_errf(cond, "predicate must be scalar");
	}
	cond->type = L_int;
}

/*
 * Compile if-unless as follows.
 *
 * No "else" leg:          "Else" leg present:
 *    <eval cond>              <eval cond>
 *    jmpFalse 1               jmpFalse 1
 *    <if leg>                 <if leg>
 * 1:                          jmp 2
 *                          1: <else leg>
 *                          2:
 */
private void
compile_ifUnless(Cond *cond)
{
	Jmp	*endjmp, *falsejmp;

	/* Test the condition and jmp if false. */
	compile_condition(cond->cond);
	falsejmp = emit_jmp_fwd(INST_JUMP_FALSE4);

	/* Compile the "if" leg. */
	frame_push(cond, NULL, SEARCH);
	compile_stmts(cond->if_body);

	if (cond->else_body) {
		/* "Else" leg present. */
		frame_pop();
		frame_push(cond, NULL, SEARCH);
		endjmp = emit_jmp_fwd(INST_JUMP4);
		fixup_jmps(falsejmp);
		compile_stmts(cond->else_body);
		fixup_jmps(endjmp);
	} else {
		/* No "else" leg. */
		fixup_jmps(falsejmp);
	}
	frame_pop();
}

private void
compile_loop(Loop *loop)
{
	switch (loop->kind) {
	    case L_LOOP_DO:
		compile_do(loop);
		break;
	    case L_LOOP_FOR:
	    case L_LOOP_WHILE:
		compile_for_while(loop);
		break;
	    default:
		L_bomb("bad loop type");
		break;
	}
}

/*
 * Do loop:
 *
 * 1: <body>
 *    <cond>
 *    jmpTrue 1
 */
private void
compile_do(Loop *loop)
{
	int	body_off;
	Jmp	*break_jmps, *continue_jmps;

	body_off = currOffset(L->frame->envPtr);
	frame_push(loop, NULL, LOOP|SEARCH);
	compile_stmts(loop->body);
	break_jmps    = L->frame->break_jumps;
	continue_jmps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jmps);

	compile_condition(loop->cond);
	emit_jmp_back(TCL_TRUE_JUMP, body_off);
	fixup_jmps(break_jmps);
}

/*
 * While loop:        For loop:
 *
 *                      <pre>
 * 1: <cond>         1: <cond>
 *    jmpFalse 2        jmpFalse 2
 *    <body>            <body>
 *                      <post>
 *    jmp 1             jmp 1
 * 2:                2:
 */
private void
compile_for_while(Loop *loop)
{
	int	cond_off;
	Jmp	*break_jmps, *continue_jmps, *out_jmp;

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->pre, L_DISCARD);

	cond_off = currOffset(L->frame->envPtr);
	compile_condition(loop->cond);
	out_jmp = emit_jmp_fwd(INST_JUMP_FALSE4);

	frame_push(loop, NULL, LOOP|SEARCH);
	compile_stmts(loop->body);
	break_jmps    = L->frame->break_jumps;
	continue_jmps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jmps);

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->post, L_DISCARD);

	emit_jmp_back(TCL_UNCONDITIONAL_JUMP, cond_off);
	fixup_jmps(out_jmp);
	fixup_jmps(break_jmps);
}

/*
 * Emit a jump instruction to a backwards target.  jmp_type is one of
 * TCL_UNCONDITIONAL, TCL_TRUE_JUMP, or TCL_FALSE_JUMP.  The jump
 * opcope is appropriately selected for the jump distance.
 */
private void
emit_jmp_back(TclJumpType jmp_type, int offset)
{
	int	op = 0;
	int	dist = currOffset(L->frame->envPtr) - offset;

	if (dist > 127) {
		switch (jmp_type) {
		    case TCL_UNCONDITIONAL_JUMP:
			op = INST_JUMP4;
			break;
		    case TCL_TRUE_JUMP:
			op = INST_JUMP_TRUE4;
			break;
		    case TCL_FALSE_JUMP:
			op = INST_JUMP_FALSE4;
			break;
		    default:
			L_bomb("bad jmp type");
			break;
		}
		TclEmitInstInt4(op, -dist, L->frame->envPtr);
	} else {
		switch (jmp_type) {
		    case TCL_UNCONDITIONAL_JUMP:
			op = INST_JUMP1;
			break;
		    case TCL_TRUE_JUMP:
			op = INST_JUMP_TRUE1;
			break;
		    case TCL_FALSE_JUMP:
			op = INST_JUMP_FALSE1;
			break;
		    default:
			L_bomb("bad jmp type");
			break;
		}
		TclEmitInstInt1(op, -dist, L->frame->envPtr);
	}
}

/*
 * Emit a jump instruction with an unknown target offset and return a
 * structure that can be passed in to fixup_jmps() to later fix-up the
 * target to any desired bytecode offset.  Caller must free the
 * returned structure.
 */
private Jmp *
emit_jmp_fwd(int op)
{
	Jmp	*ret = (Jmp *)ckalloc(sizeof(Jmp));

	ret->op     = op;
	ret->offset = currOffset(L->frame->envPtr);
	ret->next   = NULL;
	switch (op) {
	    case INST_JUMP1:
	    case INST_JUMP_TRUE1:
	    case INST_JUMP_FALSE1:
		ret->size = 1;
		TclEmitInstInt1(op, 0, L->frame->envPtr);
		break;
	    case INST_JUMP4:
	    case INST_JUMP_TRUE4:
	    case INST_JUMP_FALSE4:
		ret->size = 4;
		TclEmitInstInt4(op, 0, L->frame->envPtr);
		break;
	    default:
		L_bomb("unexpected jump instruction");
		break;
	}
	return (ret);
}

/*
 * Fix up jump targets to point to the current PC, and free the
 * passed-in fix-ups list.
 */
private void
fixup_jmps(Jmp *j)
{
	int	target;
	Jmp	*t;
	unsigned char *jmp_pc;

	while (j) {
		target = currOffset(L->frame->envPtr) - j->offset;
		jmp_pc = L->frame->envPtr->codeStart + j->offset;
		switch (j->size) {
		    case 1:
			ASSERT(*jmp_pc == j->op);
			TclUpdateInstInt1AtPc(j->op, target, jmp_pc);
			break;
		    case 4:
			ASSERT(*jmp_pc == j->op);
			TclUpdateInstInt4AtPc(j->op, target, jmp_pc);
			break;
		    default:
			L_bomb("unexpected jump fixup");
			break;
		}
		t = j->next;
		ckfree((char *)j);
		j = t;
	}
}

private void
compile_foreach(ForEach *loop)
{
	compile_expr(loop->expr, L_PUSH_VAL);

	switch (loop->expr->type->kind) {
	    case L_ARRAY:
	    case L_LIST:
		compile_foreachArray(loop);
		break;
	    case L_HASH:
		compile_foreachHash(loop);
		break;
	    case L_STRING:
		compile_foreachString(loop);
		break;
	    default:
		L_errf(loop->expr, "foreach expression must be"
		       " array, hash, or string");
		break;
	}
}

/*
 * Most of the following function came from tclCompCmds.c
 * TclCompileForEachCmd(), modified in various ways for L.
 */
private void
compile_foreachArray(ForEach *loop)
{
	int		i, continue_off, loopctr_idx, num_vars, val_idx;
	Expr		*var;
	ForeachInfo	*info;
	ForeachVarList	*varlist;
	Jmp		*break_jumps, *continue_jumps, *false_jump;
	int		jumpBackDist, jumpBackOffset, infoIndex;

	/*
	 * Type-check the value variables.  In "foreach (v1,v2,v3 in
	 * a)", v* are the value variables or variable list, and a is
	 * the value list, in tcl terminology.
	 */
	for (var = loop->key, num_vars = 0; var; var = var->next, ++num_vars) {
		unless (sym_lookup(var, 0)) return;  // undeclared var
		unless (L_typeck_arrElt(var->type, loop->expr->type)) {
			L_errf(var, "loop index type incompatible with"
				    " array element type");
		}
	}

	/* Temps for value list value and loop counter. */
	val_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);
	loopctr_idx = TclFindCompiledLocal(NULL, 0, 1,
					   L->frame->envPtr);

	/*
	 * ForeachInfo and ForeachVarList are structures required by
	 * the bytecode interpreter for foreach bytecodes.  In our
	 * case, we have only one value and one variable list
	 * consisting of num_vars variables.
	 */
	info = (ForeachInfo *)ckalloc(sizeof(ForeachInfo) +
	    sizeof(ForeachVarList *));
	info->numLists       = 1;
	info->firstValueTemp = val_idx;
	info->loopCtTemp     = loopctr_idx;
	varlist = (ForeachVarList *)ckalloc(sizeof(ForeachVarList) +
	    num_vars * sizeof(int));
	varlist->numVars = num_vars;
	for (i = 0, var = loop->key; var; var = var->next, ++i) {
		Sym *s = sym_lookup(var, 0);
		varlist->varIndexes[i] = s->idx;
	}
	info->varLists[0] = varlist;
	infoIndex = TclCreateAuxData(info, &tclForeachInfoType,
				     L->frame->envPtr);

	/* The values to iterate through are already on the stack (the
	 * caller evaluated loop->expr).  Assign to the value temp. */
	emit_store_scalar(val_idx);
	emit_pop();

	/* Initialize the loop state. */
	TclEmitInstInt4(INST_FOREACH_START4, infoIndex, L->frame->envPtr);

	/* Top of the loop.  Step, and jump out if done. */
	continue_off = currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_FOREACH_STEP4, infoIndex, L->frame->envPtr);
	false_jump = emit_jmp_fwd(INST_JUMP_FALSE4);

	/* Loop body. */
	frame_push(loop, NULL, LOOP|SEARCH);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* End of loop -- jump back to top. */
	jumpBackOffset = currOffset(L->frame->envPtr);
	jumpBackDist   = jumpBackOffset - continue_off;
	if (jumpBackDist > 120) {
		TclEmitInstInt4(INST_JUMP4, -jumpBackDist, L->frame->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP1, -jumpBackDist, L->frame->envPtr);
	}

	fixup_jmps(false_jump);

	/* Set the value variables to undef. */
	TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
	for (var = loop->key; var; var = var->next) {
		Sym *s = sym_lookup(var, 0);
		ASSERT(s);
		emit_store_scalar(s->idx);
	}
	emit_pop();

	fixup_jmps(break_jumps);
}

private void
compile_foreachHash(ForEach *loop)
{
	Sym	*key;
	Sym	*val = NULL;
	int	body_off, disp, it_idx;
	Jmp	*break_jumps, *continue_jumps, *out_jmp;

	/* Check types and ensure variables are declared etc. */
	unless ((key = sym_lookup(loop->key, 0))) return;
	if (loop->value) {
		unless ((val = sym_lookup(loop->value, 0))) return;
		unless (L_typeck_compat(val->type,
					loop->expr->type->base_type)) {
			L_errf(loop->value, "loop index value type "
			       "incompatible with hash element type");
		}
	}
	unless (L_typeck_compat(key->type, loop->expr->type->u.hash.idx_type)) {
		L_errf(loop->key,
		       "loop index key type incompatible with hash index type");
	}
	if (loop->key->next) {
		L_errf(loop, "multiple variables illegal in foreach over hash");
	}

	/* A temp to hold the iterator state.*/
	it_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);

	/*
	 * Both DICT_FIRST and DICT_NEXT leave value, key, and done-p
	 * on the stack.  Check done-p and jump out of the loop if
	 * it's true. (We fixup the jump target once we know the size
	 * of the loop body.)
	 */
	TclEmitInstInt4(INST_DICT_FIRST, it_idx, L->frame->envPtr);
	out_jmp = emit_jmp_fwd(INST_JUMP_TRUE4);

	/*
	 * Update the key and value variables. We save the offset of
	 * this code so we can jump back to it after DICT_NEXT.
	 * Note: the caller already pushed loop->expr.
	 */
	body_off = currOffset(L->frame->envPtr);
	emit_store_scalar(key->idx);
	emit_pop();
	if (loop->value) emit_store_scalar(val->idx);
	emit_pop();

	/*
	 * Compile loop body.  Note that we must grab the jump fix-ups
	 * out of the frame before popping it.
	 */
	frame_push(loop, NULL, LOOP|SEARCH);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* If there's another entry in the hash, go around again. */
	TclEmitInstInt4(INST_DICT_NEXT, it_idx, L->frame->envPtr);
	disp = body_off - currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_JUMP_FALSE4, disp, L->frame->envPtr);

	/* End of the loop.  Point the jump after the DICT_FIRST to here. */
	fixup_jmps(out_jmp);

	/* All done.  Cleanup the values that DICT_FIRST/DICT_NEXT left. */
	emit_pop();
	emit_pop();

	/* Set key and/or value counters to undef. */
	TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
	emit_store_scalar(key->idx);
	if (val) emit_store_scalar(val->idx);
	emit_pop();

	fixup_jmps(break_jumps);
	/* XXX We need to ensure that DICT_DONE happens in the face of
	   exceptions, so that the refcount on the dict will be
	   decremented, and the iterator freed.  See the
	   implementation of "dict for" in tclCompCmds.c.  --timjr
	   2006.11.3 */
	TclEmitInstInt4(INST_DICT_DONE, it_idx, L->frame->envPtr);
}

/*
 * Foreach over a string uses three temp variables (str_idx, len_idx,
 * and it_idx) and compiles to this:
 *
 *    str_idx = string value already on stack
 *    len_idx = [::string length $str_idx]
 *    it_idx  = 0
 *    jmp 2
 * 1: loopvar1 = str_idx[it_idx++]
 *    loopvar2 = str_idx[it_idx++]
 *    ...
 *    loopvarn = str_idx[it_idx++]
 *    <loop body>
 * 2: test it_idx < len_idx
 *    jmp if true to 1
 */
private void
compile_foreachString(ForEach *loop)
{
	int	body_off, it_idx, jmp_dist, len_idx, str_idx;
	Jmp	*break_jmps, *continue_jmps;
	Jmp	*cond_jmp = 0;
	Expr	*id;

	/* Temps for the loop index, string value, and string length. */
	it_idx  = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);
	str_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);
	len_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);

	emit_store_scalar(str_idx);

	push_str("::string");
	push_str("length");
	TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
	emit_invoke(3);
	emit_store_scalar(len_idx);
	emit_pop();

	push_str("0");
	emit_store_scalar(it_idx);
	emit_pop();

	cond_jmp = emit_jmp_fwd(INST_JUMP4);
	body_off = currOffset(L->frame->envPtr);

	for (id = loop->key; id; id = id->next) {
		unless (sym_lookup(id, 0)) return;  // undeclared var
		unless (L_typeck_compat(id->type, L_string)) {
			L_errf(id, "loop index not of string type");
		}
		emit_load_scalar(str_idx);
		emit_load_scalar(it_idx);
		TclEmitInstInt4(INST_L_INDEX, L_IDX_STRING | L_PUSH_VAL,
				L->frame->envPtr);
		emit_store_scalar(id->sym->idx);
		emit_pop();
		TclEmitInstInt1(INST_INCR_SCALAR1_IMM, it_idx,
				L->frame->envPtr);
		TclEmitInt1(1, L->frame->envPtr);
		emit_pop();
	}

	frame_push(loop, NULL, LOOP|SEARCH);
	compile_stmts(loop->body);
	break_jmps    = L->frame->break_jumps;
	continue_jmps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jmps);

	fixup_jmps(cond_jmp);
	emit_load_scalar(it_idx);
	emit_load_scalar(len_idx);
	TclEmitOpcode(INST_LT, L->frame->envPtr);
	jmp_dist = currOffset(L->frame->envPtr) - body_off;
	TclEmitInstInt4(INST_JUMP_TRUE4, -jmp_dist, L->frame->envPtr);

	/* Set the loop counters to undef. */
	TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
	for (id = loop->key; id; id = id->next) {
		emit_store_scalar(id->sym->idx);
	}
	emit_pop();

	fixup_jmps(break_jmps);
}

private VarDecl *
struct_lookupMember(Type *t, Expr *idx, int *offset)
{
	VarDecl *m;

	ASSERT((idx->op == L_OP_DOT) || (idx->op == L_OP_POINTS));

	unless (t->u.struc.members) {
		L_errf(idx, "incomplete struct type %s", t->u.struc.tag);
		return (NULL);
	}
	for (*offset = 0, m = t->u.struc.members; m; m = m->next, ++*offset) {
		if (!strcmp(idx->u.string, m->id->u.string)) {
			return (m);
		}
	}
	return (NULL);
}

/*
 * Generate code to push an array/hash/struct/string index onto the stack.
 * Return flags suitable for the INST_L_INDEX instruction which indicate
 * whether the operator is an array, hash, struct, or string index.
 */
private int
push_index(Expr *expr)
{
	int	ret;
	Type	*type;
	VarDecl *member;
	int	offset;
	char	buf[16];

	/* Error-path return values. */
	ret  = 0;
	type = L_poly;

	ASSERT(type);
	switch (expr->op) {
	    case L_OP_DOT:
	    case L_OP_POINTS:
		unless (isstruct(expr->a)) {
			L_errf(expr, "not a struct");
			goto out;
		}
		member = struct_lookupMember(expr->a->type,
					     expr,
					     &offset);
		if (member) {
			snprintf(buf, sizeof(buf), "%i", offset);
			push_str(buf);
			type = member->type;
		} else {
			L_errf(expr, "struct field %s not found",
			       expr->u.string);
		}
		ret = L_IDX_ARRAY;
		break;
	    case L_OP_ARRAY_INDEX:
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->b, "in array/string index");
		if (isarray(expr->a) || islist(expr->a)) {
			type = expr->a->type->base_type;
			ret  = L_IDX_ARRAY;
		} else if (isstring(expr->a)) {
			type = L_string;
			ret  = L_IDX_STRING;
		} else if (ispoly(expr->a)) {
			type = L_poly;
			ret  = L_IDX_ARRAY;
		} else {
			L_errf(expr, "not an array or string");
		}
		break;
	    case L_OP_HASH_INDEX: {
		compile_expr(expr->b, L_PUSH_VAL);
		if (ishash(expr->a)) {
			L_typeck_expect(expr->a->type->u.hash.idx_type->kind,
					expr->b,
					"in hash index");
			type = expr->a->type->base_type;
		} else {
			L_errf(expr, "not a hash");
		}
		ret = L_IDX_HASH;
		break;
	    }
	    default:
		L_bomb("Invalid index op, %d", expr->op);
		break;
	}
 out:
	expr->type = type;
	return (ret);
}

/*
 * Compile a hash/array/struct/class or string index.  These are the
 * L_OP_HASH_INDEX, L_OP_ARRAY_INDEX, L_OP_DOT, and L_OP_POINTS nodes.
 *
 * The resulting stack depends on the flags which specify whether the
 * indexed element's value, pointer, or both (and in what order) are
 * wanted.  We get one of
 *
 * <elem-obj>                  if flags & L_PUSH_VAL
 * <deep-ptr>                  if flags & L_PUSH_PTR
 * <elem-obj> <deep-ptr>       if flags & L_PUSH_VAL_PTR
 * <deep-ptr> <elem-obj>       if flags & L_PUSH_PTR_VAL
 */
private int
compile_idxOp(Expr *expr, Expr_f flags)
{
	compile_expr(expr->a, L_PUSH_PTR | L_PUSH_VAL | (flags & L_LVALUE));

	/*
	 * Require "->" for all objects and call-by-reference structures.
	 * Require "." for all call-by-value and non-parameter structures.
	 */
	if (isclass(expr->a)) {
		unless (expr->op == L_OP_POINTS) {
			L_errf(expr, ". illegal on objects; use -> instead");
		}
	} else if (expr->a->sym && (expr->a->sym->decl->flags & DECL_REF)) {
		if (expr->op == L_OP_DOT) {
			L_errf(expr, ". illegal on call-by-reference "
			       "parms; use -> instead");
		}
	} else {
		if (expr->op == L_OP_POINTS) {
			L_errf(expr, "-> illegal except on call-by-reference "
			       "parms; use . instead");
		}
	}

	/*
	 * Handle obj->var.  We check here because, in general, we
	 * don't know until now whether expr->a has type class.
	 */
	if (isclass(expr->a) && ((expr->op == L_OP_DOT) ||
				 (expr->op == L_OP_POINTS))) {
		return (compile_clsInstDeref(expr, flags));
	}

	if (isstring(expr->a)) {
		TclEmitOpcode(INST_L_PUSH_STR_SIZE, L->frame->envPtr);
	} else if (isarray(expr->a) || islist(expr->a) || ispoly(expr->a)) {
		TclEmitOpcode(INST_L_PUSH_LIST_SIZE, L->frame->envPtr);
	}

	++L->idx_nesting;
	flags |= push_index(expr);
	--L->idx_nesting;

	if (isstring(expr->a) || isarray(expr->a) || islist(expr->a) ||
	    ispoly(expr->a)) {
		TclEmitOpcode(INST_L_POP_SIZE, L->frame->envPtr);
	}

	/*
	 * Perform an optimization and don't create a deep pointer if
	 * the caller won't be doing a deep dive into the expression
	 * being evaluated but instead just needs its value.  This
	 * happens when the deep dive we're doing now results in
	 * something of type class and the caller requested a value.
	 * See the comments in compile_expr().
	 *
	 * This wart is here because the caller can't know in general
	 * whether expr is a deep dive or a class deref.  Their
	 * expressions look identical but are evaluated in drastically
	 * different ways.
	 */
	if (isclass(expr) && (flags & (L_PUSH_VAL | L_DISCARD))) {
		flags &= ~(L_PUSH_PTR | L_PUSH_VALPTR | L_PUSH_PTRVAL |
			   L_LVALUE);
	} else if (flags & (L_PUSH_PTR | L_PUSH_VALPTR | L_PUSH_PTRVAL)) {
		flags &= ~L_PUSH_VAL;
	}

	TclEmitInstInt4(INST_L_INDEX, flags, L->frame->envPtr);

	/*
	 * Adjust the stack depth that Tcl tracks (debug build) to
	 * reflect when two objs are left on the stack instead of one
	 * as indicated by the entry in the tclInstructionTable in
	 * tclCompile.c
	 */
	if (flags & (L_PUSH_PTRVAL | L_PUSH_VALPTR)) {
		TclAdjustStackDepth(1, L->frame->envPtr);
	}

	expr->sym   = expr->a->sym;  // propagate sym table ptr up the tree
	expr->flags = flags | L_EXPR_DEEP;
	return (1);
}

/* Compile classname->var. */
private int
compile_clsDeref(Expr *expr, Expr_f flags)
{
	int	in_class = 0;
	int	tmpidx;
	char	*clsnm, *tmpnm, *varnm;
	Expr	*tmpid;
	Sym	*sym, *tmpsym;
	VarDecl	*tmpdecl;
	Type	*type    = (Type *)expr->a;
	ClsDecl	*clsdecl = type->u.class.clsdecl;
	Tcl_HashEntry *hPtr;

	ASSERT(type && clsdecl);

	clsnm = clsdecl->decl->id->u.string;
	varnm = expr->u.string;
	if (L->enclosing_func) {
		in_class = L->enclosing_func->decl->flags & DECL_CLASS_FN;
	}

	hPtr = Tcl_FindHashEntry(clsdecl->symtab, varnm);
	unless (hPtr) {
		L_errf(expr, "%s is not a member of class %s", varnm, clsnm);
		expr->type = L_poly;
		return (0);
	}
	sym = (Sym *)Tcl_GetHashValue(hPtr);
	unless (in_class || (sym->decl->flags & DECL_PUBLIC)) {
		L_errf(expr, "%s is not a public variable of class %s",
		       varnm, clsnm);
	}
	unless (sym->decl->flags & DECL_CLASS_VAR) {
		L_errf(expr, "%s is not a class variable of class %s",
		       varnm, clsnm);
	}

	if (flags & L_PUSH_NAME) {
		push_str("::L::_class_%s::%s", clsnm, sym->name);
		expr->sym  = sym;
		expr->type = sym->type;
		return (1);  // stack effect
	}

	tmpidx  = tmp_getFree(&tmpnm);
	tmpid   = ast_mkId(tmpnm, 0, 0);
	tmpdecl = ast_mkVarDecl(sym->type, tmpid, 0, 0);
	tmpdecl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR | DECL_TEMP;
	tmpsym  = sym_store(tmpdecl);
	ASSERT(tmpsym);  // cannot be multiply declared
	tmpsym->used_p = TRUE;

	push_str("::L::_class_%s", clsnm);
	push_str(sym->name);
	TclEmitInstInt4(INST_NSUPVAR, tmpidx, L->frame->envPtr);
	emit_pop();

	expr->sym  = tmpsym;
	expr->type = sym->type;

	if (flags & L_PUSH_VAL) {
		emit_load_scalar(tmpidx);
		return (1);  // stack effect
	} else {
		return (0);  // stack effect
	}
}

/*
 * Compile obj->var.  Code to push the value of obj on the run-time
 * stack already has been generated by compile_idxOp().
 */
private int
compile_clsInstDeref(Expr *expr, Expr_f flags)
{
	int	in_class = 0;
	int	tmpidx;
	char	*clsnm, *tmpnm, *varnm;
	Expr	*tmpid;
	Sym	*sym, *tmpsym;
	VarDecl	*tmpdecl;
	ClsDecl	*clsdecl = expr->a->type->u.class.clsdecl;
	Tcl_HashEntry *hPtr;

	ASSERT(isclass(expr->a) && clsdecl);
	ASSERT(clsdecl->symtab);

	clsnm = clsdecl->decl->id->u.string;
	varnm = expr->u.string;
	if (L->enclosing_func) {
		in_class = L->enclosing_func->decl->flags & DECL_CLASS_FN;
	}

	hPtr = Tcl_FindHashEntry(clsdecl->symtab, varnm);
	unless (hPtr) {
		L_errf(expr, "%s is not a member of class %s", varnm, clsnm);
		expr->type = L_poly;
		return (0); // stack effect
	}
	sym = (Sym *)Tcl_GetHashValue(hPtr);
	unless (in_class || (sym->decl->flags & DECL_PUBLIC)) {
		L_errf(expr, "%s is not a public variable of class %s",
		       varnm, clsnm);
	}
	unless (sym->decl->flags & DECL_CLASS_INST_VAR) {
		L_errf(expr, "%s is not an instance variable of class %s",
		       varnm, clsnm);
	}

	if (flags & L_PUSH_NAME) {
		// Caller already pushed obj value, so concat var name to it.
		push_str("::%s", sym->name);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		expr->sym  = sym;
		expr->type = sym->type;
		return (1);  // stack effect
	}

	tmpidx  = tmp_getFree(&tmpnm);
	tmpid   = ast_mkId(tmpnm, 0, 0);
	tmpdecl = ast_mkVarDecl(sym->type, tmpid, 0, 0);
	tmpdecl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR | DECL_TEMP;
	tmpsym  = sym_store(tmpdecl);
	ASSERT(tmpsym);  // cannot be multiply declared
	tmpsym->used_p = TRUE;

	push_str(sym->name);
	TclEmitInstInt4(INST_NSUPVAR, tmpidx, L->frame->envPtr);
	emit_pop();

	expr->sym  = tmpsym;
	expr->type = sym->type;

	if (flags & L_PUSH_VAL) {
		emit_load_scalar(tmpidx);
		return (1);  // stack effect
	} else {
		return (0);  // stack effect
	}
}

private void
compile_assign(Expr *expr)
{
	Expr	*lhs = expr->a;
	Expr	*rhs = expr->b;

	if (lhs->op == L_OP_LIST) {
		/* Handle {a,b,c} = ... */
		compile_assignComposite(expr);
	} else {
		/* Handle regular assignment. */
		compile_expr(rhs, L_PUSH_VAL);
		compile_assignFromStack(lhs, rhs, expr);
	}
}

private void
compile_assignFromStack(Expr *lhs, Expr *rhs, Expr *expr)
{
	/* Whether it's an arithmetic assignment (lhs op= rhs). */
	int	arith = (expr->op != L_OP_EQUALS);

	compile_expr(lhs, (arith?L_PUSH_VALPTR:L_PUSH_PTR) | L_LVALUE);
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in assignment");
		return;
	}
	L_typeck_assign(lhs, rhs);

	if (isdeepdive(lhs)) {
		// <rval> <lhs-ptr>               if !arith
		// <rval> <lhs-val> <lhs-ptr>     if arith
		if (arith) {
			// <rval> <lhs-val> <lhs-ptr>
			TclEmitInstInt4(INST_REVERSE, 3, L->frame->envPtr);
			// <lhs-ptr> <lhs-val> <rval>
			emit_instrForLOp(expr);
			// <lhs-ptr> <new-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		}
		// <rval> <lhs-ptr>   or   <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(L_PUSH_NEW, L->frame->envPtr);
	} else {
		// <rval>
		if (arith) {
			emit_load_scalar(lhs->sym->idx);
			// <rval> <old-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
			// <old-val> <rval>
			emit_instrForLOp(expr);
			// <new-val>
		}
		// <rval>   or   <new-val>
		emit_store_scalar(lhs->sym->idx);
	}
	// <rval>
}

private void
list_mapReverse(Expr *l, int (*fn)(Expr *, Expr_f), int arg)
{
	ASSERT(l->op == L_OP_LIST);

	if (l->b) {
		list_mapReverse(l->b, fn, arg);
	}
	if (l->a) fn(l->a, arg);
}

private void
compile_assignComposite(Expr *expr)
{
	Expr	*lhs = expr->a;
	Expr	*rhs = expr->b;

	unless (expr->op == L_OP_EQUALS) {
		L_errf(expr, "arithmetic assignment illegal");
		lhs->type = L_poly;
		rhs->type = L_poly;
		return;
	}
	unless (rhs->op == L_OP_LIST) {
		L_errf(expr, "right-hand side must be list {}");
		lhs->type = L_poly;
		rhs->type = L_poly;
		return;
	}
	ASSERT(lhs->op == L_OP_LIST);

	/* Push all rhs list elements (right to left). */
	list_mapReverse(rhs, compile_expr, L_PUSH_VAL);

	/* Assign lhs <- rhs elements (left to right) until we run out. */
	for (lhs = expr->a, rhs = expr->b;
	     lhs && rhs && rhs->a;
	     lhs = lhs->b, rhs = rhs->b) {
		ASSERT((lhs->op == L_OP_LIST) && (rhs->op == L_OP_LIST));
		/* A lhs undef means skip the corresponding rhs element. */
		unless (isid(lhs->a, "undef")) {
			compile_assignFromStack(lhs->a, rhs->a, expr);
		}
		emit_pop();
	}
	/* Any left-over lhs elements get assigned undef. */
	for (; lhs; lhs = lhs->b) {
		ASSERT(lhs->op == L_OP_LIST);
		unless (isid(lhs->a, "undef")) {
			TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
			compile_assignFromStack(lhs->a, NULL, expr);
			emit_pop();
		}
	}
	/* Pop any left-over rhs elements to balance run-time stack. */
	for (; rhs && rhs->a; rhs = rhs->b) {
		emit_pop();
	}

	/* The value of the assignment is undef. */
	TclEmitOpcode(INST_L_PUSH_UNDEF, L->frame->envPtr);
}

private void
compile_incdec(Expr *expr)
{
	Expr	*lhs = expr->a;
	/* Whether expr is a postfix operator. */
	int	post = ((expr->op == L_OP_PLUSPLUS_POST) ||
			(expr->op == L_OP_MINUSMINUS_POST));
	/* Whether expr is a ++ operator. */
	int	inc = ((expr->op == L_OP_PLUSPLUS_PRE) ||
		       (expr->op == L_OP_PLUSPLUS_POST));

	compile_expr(lhs, L_PUSH_PTRVAL | (post?L_PUSH_VAL:0) | L_LVALUE);
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in inc/dec");
		return;
	}
	L_typeck_expect(L_INT|L_FLOAT, lhs, "in ++/--");

	if (isdeepdive(lhs)) {
		// <lhs-ptr> <lhs-val>
		push_str("1");
		// <hs-ptr> <lhs-val> 1
		TclEmitOpcode(inc?INST_ADD:INST_SUB, L->frame->envPtr);
		// <lhs-ptr> <new-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(post?L_PUSH_OLD:L_PUSH_NEW, L->frame->envPtr);
	} else {
		// <old-val>   if post
		TclEmitInstInt1(INST_INCR_SCALAR1_IMM, lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(inc? 1 : -1, L->frame->envPtr);
		// <old-val> <new-val>   if post
		// <new-val>             if !post
		if (post) emit_pop();
	}
	// <old-val>   if post
	// <new-val>   if !post
}

private int
push_regexpModifiers(Expr *regexp)
{
	int	n = 0;

	if (regexp->flags & L_EXPR_RE_I) {
		push_str("-nocase");
		n++;
	}
	if (regexp->flags & L_EXPR_RE_G) {
		push_str("-all");
		n++;
	}
	return (n);
}

private void
emit_instrForLOp(Expr *expr)
{
	int	arg = 0;
	int	op  = 0;

	switch (expr->op) {
	    case L_OP_STR_EQ:
	    case L_OP_EQUALEQUAL:
		op = INST_EQ;
		break;
	    case L_OP_STR_NE:
	    case L_OP_NOTEQUAL:
		op = INST_NEQ;
		break;
	    case L_OP_STR_GT:
	    case L_OP_GREATER:
		op = INST_GT;
		break;
	    case L_OP_STR_GE:
	    case L_OP_GREATEREQ:
		op = INST_GE;
		break;
	    case L_OP_STR_LT:
	    case L_OP_LESSTHAN:
		op = INST_LT;
		break;
	    case L_OP_STR_LE:
	    case L_OP_LESSTHANEQ:
		op = INST_LE;
		break;
	    case L_OP_PLUS:
	    case L_OP_EQPLUS:
		op = INST_ADD;
		break;
	    case L_OP_MINUS:
	    case L_OP_EQMINUS:
		op = INST_SUB;
		break;
	    case L_OP_STAR:
	    case L_OP_EQSTAR:
		op = INST_MULT;
		break;
	    case L_OP_SLASH:
	    case L_OP_EQSLASH:
		op = INST_DIV;
		break;
	    case L_OP_PERC:
	    case L_OP_EQPERC:
		op = INST_MOD;
		break;
	    case L_OP_BITAND:
	    case L_OP_EQBITAND:
		op = INST_BITAND;
		break;
	    case L_OP_BITOR:
	    case L_OP_EQBITOR:
		op = INST_BITOR;
		break;
	    case L_OP_BITXOR:
	    case L_OP_EQBITXOR:
		op = INST_BITXOR;
		break;
	    case L_OP_LSHIFT:
	    case L_OP_EQLSHIFT:
		op = INST_LSHIFT;
		break;
	    case L_OP_RSHIFT:
	    case L_OP_EQRSHIFT:
		op = INST_RSHIFT;
		break;
	    case L_OP_UMINUS:
		op = INST_UMINUS;
		break;
	    case L_OP_UPLUS:
		op = INST_UPLUS;
		break;
	    case L_OP_BANG:
		op = INST_LNOT;
		break;
	    case L_OP_BITNOT:
		op = INST_BITNOT;
		break;
	    default:
		break;
	}
	if (op) {
		TclEmitOpcode(op, L->frame->envPtr);
		return;
	}
	switch (expr->op) {
	    case L_OP_EQDOT:
		op  = INST_CONCAT1;
		arg = 2;
		break;
	    default:
		L_bomb("Unable to map operator %d to an instruction", expr->op);
		break;
	}
	if (op) {
		TclEmitInstInt1(op, arg, L->frame->envPtr);
	}
}

private void
compile_continue(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_find(LOOP);

	unless (loop_frame) {
		L_errf(stmt, "continue allowed only inside loops");
		return;
	}
	j = emit_jmp_fwd(INST_JUMP4);
	j->next = loop_frame->continue_jumps;
	loop_frame->continue_jumps = j;
}

private void
compile_break(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_find(LOOP);

	unless (loop_frame) {
		L_errf(stmt, "break allowed only inside loops");
		return;
	}
	j = emit_jmp_fwd(INST_JUMP4);
	j->next = loop_frame->break_jumps;
	loop_frame->break_jumps = j;
}

private void
compile_label(Stmt *stmt)
{
	Label	*label;

	label = label_lookup(stmt, LABEL_DEF);
	fixup_jmps(label->fixups);
	label->fixups = NULL;
	label->offset = currOffset(L->frame->envPtr);
}

private void
compile_goto(Stmt *stmt)
{
	Label	*label;
	Jmp	*jmp;

	label = label_lookup(stmt, LABEL_USE);
	if (label->offset >= 0) {
		emit_jmp_back(TCL_UNCONDITIONAL_JUMP, label->offset);
	} else {
		jmp = emit_jmp_fwd(INST_JUMP4);
		jmp->next = label->fixups;
		label->fixups = jmp;
	}
}

private Label *
label_lookup(Stmt *stmt, Label_f flags)
{
	int		new;
	char		*name = stmt->u.label;
	Label		*label = NULL;
	Frame		*frame;
	Tcl_HashEntry	*hPtr = NULL;

	/* Labels are restricted to the enclosing proc's labeltab. */
	frame = frame_find(FUNC);
	ASSERT(frame);

	hPtr = Tcl_FindHashEntry(frame->labeltab, name);
	if (hPtr) {
		label = (Label *)Tcl_GetHashValue(hPtr);
	} else {
		label = (Label *)ckalloc(sizeof(Label));
		memset(label, 0, sizeof(Label));
		label->name   = name;
		label->offset = -1;
		hPtr = Tcl_CreateHashEntry(frame->labeltab, name, &new);
		ASSERT(new);
		Tcl_SetHashValue(hPtr, label);
	}
	if ((flags & LABEL_DEF) && (label->offset >= 0)) {
		L_errf(stmt, "label %s already defined", name);
	}
	return (label);
}

private void
emit_globalUpvar(Sym *sym)
{
	VarDecl	*decl = sym->decl;
	char	*id = sym->name;

	/*
	 * Tim comment: We attempt to detect whether L global
	 * variables should be true globals, or should be shared with
	 * the calling proc, by checking if the current variable frame
	 * pointer in interp is the same as the global frame pointer.
	 * (Sharing variables with the calling proc is useful if you
	 * want to use L as an expr replacement).
	 */
	if (((Interp *)L->interp)->rootFramePtr !=
	    ((Interp *)L->interp)->varFramePtr) {
		ASSERT(!(decl->flags & (DECL_CLASS_VAR | DECL_CLASS_INST_VAR)));
		frame_resumePrologue();
		push_str("1");
		push_str(id);
		TclEmitInstInt4(INST_UPVAR, sym->idx, L->frame->envPtr);
		emit_pop();
		frame_resumeBody();
		return;
	}

	/*
	 * The namespace of the var we're creating an upvar alias to is
	 * either ::, an L class namespace, or an L class instance namespace
	 * where the local "self" holds the namespace name.
	 */
	frame_resumePrologue();
	switch (decl->flags &
		(DECL_GLOBAL_VAR | DECL_CLASS_VAR | DECL_CLASS_INST_VAR)) {
	    case DECL_GLOBAL_VAR:
		push_str("::");
		/* Private globals get mangled to avoid clashes. */
		if (decl->flags & DECL_PRIVATE) {
			push_str("_%s_%s", L->toplev, id);
		} else {
			push_str(id);
		}
		break;
	    case DECL_CLASS_VAR:
		push_str("::L::_class_%s", decl->clsdecl->decl->id->u.string);
		push_str(id);
		break;
	    case DECL_CLASS_INST_VAR: {
		Sym *self = sym_lookup(ast_mkId("self", 0, 0), L_NOWARN);
		ASSERT(self);
		emit_load_scalar(self->idx);
		push_str(id);
		break;
	    }
	}
	TclEmitInstInt4(INST_NSUPVAR, sym->idx, L->frame->envPtr);
	emit_pop();
	frame_resumeBody();
}

/*
 * Add a variable or function name to the symbol table.  If it's a
 * local variable, allocate a slot for it in the current proc.
 *
 * Print an error if the symbol is already defined.  The rules are
 *
 * - Multiply defined globals are illegal, with the exception that
 *   main() can be re-defined.
 * - A local cannot shadow any other local in the proc.
 * - A local can shadow a global.
 * - A local can shadow a global upvar shadow (which is a local
 *   with special status).
 *
 * Scopes are created as follows.  The complexity stems from Tcl
 * requiring local upvar shadows as the only way to access globals.
 * So we have a scope in which the global symbol is stored and a
 * nested scope for the proc in which the local upvar shadow is
 * stored.
 *
 * There is one scope hierarchy per Tcl Interp in which L code
 * appears, as illustrated next.  OUTER,SCRIPT,TOPLEV,SKIP etc are frame
 * flags (Frame_f); SKIP means that the scope is skipped when
 * searching enclosing scopes.
 *
 * [ outer-most scope (OUTER): public globals go in this frame's symtab
 *     [ file scope (SCRIPT): private globals go in this frame's symtab
 *         [ * (%%n_toplevel proc) (TOPLEV|SKIP)
 *             global initializers get compiled in this scope, causing the
 *             local upvar shadows to go in this scope's symtab
 *             [ class outer-most (CLS_OUTER): class/instance vars & private
 *                 member fns go in this frame's symtab
 *                 [ * class top-level (CLS_TOPLEV|SKIP)
 *                     class variable initializers get compiled in this scope
 *                     (note that this is still in the %%n_toplevel proc)
 *                     [ (constructor proc)
 *                         instance var initializers get compiled here
 *                     ]
 *                     [ (destructor proc)
 *                     ]
 *                     [ (member fn proc): public fn names go in outer-most
 *                         scope's, symtable, private fn names go in class
 *                         outer-most scope, fn locals go in this frame's
 *                         symtab
 *                         [ block
 *                             [ nested blocks...
 *                             ]
 *                         ]
 *                     ]
 *                 ]
 *             ]
 *             [ regular function (proc): public fn name goes in outer-most
 *               scope's symtab, private fn name goes in file scope's symtab,
 *               fn locals go in this frame's symtab
 *                 [ block
 *                     [ nested blocks...
 *                     ]
 *                 ]
 *             ]
 *         ]
 *     ]
 * ]
 */
private Sym *
sym_store(VarDecl *decl)
{
	int	new;
	char	*name = decl->id->u.string;
	Sym	*sym = NULL;
	Frame	*frame = NULL;
	Tcl_HashEntry *hPtr;

	/* Check for multiple declaration. */
	switch (decl->flags &
		(SCOPE_LOCAL | SCOPE_GLOBAL | SCOPE_SCRIPT | SCOPE_CLASS)) {
	    case SCOPE_GLOBAL:
	    case SCOPE_SCRIPT:
		/* Declaring a global -- search outer-most and file frames. */
		frame = frame_find(OUTER);
		hPtr = Tcl_FindHashEntry(frame->symtab, name);
		unless (hPtr) {
			frame = frame_find(SCRIPT);
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
		}
		/*
		 * Special case for main: allow redeclaration but not within
		 * the same script, determined by whether the current AST
		 * root is the same one as when main was last declared.
		 */
		if (!strcmp(name, "main")) {
			if (hPtr && (L->mains_ast == L->ast)) {
				L_errf(decl->id, "redeclaration of main");
				return (NULL);
			}
			if (hPtr) Tcl_DeleteHashEntry(hPtr);
			L->mains_ast = L->ast;
		} else if (hPtr) {
			if (decl->flags & DECL_EXTERN) {
				sym = (Sym *)Tcl_GetHashValue(hPtr);
				if (L_typeck_same(decl->type, sym->type)) {
					return (sym);
				}
				L_errf(decl,
				       "extern re-declaration type does not "
				       "match other declaration");
				return (NULL);
			} else {
				L_errf(decl,
				    "multiple declaration of global %s", name);
				return (NULL);
			}
		}
		break;
	    case SCOPE_CLASS:
		/* Declaring class var -- search up thru class outer scope. */
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) {
				L_errf(decl, "multiple declaration of %s",
				       name);
				return (NULL);
			}
			if (frame->flags & CLS_OUTER) break;
		}
		break;
	    case SCOPE_LOCAL:
		/* Declaring a local -- search current proc's local scopes. */
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			unless (frame->envPtr == L->frame->envPtr) break;
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) {
				sym = (Sym *)Tcl_GetHashValue(hPtr);
				ASSERT(sym->kind & L_SYM_LVAR);
				unless (sym->kind & L_SYM_LSHADOW) {
					L_errf(decl, "multiple declaration "
					       "of local %s", name);
					return (NULL);
				}
			}
		}
		break;
	    default:
		ASSERT(0);
		break;
	}

	/* Select the frame to add the symbol to. */
	switch (decl->flags &
		(SCOPE_LOCAL | SCOPE_GLOBAL | SCOPE_SCRIPT | SCOPE_CLASS)) {
	    case SCOPE_GLOBAL:
		frame = frame_find(OUTER);
		break;
	    case SCOPE_SCRIPT:
		frame = frame_find(SCRIPT);
		break;
	    case SCOPE_CLASS:
		frame = frame_find(CLS_OUTER);
		break;
	    case SCOPE_LOCAL:
		frame = L->frame;
		break;
	    default:
		ASSERT(0);
		break;
	}
	hPtr = Tcl_CreateHashEntry(frame->symtab, name, &new);
	/* If it's not new, it must be shadowing a global. */
	ASSERT(new || (sym && (sym->kind & L_SYM_LSHADOW) &&
		       (decl->flags & (DECL_LOCAL_VAR | DECL_CLASS_INST_VAR))));
	sym = (Sym *)ckalloc(sizeof(Sym));
	memset(sym, 0, sizeof(*sym));
	sym->name = ckstrdup(name);
	sym->type = decl->type;
	sym->decl = decl;

	/*
	 * Set the name of the tcl variable, mangling it to avoid
	 * clashes.
	 */
	if (isfntype(decl->type)) {
		ASSERT(decl->flags & (DECL_FN | DECL_CLASS_FN));
		sym->kind = L_SYM_FN;
		if (decl->tclprefix) {
			sym->tclname = cksprintf("%s%s", decl->tclprefix, name);
		} else {
			sym->tclname = ckstrdup(name);
		}
	} else if (decl->flags & DECL_GLOBAL_VAR) {
		sym->kind    = L_SYM_GVAR;
		sym->tclname = cksprintf("_%s", name);
	} else if (decl->flags & (DECL_CLASS_VAR | DECL_CLASS_INST_VAR)) {
		sym->kind    = L_SYM_GVAR;
		sym->tclname = cksprintf("_%s_%s",
					 decl->clsdecl->decl->id->u.string,
					 name);
	} else {
		ASSERT(decl->flags & DECL_LOCAL_VAR);
		sym->kind    = L_SYM_LVAR;
		sym->tclname = ckstrdup(name);
	}

	/* If a local, allocate a slot for it. */
	if (sym->kind & L_SYM_LVAR) {
		sym->idx = TclFindCompiledLocal(name, strlen(name),
						1, L->frame->envPtr);
	} else {
		sym->idx = -1;
	}

	decl->id->sym  = sym;
	decl->id->type = decl->type;
	Tcl_SetHashValue(hPtr, sym);

	return (sym);
}

/*
 * Lookup id in the symbol table.
 *
 * flags & L_NOTUSED ==> don't mark the id as having been referenced
 * (used for warning which variables are unused).
 *
 * flags & L_NOWARN ==> don't print error message if id not found.
 *
 * The first time a global is referenced within a scope, an upvar is
 * created for it.
 */
private Sym *
sym_lookup(Expr *id, Expr_f flags)
{
	int	new;
	char	*name;
	Sym	*shw;
	Sym	*sym = NULL;
	Frame	*frame;
	Tcl_HashEntry *hPtr = NULL;

	unless (id->kind == L_EXPR_ID) return (NULL);
	name = id->u.string;

	for (frame = L->frame; frame; frame = frame->prevFrame) {
		if ((frame->envPtr == L->frame->envPtr) ||
		    (frame->flags & SEARCH)) {
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) break;
		}
	}
	if (hPtr) sym = (Sym *)Tcl_GetHashValue(hPtr);
	if (sym) {
		/*
		 * If a global is being referenced for the first time
		 * in this scope, create a local upvar to shadow it
		 * in the symtab of the enclosing proc or top-level.
		 */
		if ((sym->kind & L_SYM_GVAR) && (sym->idx == -1)) {
			Frame	*proc_frame;
			// assert global => in outer-most or file frame
			ASSERT(!(sym->decl->flags & DECL_GLOBAL_VAR) ||
			       (frame->flags & (OUTER|SCRIPT)));
			// assert class var => in class outer-most frame
			ASSERT(!(sym->decl->flags & DECL_CLASS_VAR) ||
			       (frame->flags & CLS_OUTER));
			// assert class instance var => class outer-most frame
			ASSERT(!(sym->decl->flags & DECL_CLASS_INST_VAR) ||
			       (frame->flags & CLS_OUTER));
			proc_frame = frame_find(TOPLEV|CLS_TOPLEV|FUNC);
			ASSERT(proc_frame);
			hPtr = Tcl_CreateHashEntry(proc_frame->symtab, name,
						   &new);
			ASSERT(new);
			shw = (Sym *)ckalloc(sizeof(Sym));
			memset(shw, 0, sizeof(*shw));
			shw->kind    = L_SYM_LVAR | L_SYM_LSHADOW;
			shw->name    = ckstrdup(name);
			shw->tclname = ckstrdup(sym->tclname);
			shw->type    = sym->decl->type;
			shw->decl    = sym->decl;
			shw->used_p  = TRUE;
			shw->idx     = TclFindCompiledLocal(shw->tclname,
						strlen(shw->tclname),
						1,
						L->frame->envPtr);
			emit_globalUpvar(shw);
			Tcl_SetHashValue(hPtr, shw);
			sym = shw;
		}
		unless (flags & L_NOTUSED) sym->used_p = TRUE;
		id->sym  = sym;
		id->type = sym->type;
		return (sym);
	} else {
		unless (flags & L_NOWARN) {
			L_errf(id, "undeclared variable: %s", name);
		}
		ASSERT(id->sym == NULL);
		id->type = L_poly;  // to minimize cascading errors
		return (NULL);
	}
}

/*
 * XXX this should be enhanced to re-use temps.
 */
private int
tmp_getFree(char **p)
{
	char *s = cksprintf("=temp%d", L->tmpnum++);
	*p = s;
	return (TclFindCompiledLocal(s, strlen(s), 1, L->frame->envPtr));
}

private int
tmp_getSingle(char **p)
{
	static char *s = "=single_temp";
	*p = s;
	return (TclFindCompiledLocal(s, strlen(s), 1, L->frame->envPtr));
}

void
L_bomb(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	fprintf(stderr, "L Internal Error: ");
	vfprintf(stderr, format, ap);
	va_end(ap);
	fprintf(stderr, "\n");
	exit(1);
}

/* This is scheduled for a major make-over. */
void
L_trace(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	if (getenv("LTRACE")) {
		fprintf(stderr, "***: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
	}
	va_end(ap);
	fflush(stderr);
}

void
L_warn(char *s)
{
	unless (L->options & L_OPT_NOWARN) {
		fprintf(stderr, "L Warning: %s\n", s);
	}
}

void
L_warnf(void *node, const char *format, ...)
{
	va_list	ap;

	unless (L->options & L_OPT_NOWARN) {
		va_start(ap, format);
		if (node) {
			fprintf(stderr, "%s:%d: ",
				((Ast *)node)->file, ((Ast *)node)->line);
		}
		fprintf(stderr, "L Warning: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
		va_end(ap);
	}
}

/*
 * L_synerr is Bison's yyerror and is called by the parser for syntax
 * errors.  Bail out by longjumping back to Tcl_LObjCmd, as a way
 * to work-around a possible compiler bug in our Windows build where
 * the Bison-generated parser's own internal longjmp causes a crash.
 */
void
L_synerr(const char *format, ...)
{
	va_list ap;
	int	len = 64;
	char	*buf;

	va_start(ap, format);
	while (!(buf = ckvsprintf(format, ap, len))) {
		va_end(ap);
		va_start(ap, format);
		len *= 2;
	}
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	Tcl_AppendPrintfToObj(L->errs, "%s:%d: L Error: %s\n",
			      L->file, L->line, buf);
	ckfree(buf);
	longjmp(L->jmp, 0);
}

void
L_err(const char *format, ...)
{
	va_list ap;
	int	len = 64;
	char	*buf;

	va_start(ap, format);
	while (!(buf = ckvsprintf(format, ap, len))) {
		va_end(ap);
		va_start(ap, format);
		len *= 2;
	}
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	Tcl_AppendPrintfToObj(L->errs, "%s:%d: L Error: %s\n",
			      L->file, L->line, buf);
	ckfree(buf);
}

void
L_errf(void *node, const char *format, ...)
{
	va_list ap;
	int	len = 64;
	char	*buf;

	va_start(ap, format);
	while (!(buf = ckvsprintf(format, ap, len))) {
		va_end(ap);
		va_start(ap, format);
		len *= 2;
	}
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	if (node) {
		Tcl_AppendPrintfToObj(L->errs, "%s:%d: ",
				      ((Ast *)node)->file, ((Ast *)node)->line);
	}
	Tcl_AppendPrintfToObj(L->errs, "L Error: %s\n", buf);
	ckfree(buf);
}

private void
ast_free(Ast *ast_list)
{
	while (ast_list) {
		Ast	*node = ast_list;
		ast_list = ast_list->next;
		switch (node->type) {
		    case L_NODE_EXPR: {
			Expr *e = (Expr *)node;
			switch (e->kind) {
			    case L_EXPR_CONST:
				if (e->type == L_string) {
					ckfree(e->u.string);
				}
				break;
			    case L_EXPR_BINOP:
				if ((e->op == L_OP_DOT) ||
				    (e->op == L_OP_POINTS)) {
					ckfree(e->u.string);
				}
				break;
			    case L_EXPR_ID:
			    case L_EXPR_RE:
				ckfree(e->u.string);
				break;
			    default:
				break;
			}
			break;
		    }
		    case L_NODE_VAR_DECL:
			ckfree(((VarDecl *)node)->tclprefix);
			break;
		    default:
			break;
		}
		ckfree((char *)node);
	}
}

private void
type_free(Type *type_list)
{
	while (type_list) {
		Type	*type = type_list;
		type_list = type_list->list;
		if (type->kind == L_STRUCT) ckfree(type->u.struc.tag);
		ckfree((char *)type);
	}
}

/*
 * This is basically a whacked version of EnterCmdStartData and
 * EnterCmdWordData from tclCompile.c.
 */
private void
track_cmd(int codeOffset, void *node)
{
	int	cmdIndex = L->frame->envPtr->numCommands++;
	Ast	*ast = (Ast *)node;
	int	len = ast->end - ast->beg;
	int	srcOffset = ast->beg;
	int	*wwlines;
	ECL	*ePtr;
	CmdLocation *cmdLocPtr;
	CompileEnv *envPtr = L->frame->envPtr;
	ExtCmdLoc *eclPtr = envPtr->extCmdMapPtr;

	if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
		Tcl_Panic("track_cmd: bad command index %d", cmdIndex);
	}
	if (cmdIndex >= envPtr->cmdMapEnd) {
		/*
		 * Expand the command location array by allocating
		 * more storage from the heap. The currently allocated
		 * CmdLocation entries are stored from cmdMapPtr[0] up
		 * to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
		 */
		size_t currElems = envPtr->cmdMapEnd;
		size_t newElems  = 2*currElems;
		size_t currBytes = currElems * sizeof(CmdLocation);
		size_t newBytes  = newElems * sizeof(CmdLocation);
		CmdLocation *newPtr = (CmdLocation *)ckalloc((int)newBytes);

		/*
		 * Copy from old command location array to new, free
		 * old command location array if needed, and mark new
		 * array as malloced.
		 */
		memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
		if (envPtr->mallocedCmdMap) ckfree((char *)envPtr->cmdMapPtr);
		envPtr->cmdMapPtr      = (CmdLocation *)newPtr;
		envPtr->cmdMapEnd      = newElems;
		envPtr->mallocedCmdMap = 1;
	}

	cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
	cmdLocPtr->codeOffset   = codeOffset;
	cmdLocPtr->srcOffset    = srcOffset;
	cmdLocPtr->numSrcBytes  = len;
	cmdLocPtr->numCodeBytes = currOffset(envPtr) - codeOffset;

	/*
	 * The command locations have to be sorted in ascending order
	 * by codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(),
	 * if nothing else). However, when L compiles nested function
	 * calls, the outer one will get tracked second, even though
	 * it begins first.  So we walk the new CmdLocation entry back
	 * from the end until it lands where it belongs.
	 */
	while ((cmdIndex > 0) && (envPtr->cmdMapPtr[cmdIndex-1].codeOffset >
				  envPtr->cmdMapPtr[cmdIndex].codeOffset)) {
		CmdLocation cmdLoc = envPtr->cmdMapPtr[cmdIndex];
		envPtr->cmdMapPtr[cmdIndex]   = envPtr->cmdMapPtr[cmdIndex-1];
		envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
		cmdIndex--;
	}

	if (eclPtr->nuloc >= eclPtr->nloc) {
		/*
		 * Expand the ECL array by allocating more storage
		 * from the heap. The currently allocated ECL entries
		 * are stored from eclPtr->loc[0] up to
		 * eclPtr->loc[eclPtr->nuloc-1] (inclusive).
		 */
		size_t currElems = eclPtr->nloc;
		size_t newElems = (currElems ? 2*currElems : 1);
		size_t newBytes = newElems * sizeof(ECL);
		eclPtr->loc = (ECL *) ckrealloc((char *) eclPtr->loc, newBytes);
		eclPtr->nloc = newElems;
	}

	/* We enter only one word for the L command. */
	ePtr = &eclPtr->loc[eclPtr->nuloc];
	ePtr->srcOffset = srcOffset;
	ePtr->line = (int *) ckalloc(sizeof(int));
	ePtr->nline = 1;
	wwlines = (int *) ckalloc(sizeof(int));
	wwlines[0] = ast->line;
	eclPtr->nuloc ++;
}

char *
ckstrdup(const char *str)
{
	if (str) {
		return (ckstrndup(str, strlen(str)));
	} else {
		return (NULL);
	}
}

char *
ckstrndup(const char *str, int len)
{
	char	*newStr = ckalloc(len+1);

	strncpy(newStr, str, len);
	newStr[len] = '\0';
	return (newStr);
}

char *
cksprintf(const char *fmt, ...)
{
	va_list	ap;
	int	len = 64;
	char	*buf;

	va_start(ap, fmt);
	while (!(buf = ckvsprintf(fmt, ap, len))) {
		va_end(ap);
		va_start(ap, fmt);
		len *= 2;
	}
	va_end(ap);
	return (buf);
}

/*
 * Allocate a buffer of len bytes and attempt a vsnprintf and fail
 * (return NULL) if len isn't enough.  The caller should double len
 * and re-try.  We require the caller to re-try instead of re-trying
 * here because on some platforms "ap" is changed by the vsnprintf
 * call and there is no portable way to save and restore it.
 */
char *
ckvsprintf(const char *fmt, va_list ap, int len)
{
	char	*buf = ckalloc(len);
	int	ret  = vsnprintf(buf, len, fmt, ap);
	/*
	 * The meaning of the return value depends on the platform.
	 * Some return the needed length (minus 1), some return -1,
	 * some truncate the buffer.  For the latter, ret will be
	 * len-1 and we won't know whether it barely fit or wasn't
	 * enough, to just fail on that case.
	 */
	if ((ret >= (len-1)) || (ret < 0)) {
		ckfree(buf);
		return (NULL);
	}
	return (buf);
}

/*
 * Since we have C-like variable declarations in L, when hashes and
 * arrays are declared, the base type is parsed separately from the
 * array sizes or hash-element types.  The next two functions put them
 * back together.  E.g., in
 *
 *    string h{int};
 *
 * the main type passed in to these functions is a hash type
 * (w/index type of "int") but the hash type doesn't yet have its
 * base type set, which in this example is "string".
 *
 * For simple declarations (like "string s") where there is no
 * explicit array or hash, decl->type won't be set by the parser, so
 * the base type goes there.  For arrays/hashes, decl->type points to
 * the first level of array or hash, and the base type must go onto
 * the last nested hash or array type.
 */

void
L_set_baseType(Type *type, Type *base_type)
{
	while (type->base_type) {
		ASSERT((type->kind == L_ARRAY) ||
		       (type->kind == L_HASH) ||
		       (type->kind == L_NAMEOF));
		type = type->base_type;
	}
	type->base_type = base_type;
}

void
L_set_declBaseType(VarDecl *decl, Type *base_type)
{
	if (decl->type) {
		L_set_baseType(decl->type, base_type);
	} else {
		decl->type = base_type;
	}
	if (isnameoftype(base_type)) decl->flags |= DECL_REF;
}

/*
 * These are called before each Tcl interp is created (see
 * tclInterp.c) and after it is deleted.  Set up a top-level scope and
 * call frame in order to persist typedefs, struct types, and globals
 * across all the L programs compiled inside the interp.
 */
void
TclLInitCompiler(Tcl_Interp *interp)
{
	static Lglobal	global;  // L global state

//	putenv("MallocStackLogging=1");

	/* Associate the L interp state with this interp. */
	L = (Linterp *)ckalloc(sizeof(Linterp));
	memset(L, 0, sizeof(Linterp));
	Tcl_SetAssocData(interp, "L", TclLCleanupCompiler, L);

	L->global = &global;
	L->interp = interp;
	frame_push(NULL, NULL, OUTER|SEARCH);
	L_scope_enter();
}

void
TclLCleanupCompiler(ClientData clientData, Tcl_Interp *interp)
{
	char	buf[32];

	L = (Linterp *)clientData;
	L_scope_leave();
	frame_pop();
	ast_free(L->ast_list);
	type_free(L->type_list);
	if (L->include_table) {
		Tcl_DeleteHashTable(L->include_table);
		ckfree((char *)L->include_table);
	}
	ckfree(L->file);
	ckfree(L->toplev);
	ckfree((char *)L);
	L = NULL;

	snprintf(buf, sizeof(buf), "/usr/bin/leaks %u", getpid());
//	system(buf);
}

void
L_scope_enter()
{
	Scope	*new_scope = (Scope *)ckalloc(sizeof(*new_scope));

	new_scope->structs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->structs, TCL_STRING_KEYS);

	new_scope->typedefs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->typedefs, TCL_STRING_KEYS);

	new_scope->prev = L->curr_scope;
	L->curr_scope = new_scope;
}

void
L_scope_leave()
{
	Scope	*prev = L->curr_scope->prev;

	Tcl_DeleteHashTable(L->curr_scope->structs);
	ckfree((char *)L->curr_scope->structs);

	Tcl_DeleteHashTable(L->curr_scope->typedefs);
	ckfree((char *)L->curr_scope->typedefs);

	ckfree((char *)L->curr_scope);

	L->curr_scope = prev;
}

/*
 * Called by parser to look up a reference to "struct tag".  If
 * "local" is true, check only the current scope.  If the struct
 * hasn't yet been declared, add an incomplete type to the current
 * scope's struct table whose members will get filled up later when
 * the struct is fully declared.
 */
Type *
L_struct_lookup(char *tag, int local)
{
	int		new;
	Type		*type;
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->structs, tag);
		if (local) break;
	}
	if (hPtr) {
		type = (Type *)Tcl_GetHashValue(hPtr);
	} else {
		hPtr = Tcl_CreateHashEntry(L->curr_scope->structs, tag, &new);
		type = type_mkStruct(tag, NULL, PER_INTERP);
		Tcl_SetHashValue(hPtr, type);
	}
	return (type);
}

/*
 * Called by parser to declare a new struct type.  If the struct
 * already has been declared but without any members, fill them in
 * now and return the existing type pointer.  If tag is NULL, just
 * sanity check the members' types (checking for void etc).
 */
Type *
L_struct_store(char *tag, VarDecl *m)
{
	Type	*type = NULL;

	ASSERT(m);

	if (tag) {
		type = L_struct_lookup(tag, TRUE);
		if (type->u.struc.members) {
			L_errf(m, "multiple declaration of struct %s", tag);
		} else {
			type->u.struc.members = m;
		}
	}

	/* Check member types for legality. */
	for (; m; m = m->next) {
		L_typeck_declType(m);
	}

	return (type);
}

/*
 * Called by parser to look up an ID in the typedef table to see if
 * it's been previously declared as a type name.
 */
Type *
L_typedef_lookup(char *name)
{
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->typedefs, name);
	}
	if (hPtr) {
		return ((Type *)Tcl_GetHashValue(hPtr));
	} else {
		return (NULL);
	}
}

/*
 * Called by parser to define a new type name.
 */
void
L_typedef_store(VarDecl *decl)
{
	int		new;
	Tcl_HashEntry	*hPtr;
	char		*name = decl->id->u.string;

	hPtr = Tcl_CreateHashEntry(L->curr_scope->typedefs, name, &new);
	if (new) {
		Tcl_SetHashValue(hPtr, decl->type);
	} else {
		Type *t = Tcl_GetHashValue(hPtr);
		unless (L_typeck_same(decl->type, t)) {
			L_errf(decl, "Cannot redefine type %s", name);
		}
	}
}

/*
 * This function executes the INST_L_SPLIT bytecode and is based on
 * pieces from tclCmdMZ.c.
 *
 * For edge cases, some of Perl's "split" semantics are obeyed:
 *
 * - A limit <= 0 means no limit.
 *
 * - If the regexp is ' ', we split on white space but leading
 *   white space does not produce a null first field.
 *
 * - No regexp means split on white space.
 */
Tcl_Obj *
L_split(Tcl_Interp *interp, Tcl_Obj *strobj, Tcl_Obj *reobj, Tcl_Obj *limobj)
{
	int		end, lim, matches, off, ret, start;
	int		ondefault=0, onspace=0;
	Tcl_RegExp	regExpr;
	Tcl_RegExpInfo	info;
	Tcl_Obj		*resultPtr, *objPtr, *listPtr;
	char		*str;
	int		len;

	if (limobj) {
		Tcl_GetIntFromObj(interp, limobj, &lim);
		if (lim <= 0) {
			lim = INT_MAX;
		} else {
			/* The lim is the max # fields to return,
			 * which is one less than the max # matches to
			 * allow. */
			--lim;
		}
	} else {
		lim = INT_MAX;
	}

	/*
	 * Check for the cases of no regexpr (split on white space) or
	 * splitting on ' ' (split on white space but don't return a
	 * null field for any leading white space).
	 */
	if (reobj) {
		unless (strcmp(" ", Tcl_GetString(reobj))) onspace = 1;
	} else {
		ondefault = 1;
	}

	/*
	 * Make sure to avoid problems where the objects are shared. This can
	 * cause RegExpObj <> UnicodeObj shimmering that causes data corruption.
	 * [Bug #461322]
	 */
	if (strobj == reobj) {
		objPtr = Tcl_DuplicateObj(strobj);
	} else {
		objPtr = strobj;
	}
	str = TclGetStringFromObj(objPtr, &len);

	listPtr = Tcl_NewObj();
	matches = 0;
	off     = 0;

	/*
	 * Split on white space if no regexp or ' ' was specified.  No
	 * need for the regexp engine here.
	 */
	if (ondefault || onspace) {
		int letters = 0, skip = 0;
		for (start = 0; (off < len) && (matches < lim); ++off) {
			if (skip) {
				unless (isspace(str[off])) {
					start   = off;
					letters = 1;
					skip    = 0;
					++matches;
				}
			} else {
				if (isspace(str[off])) {
					/* When regexp is ' ', create no null
					 * field for leading white space. */
					unless (onspace && !off && !start) {
						resultPtr = Tcl_NewStringObj(
								str+start,
								off-start);
						Tcl_ListObjAppendElement(
								NULL, listPtr,
								resultPtr);
					}
					skip = 1;
				} else letters = 1;
			}
		}
		unless (skip) {
			resultPtr = Tcl_NewStringObj(str+start, len-start);
			Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		}
		/* If input was all whitespace, return empty list. */
		unless (letters || !lim) listPtr = Tcl_NewObj();
		goto done;
	}

	/*
	 * Split on the specified regular expression.
	 */
	regExpr = Tcl_GetRegExpFromObj(interp, reobj,
				       TCL_REG_ADVANCED | TCL_REG_PCRE);
	unless (regExpr) {
		listPtr = Tcl_NewObj();
		goto done;
	}
	while ((off < len) && (matches < lim)) {
		ret = Tcl_RegExpExecObj(interp, regExpr, objPtr, off,
				10 /* matches */,
				((off > 0 && (str[off-1] != '\n'))
				? TCL_REG_NOTBOL : 0));
		if (ret < 0) goto done;
		if (ret == 0) break;

		Tcl_RegExpGetInfo(regExpr, &info);
		start = info.matches[0].start;
		end   = info.matches[0].end;
		matches++;

		/*
		 * Copy to the result list the portion of the source
		 * string before the match. If we matched the empty
		 * string, split after the current char.
		 */
		if (start == end) {
			ASSERT(start == 0);
			resultPtr = Tcl_NewStringObj(str+off, 1);
			++off;
		} else {
			resultPtr = Tcl_NewStringObj(str+off, start);
		}
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		off += end;
	}
	/*
	 * Copy to the result list the portion of the source string after
	 * the last match, unless we matched the last char.
	 */
	if (off < len) {
		resultPtr = Tcl_NewStringObj(str+off, len-off);
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
	}

 done:
	if (objPtr && (strobj == reobj)) {
		Tcl_DecrRefCount(objPtr);
	}
	return (listPtr);
}
