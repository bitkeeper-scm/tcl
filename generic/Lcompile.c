#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "Lcompile.h"
#include "Last.h"

static L_compile_frame *lframe = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
int L_interactive = 0;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_dump_ast_nodes(void *node);
static void L_free_ast();
static void separate_array_type(L_ast_node **name, L_ast_node **array_type);

/* we keep track of each AST node we allocate and free them all at once */
void *ast_trace_root = NULL;

/* Parse an L script into an AST */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer = (void *)L__scan_bytes(str, numBytes);

    L_trace("Parsing: %.*s\n", numBytes, str);
    L_line_number = 0;
    L_errors = NULL;
    L_parse();  /* XXX: get the AST */
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.\n");
            return TCL_ERROR;
    }
    L_trace("Done parsing.\n");
    return TCL_OK;
}

/* Compile an AST into Tcl ByteCodes */
void
LCompileScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    CompileEnv *envPtr,
    L_ast_node *ast)
{
    L_trace("Compiling: \n %.*s\n", numBytes, str);
}

/**
 * These next functions are the bulk of the parser's semantic actions.
 * Right now they attempt to compile straight to bytecode.  We may
 * want to first generate an AST so we can chew on it a little harder,
 * and don't have to mess with global variables.
 */

void 
L_begin_function_decl(L_ast_node *name) 
{
/*     Interp *iPtr = (Interp *)lframe->interp; */
/*     Proc *procPtr; */
/*     CompileEnv *envPtr; */

/*     envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv)); */
/*     L_frame_push(lframe->interp, envPtr); */

/*     procPtr = (Proc *) ckalloc(sizeof(Proc)); */
/*     procPtr->iPtr = iPtr; */
/*     procPtr->refCount = 1; */
/*     procPtr->bodyPtr = Tcl_NewObj(); */
/*     procPtr->numArgs  = 0; */
/*     procPtr->numCompiledLocals = 0; */
/*     procPtr->firstLocalPtr = NULL; */
/*     procPtr->lastLocalPtr = NULL; */

/*     TclInitCompileEnv(lframe->interp, envPtr, "L Compiler",  */
/*                       strlen("L Compiler")); */
/*     lframe->originalCodeNext = envPtr->codeNext; */
/*     envPtr->procPtr = procPtr; */
}

void 
L_end_function_decl(L_ast_node *name) 
{
/*     Tcl_Obj *bodyObjPtr; */
/*     Proc *procPtr = lframe->envPtr->procPtr; */
/*     Tcl_Command cmd; */
    
/*     /\* This is the "fall off the end" implicit return. We return "". *\/ */
/*     L_return(FALSE); */

/*     TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr); */
/*     bodyObjPtr = TclNewProcBodyObj(procPtr); */
/*     if (bodyObjPtr == NULL) { */
/*         L_bomb("failed to create a ProcBodyObj for some reason"); */
/*     } */
/*     Tcl_IncrRefCount(bodyObjPtr); */

/*     cmd = Tcl_CreateObjCommand(lframe->interp, name->v.s, */
/*         TclObjInterpProc, (ClientData) procPtr, TclProcDeleteProc); */
/*     procPtr->cmdPtr = (Command *) cmd; */


/*     TclFreeCompileEnv(lframe->envPtr); */
/*     ckfree((char *)lframe->envPtr); */
/*     L_frame_pop(); */
}


void 
L_begin_function_call(L_ast_node *name) 
{
/*     TclEmitPush(TclRegisterNewLiteral(lframe->envPtr, name->v.s,  */
/*                                       strlen(name->v.s)),  */
/*                 lframe->envPtr); */
}

void 
L_end_function_call(L_ast_node *name, int param_count) 
{
    TclEmitInstInt4(INST_INVOKE_STK4, param_count+1, lframe->envPtr);
}


#define JUMP_IF_FALSE_INDEX 0
#define JUMP_IF_END_INDEX 1

void 
L_if_condition(int unless_p) 
{
    JumpFixupArray *jumpFalsePtr;

    jumpFalsePtr = (JumpFixupArray *)ckalloc(sizeof(JumpFixupArray));
    /* save the fixup array in a compile frame so that we can do the fixups at
       the end of this if statement. */
    L_frame_push(lframe->interp, lframe->envPtr);
    lframe->jumpFixupArrayPtr = jumpFalsePtr;

    TclInitJumpFixupArray(jumpFalsePtr);
    /* allocate space for two jump fixups, one for the skipping the consequent
       and one for skipping the alternate. */
    if (2 >= jumpFalsePtr->end) {
        TclExpandJumpFixupArray(jumpFalsePtr);
    }
    jumpFalsePtr->next += 2;
    /* emit a jump which will skip the consequent if the top value on the
       stack is false. */
    TclEmitForwardJump(lframe->envPtr, 
                       unless_p ? TCL_TRUE_JUMP : TCL_FALSE_JUMP, 
                       jumpFalsePtr->fixup + JUMP_IF_FALSE_INDEX);
}

void 
L_if_consequent_end() 
{
    TclFixupForwardJumpToHere(lframe->envPtr,
                              lframe->jumpFixupArrayPtr->fixup + JUMP_IF_FALSE_INDEX,
                              127);
}

void 
L_if_alternative_end() 
{
    /* End the scope that was started for the consequent and start a new one,
       copying the jump fixup pointers. */
    JumpFixupArray *jumpFixupPtr = lframe->jumpFixupArrayPtr;
    L_frame_pop();
    L_frame_push(lframe->interp, lframe->envPtr);
    lframe->jumpFixupArrayPtr = jumpFixupPtr;

    TclEmitForwardJump(lframe->envPtr, TCL_UNCONDITIONAL_JUMP,
                       lframe->jumpFixupArrayPtr->fixup + JUMP_IF_END_INDEX);
    
    if (TclFixupForwardJumpToHere(lframe->envPtr,
                                  lframe->jumpFixupArrayPtr->fixup + JUMP_IF_FALSE_INDEX,
                                  127)) {
        L_bomb("The jump to skip the consequent of an if statement has been\n"
               "expanded, but we don't handle that case yet.");
    }
}

void 
L_if_end(int elseClause) 
{
    /* Fixup (set the target of) the appropriate jump.  */
    if (elseClause) {
        TclFixupForwardJumpToHere(lframe->envPtr,
                                  lframe->jumpFixupArrayPtr->fixup + JUMP_IF_END_INDEX,
                                  127);
    } else {
        TclFixupForwardJumpToHere(lframe->envPtr,
                                  lframe->jumpFixupArrayPtr->fixup + JUMP_IF_FALSE_INDEX,
                                  127);
    }
    /* Free the jump fixup array and end the scope. */
    TclFreeJumpFixupArray(lframe->jumpFixupArrayPtr);
    ckfree((char *)lframe->jumpFixupArrayPtr);
    L_frame_pop();
}

void
L_push_literal(L_ast_node *literal)
{
    Tcl_Obj *obj;

/*     switch (literal->type) { */
/*     case L_NODE_INT: */
/*         obj = Tcl_NewIntObj(literal->v.i); */
/*         break; */
/*     case L_NODE_FLOAT: */
/*         obj = Tcl_NewDoubleObj(literal->v.f); */
/*         break; */
/*     case L_NODE_STRING: */
/*         obj = Tcl_NewStringObj(literal->v.s, strlen(literal->v.s)); */
/*         break; */
/*     default: */
/*         L_bomb("bad literal type %d", literal->type); */
/*     } */

/* /\*     TclEmitPush(TclRegisterNewNSLiteral(lframe->envPtr,  *\/ */
/* /\*                                         str->v.s, strlen(str->v.s)),  *\/ */
/* /\*                 lframe->envPtr); *\/ */
/* /\*     TclEmitPush(TclAddLiteralObj(lframe->envPtr,  *\/ */
/* /\*                                  Tcl_NewIntObj(i->v.i), NULL),  *\/ */
/* /\*                 lframe->envPtr); *\/ */
/* /\*     TclEmitPush(TclAddLiteralObj(lframe->envPtr,  *\/ */
/* /\*                                  Tcl_NewIntObj(i->v.i), NULL),  *\/ */
/* /\*                 lframe->envPtr); *\/ */
    TclEmitPush(TclAddLiteralObj(lframe->envPtr, obj, NULL),
                lframe->envPtr);
}

void
L_push_id(L_ast_node *id)
{
/*     L_symbol *var; */

/*     if (!(var = L_get_symbol(id->v.s, TRUE))) return; */
/*     if (var->localIndex <= 255) { */
/*         TclEmitInstInt1(INST_LOAD_SCALAR1, var->localIndex, lframe->envPtr); */
/*     } else { */
/*         TclEmitInstInt4(INST_LOAD_SCALAR4, var->localIndex, lframe->envPtr); */
/*     } */
}

void 
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        TclEmitPush( TclAddLiteralObj(lframe->envPtr, Tcl_NewObj(), NULL),
                     lframe->envPtr);
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

void
L_assignment(L_ast_node *lvalue)
{
/*     L_symbol *var; */

/*     if (!(var = L_get_symbol(lvalue->v.s, TRUE))) return; */
/*     if (var->localIndex <= 255) { */
/*         TclEmitInstInt1(INST_STORE_SCALAR1, var->localIndex, lframe->envPtr); */
/*     } else { */
/*         TclEmitInstInt4(INST_STORE_SCALAR4, var->localIndex, lframe->envPtr); */
/*     } */
}

void 
L_op_pre_incdec(L_ast_node *lvalue, char op) {
/*     L_symbol *var; */
    
/*     if (!(var = L_get_symbol(lvalue->v.s, TRUE))) return; */
/*     TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex, lframe->envPtr); */
/*     TclEmitInt1((op == '+') ? 1 : -1, lframe->envPtr); */
}

void 
L_op_post_incdec(L_ast_node *lvalue, char op) 
{
/*     L_symbol *var; */
    
/*     if (!(var = L_get_symbol(lvalue->v.s, TRUE))) return; */
/*     /\* we push the value of the variable, do the increment, and then pop the */
/*        result of the increment, leaving the old value on top. *\/ */
/*     L_push_id(lvalue); */
/*     TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex, lframe->envPtr); */
/*     TclEmitInt1((op == '+') ? 1 : -1, lframe->envPtr); */
/*     TclEmitOpcode(INST_POP, lframe->envPtr); */
}

void 
L_op_binop(L_operator_name op) 
{
    int instruction;

    switch (op) {
    case L_OP_PLUS:
        instruction = INST_ADD;
        break;
    case L_OP_MINUS:
        instruction = INST_SUB;
        break;
    case L_OP_MULTIPLY:
        instruction = INST_MULT;
        break;
    case L_OP_DIVIDE:
        instruction = INST_DIV;
        break;
    case L_OP_MODULUS:
        instruction = INST_MOD;
        break;
    default:
        L_bomb("Undefined operator %d", op);
    }
    TclEmitOpcode(instruction, lframe->envPtr);
}

void 
L_declare_parameter(L_ast_node *name, int base_type)
{
/*     Proc *procPtr = lframe->envPtr->procPtr; */
/*     CompiledLocal *localPtr; */
/*     int i; */
/*     L_ast_node *array_type; */

/*     separate_array_type(&name, &array_type); */

/*     /\* formal parameters are stored in local variable slots *\/ */
/*     ++procPtr->numArgs; */
/*     procPtr->numCompiledLocals = procPtr->numArgs; */

/*     localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -  */
/*                                          sizeof(localPtr->name) +  */
/*                                          strlen(name->v.s) + 1); */
/*     if (procPtr->firstLocalPtr == NULL) { */
/*         procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr; */
/*     } else { */
/*         procPtr->lastLocalPtr->nextPtr = localPtr; */
/*         procPtr->lastLocalPtr = localPtr; */
/*     } */
/*     localPtr->nextPtr = NULL; */
/*     localPtr->nameLength = strlen(name->v.s); */
/*     localPtr->frameIndex = i; */
/*     localPtr->flags = VAR_SCALAR | VAR_ARGUMENT; */
/*     localPtr->resolveInfo = NULL; */
/*     localPtr->defValuePtr = NULL; */
/*     strcpy(localPtr->name, name->v.s); */

/*     /\* TODO: handle array types like L_declare_variable does *\/ */
/*     L_make_symbol(name->v.s, base_type, array_type,  */
/*                   procPtr->numCompiledLocals - 1); */
}

void 
L_declare_variable(L_ast_node *name, int base_type, int initialize_p)
{
/*     L_symbol *symbol; */
/*     L_ast_node *array_type = NULL; */
/*     int localIndex; */

/*     separate_array_type(&name, &array_type); */
/*     localIndex = TclFindCompiledLocal(name->v.s, strlen(name->v.s),  */
/*                                       1, 0, lframe->envPtr->procPtr); */
/*     symbol = L_make_symbol(name->v.s, base_type, array_type, localIndex); */
/* /\*     localIndex = TclRegisterNewNSLiteral(lframe->envPtr, name->v.s,  *\/ */
/* /\*                                          strlen(name->v.s)); *\/ */
/*     if (initialize_p) { */
/*         /\* initialize the variable *\/ */
/*         if (localIndex <= 255) { */
/*             TclEmitInstInt1(INST_STORE_SCALAR1, localIndex, lframe->envPtr); */
/*         } else { */
/*             TclEmitInstInt4(INST_STORE_SCALAR4, localIndex, lframe->envPtr); */
/*         } */
/*     } */
}

static void
separate_array_type(L_ast_node **name, L_ast_node **array_type)
{
/*     /\* If the name consists of more than one element, the variable is an */
/*        array.  Separate the name from the array type info prior to creating */
/*        the symbol.  *\/ */
/*     if ((*name)->next) { */
/*         L_ast_node *tmp; */
/*         /\* the array type comes first *\/ */
/*         *array_type = *name; */
/*         /\* walk down to the end where the name is  *\/ */
/*         for (tmp = *name; tmp->next && tmp->next->next; tmp = tmp->next); */
/*         /\* the name is the last node *\/ */
/*         *name = tmp->next; */
/*         /\* separate them *\/ */
/*         tmp->next = LNIL; */
/*     } */
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(char *name, int base_type, L_ast_node *array_type, int localIndex) 
{
/*     int new; */
/*     L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol)); */
/*     Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name, &new); */
/*     if (!new) { */
/*         L_errorf("Duplicate definition of symbol %s", name); */
/*     } */
/*     symbol->name = name; */
/*     symbol->base_type = base_type; */
/*     symbol->array_type = array_type; */
/*     symbol->localIndex = localIndex; */
/*     Tcl_SetHashValue(hPtr, symbol); */
/*     return symbol; */
    return (L_symbol*)0;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(char *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name);
    }
    if (hPtr) {
        return (L_symbol *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf("Undeclared variable: %s", name);
        }
        return NULL;
    }
}


/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void 
maybeFixupEmptyCode(L_compile_frame *frame) 
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        TclEmitPush( TclAddLiteralObj(frame->envPtr, Tcl_NewObj(), NULL),
            frame->envPtr);
    }
}


/* Push and Pop the L_compile_frames. */

void 
L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr) 
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->prevFrame = lframe;
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        vfprintf(stderr, format, ap);
    }
    va_end(ap);
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    TclObjPrintf(NULL, L_errors, "L Error: %s on line %d\n", s, L_line_number);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    L_error(buf);
    ckfree(buf);
}

/* Print an AST on stdout.  The AST nodes are listed in parentheses. Each
   interior node (node of type L_NODE_NODE) adds a new nesting level. */
void
L_dump_ast(L_ast_node *ast)
{
    L_trace("AST: (");
    L_dump_ast_nodes(ast);
    L_trace(")\n");
}

/* Auxiliary of L_dump_ast */
static void
L_dump_ast_nodes(void *node)
{
    switch(((L_ast_node*)node)->type) {
        /* these are all in the L_NODE_TYPE enum */
/*     case L_NODE_PROGRAM: */
/*         L_walk_l_node_progam((L_node_program *)node); */
/*         break; */
/*     case L_NODE_VARIABLE_DECLARATION: */
/*         L_walk_l_node_variable_declaration((L_node_variable_declaration *)node); */
/*         break; */
/*     case L_NODE_FUNCTION_DECLARATION: */
/*         L_walk_l_node_function_declaration((L_node_function_declaration *)node); */
/*         break; */
/*     case L_NODE_STATEMENT: */
/*         L_walk_l_node_statement((L_node_statement *)node); */
/*         break; */
/*     case L_NODE_IF_UNLESS: */
/*         L_walk_l_node_if_unless((L_node_program *)node); */
/*         break; */
/*     case L_NODE_LOOP: */
/*         L_walk_l_node_loop((L_node_program *)node); */
/*         break; */
/*     case L_NODE_EXPRESSION: */
/*         L_walk_l_node_expression((L_node_program *)node); */
/*         break; */
/*     case L_NODE_TYPE: */
/*         L_walk_l_node_type((L_node_program *)node); */
/*         break; */
    default:
        L_bomb("AST node type error: %d", ((L_ast_node*)node)->type);
    }
}

static void 
L_free_ast() {
/*     while(ast_trace_root) { */
/*         L_ast_node *node = ast_trace_root; */
/*         ast_trace_root = ast_trace_root->_trace; */
/*         if (node->type == L_NODE_STRING) { */
/*             ckfree(node->v.s); */
/*         } */
/*         ckfree((char *)node); */
/*     } */
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */


