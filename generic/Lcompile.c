/*
 * Copyright (c) 2006-2007 BitMover, Inc.
 */
#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"

/*
 * Special obj type to store deep pointers. These CANNOT ever go out of the
 * engine (ie, stored in a var or returned), and they do not remain valid
 * after any command or expression that may access variables.
 *
 * These are generated by L_DeepDiveIntoStruct and are consumed immediately
 * after that.
 */

Tcl_ObjType LdeepPtrType = {
    "l-deepType",			/* name */
    NULL,				/* freeIntRepProc */
    NULL,				/* dupIntRepProc */
    NULL,				/* updateStringProc */
    NULL			        /* setFromAnyProc */
};

/*
 * WARNING: this may break if dicts change their internal rep!
 * Dicts do not expose their guts; we need access to the hash table here. 
 */

typedef struct Dict {
    Tcl_HashTable table;	/* Object hash table to store mapping in. */
    int epoch;			/* Epoch counter */
    int refcount;		/* Reference counter (see above) */
    Tcl_Obj *chain;		/* Linked list used for invalidating the
				 * string representations of updated nested
				 * dictionaries. */
} Dict;

/*
 * Macro to find out if we can compile a regexp inline: type is set to 1 if no
 * modifiers, 'i' if only -nocase, 0 otherwise.
 */

#define REGEXP_TYPE(regexp, type) \
    {				  \
	L_expression *local = regexp; \
				      \
	type = (local->c) ? 0 : 1;			       \
	if (local->c && !strchr(local->c->u.string, 'g')) {		\
	    if (strchr(local->c->u.string, 'i')) {	       \
		type = 'i';					 \
	    } \
	} \
    }

/* Insure single tempvar per bytecode obj for non-conflicting usage */
#define SINGLE_TEMPVAR "%% L: single tempvar for non-conflicting usage"
#define get_single_tempvar() \
    (TclFindCompiledLocal(SINGLE_TEMPVAR, strlen(SINGLE_TEMPVAR),	\
	    1, lframe->envPtr->procPtr))

/* Grab the offset of the next instruction to be issued.  Stolen from
   tclCompCmds.c. */
#define CurrentOffset(envPtr) \
    ((envPtr)->codeNext - (envPtr)->codeStart)

#define SourceOffset(node) \
    ((L_ast_node *)node)->offset

#define looks_like_pattern_func(name, len, p) \
    (((len = strlen(name)) > 0) &&					\
	(name[0] >= 'A') && (name[0] <= 'Z') &&				\
	(p = strchr(name, '_'))) 

L_compile_frame *lframe = NULL;
static Tcl_HashTable *L_struct_types = NULL;
Tcl_Obj *L_errors = NULL;
int L_line_number = 0;
char *L_source_file = "";
void *L_current_ast = NULL;
int L_interactive = 0;

/* The source of the script that we're compiling. */
static char *L_script = NULL;
static int L_scriptLen = 0;

/* The token offset is the number of bytes between the beginning of the input
 * string and the beginning of a token.  It's tracked by the lexer, but we
 * declare it here so that it can be reset before lexing begins. */
int L_token_offset = 0;
int L_prev_token_len = 0;


static int gensym_counter = 0;  /* used to create unique names */

/* The table we store typedef information in.  Use L_typedef_table() to access
   it. */
Tcl_HashTable *__L_typedef_table = NULL;

/* This table stores the names of all L functions seen.  The parser uses it
 * via the interface below to identify calls to pattern functions such as
 * Frame_*. */
Tcl_HashTable *__L_func_table = NULL;

/* We use the include table to track files that have already been included,
 * since L's include() will only ever include a file once. */
Tcl_HashTable *__L_include_table = NULL;

/* these are generated by lex: */
void *L__scan_bytes (const char *bytes, int len);
void L__delete_buffer(void *buf);

/* functions local to this file */
static void L_free_ast(L_ast_node *ast);
static int global_symbol_p(L_symbol *symbol);
static void fixup_struct_type(L_type *type);
static int auto_extending_array_p(L_type *t);
static L_type *lookup_struct_type(char *tag);
static int L_push_set_of_indices(L_expression *expr, L_type *type,
	int *depthPtr, Tcl_Obj **countsPtr);
void l_push_literal(L_expression *expr);
static char *atomic_initial_value(L_type *type);
static L_symbol *import_global_symbol(L_symbol *var);
static char *gensym(char *name);
static void L_write_index(L_symbol *var, L_expression *index,
  L_expression *expr, L_expression *rval, int post_incr_p);
static Tcl_HashTable *L_typedef_table();
static L_expression *reference_mangle(char *name);
static int param_passed_by_name_p(L_variable_declaration *p);
static L_symbol *L_get_local_symbol(L_expression *name, int error_p);
static void compile_initializer(L_initializer *init, L_type *type);
static void compile_blank_initializer(L_type *type);
static char *blank_initializer_code(L_type *type, int *needs_eval);
static int LDumpAstNodes(L_ast_node *node, void *data, int order);
static int push_parameters(char *funcname, L_expression *parameters);
static void L_push_pointer(L_expression *lval);
static L_compile_frame *enclosing_loop_frame();
static void fixup_jumps(CompileEnv *envPtr, JumpOffsetList *jumps,
			int targetOffset);
static Proc *Begin_Proc();
static void Finish_Proc(Proc *procPtr, char *name);
static int instruction_for_l_op(int op);
static void regsub_for_assignment(char *varName, int varIndex,
	L_expression *regexp);
static void track_lineInfo(int codeOffset, int srcOffset, int len);
static int push_regexp_modifiers(L_expression *regexp);
static void L_do_includes(Tcl_Interp *interp, const char *str, int numBytes);
static int fresh_include_p(Tcl_Interp *interp, const char *file);
static Tcl_HashTable *L_include_table();
static char *L_include_search(Tcl_Interp *interp, const char *file);
static Tcl_HashTable *L_func_table();

/* we keep track of each AST node we allocate and free them all at once */
L_ast_node *ast_trace_root = NULL;

/* If TCL encounters an lang(L) directive while evaluating code directly,
 * e.g., from an upvar, it will enter the L compiler via L_LObjCmd(). */
int
Tcl_LObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])
{
    int stringLen;
    char *stringPtr;
    L_ast_node *ast;
    static CONST char *options[] = { "-poly", "-nowarn", NULL };
    enum options { L_POLY, L_NOWARN };
    int index, i;
    int opts = 0;

    L_trace("Entering L compiler via Tcl_LObjCmd");

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? l-program");
	return TCL_ERROR;
    }

    /* option parsing -- add flags to :opts */
    for (i = 1; i < objc - 1; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
	    != TCL_OK)
	{
	    return TCL_ERROR;
	}
	switch ((enum options)index) {
	case L_POLY:
	    L_trace("poly mode");
	    opts |= L_OPT_POLY;
	    break;
	case L_NOWARN:
	    L_trace("nowarn mode");
	    opts |= L_OPT_NOWARN;
	    break;
	default:
	    L_bomb("bad option that Tcl_GetIndexFromObj should've caught");
	}
    }

    stringPtr = Tcl_GetStringFromObj(objv[objc - 1], &stringLen);
    if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    if (ast == NULL) return TCL_OK;	/* empty script */
    return LCompileScript(interp, NULL, ast, opts);
}

/* If TCL encounters an L pragma while compiling TCL code, for example when
   processing an entire file in TclCompileScript(), it will enter L via
   TclCompileLCmd().  In that case, we get a pointer to the toplevel
   compilation environment, so we have the option of emitting global code.

   If there is an error during L compilation, we return TCL_ERROR.  However,
   the error only causes TCL to defer evaluation of the L pragma until
   runtime, at which point Tcl_LObjCmd() will recompile the L code and hit
   the same error.  */
int
TclCompileLCmd(
    Tcl_Interp *interp,
    Tcl_Parse *parsePtr,
    Command *cmdPtr,		// unused
    CompileEnv *envPtr)
{
    Tcl_Token *lTokenPtr;
    L_ast_node *ast;

    L_trace("Entering L compiler via TclCompileLCmd");
    if (parsePtr->numWords != 2) {

/*         L_bomb("Assertion failed in TclCompileLCmd: we expected 2 " */
/*                "words but got %d.", parsePtr->numWords); */

	return TCL_ERROR;
    }
    // advance to the second token
    lTokenPtr = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
    // the first component of the second token contains the code
    if (LParseScript(interp, lTokenPtr[1].start,
                     lTokenPtr[1].size, &ast) != TCL_OK) {
        return TCL_ERROR;
    }
    if (ast == NULL) {
	/* empty script, which is fine, but Tcl expects us to leave a value on
           the stack. */
        L_trace("empty script");
        L_frame_push(interp, envPtr, NULL);
        L_PUSH_STR("");
        L_frame_pop();
	return TCL_OK;
    }
    return LCompileScript(interp, envPtr, ast, 0);
}

/* Parse an L script into an AST.  Parsing and compiling are broken into two
   stages in order to support an interactive mode that parses many times
   before finally compiling.  */
int
LParseScript(
    Tcl_Interp *interp,
    CONST char *str,
    int numBytes,
    L_ast_node **L_ast
) {
    void    *lex_buffer;

    if (((Interp *)interp)->scriptFile) {
	L_source_file = Tcl_GetString(((Interp *)interp)->scriptFile);
    } else {
	L_source_file = "unknown";
    }
    L_do_includes(interp, str, numBytes);
    L_line_number = 1;
    L_token_offset = L_prev_token_len = 0;
    L_script = (char *)str;
    L_scriptLen = numBytes;
    L_start_lexer();
    lex_buffer = (void *)L__scan_bytes(str, numBytes);
    /* L_trace("Parsing: %.*s", numBytes, str); */
    L_trace("parsing");
    L_errors = NULL;
    L_parse();
    if (getenv("L_DUMP_AST") && L_current_ast) {
        if (L_WALK_ERROR ==
	    L_walk_ast(L_current_ast, L_WALK_PRE, LDumpAstNodes, NULL)) 
	{
	    L_trace("Error walking AST");
	}    
        fprintf(stderr, "\n");
    }
    if (L_ast == NULL) {
        L_free_ast(L_current_ast);
    } else {
        *L_ast = L_current_ast;
    }
    L__delete_buffer(lex_buffer);
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to parse.");
            return TCL_ERROR;
    }
    L_trace("Done parsing.");
    return TCL_OK;
}


/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
int
LCompileScript(
    Tcl_Interp *interp,
    CompileEnv *envPtr,
    void *ast,
    int opts)
{
    int result = TCL_OK;

    L_trace("compiling");
    L_frame_push(interp, envPtr, ast);
    lframe->options = opts;
    if (envPtr)
        lframe->originalCodeNext = envPtr->codeNext;

    switch(((L_ast_node*)ast)->type) {
    case L_NODE_TOPLEVEL_STATEMENT:
        result = L_compile_toplevel_statements(ast);
        break;
    default:
        L_bomb("LCompileScript error, expecting a toplevel statement, "
               "got: %s", L_node_type_tostr[((L_ast_node*)ast)->type]);
    }
    if (envPtr)
        maybeFixupEmptyCode(lframe);
    L_frame_pop();
    L_finish_typechecks();
/*     L_free_ast(ast); */
    if (L_errors) {
            Tcl_SetObjResult(interp, L_errors);
            L_trace("Failed to compile.");
            return TCL_ERROR;
    }
    L_trace("Done compiling");
    return result;
}

int
L_compile_toplevel_statements(L_toplevel_statement *stmt)
{
    L_toplevel_statement *s;
    char *name;
    Proc *toplevelProcPtr;
    int	 has_toplevel_stmt = 0;

    /* first compile the declarations */
    for (s = stmt; s; s = s->next) {
	switch (s->kind) {
	case L_TOPLEVEL_STATEMENT_FUN:
	    L_compile_function_decl(s->u.fun);
	    break;
	case L_TOPLEVEL_STATEMENT_TYPE:
	    L_compile_struct_decl(s->u.type);
	    break;
	case L_TOPLEVEL_STATEMENT_TYPEDEF:
	    /* ignore -- handled at parse time */
	    break;
	case L_TOPLEVEL_STATEMENT_GLOBAL:
	    L_compile_global_decls(s->u.global);
	    /* The initalizers of the globals are toplevel code. */
	    has_toplevel_stmt = 1;
	    break;
	case L_TOPLEVEL_STATEMENT_STMT:
	    has_toplevel_stmt = 1;
	    /* handled below */
	    break;
	case L_TOPLEVEL_STATEMENT_INC:
	    /* handled by L_do_includes() at parse time */
	    break;
	default:
	    L_bomb("Unexpected toplevel statement type %d", s->kind);
	}
    }
    if (has_toplevel_stmt == 0) return TCL_OK;
    /* Now compile the toplevel code.  It all goes into a Tcl proc that we
       call as soon as we're done building it. */
    name = gensym("%%l_toplevel");
    toplevelProcPtr = Begin_Proc();
    /* Mark the frame so that we can treat things specially */
    lframe->toplevel_p = TRUE;
    for (s = stmt; s; s = s->next) {
	switch (s->kind) {
	case L_TOPLEVEL_STATEMENT_STMT:
	    L_compile_statements(s->u.stmt);
	    break;
	case L_TOPLEVEL_STATEMENT_GLOBAL:
	    L_compile_variable_decls(s->u.global);
	    break;
	default:
	    break;
	}
    }

    L_return(FALSE);
    Finish_Proc(toplevelProcPtr, name);
    if (L_errors == NULL) {
	/* This actually invokes the toplevel code that we just compiled */
	if (lframe->envPtr) {
	    L_PUSH_STR(name);
	    L_INVOKE(1);
	} else {
	    return	Tcl_Eval(lframe->interp, name);
	}
    }
    return TCL_OK;
}

int
L_compile_include(Tcl_Interp *interp, const char *file)
{
    L_compile_frame *_lframe = lframe;
    Tcl_Obj *_L_errors = L_errors;
    int _L_line_number = L_line_number;
    char *_L_source_file = L_source_file;
    void *_L_current_ast = L_current_ast;
    char *_L_script = L_script;
    int _L_scriptLen = L_scriptLen;
    int _L_token_offset = L_token_offset;
    int _L_prev_token_len = L_prev_token_len;
    Tcl_Obj *o = Tcl_NewStringObj(file, strlen(file));
    int retval;

    L_trace("including %s\n", file);
    Tcl_IncrRefCount(o);
    retval = Tcl_FSEvalFile(interp, o);
    Tcl_DecrRefCount(o);
    lframe = _lframe;
    L_errors = _L_errors;
    L_line_number = _L_line_number;
    L_source_file = _L_source_file;
    L_current_ast = _L_current_ast;
    L_script = _L_script;
    L_scriptLen = _L_scriptLen;
    L_token_offset = _L_token_offset;
    L_prev_token_len = _L_prev_token_len;

    return retval;
}

void
L_compile_function_decl(L_function_declaration *fun)
{
    Proc *procPtr;

    if (!fun) return;
    L_trace("compiling function %s", fun->name->u.string);

    L_store_fun_type(fun);

    procPtr = Begin_Proc();
    lframe->block = (L_ast_node *)fun;

    L_compile_parameters(fun->params);
    L_compile_block(fun->body);

    /* This is the "fall off the end" implicit return. We return "". */
    L_return(FALSE);

    Finish_Proc(procPtr, fun->name->u.string);
}

static Proc *
Begin_Proc()
{
    Proc *procPtr;
    CompileEnv *envPtr;
    char *scriptCopy;

    envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
    L_frame_push(lframe->interp, envPtr, NULL);

    scriptCopy = ckalloc(L_scriptLen + 1);
    strncpy(scriptCopy, L_script, L_scriptLen);
    *(scriptCopy + L_scriptLen) = '\0';

    procPtr = (Proc *)ckalloc(sizeof(Proc));
    procPtr->iPtr = (struct Interp *)lframe->interp;
    procPtr->refCount = 1;
    procPtr->bodyPtr = Tcl_NewObj();
    Tcl_IncrRefCount(procPtr->bodyPtr);
    procPtr->numArgs  = 0;
    procPtr->numCompiledLocals = 0;
    procPtr->firstLocalPtr = NULL;
    procPtr->lastLocalPtr = NULL;
    TclInitCompileEnv(lframe->interp, envPtr, scriptCopy, L_scriptLen,
	NULL, 0);
    lframe->originalCodeNext = envPtr->codeNext;
    envPtr->procPtr = procPtr;

    return procPtr;
}

static void
Finish_Proc(
    Proc *procPtr,
    char *name)
{
    Tcl_Obj *bodyObjPtr;
    Tcl_Command cmd;

    TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
    bodyObjPtr = TclNewProcBodyObj(procPtr);
    if (bodyObjPtr == NULL) {
	L_bomb("failed to create a ProcBodyObj for some reason");
    }
    Tcl_IncrRefCount(bodyObjPtr);
#ifdef TCL_COMPILE_DEBUG
   if (getenv("L_DISASSEMBLE")) {
	printf("Bytecode for %s:\n", name);
	TclPrintByteCodeObj(lframe->interp, procPtr->bodyPtr);
   }
#endif
    cmd = Tcl_CreateObjCommand(lframe->interp, name, TclObjInterpProc,
	(ClientData) procPtr, TclProcDeleteProc);
    procPtr->cmdPtr = (Command *) cmd;
    TclFreeCompileEnv(lframe->envPtr);
    ckfree((char *)lframe->envPtr);
    L_frame_pop();
}

void
L_compile_struct_decl(L_type *decl)
{
    Tcl_HashEntry *hPtr;
    int freshp;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    if (!decl->struct_tag ||
        !(decl->struct_tag->kind == L_EXPRESSION_STRING)) {
        L_errorf(decl, "Untagged struct types are not supported yet");
        return;
    }
    hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.string,
                               &freshp);
    Tcl_SetHashValue(hPtr, decl);
    L_trace("Declared struct type %s", decl->struct_tag->u.string);
}

void
L_compile_global_decls(L_variable_declaration *decl)
{
    L_symbol *symbol;

    for (; decl; decl = decl->next) {
	symbol = L_make_symbol(decl->name, decl->type, -1);
	symbol->global_p = TRUE;
    }
}

/* Initialize the struct types table and lookup a type in it.  Returns the
   type, or NULL if none was found.  */
L_type *
lookup_struct_type(char *tag)
{
    Tcl_HashEntry *hPtr = NULL;

    if (L_struct_types == NULL) {
        L_struct_types = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
    }
    hPtr = Tcl_FindHashEntry(L_struct_types, tag);

    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        return NULL;
    }
}

/* stackeffect 0 */
void 
L_compile_variable_decls(L_variable_declaration *var)
{
    L_symbol *symbol;

    if (!var) return;
    L_trace("declaring variable %s", var->name->u.string);

    if ((symbol = L_get_symbol(var->name, FALSE)) &&
        !global_symbol_p(symbol))
    {
        L_errorf(var, "Illegal redeclaration of local variable %s",
                 var->name->u.string);
    }

    if (var->extern_p) {
	L_compile_frame *old_frame = lframe;
	L_symbol *symbol;
	L_trace("Extern var %s", var->name->u.string);
	/* stuff the extern in the uppermost symbol table as if we'd seen a
	   global declaration for it */
	if (!(symbol = L_get_local_symbol(var->name, FALSE))) {
	    while (lframe->prevFrame) lframe = lframe->prevFrame;
	    symbol = L_make_symbol(var->name, var->type, -1);
	    symbol->global_p = TRUE;
	    lframe = old_frame;
	}
    } else {
	/* if the variable isn't extern, then we must create it, so we emit
	   code to initialize it */
	if (lframe->toplevel_p) {
	    if (!(symbol = L_get_local_symbol(var->name, FALSE))) {
		L_bomb("assertion failed, global variable not declared");
	    }
	} else {
	    int localIndex;
	    localIndex = TclFindCompiledLocal(var->name->u.string,
					      strlen(var->name->u.string),
					      1, lframe->envPtr->procPtr);
	    symbol = L_make_symbol(var->name, var->type, localIndex);
	}

	if (var->initial_value) {
	    compile_initializer(var->initial_value, var->type);
	} else {
	    compile_blank_initializer(var->type);
	}
	L_STORE_SCALAR(symbol->localIndex);
	L_POP();
    }

    L_compile_variable_decls(var->next);
}

/* Compile an initializer and stack the value: stackeffect +1 */
static void
compile_initializer(
    L_initializer *init,
    L_type *type)
{
    L_initializer *i;
    int count;

    /* XXX: this is not finished.  We only handle a single dimension, and we
       don't check the field count for structs. */
    switch (type->kind) {
    case L_TYPE_STRUCT:
    case L_TYPE_ARRAY:
	if (init->value && ((L_ast_node *)init->value)->type == L_NODE_INITIALIZER) {
	    L_PUSH_STR("::list");
	    for (i = (L_initializer *)init->value, count = 0;
		 i;
		 i = i->next, count++)
	    {
		if (i->key) {
		    L_errorf(i, "Keys are not allowed in array initializers.");
		}
		L_compile_expressions(i->value);
	    }
	    L_INVOKE(count+1);
	} else {
	    L_compile_expressions(init->value);
	}
	break;
    case L_TYPE_HASH:
	if (init->value && ((L_ast_node *)init->value)->type == L_NODE_INITIALIZER) {
	    L_PUSH_STR("::list");
	    for (i = (L_initializer *)init->value, count = 0;
		 i;
		 i = i->next, count++)
	    {
		if (!i->key) {
		    L_errorf(i, "Keys are required for hash initializers.");
		} else {
		    L_compile_expressions(i->key);
		}
		L_compile_expressions(i->next_dim->value);
	    }
	    L_INVOKE((count * 2) + 1);
	} else {
	    L_compile_expressions(init->value);
	}
	break;
    default:
        /* atomic type */
        L_compile_expressions(init->value);
    }
}

/* Stack a suitable empty value for variable's type: stackeffect +1. */
static void
compile_blank_initializer(
    L_type *type)
{
    char *code;
    int needs_eval;

    /* array or struct */
    code = blank_initializer_code(type, &needs_eval);
    if (needs_eval) {
        L_PUSH_STR("::eval");
        L_PUSH_STR(code);
	L_INVOKE(2);
    } else {
        L_PUSH_STR(code);
    }
}

/* Return the default value for an atomic type, such as 0 for an int or "" for
   a string.  If the type is not atomic or has no special default initial
   value, defaults to a Tcl_Obj with an empty string rep and no type.  The
   reference count on the return value is 0. */
static char *
atomic_initial_value(L_type *type) {
    switch (type->kind) {
    case L_TYPE_INT:
        return "0";
    case L_TYPE_FLOAT:
        return "0.0";
    case L_TYPE_STRING:
    default:
        return "";
    }
}

/* Generate code to initialize an array or struct.  If name is passed,
   generate a set into a variable of that name.  needs_eval will be set to
   true if the code must be evaluated, false if the code is constant.  */
static char *
blank_initializer_code(
    L_type *type,
    int *needs_eval)
{
    Tcl_Obj *code = Tcl_NewObj();
    int brackets = 0, i;
    L_expression *retval;

    *needs_eval = FALSE;
    if (auto_extending_array_p(type)) {
	MK_STRING_NODE(retval, "");
	return retval->u.string;
    }
    Tcl_IncrRefCount(code);
    while (type->kind == L_TYPE_ARRAY) {
        if (type->array_dim->kind != L_EXPRESSION_INTEGER) {
            L_errorf(type->array_dim,
                     "Bad dimension for an array: must be an int.");
            break;
        }
        if (type->array_dim->u.integer > 0) {
            *needs_eval = TRUE;
            /* skip the outermost set of brackets  */
            if (brackets > 0) {
		Tcl_AppendPrintfToObj(code, "[");
            }
            brackets++;
	    Tcl_AppendPrintfToObj(code, "lrepeat %d ",
		type->array_dim->u.integer);
            type = type->next_dim;
        } else {
            break;
        }
    }
    /* the base type */
    if (type->kind != L_TYPE_STRUCT) {
	if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "{%s}", atomic_initial_value(type));
        } else {
	    Tcl_AppendPrintfToObj(code, "%s", atomic_initial_value(type));
        }
    } else {
        L_variable_declaration *mem;

	fixup_struct_type(type);
        *needs_eval = TRUE;
        if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "[");
        }
	Tcl_AppendPrintfToObj(code, "list ");
        for (mem = type->members; mem; mem = mem->next) {
            if (mem->type->kind == L_TYPE_ARRAY) {
                int needs_eval1;
                char *code1 = blank_initializer_code(mem->type, &needs_eval1);
                if (needs_eval1) {
		    Tcl_AppendPrintfToObj(code, "[%s] ", code1);
                } else {
		    Tcl_AppendPrintfToObj(code, "%s ", code1);
                }
            } else {
		Tcl_AppendPrintfToObj(code, " {%s} ", atomic_initial_value(mem->type));
            }
        }
        if (brackets > 0) {
	    Tcl_AppendPrintfToObj(code, "]");
        }
    }
    for (i = 1; i < brackets; i++) {
	Tcl_AppendPrintfToObj(code, "]");
    }
    MK_STRING_NODE(retval, Tcl_GetString(code));
    Tcl_DecrRefCount(code);
    L_trace("blank value: %s", retval->u.string);
    return retval->u.string;
}

void
fixup_struct_type(L_type *type)
{
/*     Tcl_Obj *val = NULL; */
/*     int i; */
    L_type *struct_type = type;
/*     L_variable_declaration *member; */

    /* if we have a struct tag without the struct definition, lookup the
       definition. */
    if (!struct_type->members) {
        if (!struct_type->struct_tag) {
            L_bomb("Assertion failed: a struct must either have a tag or "
                   "members");
        }
        struct_type = lookup_struct_type(struct_type->struct_tag->u.string);
        if (!struct_type) {
            L_errorf(type, "Undefined structure type: %s",
                     type->struct_tag->u.string);
            return;
        }
        /* Fixup the original type so that it also has the member
           information.  This allows all the other code to skip the
           lookup. */
        type->members = struct_type->members;
    }
/*     val = Tcl_NewListObj(0, NULL); */
/*     /\* initialize the struct fields *\/ */
/*     for (member = type->members; member; member = member->next, i++) { */
/*         Tcl_Obj *el = */
/*             create_array_or_struct(member->type->next_dim, member->type); */
/*         if (!el) return NULL; */
/*         Tcl_ListObjAppendElement(NULL, val, el); */
/*     } */
/*     return val; */
}

static int
auto_extending_array_p(L_type *t)
{

    return (t->kind == L_TYPE_ARRAY) &&
	(t->array_dim->kind == L_EXPRESSION_INTEGER) &&
	(t->array_dim->u.integer == 0) &&
	/* rule out struct arrays and n-dimensional arrays */
	!(t->next_dim && t->next_dim->array_dim) &&
	!(t->next_dim && t->next_dim->kind == L_TYPE_STRUCT);
}

int
global_symbol_p(L_symbol *symbol)
{
    return symbol->global_p;
}

void
L_compile_statements(L_statement *stmt)
{
    if (!stmt) return;
    switch (stmt->kind) {
    case L_STATEMENT_BLOCK:
	L_frame_push(lframe->interp, lframe->envPtr, stmt);
        L_compile_block(stmt->u.block);
	L_frame_pop();
        break;
    case L_STATEMENT_EXPR:
        L_compile_expressions(stmt->u.expr);
        /* Expressions leave a value on the evaluation stack, but statements
           don't. So pop the value. */
        L_POP();
        break;
    case L_STATEMENT_COND:
        L_compile_if_unless(stmt->u.cond);
        break;
    case L_STATEMENT_LOOP:
	L_compile_loop(stmt->u.loop);
        break;
    case L_STATEMENT_FOREACH:
	L_compile_foreach_loop(stmt->u.foreach);
	break;
    case L_STATEMENT_RETURN:
        L_trace("compiling return statement");
        if (stmt->u.expr) {
            L_trace("    with return value");
            /* compile the return value */
            L_compile_expressions(stmt->u.expr);
        } else {
            L_trace("    without return value");
            /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
            L_PUSH_STR("");
        }
        /* INST_RETURN_STK involves a little more magic that I haven't wangled out
           yet... but I think it lets us pass back error codes and such that could
           be useful. --timjr 2006.3.31  */
        /* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
        TclEmitOpcode(INST_DONE, lframe->envPtr);
        break;
    case L_STATEMENT_DECL:
	    L_bomb("Found L_STATEMENT_DECL where it's not supposed to be");
	    break;
    case L_STATEMENT_BREAK:
	L_compile_break(stmt);
	break;
    case L_STATEMENT_CONTINUE:
	L_compile_continue(stmt);
	break;
    default:
	L_bomb("Malformed AST in L_compile_statements");
    }
    L_compile_statements(stmt->next);
}

void
L_compile_block(L_block *block) {
    L_compile_variable_decls(block->decls);
    L_compile_statements(block->body);
}

void 
L_compile_parameters(L_variable_declaration *param)
{
    Proc *procPtr = lframe->envPtr->procPtr;
    CompiledLocal *localPtr;
    L_expression *name;
    int i;
    L_variable_declaration *p;
    int hasParamByName = 0;

    /* Loop through all params and create the argument list for the proc. */
    for (p = param, i = 0; p; p = p->next, i++) {
        if (param_passed_by_name_p(p)) {
            /* if the parameter is pass by name, we use a mangled name for it
               so that we can define an upvar using the original name */
            name = reference_mangle(p->name->u.string);
	    hasParamByName = 1;
        } else {
            name = p->name;
        }
        L_trace("Compiling parameter %d (%s)", i, name->u.string);
        /* Formal parameters are stored in local variable slots. */
        procPtr->numArgs = i + 1;
        procPtr->numCompiledLocals = i + 1;
        localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
                                             sizeof(localPtr->name) +
                                             strlen(name->u.string) + 1);
        if (procPtr->firstLocalPtr == NULL) {
            procPtr->firstLocalPtr = procPtr->lastLocalPtr = localPtr;
        } else {
            procPtr->lastLocalPtr->nextPtr = localPtr;
            procPtr->lastLocalPtr = localPtr;
        }
        localPtr->nextPtr = NULL;
        localPtr->nameLength = strlen(name->u.string);
        localPtr->frameIndex = i;
        localPtr->flags = VAR_ARGUMENT;
	if (p->rest_p) {
	    localPtr->flags |= VAR_IS_ARGS;
	    if (p->next) {
		L_errorf(p, "Rest parameter must be last");
	    }
	}
        localPtr->resolveInfo = NULL;
        localPtr->defValuePtr = NULL;
        strcpy(localPtr->name, name->u.string);
        L_make_symbol(name, p->type, i);
    }

    
    /* If no parameter is passed by name we are done; otherwise emit
     * instructions to create the upvar links */
    
    if (!hasParamByName) return;

    L_PUSH_CSTR("1", 1);
    for (p = param, i = 0; p; p = p->next, i++) {
	if (param_passed_by_name_p(p)) {
	    L_symbol *symbol;
	    int localIndex;
	    
	    /* if the parameter is pass by name, we use a mangled name for it
	       so that we can define an upvar using the original name */
	    name = reference_mangle(p->name->u.string);
	    symbol = L_get_symbol(name, TRUE);
	    
	    localIndex =
		TclFindCompiledLocal(p->name->u.string, strlen(p->name->u.string),
			1, procPtr);
	    L_make_symbol(p->name, p->type, localIndex);
	    L_LOAD_SCALAR(symbol->localIndex);
	    TclEmitInstInt4(INST_UPVAR, localIndex, lframe->envPtr);
	}
    }
    L_POP();
}

static int
param_passed_by_name_p(L_variable_declaration *p)
{
    return p->by_name;
}

void
L_compile_expressions(L_expression *expr)
{
    int len, param_count, startOffset;
    char *p, *name;
    L_type *type;
    L_symbol *symbol;
    Tcl_HashEntry *hPtr;

    if (!expr) return;
    startOffset = CurrentOffset(lframe->envPtr);
    switch (expr->kind) {
    case L_EXPRESSION_FUNCALL:
    	name = expr->a->u.string;
	L_trace("compiling a call to %s", name);
        if ((symbol = L_get_local_symbol(expr->a, FALSE))) {
	    /* looks like the function name is in a variable */
	    L_push_variable(expr);
	} else if (looks_like_pattern_func(name, len, p)
	    && !(hPtr = Tcl_FindHashEntry(L_func_table(), name))) {
		L_expression *newArg;

		MK_STRING_NODE(newArg, p+1);
		if ((type = L_expression_type(expr->b))
		    && (type->kind == L_TYPE_WIDGET)) {
		    L_push_variable(expr->b);
		    newArg->next = expr->b->next;
		} else {
		    *p = '\0';
		    Tcl_UtfToLower(name);
		    L_PUSH_STR(name);
		    newArg->next = expr->b;
		    *p = '_';
		}
		expr->b = newArg;
	} else {
	    L_PUSH_STR(expr->a->u.string);
	}
        param_count =
	    push_parameters(symbol ? NULL : expr->a->u.string, expr->b);
	L_INVOKE(param_count+1);
	if (!symbol) {
	    L_check_arg_count(expr->a->u.string, param_count, expr);
	}
	L_trace("tracking lineinfo for call to %s", expr->a->u.string);
	/* Since the function call node is created after all of its child
	 * nodes have been created, its offset is at the end of the complete
	 * expression. Hence subtracting the offset of the first child gives
	 * you the length of the whole expression. */
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset) + 1);
        break;
    case L_EXPRESSION_PRE:
    case L_EXPRESSION_POST:
        L_compile_incdec(expr);
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset));
        break;
    case L_EXPRESSION_UNARY:
        L_compile_unop(expr);
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset));
        break;
    case L_EXPRESSION_BINARY:
        L_trace("Binary expression");
        L_compile_binop(expr);
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset));
        break;
    case L_EXPRESSION_INTEGER:
    case L_EXPRESSION_STRING:
    case L_EXPRESSION_FLOTE:
	l_push_literal(expr);
        break;
    case L_EXPRESSION_REGEXP:
	/* for a regexp, just handle the match part */
	L_compile_expressions(expr->a);
        break;
    case L_EXPRESSION_INTERPOLATED_STRING:
        L_compile_interpolated_string(expr);
	track_lineInfo(startOffset, ((L_ast_node *)expr->a)->offset,
	    (((L_ast_node *)expr)->offset - ((L_ast_node *)expr->a)->offset));
        break;
    case L_EXPRESSION_VARIABLE:
        L_push_variable(expr);
        break;
    default:
        L_bomb("Unknown expression type %d", expr->kind);
    }
    L_compile_expressions(expr->next);
}

/* Push the parameters of a function call on the evaluation stack and return
   the number of parameters pushed.  This is complicated because we need to
   make arrays and hashtables be implicit references, and check for
   "-foovariable, &foo", in which case we make an L pointer for foo. */
static int
push_parameters(
    char *funcname,		/* if non-null, used to check param types */
    L_expression *parameters)
{
    L_expression *p;
    int i = 0;
    int widget_flag = FALSE;

    /* count the parameters stack them, checking for implicit references
       and L pointers. */
    for (i = 0, p = parameters; p; p = p->next, i++)
    {
        L_symbol *var = NULL;

	if (funcname) {
	    L_check_arg_type(funcname, i, p);
	}
        if ((p->kind == L_EXPRESSION_VARIABLE) && !p->indices) {
            var = L_get_local_symbol(p->a, FALSE);
        }
        /* if the previous parameter was -foovariable and there's an &,
           then we need to make an L pointer */
        if (widget_flag && (p->kind == L_EXPRESSION_UNARY) &&
            (p->op == T_BITAND))
        {
            L_trace("making an L pointer for %s\n", p->a->a->u.string);
            L_push_pointer(p->a);
        } else {
            /* compile just one parameter for its value */
            L_expression *next = p->next;
            p->next = NULL;
            L_compile_expressions(p);
            p->next = next;
        }
        /* if we see a parameter that looks like -foovariable, we set the
           widget flag to true so we know that the next parameter might be an
           L pointer. */
	widget_flag = FALSE;
        if (p->kind == L_EXPRESSION_STRING) {
            widget_flag =
		/* has at least the minimum length */
                (strlen(p->u.string) >= strlen("-variable")) &&
		/* starts with '-' */
                (p->u.string[0] == '-') &&
		/* ends with "variable" */
                (0 == strcmp("variable",
                             p->u.string +
                             (strlen(p->u.string) - strlen("variable"))));
        }
    }
    return i;
}

static void
L_push_pointer(L_expression *lval)
{
    L_PUSH_STR("::pointer");
    L_PUSH_STR("new");
    L_PUSH_STR(lval->a->u.string);
    if (!lval->indices) {
	L_INVOKE(3);
    } else {
        L_symbol *var;
        if (lval->indices->indices) {
            L_errorf(lval, "more than one index is not supported yet");
        }
        if (lval->indices->kind== L_EXPRESSION_HASH_INDEX) {
            L_errorf(lval, "hash keys are not yet supported by pointers");
        }
        if (!(var = L_get_local_symbol(lval->a, TRUE))) return;
        L_compile_index(var->type, lval->indices);
	L_INVOKE(4);
    }
}

/* Push a Tcl shared literal containing the value of a constant literal L AST
   node. */
void
l_push_literal(L_expression *expr)
{

    char buf[128];
	
    switch (expr->kind) {
    case L_EXPRESSION_STRING:
	L_PUSH_CSTR(expr->u.string, strlen(expr->u.string));
        return;
    case L_EXPRESSION_INTEGER:
	snprintf(buf, 128, "%i", expr->u.integer);
        break;
    case L_EXPRESSION_FLOTE:
	snprintf(buf, 128, "%f", expr->u.flote);
        break;
    case L_EXPRESSION_UNARY:
        if (expr->op == T_PLUS) {
	    snprintf(buf, 128, "%i", expr->a->u.integer);
        } else if (expr->op == T_MINUS) {
	    snprintf(buf, 128, "%i", -expr->a->u.integer);
        } else {
            L_errorf(expr, "Illegal initializer");
	    return;
        }
        break;
    default:
/*         L_bomb("l_push_literal literal can't handle expressions of type %d\n", */
/*                expr->kind); */
	return;
    }
    L_PUSH_STR(buf);
}

void L_compile_unop(L_expression *expr)
{
    switch (expr->op) {
    case T_TCL_CAST:
        if ((expr->a->kind == L_EXPRESSION_VARIABLE) && !expr->a->indices) {
            /* XXX: this duplicates some code from L_push_variable... maybe
               'twould be better to parameterize L_push_variable? */
            L_symbol *var;
            L_expression *name = expr->a->a;
            if (!(var = L_get_local_symbol(name, TRUE))) return;
            L_LOAD_SCALAR(var->localIndex);
        } else {
            /* we don't do anything special if it's not a plain jane
               variable */
            L_compile_expressions(expr->a);
        }
        break;
    case T_STRING_CAST:
        /* no conversion -- it's all a string. However, we might have to do
           something here to make the future type checker happy. */
        L_compile_expressions(expr->a);
        break;
    case T_INT_CAST:
        L_PUSH_STR("::tcl::mathfunc::int");
        L_compile_expressions(expr->a);
	L_INVOKE(2);
        break;
    case T_FLOAT_CAST:
        L_PUSH_STR("::tcl::mathfunc::double");
        L_compile_expressions(expr->a);
	L_INVOKE(2);
        break;
    case T_HASH_CAST:
        L_compile_expressions(expr->a);
        break;
    case T_BANG:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_LNOT, lframe->envPtr);
        break;
    case T_BITNOT:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_BITNOT, lframe->envPtr);
        break;
    case T_PLUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UPLUS, lframe->envPtr);
        break;
    case T_MINUS:
        L_compile_expressions(expr->a);
        TclEmitOpcode(INST_UMINUS, lframe->envPtr);
        break;
    case T_BITAND:
        /* &, address-of operator */
	L_get_local_symbol(expr->a->a, TRUE);
        L_compile_expressions(expr->a->a);
        break;
    case T_DEFINED:
        L_compile_defined(expr->a);;
        break;
    default:
        L_bomb("Unknown unary operator %d", expr->op);
    }
}

void L_compile_binop(L_expression *expr)
{
    L_type *type;

    switch (expr->op) {
    case T_EQUALS:
	if ((type = L_expression_type(expr->a))) {
	    L_check_type(type, expr->b);
	}
        L_compile_assignment(expr);
	break;
    case T_EQPLUS:
    case T_EQMINUS:
    case T_EQSTAR:
    case T_EQSLASH:
    case T_EQPERC:
    case T_EQBITAND:
    case T_EQBITOR:
    case T_EQBITXOR:
    case T_EQLSHIFT:
    case T_EQRSHIFT:
	L_check_kind(L_TYPE_NUMBER, expr->a);
	L_check_kind(L_TYPE_NUMBER, expr->b);
        L_compile_assignment(expr);
	break;
    case T_ANDAND:
    case T_OROR:
        L_compile_short_circuit_op(expr);
	break;
    case T_EQTWID:
	L_check_kind(L_TYPE_STRING, expr->a);
        L_compile_twiddle(expr);
	break;
    case T_EQ:
    case T_NE:
    case T_GT:
    case T_GE:
    case T_LT:
    case T_LE:
	L_check_kind(L_TYPE_STRING, expr->a);
	L_check_kind(L_TYPE_STRING, expr->b);
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    case T_EQUALEQUAL:
    case T_NOTEQUAL:
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    case T_GREATER:
    case T_GREATEREQ:
    case T_LESSTHAN:
    case T_LESSTHANEQ:
    case T_PLUS:
    case T_MINUS:
    case T_STAR:
    case T_SLASH:
    case T_PERC:
    case T_BITAND:
    case T_BITOR:
    case T_BITXOR:
    case T_LSHIFT:
    case T_RSHIFT:
	L_check_kind(L_TYPE_NUMBER, expr->a);
	L_check_kind(L_TYPE_NUMBER, expr->b);
        L_compile_expressions(expr->a);
        L_compile_expressions(expr->b);
        TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	break;
    default:
	L_bomb("L_compile_binop: malformed AST");
    }
}

void
L_compile_interpolated_string(L_expression *expr)
{
    int count = 2;
    
    L_compile_expressions(expr->a);
    L_compile_expressions(expr->b);
    if (expr->c) {
        L_compile_expressions(expr->c);
	count++;
    } else {
        /* Currently, an interpolated string node will always be
           followed by another one, or by a regular string node, so
           there's no way to test this branch.  */
        L_bomb("L_compile_interpolated_string: Malformed AST");
    }
    TclEmitInstInt1(INST_CONCAT1, count, lframe->envPtr);
}

void
L_compile_twiddle(L_expression *expr)
{
    Tcl_Obj *const_regexp = Tcl_NewObj();
    Tcl_RegExp compiled;
    int submatchCount = 0, i, modCount;
    L_expression *runner, *regexp = expr->b;
    int rtype;
    
    if (regexp->b) {
	/* it's a substitution, so let L_compile_assignment do the hard
	 * stuff */
	L_compile_assignment(expr);
	return;
    }
    /* put together the parts of the regexp that we know at compile time */
    Tcl_IncrRefCount(const_regexp);
    for (runner = regexp->a; runner; runner = runner->c) {
        switch (runner->kind) {
        case L_EXPRESSION_INTERPOLATED_STRING:
            Tcl_AppendToObj(const_regexp, runner->a->u.string, -1);
            /* if we ever find a spot where the regexp breaks, we could try
               adding a space to replace the runner->b interpolated part.
               (see the XXX comment below) */
            //            Tcl_AppendToObj(const_regexp, " ", 1);
            break;
        case L_EXPRESSION_STRING:
            Tcl_AppendToObj(const_regexp, runner->u.string, -1);
            break;
        default:
            L_bomb("L_compile_twiddle: Malformed AST");
        }
    }
    /* now try to compile the regexp, just to figure out how many submatches
       there are. */
    compiled = Tcl_GetRegExpFromObj(lframe->interp, const_regexp,
                                    TCL_REG_ADVANCED);
    if (compiled == NULL) {
        /* XXX: does a regexp really have to be correct sans interpolated
           parts?  If not, this error might happen at the wrong time.  To
           support such regexps, we would have to count submatches at
           runtime. */
        L_errorf(expr, "Bad regular expression");
    } else {
        submatchCount = ((TclRegexp *)compiled)->re.re_nsub;
    }
    L_trace("The submatch count in %s is %d\n",
            Tcl_GetString(const_regexp), submatchCount);
    /* create the submatch variables */
    for (i = 0; i <= submatchCount; i++) {
        char buf[128];
        L_expression *name;
	L_symbol *s;

        snprintf(buf, 128, "$%d", i);
        MK_STRING_NODE(name, buf);
        if (!L_get_symbol(name, FALSE)) {
            int localIndex =
                TclFindCompiledLocal(name->u.string, strlen(name->u.string),
                                     1, lframe->envPtr->procPtr);
            s = L_make_symbol(name, mk_type(L_TYPE_STRING, NULL, NULL, NULL,
				  NULL, FALSE), localIndex);
	    s->used_p = TRUE;	/* suppress unused var warning */
        }
    }

    /*
     * Check if the regexp can be compiled (like Tcl's)
     */

    REGEXP_TYPE(regexp, rtype);
    if  (!submatchCount && rtype) {
	/*
	 * Can compile it: no match vars, no options (or just -nocase ) 
	 */
	int simple = 0, exact = 0, nocase;

	nocase = (rtype == 'i');
	
	if (regexp->kind == L_EXPRESSION_STRING) {
	    Tcl_DString ds;
	    int len;
	    
	    /*
	     * Attempt to convert pattern to glob.  If successful, push the
	     * converted pattern as a literal.
	     */

	    len = strlen(regexp->u.string);
	    if (TclReToGlob(NULL, regexp->u.string, len, &ds, &exact)
		    == TCL_OK) {
		simple = 1;
		L_PUSH_CSTR(Tcl_DStringValue(&ds),Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
	}
	if (!simple) {
	    L_compile_expressions(regexp);
	}
	/* the target string */
	L_compile_expressions(expr->a);
	if (simple) {
	    if (exact && !nocase) {
		TclEmitOpcode(INST_STR_EQ, lframe->envPtr);
	    } else {
		TclEmitInstInt1(INST_STR_MATCH, nocase, lframe->envPtr);
	    }
	} else {
	    TclEmitInstInt1(INST_REGEXP, nocase, lframe->envPtr);
	}
	Tcl_DecrRefCount(const_regexp);
	return;
    }
    
    /* emit code to call the regexp object command */
    L_PUSH_STR("::regexp");
    /* modifiers */
    modCount = push_regexp_modifiers(regexp);
    L_PUSH_STR("--");
    /* the regexp */
    L_compile_expressions(regexp);
    /* the target string */
    L_compile_expressions(expr->a);
    /* match/submatch vars. NB: this loop always goes around at least once. */
    for (i = 0; i <= submatchCount; i++) {
	 char buf[128];
	 snprintf(buf, 128, "$%d", i);

	 /*
	  * You do not want THESE to be shared literals, likely to cause too
	  * much shimmering with literal numbers
	  *  L_PUSH_STR(buf);
	  */

	 L_PUSH_OBJ(Tcl_NewStringObj(buf, -1));
    }
    L_trace("submatch count is %d\n", submatchCount);
    L_INVOKE(5 + submatchCount + modCount);
    Tcl_DecrRefCount(const_regexp);
}

void
L_compile_short_circuit_op(L_expression *expr)
{
    int jumpOffset;
    unsigned char op;

    L_compile_expressions(expr->a);
    /* In case the operator short-circuits, we need one value on the
       evaluation stack for the jump and one for the value of the
       expression. */
    TclEmitOpcode(INST_DUP, lframe->envPtr);
    op = (expr->op == T_ANDAND) ? INST_JUMP_FALSE4 : INST_JUMP_TRUE4;
    jumpOffset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(op, 0, lframe->envPtr);
    /* If the operator doesn't short-circuit, we want to leave the value of
       the second expression on the stack, so remove the value that we DUPed
       above. */
    L_POP();
    L_compile_expressions(expr->b);
    TclUpdateInstInt4AtPc(op, CurrentOffset(lframe->envPtr) - jumpOffset,
			      lframe->envPtr->codeStart + jumpOffset);
}

void
L_compile_if_unless(L_if_unless *cond)
{
    /* There are two jumps: one that skips the consequent, called jumpFalse,
     * and one called jumpEnd that skips the alternate (else) part. */
    int jumpFalseOffset, jumpEndOffset;

    L_compile_expressions(cond->condition);
    L_PUSH_STR("0");
    TclEmitOpcode(INST_NEQ, lframe->envPtr);

    /* Emit jumpFalse.  We use fixed-size jumps to simplify the code. */
    jumpFalseOffset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP_FALSE4, 0, lframe->envPtr);

    L_frame_push(lframe->interp, lframe->envPtr, cond);

    if (cond->if_body != NULL) {
        L_compile_statements(cond->if_body);
    }

    if (cond->else_body == NULL) {
	TclUpdateInstInt4AtPc(INST_JUMP_FALSE4,
	    CurrentOffset(lframe->envPtr) - jumpFalseOffset,
	    lframe->envPtr->codeStart + jumpFalseOffset);
    } else {
        L_frame_pop();
        L_frame_push(lframe->interp, lframe->envPtr, cond);

	/* Emit jumpEnd. */
	jumpEndOffset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);

	/* Set the target on jumpFalse to here, so it skips over jumpEnd. */
	TclUpdateInstInt4AtPc(INST_JUMP_FALSE4,
	    CurrentOffset(lframe->envPtr) - jumpFalseOffset,
	    lframe->envPtr->codeStart + jumpFalseOffset);

        L_compile_statements(cond->else_body);

	/* Set the jumpEnd target to just after the body of the else part. */
	TclUpdateInstInt4AtPc(INST_JUMP4,
	    CurrentOffset(lframe->envPtr) - jumpEndOffset,
	    lframe->envPtr->codeStart + jumpEndOffset);
    }
    L_frame_pop();
}

void
L_compile_loop(L_loop *loop)
{
    int jumpToCond;
    JumpOffsetList *break_jumps, *continue_jumps;
    int bodyCodeOffset, jumpDist, startOffset;

    startOffset = CurrentOffset(lframe->envPtr);
    if ((loop->kind == L_LOOP_FOR) && loop->pre) {
        L_compile_expressions(loop->pre);
        L_POP();
    }
    /* XXX: need optimization for null conditions and infinite loops
     * See TclCompileWhileComd() for the stuff Tcl does.
     */
    jumpToCond = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
    L_frame_push(lframe->interp, lframe->envPtr, loop);
    bodyCodeOffset = CurrentOffset(lframe->envPtr);
    L_compile_statements(loop->body);
    /* grab the jump offsets out of the frame before popping it */
    break_jumps = lframe->break_jumps;
    continue_jumps = lframe->continue_jumps;
    L_frame_pop(lframe->interp, lframe->envPtr);
    fixup_jumps(lframe->envPtr, continue_jumps, CurrentOffset(lframe->envPtr));
    if ((loop->kind == L_LOOP_FOR) && loop->post) {
        L_compile_expressions(loop->post);
        L_POP();
    }
    TclUpdateInstInt4AtPc(INST_JUMP4,
	CurrentOffset(lframe->envPtr) - jumpToCond,
	lframe->envPtr->codeStart + jumpToCond);
    L_compile_expressions(loop->condition);
    jumpDist = CurrentOffset(lframe->envPtr) - bodyCodeOffset;
    if (jumpDist > 127) {
        TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
    } else {
        TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
    }
    fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
    track_lineInfo(startOffset,
	(loop->pre ? SourceOffset(loop->pre) : SourceOffset(loop->condition)) - 8,
	SourceOffset(loop));

}

/* Fix the jump target for a list of INST_JUMP4 jumps and free the
   JumpOffsetList entries. */
static void
fixup_jumps(
    CompileEnv *envPtr,		/* The envPtr that the jump is in. */
    JumpOffsetList *jumps,	/* The list of jumps to adjust. */
    int targetOffset)		/* The target to jump to, relative to the
				   beginning of the code array. */
{
    JumpOffsetList *j;
    for (j = jumps; j; jumps = j->next, ckfree((char *)j), j = jumps) {
	TclUpdateInstInt4AtPc(INST_JUMP4, targetOffset - j->offset,
			      envPtr->codeStart + j->offset);
    }
}

void
L_compile_foreach_loop(L_foreach_loop *loop)
{
    L_symbol *keyVar, *valueVar = NULL;
    int jumpWhenEmptyOffset, bodyTargetOffset, iteratorIndex, jumpDisplacement;
    JumpOffsetList *break_jumps, *continue_jumps;

    if (!(keyVar = L_get_local_symbol(loop->key, TRUE))) return;
    if (loop->value) {
	if (!(valueVar = L_get_local_symbol(loop->value, TRUE))) return;
    }
    L_compile_expressions(loop->hash);
    /* A temporary variable to hold the iterator state.*/
    iteratorIndex = TclFindCompiledLocal(NULL, 0, 1, lframe->envPtr->procPtr);
    /* Both DICT_FIRST and DICT_NEXT leave value, key, and done-p on the
       stack.  Check done-p and jump out of the loop if it's true. (We fixup
       the jump target once we know the size of the loop body.) */
    TclEmitInstInt4(INST_DICT_FIRST, iteratorIndex, lframe->envPtr);
    jumpWhenEmptyOffset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP_TRUE4, 0, lframe->envPtr);
    /* Update the key and value variables. We save the offset of this code so
       we can jump back to it after DICT_NEXT. */
    bodyTargetOffset = CurrentOffset(lframe->envPtr);
    L_STORE_SCALAR(keyVar->localIndex);
    L_POP();
    if (loop->value) {
	L_STORE_SCALAR(valueVar->localIndex);
    }
    L_POP();
    L_frame_push(lframe->interp, lframe->envPtr, loop);
    L_compile_statements(loop->body);
    /* grab the jump offsets out of the frame before popping it */
    break_jumps = lframe->break_jumps;
    continue_jumps = lframe->continue_jumps;
    L_frame_pop();
    fixup_jumps(lframe->envPtr, continue_jumps, CurrentOffset(lframe->envPtr));
    TclEmitInstInt4(INST_DICT_NEXT, iteratorIndex, lframe->envPtr);
    /* If there's another entry in the hash, go around the loop again. */
    jumpDisplacement = bodyTargetOffset - CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP_FALSE4, jumpDisplacement, lframe->envPtr);
    /* This is the end of the loop.  Point the jump after the DICT_FIRST to
       here. */
    jumpDisplacement = CurrentOffset(lframe->envPtr) - jumpWhenEmptyOffset;
    TclUpdateInstInt4AtPc(INST_JUMP_TRUE4, jumpDisplacement,
			  lframe->envPtr->codeStart + jumpWhenEmptyOffset);
    /* All done.  Cleanup the bogus values that DICT_FIRST/DICT_NEXT pushed
       and emit DICT_DONE. */
    L_POP();
    L_POP();
    fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
    /* XXX We need to ensure that DICT_DONE happens in the face of exceptions,
       so that the refcount on the dict will be decremented, and the iterator
       freed.  See the implementation of "dict for" in tclCompCmds.c.
       --timjr 2006.11.3 */
    TclEmitInstInt4(INST_DICT_DONE, iteratorIndex, lframe->envPtr);
}

/* Pushes all the indices necessary for an expression. Return value is
 * L_FIRST_IS_HASH if the first set is for a hash table, 0 otherwise. */


#define IS_HASH(index) ((index)->kind == L_EXPRESSION_HASH_INDEX)

static int
L_push_set_of_indices(
    L_expression *expr,
    L_type *type,
    int *depthPtr,
    Tcl_Obj **countsPtr)
{
    L_expression *index = expr->indices;
    int flags, isHash, depth, levelCount;
    Tcl_Obj *counts = Tcl_NewObj();
    
    if (!index) {
	Tcl_Panic("Calling L_push_set_of_indices and no indices present");
    }

    isHash = IS_HASH(index);
    flags = (isHash? L_FIRST_IS_HASH : 0);

    depth = 0;
    levelCount = 0;
    while (1) {
        type = L_compile_index(type, index);
	depth++;
	levelCount++;
        index = index->indices;
	if (index && (IS_HASH(index) == isHash)) {
	    continue;
	}

	/*
	 * This is the end of a level: lappend the levelCount to counts. Then
	 * return if we are done, or prepare for the next level.
	 */

	Tcl_ListObjAppendElement(NULL, counts, Tcl_NewIntObj(levelCount));
	if (!index) {
	    break;
	}
	isHash = !isHash;
	levelCount = 0;
    }

    *depthPtr = depth;
    *countsPtr = counts;
    return flags;
}

void
L_push_variable(L_expression *expr)
{
    L_symbol *var;
    L_expression *name = expr->a;

    if (!(var = L_get_local_symbol(name, TRUE))) {
	L_PUSH_STR("");
	return;
    }
    if (!expr->indices) {
        L_LOAD_SCALAR(var->localIndex);
    } else {
	/*
	 * Compile the L deep diving code for reading
	 *
	 * FIXME: should we use direct code for lindex/dict-get when there is
	 * only one level? Only if it is much faster ...	 
	 */

	int depth, flags;
	Tcl_Obj *counts;

	flags = L_push_set_of_indices(expr, var->type, &depth, &counts);

	/* store the list of counts at stacktop; pushing a literal, it will
	 * be reconverted to list rep at first use.
	 * FIXME: check if we can store this object as literal directly!
	 * Probably not good, it will prevent sharing.
	 */
	
	L_PUSH_STR(Tcl_GetString(counts));
	Tcl_DecrRefCount(counts);
	L_LOAD_SCALAR(var->localIndex);

	TclEmitInstInt4(INST_L_DEEP, depth+2, lframe->envPtr);
	TclEmitInt1(flags, lframe->envPtr);
    }
}

/* Import a global variable into a procedure's table of locals and
   create an L symbol that shadows the global one. Return the new L
   symbol. */
static L_symbol *
import_global_symbol(L_symbol *var)
{
    L_symbol *local;
    int localIndex;
    L_expression *name;  // eugh

    L_trace("importing global variable %s", var->name);
    /* create a new local variable that shadows the global in our
       symbol table */
    localIndex = TclFindCompiledLocal(var->name, strlen(var->name),
                                      1, lframe->envPtr->procPtr);
    MK_STRING_NODE(name, var->name);
    local = L_make_symbol(name, var->type, localIndex);
    local->used_p = TRUE;
    /* XXX: This might be bogus.  We attempt to detect whether L global
       variables should be true globals, or should be shared with the calling
       proc, by checking if the current variable frame pointer in interp is
       the same as the global frame pointer.  (Sharing variables with the
       calling proc is useful if you want to use L as an expr replacement). */
    if (((Interp *)lframe->interp)->rootFramePtr ==
	((Interp *)lframe->interp)->varFramePtr)
    {
	L_PUSH_STR("::");
	L_PUSH_STR(var->name);
	TclEmitInstInt4(INST_NSUPVAR, localIndex, lframe->envPtr);
    } else {
	L_PUSH_STR("1");
	L_PUSH_STR(var->name);
	TclEmitInstInt4(INST_UPVAR, localIndex, lframe->envPtr);
    }
    L_POP();
    return local;
}

void
L_return(int value_on_stack_p)
{
    if (!value_on_stack_p) {
        /* Leave a NULL (an Tcl_Obj with the string rep "") on the stack. */
        L_PUSH_STR("");
    }
    /* INST_RETURN_STK involves a little more magic that I haven't wangled out
       yet... but I think it lets us pass back error codes and such that could
       be useful. --timjr 2006.3.31  */
/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
    TclEmitOpcode(INST_DONE, lframe->envPtr);
}

void
L_compile_defined(L_expression *lval)
{
    L_expression *idx, *last_index;

    if ((lval->kind != L_EXPRESSION_VARIABLE) || !lval->indices) {
        L_errorf(lval, "defined is only defined for array and hash entries");
        return;
    }
    /* walk idx down to the second-to-last index */
    for (idx = lval; idx->indices && idx->indices->indices; idx = idx->indices);
    /* trim the last index off and save it in last_index */
    last_index = idx->indices;
    idx->indices = NULL;
    /* now check for the presence of the last index in the list or dict */
    if (last_index->kind == L_EXPRESSION_HASH_INDEX) {
	L_PUSH_STR("::dict");
	L_PUSH_STR("exists");
	L_compile_expressions(lval);
	L_compile_expressions(last_index->a);
	L_INVOKE(4);
    } else {
	L_compile_expressions(last_index->a);
	TclEmitOpcode(INST_DUP, lframe->envPtr);
	/* grab the length of the list */
	L_compile_expressions(lval);
	TclEmitOpcode(INST_LIST_LENGTH, lframe->envPtr);
	/* check if the index is within bounds */
	TclEmitOpcode(INST_LT, lframe->envPtr);
	TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);
	L_PUSH_STR("0");
	TclEmitOpcode(INST_GE, lframe->envPtr);
	TclEmitOpcode(INST_LAND, lframe->envPtr);
    }
    /* put the AST back the way it was */
    idx->indices = last_index;
}

void
L_compile_assignment(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a;
    L_expression *rval = expr->b;

    if (!(var = L_get_local_symbol(lval->a, TRUE))) {
	L_PUSH_STR("");
	return;
    }
    L_trace("COMPILING ASSIGNMENT: %s", L_expression_tostr[lval->a->kind],
            lval->a->u.string);
    if (lval->indices) {
        L_write_index(var, lval->indices, expr, rval, FALSE);
    } else if (expr->op == T_EQTWID) {
	L_compile_expressions(rval);	
	regsub_for_assignment(var->name, var->localIndex, rval);
    } else {
	if (expr->op != T_EQUALS) {
	    L_LOAD_SCALAR(var->localIndex);
	}
        L_compile_expressions(rval);
	if (expr->op != T_EQUALS) {
	    TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	}
        L_STORE_SCALAR(var->localIndex);
    }
}

/* Compile an expression like "baz.bar[3][4]{"asdf"} *= 2" */
static void
L_write_index(
    L_symbol *var,              /* the lvalue */
    L_expression *index,	/* the indices into the lvalue */
    L_expression *expr,		/* the whole assignment expression */
    L_expression *rval,		/* the rvalue to use. */
    int post_incr_p)		/* whether we're doing a post-increment */
{
    int depth, flags;
    Tcl_Obj *counts;
    
    /* auto-extending array special case */
    if (auto_extending_array_p(var->type) && (expr->op == T_EQUALS)) {
	if (index->indices) {
	    L_errorf(index->indices,
	      "Autoextending in multiple dimensions is not implemented yet");
	}
	L_PUSH_STR("::extendingLset");
	L_PUSH_STR(var->name);
	L_compile_index(var->type, index);
	L_compile_expressions(rval);
	L_INVOKE(4);
	return;
    }

    /*
     * FIXME: should we use direct code for lset/dict-set when there is
     * only one level? Only if it is much faster?
     */
    
    /* push the RHS first */
    L_compile_expressions(rval);
    /* <rval> */
    
    flags = L_push_set_of_indices(expr->a, var->type, &depth, &counts);
    flags |= ((expr->op == T_EQUALS)? L_DEEP_WRITE|L_DEEP_CREATE : L_DEEP_WRITE);
    /* <rval idx_1 idx_2 ...> */

    /*
     * FIXME: get llength($counts), special cases for 0 (error) and 1 (just use
     * lset or dict set?). The length is ==1 for (hashes, arrays, arrays in
     * structs and structs in arrays), >=2 when hashes and (structs or arrays)
     * are both involved.
     */
    
    /* store the list of counts at stacktop; pushing a literal, it will
     * be reconverted to list rep at first use. CAREFUL: shimmering of
     * singletons! Special string rep {foo}?
     * FIXME: should we use direct code for lindex/dict-get when there is
     * only one level and it is a read?
     */
    
    L_PUSH_STR(Tcl_GetString(counts)); //!! string rep of [list 1] is 1:
				       //!! shimmering; should we edit to {1}?
                                       // or add a space to distinguish? Could
                                       // well make the single elements be the
                                       // normal literals! How often does this
                                       // happen in Tcl?
    Tcl_DecrRefCount(counts);
    L_LOAD_SCALAR(var->localIndex);
    /* <rval idx_1 idx_2 ... counts oldval> */
    
    TclEmitInstInt4(INST_L_DEEP, depth+2, lframe->envPtr);
    TclEmitInt1(flags, lframe->envPtr);
    /* <rval elemPtr newVarVal> */
    
    /*
     * L_DEEP may lie about the stack depth, underestimating by two:
     * the INST_L_DEEP opcode is defined to remove all arguments and leave a
     * result; in some cases it leaves THREE results
     * <rval> --> <elemPtr elem rval newVarVal>.
     * Fix it.
     */

    if (expr->op != T_EQUALS) {
	lframe->envPtr->currStackDepth += 2;
    }        


    /*
     * We have now updated the deep struct to have an unshared path to the
     * element of interest. The stack now has (rval was already in):
     *  <elem newVarVal>          if op==T_EQUALS
     *  <rval elemPtr newVarVal>  otherwise
     * Set the variable, then modify elem in-place if needed
     */
    
    L_STORE_SCALAR(var->localIndex);
    L_POP();
    if (expr->op == T_EQUALS) {
	/* <elem>: nothing else to be done */
    } else {
	/* <elemPtr elem rval> */
	if (expr->op == T_EQTWID) {
	    /* regexp substitution: use tempvar as regsub_for_assignment 
	     * requires a var. Can reuse the same one: only used at the
	     * last stage, all indices are computed already and
	     * regsub_for_assignment takes care of avoiding conflicts within 
	     * itself. */
	
	    int localIndex = get_single_tempvar();
	    
	    /* <elemPtr elem rval> */
	    TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);
	    /* <elemPtr rVal elem> */

	    L_STORE_SCALAR(localIndex);
	    L_POP();

	    /* <elemPtr rval> */
	    regsub_for_assignment(SINGLE_TEMPVAR, localIndex, expr->b);
	    /* <elemPtr match?> */
	    TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);
	    L_LOAD_SCALAR(localIndex);
	    /* <match? elemPtr newVal> */
	    TclEmitInstInt1(INST_L_DEEP_WRITE, 0, lframe->envPtr);
	    L_POP();
	} else {
	    /* <elemPtr elem rval> */
	    TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
	    /* <elemPtr newVal> */
	    TclEmitInstInt1(INST_L_DEEP_WRITE, post_incr_p, lframe->envPtr);
	}
    }
}

/* Do a regexp substitution on lvalIndex and store the result back into
 * it. Leave a boolean indicating match success/failure on the stack top. */
static void
regsub_for_assignment(
    char *varName,
    int varIndex,               /* name and index of var containing subject
				 * string, and where the result will be
				 * stored */
    L_expression *regexp)	/* the regexp, substitution, and modifiers */
{
    int modCount;

    L_trace("regsub_for_assignment");
    L_PUSH_STR("::regsub");
    modCount = push_regexp_modifiers(regexp);
    L_PUSH_STR("-line");
    L_PUSH_STR("--");

    /* the regexp */
    TclEmitInstInt1(INST_ROT, 3+modCount, lframe->envPtr);

    /* the substitution */
    L_compile_expressions(regexp->b);

    /* the target string: push *after* everything else has been compiled to
     * insure that possible substitutions occur before we get the "initial
     * value" */
    L_LOAD_SCALAR(varIndex);
    TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);

    L_PUSH_STR(varName);
    L_INVOKE(modCount + 7);
}

static int
push_regexp_modifiers(L_expression *regexp)
{
    int modCount = 0;

    if (regexp->c) {
	if (strchr(regexp->c->u.string, 'i')) {
	    L_PUSH_STR("-nocase");
	    modCount++;
	}
	if (strchr(regexp->c->u.string, 'g')) {
	    L_PUSH_STR("-all");
	    modCount++;
	}
    }
    return modCount;
}

static int
instruction_for_l_op(
    int op)
{
    int instruction = 0;
    switch (op) {
    case T_EQ:
    case T_EQUALEQUAL:
	instruction = INST_EQ;
	break;
    case T_NE:
    case T_NOTEQUAL:
	instruction = INST_NEQ;
	break;
    case T_GT:
    case T_GREATER:
	instruction = INST_GT;
	break;
    case T_GE:
    case T_GREATEREQ:
	instruction = INST_GE;
	break;
    case T_LT:
    case T_LESSTHAN:
	instruction = INST_LT;
	break;
    case T_LE:
    case T_LESSTHANEQ:
	instruction = INST_LE;
	break;
    case T_PLUS:
    case T_PLUSPLUS:
    case T_EQPLUS:
	instruction = INST_ADD;
	break;
    case T_MINUS:
    case T_MINUSMINUS:
    case T_EQMINUS:
	instruction = INST_SUB;
	break;
    case T_STAR:
    case T_EQSTAR:
	instruction = INST_MULT;
	break;
    case T_SLASH:
    case T_EQSLASH:
	instruction = INST_DIV;
	break;
    case T_PERC:
    case T_EQPERC:
	instruction = INST_MOD;
	break;
    case T_BITAND:
    case T_EQBITAND:
	instruction = INST_BITAND;
	break;
    case T_BITOR:
    case T_EQBITOR:
	instruction = INST_BITOR;
	break;
    case T_BITXOR:
    case T_EQBITXOR:
	instruction = INST_BITXOR;
	break;
    case T_LSHIFT:
    case T_EQLSHIFT:
	instruction = INST_LSHIFT;
	break;
    case T_RSHIFT:
    case T_EQRSHIFT:
	instruction = INST_RSHIFT;
	break;
    default:
	L_bomb("Unable to map operator %d to an instruction", op);
    }
    return instruction;
}

/* Emit code to push an index onto the stack and return the type to use for
   compiling the next index.  We do some minimal type checking on the way. */
L_type *
L_compile_index(
    L_type *index_type,         /* The type of the index. */
    L_expression *index)        /* The index expression to compile. */
{
    L_type *t = index_type;

    switch (index->kind) {
    case L_EXPRESSION_STRUCT_INDEX: {
	/* structure member */
	L_variable_declaration *member;
	int memberOffset;
	char buf[128];

	member = L_get_struct_member(t, index, &memberOffset);

	if (!member) {
	    L_errorf(index, "Structure field not found, %s", index->a->u.string);
	    break;
	}
	snprintf(buf, 128, "%i", memberOffset);
	L_PUSH_STR(buf);
	t = member->type;
        break;
    }
    case L_EXPRESSION_ARRAY_INDEX:
        /* array index */
	L_trace("Compiling an array index");
        if (t->kind != L_TYPE_ARRAY) {
	    L_trace("Compiling an array index and it wasn't array");
            L_errorf(index, "Index into something that's not an array");
        }
        L_compile_expressions(index->a);
	t = t->next_dim ? t->next_dim :
	    mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE);
        break;
    case L_EXPRESSION_HASH_INDEX:
        L_trace("Spitting out a hash index\n");
        L_compile_expressions(index->a);
	t = mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE);
        break;
    default:
        L_bomb("Invalid kind of index, %d", index->kind);
    }
    return t;
}

L_variable_declaration *
L_get_struct_member(
    L_type *t,
    L_expression *index,
    int *memberOffset)
{
    L_variable_declaration *member;
    char *memberName;

    if (index->a->kind == L_EXPRESSION_STRING) {
	memberName = index->a->u.string;
    } else {
	L_bomb("Bad struct index");
	return (L_variable_declaration *)NULL;
    }
    if (!(t->kind == L_TYPE_STRUCT)) {
	L_errorf(index, "Not a structure: %s", L_type_tostr[t->kind]);
	return (L_variable_declaration *)NULL;
    }
    fixup_struct_type(t);
    L_trace("membername is %s", memberName);
    for (*memberOffset = 0, member = t->members;
	 member && strcmp(member->name->u.string, memberName);
	 (*memberOffset)++, member = member->next) {
	L_trace("member is %s", member->name->u.string);
    }
    return member;
}

void
L_compile_incdec(L_expression *expr)
{
    L_symbol *var;
    L_expression *lval = expr->a, *rval;

    if (!(var = L_get_local_symbol(lval->a, TRUE))) return;
    if (lval->indices) {
	MK_INT_NODE(rval, 1);
        L_write_index(var, lval->indices, expr, rval,
 		      (expr->kind == L_EXPRESSION_POST));
    } else {
        if (expr->kind == L_EXPRESSION_PRE) {
            TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                            lframe->envPtr);
            TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
        } else {
            /* we push the value of the variable, do the increment, and then pop
               the result of the increment, leaving the old value on top. */
            L_push_variable(lval);
            TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
                            lframe->envPtr);
            TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1, lframe->envPtr);
            L_POP();
        }
    }
}

void
L_compile_continue(L_statement *stmt)
{
    JumpOffsetList *j = (JumpOffsetList *)ckalloc(sizeof(JumpOffsetList));
    L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

    if (!loop_frame) {
	L_errorf(stmt,
		 "Continue may only be used inside loops");

	return;
    }
    j->offset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
    j->next = loop_frame->continue_jumps;
    loop_frame->continue_jumps = j;
}

void
L_compile_break(L_statement *stmt)
{
    JumpOffsetList *j = (JumpOffsetList *)ckalloc(sizeof(JumpOffsetList));
    L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

    if (!loop_frame) {
	L_errorf(stmt,
		 "Break may only be used inside loops and switch statements");

	return;
    }
    j->offset = CurrentOffset(lframe->envPtr);
    TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
    j->next = loop_frame->break_jumps;
    loop_frame->break_jumps = j;
}


/* Walk up the compile_frame stack and return the first one that corresponds
   to a loop.  If include_switch_p is true, match switch frames too.  Returns
   NULL if no matching frames were found. */
static L_compile_frame *
enclosing_loop_frame(int include_switch_p)
{
    L_compile_frame *f = NULL;

    /* XXX we're ignoring include_switch_p because there are no switch
       statements yet... */
    for (f = lframe; f; f = f->prevFrame) {
	if (f->block &&
	    ((((L_ast_node *)f->block)->type == L_NODE_LOOP) ||
	     (((L_ast_node *)f->block)->type == L_NODE_FOREACH_LOOP)))
	{
	    break;
	}
    }
    return f;
}

/* Create a new symbol and add it to the current symbol table */
L_symbol *
L_make_symbol(
    L_expression *name,
    L_type *type,
    int localIndex)
{
    int new;
    L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(lframe->symtab, name->u.string, &new);
    if (!new) {
        L_errorf(name, "Duplicate definition of symbol %s", name->u.string);
    }
    symbol->name = name->u.string;
    symbol->type = type;
    symbol->localIndex = localIndex;
    symbol->global_p = FALSE;
    symbol->used_p = FALSE;
    symbol->node = (L_ast_node *)name;
    Tcl_SetHashValue(hPtr, symbol);
    return symbol;
}

/* Look up a symbol in the current symbol table.  If the symbol is a global,
   import the global.  Return NULL and optionally emit an error if symbol is
   not found. */
static L_symbol *
L_get_local_symbol(L_expression *name, int error_p)
{
    L_symbol *var;

    if (!(var = L_get_symbol(name, error_p))) return NULL;
    if (global_symbol_p(var)) {
        L_trace("it's a global");
        var = import_global_symbol(var);
    }
    return var;
}

/* Look up a symbol in the current symbol table, return NULL and optionally
   emit an error if not found */
L_symbol *
L_get_symbol(L_expression *name, int error_p) 
{
    Tcl_HashEntry *hPtr = NULL; 
    L_compile_frame *frame;
    L_symbol *symbol;

    for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
        hPtr = Tcl_FindHashEntry(frame->symtab, name->u.string);
    }
    if (hPtr) {
        symbol = (L_symbol *)Tcl_GetHashValue(hPtr);
	symbol->used_p = TRUE;
	return symbol;
    } else {
	L_trace("Unable to find symbol %s", name->u.string);
        if (error_p) {
            L_errorf(name, "Undeclared variable: %s", name->u.string);
        }
        return NULL;
    }
}

/* Stick an & on the front of name and return the result as an L AST node. */
static L_expression *
reference_mangle(char *name) {
    L_expression *node;
    char *mangled_name = ckalloc(strlen(name) + 2);
    sprintf(mangled_name, "&%s", name);
    MK_STRING_NODE(node, mangled_name);
    ckfree(mangled_name);
    return node;
}

/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
void
maybeFixupEmptyCode(L_compile_frame *frame)
{
    if (frame->envPtr->codeNext == frame->originalCodeNext) {
        L_PUSH_STR("");
    }
}

/* Make a new unique name.  It will be freed when the current AST is freed. */
static char *
gensym(char *name)
{
    L_expression *node;
    char *gensym = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
    sprintf(gensym, "%d%s", gensym_counter++, name);
    /* exploit the property of AST nodes that they'll free the string after
       compilation has finished. */
    MK_STRING_NODE(node, gensym);
    ckfree(gensym);
    return node->u.string;
}

/* Push and Pop the L_compile_frames. */
void 
L_frame_push(
    Tcl_Interp *interp,
    CompileEnv *envPtr,
    void *block)		/* The AST node of the current block, or NULL
				   if none. */
{
    L_compile_frame *new_frame = 
        (L_compile_frame *)ckalloc(sizeof(L_compile_frame));
    new_frame->interp = interp;
    new_frame->envPtr = envPtr;
    new_frame->block = block;
    new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
    new_frame->continue_jumps = NULL;
    new_frame->break_jumps = NULL;
    new_frame->toplevel_p = FALSE;
    new_frame->prevFrame = lframe;
    /* inherit options from the previous frame */
    if (lframe != NULL) {
	new_frame->options = lframe->options;
    }
    lframe = new_frame;
}

void 
L_frame_pop() 
{
    L_compile_frame *prev = lframe->prevFrame;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSearch;
    L_symbol *symbol;

//    if (!lframe->toplevel_p) {
    /* Check for unused variables */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch);
	 hPtr != NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch))
    {
	symbol = (L_symbol *)Tcl_GetHashValue(hPtr);
	if (!symbol->used_p) {
	    L_warningf(symbol->node, "Unused variable %s", symbol->name);
	}
    }

    /* free the symbol table */
    for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSearch)) {
        ckfree(Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(lframe->symtab);
    ckfree((char *)lframe->symtab);
    /* now free the frame itself and update the global frame pointer */
    ckfree((char *)lframe);
    lframe = prev;
}

/* Give up the ghost. */
void 
L_bomb(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    fprintf(stderr, "L Internal Error: ");
    vfprintf(stderr, format, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    exit(1);
}

/* Print L compiler debugging info. */
void 
L_trace(const char *format, ...) 
{
    va_list ap;

    va_start(ap, format);
    if (getenv("LTRACE")) {
        fprintf(stderr, "***: ");
        vfprintf(stderr, format, ap);
        fprintf(stderr, "\n");
    }
    va_end(ap);
    fflush(stderr);
}

void
L_warning(char *s)
{
    if (!(lframe && lframe->options & L_OPT_NOWARN)) {
	/* XXX there must be a better way to emit a warning */
	fprintf(stderr, "L Warning: %s\n", s);
    }
}

void
L_warningf(void *node, const char *format, ...)
{
    va_list ap;

    if (!(lframe && lframe->options & L_OPT_NOWARN)) {
	va_start(ap, format);
	if (node) {
	    fprintf(stderr, "%s:%d: ", L_source_file,
		((L_ast_node *)node)->line_no);
	}
	fprintf(stderr, "L Warning: ");
	vfprintf(stderr, format, ap);
	fprintf(stderr, "\n");
	va_end(ap);
    }
}

/* L_error is yyerror */
void
L_error(char *s)
{
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    Tcl_AppendPrintfToObj(L_errors, "%s:%d: L Error: %s\n",
	L_source_file, L_line_number, s);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
    va_list ap;
    char *buf;

    va_start(ap, format);
    /* this would be nice, but it's not exported functionality: */
    /* ObjPrintfVA(NULL, L_errors, format, ap); */
    /* GNU also has a nice memory allocating sprintf function we might be able
       to use: */
    /* #ifdef _GNU_SOURCE */
    /*     vasprintf(&buf, format, ap); */
    /*     L_error(buf); */
    /*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
    buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
    vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
    va_end(ap);
    if (!L_errors) {
        L_errors = Tcl_NewObj();
    }
    if (node) {
	Tcl_AppendPrintfToObj(L_errors, "%s:%d: ",
	    L_source_file, ((L_ast_node *)node)->line_no);
    }
    Tcl_AppendPrintfToObj(L_errors, "L Error: %s\n", buf);
    ckfree(buf);
}

/* /\* */
/*  * Example of an AST dumper... needs work */
/*  *\/ */
/* int LCountNodes(void *node, void *data, int order) */
/* { */
/*     int i; */
/*     int *indent = (int *)data; */

/*     if (indent == NULL) { */
/* 	fprintf(stderr, "FOO!\n"); */
/* 	return L_WALK_ERROR; */
/*     } */
/*     if (order & L_WALK_PRE) { */
/* 	for (i = 0; i < (*indent); i++) fprintf(stderr, " "); */
/* 	fprintf(stderr, "%s: ", */
/* 	  L_node_type_tostr[((L_ast_node *)node)->type]); */
/* 	if (((L_ast_node *)node)->type == L_NODE_EXPRESSION) { */
/* 	    L_expression *e = (L_expression *)node; */
/* 	    switch (e->kind) { */
/* 		case L_EXPRESSION_STRING: */
/* 			fprintf(stderr, "%s\n", e->u.string); */
/* 			break; */
/* 		case L_EXPRESSION_INTEGER: */
/* 			fprintf(stderr, "%d\n", e->u.integer); */
/* 			break; */
/* 		default: */
/* 			fprintf(stderr, "\n"); */
/* 			break; */
/* 	    } */
/* 	} else { */
/* 	    fprintf(stderr, "\n"); */
/* 	} */
/* 	(*indent)++; */
/*     } */
/*     if (order & L_WALK_POST) { */
/* 	(*indent)--; */
/*     } */

/*     return L_WALK_CONTINUE; */
/* } */

/* An AST walker that dumps an AST with parens around it. */
static int
LDumpAstNodes(L_ast_node *node, void *data, int order)
{
    if (order & L_WALK_PRE) {
        fprintf(stderr, "(%s", L_node_type_tostr[node->type]);
        switch (node->type) {
        case L_NODE_STATEMENT:
            fprintf(stderr, " :kind %s",
                    L_statement_tostr[((L_statement *)node)->kind]);
            break;
        case L_NODE_TYPE:
            fprintf(stderr, " :kind %s",
                    L_type_tostr[((L_type *)node)->kind]);
            break;
        case L_NODE_LOOP:
            fprintf(stderr, " :kind %s",
                    L_loop_tostr[((L_loop *)node)->kind]);
            break;
        case L_NODE_TOPLEVEL_STATEMENT:
            fprintf(stderr, " :kind %s",
                    L_toplevel_statement_tostr[((L_toplevel_statement *)
                                                node)->kind]);
            break;
        case L_NODE_FUNCTION_DECLARATION:
            break;
        case L_NODE_VARIABLE_DECLARATION:
            break;
        case L_NODE_BLOCK:
            break;
        case L_NODE_INITIALIZER:
            break;
        case L_NODE_EXPRESSION: {
            L_expression *expr = (L_expression *)node;
            fprintf(stderr, " :kind %s", L_expression_tostr[expr->kind]);
            switch (expr->kind) {
            case L_EXPRESSION_INTEGER:
                fprintf(stderr, " :value %d", expr->u.integer);
                break;
            case L_EXPRESSION_STRING:
                /* XXX if there's a double-quote in the string, escape it by
                   hand */
                fprintf(stderr, " :value \"%s\"", expr->u.string);
                break;
            case L_EXPRESSION_FLOTE:
                fprintf(stderr, " :value %e", expr->u.flote);
                break;
            default:
                break;
            }
        }
            break;
        case L_NODE_IF_UNLESS:
            break;
        default:
            L_bomb("undefined node type in LDumpAstNodes");
        }
    }
    if (order & L_WALK_POST) {
        fprintf(stderr, ")");
    }
    return L_WALK_CONTINUE;
}

static void 
L_free_ast(L_ast_node *ast) {
    L_trace("Freeing L AST");
    while(ast_trace_root) {
        L_ast_node *node = ast_trace_root;
        ast_trace_root = ast_trace_root->_trace;
        if (node->type == L_NODE_EXPRESSION &&
            ((L_expression *)node)->kind == L_EXPRESSION_STRING) {
            ckfree(((L_expression *)node)->u.string);
        }
        ckfree((char *)node);
    }
    ast_trace_root = NULL;
    /* clean up the various tables too */
    Tcl_DeleteHashTable(__L_typedef_table);
    Tcl_DeleteHashTable(__L_func_table);
    Tcl_DeleteHashTable(__L_include_table);
    ckfree((char *)__L_typedef_table);
    ckfree((char *)__L_func_table);
    ckfree((char *)__L_include_table);
    __L_typedef_table = NULL;
    __L_func_table = NULL;
    __L_include_table = NULL;
}

/* Typedefs are handled at "parse time".  When the compiler walks the AST it
   can ignore them, since the types get copied into the AST by the parser. */

/* return the typedef table.  initialize it if it hasn't been initialized
   yet. */
static Tcl_HashTable *L_typedef_table() {
    if (!__L_typedef_table) {
        __L_typedef_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(__L_typedef_table, TCL_STRING_KEYS);
    }
    return __L_typedef_table;
}

L_type *L_lookup_typedef(L_expression *name, int error_p) {
    Tcl_HashEntry *hPtr = NULL;
    hPtr = Tcl_FindHashEntry(L_typedef_table(), name->u.string);
    if (hPtr) {
        return (L_type *)Tcl_GetHashValue(hPtr);
    } else {
        if (error_p) {
            L_errorf(name, "Undeclared type: %s", name->u.string);
        }
        return NULL;
    }
}

/* side effects: modifies the type so that typedef_p is true, maps name to
   type in the typedef table so that type will will be returned by
   L_lookup_typedef of name. */
void L_store_typedef(L_expression *name, L_type *type) {
    int new;
    Tcl_HashEntry *hPtr;
    L_type *t;

    hPtr = Tcl_CreateHashEntry(L_typedef_table(), name->u.string, &new);
    if (!new) {
	t = Tcl_GetHashValue(hPtr);
	if (type->kind != t->kind) {
            L_errorf(name, "Cannot redefine type: %s", name->u.string);
	}
    } else {
	/* mark all dimensions of the type as belonging to a typedef */
	for (t = type; t; t->typedef_p = TRUE, t = t->next_dim);

	Tcl_SetHashValue(hPtr, type);
    }
}

/* Pattern functions are also handled at parse time. */
static Tcl_HashTable *L_func_table() {
    if (!__L_func_table) {
        __L_func_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(__L_func_table, TCL_STRING_KEYS);
    }
    return __L_func_table;
}

/* This function returns true if the function :name is a pattern function.  In
 * that case, the name to use when calling the function is returned in
 * :newName, and the value to use for the first parameter is in :firstArg. */
int
L_lookup_pattern_func(
    char	 *name, 	/* The name of the function to look up */
    L_expression **newName, 	/* The name to use (only if retval is true) */
    L_expression **firstArg) 	/* The argument part of the name */
{
    int len;
    char *p, buf[1024];
    Tcl_HashEntry *hPtr = NULL;
    
    if (looks_like_pattern_func(name, len, p)
    	&& !(hPtr = Tcl_FindHashEntry(L_func_table(), name))) {
	/* The function being called is not a real function. */
	*p = '\0';
	snprintf(buf, sizeof(buf), "%s_*", name);
	hPtr = Tcl_FindHashEntry(L_func_table(), buf);
	*p = '_';
	if (hPtr) {
	    MK_STRING_NODE(*newName, buf);
	    MK_STRING_NODE(*firstArg, p+1);
	    L_trace("Pattern function for %s found!", name);
	    return TRUE;
	}
    }
    L_trace("No pattern function for %s found", name);
    return FALSE;
}

/* Stuff :name in the func table */
void L_pattern_store_name(L_expression *name) {
    int new;

    L_trace("Storing pattern function named %s", name->u.string);
    Tcl_CreateHashEntry(L_func_table(), name->u.string, &new);
}

/* XXX this is basically a whacked version of EnterCmdStartData int
 * tclCompile.c. */
static void
track_lineInfo(
    int codeOffset,		/* Where this command's bytecode starts */
    int srcOffset,		/* Where the source of the command starts (in
				 * L_script) */
    int len)			/* The length of the source of the command. */
{
    CmdLocation *cmdLocPtr;
    CompileEnv *envPtr = lframe->envPtr;
    int cmdIndex = lframe->envPtr->numCommands++;

    if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
	Tcl_Panic("track_lineInfo: bad command index %d", cmdIndex);
    }
    
    if (cmdIndex >= envPtr->cmdMapEnd) {
	/*
	 * Expand the command location array by allocating more storage from
	 * the heap. The currently allocated CmdLocation entries are stored
	 * from cmdMapPtr[0] up to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
	 */

	size_t currElems = envPtr->cmdMapEnd;
	size_t newElems = 2*currElems;
	size_t currBytes = currElems * sizeof(CmdLocation);
	size_t newBytes = newElems * sizeof(CmdLocation);
	CmdLocation *newPtr = (CmdLocation *) ckalloc((unsigned) newBytes);

	/*
	 * Copy from old command location array to new, free old command
	 * location array if needed, and mark new array as malloced.
	 */

	memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
	if (envPtr->mallocedCmdMap) {
	    ckfree((char *) envPtr->cmdMapPtr);
	}
	envPtr->cmdMapPtr = (CmdLocation *) newPtr;
	envPtr->cmdMapEnd = newElems;
	envPtr->mallocedCmdMap = 1;
    }

    cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
    cmdLocPtr->codeOffset = codeOffset;
    /* XXX there seems to be an off-by-one someplace in Tcl, to whit:
     * fprintf(stderr, "KKK: %.*s\n", len, lframe->envPtr->source + srcOffset);
     */
    cmdLocPtr->srcOffset = srcOffset -1;
    cmdLocPtr->numSrcBytes = len;
    cmdLocPtr->numCodeBytes = CurrentOffset(envPtr) - codeOffset;

    /* The command locations have to be sorted in ascending order by
     * codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(), if nothing
     * else). However, when L compiles nested function calls, the outer one
     * will get tracked second, even though it begins first.  So we walk the
     * new CmdLocation entry back from the end until it lands where it
     * belongs. */
    while ((cmdIndex > 0) &&
	(envPtr->cmdMapPtr[cmdIndex-1].codeOffset > 
	    envPtr->cmdMapPtr[cmdIndex].codeOffset))
    {
	CmdLocation cmdLoc;

	cmdLoc = envPtr->cmdMapPtr[cmdIndex];
	envPtr->cmdMapPtr[cmdIndex] = envPtr->cmdMapPtr[cmdIndex-1];
	envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
	cmdIndex--;
    }
}

static void
L_do_includes(
    Tcl_Interp *interp,
    const char *bytes,
    int numBytes)
{
    Tcl_RegExp includeRe = NULL;
    Tcl_Obj *strObj = Tcl_NewStringObj(bytes, numBytes);
    Tcl_Obj *regexObj = Tcl_NewStringObj(
	    "^include\\s*\\(\\s*\"([^)\"]+)\"\\s*\\)\\s*;",
	    -1);
    int offset = 0;

    Tcl_IncrRefCount(regexObj);
    includeRe =
	Tcl_GetRegExpFromObj(interp, regexObj, TCL_REG_ADVANCED | TCL_REG_NLANCH);
    Tcl_DecrRefCount(regexObj);

    Tcl_IncrRefCount(strObj);
    while (Tcl_RegExpExecObj(interp, includeRe, strObj, offset, 2, 0)) {
	const char *start, *end;
	char *file, *tmp;

	/* grab the first submatch -- the include file */
	Tcl_RegExpRange(includeRe, 1, &start, &end);

	/* search the include path */
	tmp = ckstrndup(start+offset, end - start);
	file = L_include_search(interp, tmp);
	ckfree(tmp);

	/* only include each file once */
	if (fresh_include_p(interp, file)) {
	    if (L_compile_include(interp, file) != TCL_OK) {
		L_warningf(NULL, "Unable to include file %s: \n%s", file,
		    Tcl_GetStringResult(interp));
	    }
	}
	ckfree(file);

	/* advance the starting offset by the length of the complete match */
	Tcl_RegExpRange(includeRe, 0, &start, &end);
	offset += end - start;
    }
    Tcl_DecrRefCount(strObj);
}

/* Search for file in the include path.  Currently only looks in the directory
 * of the current script (i.e., dirname of [info script]).  Only call this
 * with a relative path! */
static char *
L_include_search(Tcl_Interp *interp, const char *file)
{
    char *resolvedFile;
    Interp *iPtr = (Interp *)interp;
    Tcl_Obj *fileObj = Tcl_NewStringObj(file, -1);

	/* if the path is relative, make it absolute */
    Tcl_IncrRefCount(fileObj);
    if (Tcl_FSGetPathType(fileObj) == TCL_PATH_ABSOLUTE || !iPtr->scriptFile)
    {
	resolvedFile = ckstrdup(file);
    } else {
	Tcl_Obj *scriptDir =
	    TclPathPart(interp, iPtr->scriptFile, TCL_PATH_DIRNAME);
	Tcl_AppendPrintfToObj(scriptDir, "/%s", file);
	resolvedFile = ckstrdup(Tcl_GetString(scriptDir));
    }
    Tcl_DecrRefCount(fileObj);
    return resolvedFile;
}

/* Return true if a file has never been included before */
static int
fresh_include_p(Tcl_Interp *interp, const char *file)
{
    int new;
    char *normalizedPath;
    Tcl_Obj *pathPtr;
    Tcl_HashEntry *hPtr;

    /* get a canonical path for the file */
    pathPtr = Tcl_NewStringObj(file, -1);
    Tcl_IncrRefCount(pathPtr);
    if ((pathPtr = Tcl_FSGetNormalizedPath(NULL, pathPtr)) == NULL) {
	L_errorf(NULL, "Unable to normalize include file %s\n", file);
	return TRUE;
    }
    normalizedPath = Tcl_GetString(pathPtr);

    /* check if it's already been included */
    hPtr = Tcl_CreateHashEntry(L_include_table(), normalizedPath, &new);
    if (!new) {
	L_trace("file %s already included", normalizedPath);
    }
    Tcl_DecrRefCount(pathPtr);
    return new;
}

/* return the include table.  initialize it if it hasn't been initialized
   yet. */
static Tcl_HashTable *L_include_table() {
    if (!__L_include_table) {
        __L_include_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
        Tcl_InitHashTable(__L_include_table, TCL_STRING_KEYS);
    }
    return __L_include_table;
}

char *
ckstrdup(const char *str)
{
    return ckstrndup(str, strlen(str));
}

char *
ckstrndup(const char *str, int len)
{
    char *newStr = ckalloc(len+1);
    strncpy(newStr, str, len);
    newStr[len] = '\0';
    return newStr;
}



/*
 * L_DeepDiveIntoStruct is adapted from TclLSetFlat, DictObjGet and friends.
 *
 * It returns a Tcl_Obj of LdeepPtrType (careful, VERY special handling
 * required!) with reference count 1. The internal rep is a pointer to the
 * location of the element within the deep structure.
 *
 * If L_DEEP_WRITE is passed in the flags, the path to the element is
 * guaranteed to be unshared, and all string reps in the path will be
 * invalidated. If L_DEEP_CREATE is also passed, the path will be created if
 * necessary and an empty obj will be stored at the element.
 */
 
Tcl_Obj **
L_DeepDiveIntoStruct(
    Tcl_Interp *interp,
    Tcl_Obj *valuePtr,    /* pointer to the nested struct to dive into; any
			   * modifications will be written in place */
    Tcl_Obj **idxPtr,     /* the array of indices */
    Tcl_Obj *countPtr,    /* a list of counts for each level - a level being a
			   * contiguous set of indices of same kind (ie: hash
			   * indices or list indices). */
    int flags)            /* flag bits are L_FIRST_IS_HASH, L_DEEP_WRITE and
			   * L_DEEP_CREATE*/
{
    int typeIsHash = (flags & L_FIRST_IS_HASH);
    
    int result, numLevels, i;
    Tcl_Obj **levelCountPtr, *currValuePtr = valuePtr;
    Tcl_Obj **resultPtrPtr, *lastPtr;
    int create = (flags & L_DEEP_CREATE);
    int write = (flags & L_DEEP_WRITE);

    /*
     * TODO:
     *   - negative indices for lists
     *   - special case for just 1 level? Standard dict and list commands
     *     handle this. Note that the dict opcode for dict-set requires a var!
     *     Do we want to insist on deep-diving only into vars, or are values
     *     fair game too?
     *   - make sure (in the compiler) that struct offsets are always
     *     literals.
     *   - auto-extend: need to know (at the prober nesting levels) if the
     *     level is extensible, and access to the level's initialiser. For
     *     dict levels extensibility is easy (always extensible).
     */
    
    
    if (write && (valuePtr->refCount != 1)) {
	Tcl_Panic(
	    "L_DeepDiveIntoStruct called for writing on an obj with refCount = %i != 1!",
	    valuePtr->refCount);
    }

    if ((countPtr->typePtr != &tclListType) &&
	    (TCL_OK == TclGetIntFromObj(NULL, countPtr, &i))) {
	/* NOTE: when countPtr is a singleton, avoid causing unwanted 
	 * shimmering between dict and number! Special case it.
	 */

	numLevels = 1;
	levelCountPtr = &countPtr;
    } else {
	if (Tcl_IsShared(countPtr)) {
	    /*
	     * Make a copy to prevent the intrep to shimmer away from us.
	     */
	    
	    countPtr = TclListObjCopy(interp, countPtr);
	    if (!countPtr) {
		return NULL;
	    }
	}
	
	result = Tcl_ListObjGetElements(interp, countPtr, &numLevels, &levelCountPtr);
	if (result != TCL_OK) {
	    return NULL;
	}
	if (!numLevels) {
	    return NULL;
	}
    }
    Tcl_IncrRefCount(countPtr);
    
    for (i = 0; i < numLevels; i++) {
	int idxCount;

	result = Tcl_GetIntFromObj(interp, *levelCountPtr, &idxCount);
	if (result != TCL_OK) {
	    goto done;
	}
	
	if (typeIsHash) {
	    /*
	     * Essentially, DictObjGet/DictObjSet.
	     * Loop through the list of keys, looking up the key at the
	     * current index in the current dictionary each time. Once we've
	     * done the lookup, we set the current dictionary to be the value
	     * we looked up (in case the value was not the last one and we are
	     * going through a chain of searches.) Note that this loop always
	     * executes at least once. 
	     */

	    int tmp;
	    Tcl_HashEntry *hPtr;
	    Dict *dict;
	    Tcl_Obj *objPtr;
	    void **tmpPtrPtr; /* to avoid type punning */
	    
	    if (write && Tcl_IsShared(currValuePtr)) Tcl_Panic("A shared dict in the path\n");
	    if (idxCount==1) {
		/*
		 * This is unshared when writing: a loop invariant.
		 */

		lastPtr = currValuePtr;
	    } else {
		int traceFlags = 0;

		if (!write) {
		    traceFlags = DICT_PATH_READ;
		} else if (create) {
		    traceFlags = DICT_PATH_CREATE;
		} else {
		    traceFlags = DICT_PATH_UPDATE;
		}

		lastPtr = TclTraceDictPath(interp, currValuePtr, idxCount-1, idxPtr, traceFlags);
		if (!lastPtr) {
		    /* FIXME: error message ok? What if error before the last
		       step? */
		    goto dictErr;
		}
		if (write && Tcl_IsShared(lastPtr)) {
		    Tcl_Panic("Shared lastPtr of dict type");
		}
	    }

	    /*
	     * Look for the corresponding entry. Get into the dict guts ...
	     */

	    if (TCL_OK != Tcl_DictObjSize(NULL, lastPtr, &tmp)) {
		/*
		 * lastPtr is not a dict!
		 */
		
		goto dictErr;
	    }
	    
	    dict = (Dict *) lastPtr->internalRep.otherValuePtr;
	    if (create) {		
		hPtr = Tcl_CreateHashEntry(&dict->table, (char *)idxPtr[idxCount-1], &tmp);
		if (tmp) {
		    objPtr = Tcl_NewObj();
		    Tcl_IncrRefCount(objPtr);
		    Tcl_SetHashValue(hPtr, (ClientData)objPtr);
		}
	    } else {
		hPtr = Tcl_FindHashEntry(&dict->table, (char *)idxPtr[idxCount-1]);
		if (!hPtr) {
		    goto dictErr;
		}
	    }
	    if (write) {
		dict->epoch++;
	    }
	    tmpPtrPtr = &Tcl_GetHashValue(hPtr);
	    resultPtrPtr = (Tcl_Obj **) tmpPtrPtr;
	} else {
	    int idx, len;
	    
	    if (idxCount == 1) {
		/*
		 * This is unshared when writing: a loop invariant.
		 */
		
		lastPtr = currValuePtr;
	    } else {
		lastPtr = TclLindexFlat(interp, currValuePtr, idxCount-1, idxPtr);
		if (!lastPtr) {
		    goto listErr;
		}
		if (lastPtr->refCount < 2) {
		    int len;

		    Tcl_ListObjLength(NULL, currValuePtr, &len);
		    if ((idxCount-1) >= len) {
			goto autoErr;
		    } else if ((idxCount-1) < 0) {
			goto listErr;
		    }
		    /*
		     * Is this really a good test for "autoextending along the
		     * path"? Does that case always return an unshared {}?
		     */
		    
		    Tcl_Panic("lastPtr has refCount %i<2, how come?\n");
		}
		Tcl_DecrRefCount(lastPtr);
		if (write) {
		    /*
		     * Insure an unshared path: use lset
		     */

		    if (Tcl_IsShared(lastPtr)) {
			lastPtr = TclListObjCopy(NULL, lastPtr);
			if (!lastPtr) {
			    goto listErr;
			}
		    }
		    TclLsetFlat(NULL, currValuePtr, idxCount-1, idxPtr, lastPtr);
		    Tcl_DecrRefCount(currValuePtr);
		    
		    if (Tcl_IsShared(lastPtr)) {
			lastPtr = TclListObjCopy(NULL, lastPtr);
			TclLsetFlat(NULL, currValuePtr, idxCount-1, idxPtr, lastPtr);
			Tcl_DecrRefCount(currValuePtr);
		    }
		}
	    }

	    if (TCL_OK != TclListObjGetElements(interp, lastPtr, &len, &resultPtrPtr)) {
		goto listErr;
	    }
	    if (TCL_OK != TclGetIntFromObj(NULL, idxPtr[idxCount-1], &idx)  || (idx < 0)) {
		goto listErr;
	    }
	    
	    if (idx >= len) {
		/*
		 * FIXME: auto-extending arrays GO HERE? This code assume the
		 * depth is there ... do initialise for auto-extending.
		 */
		goto autoErr;
	    }
	    if (write && (((List *)(lastPtr->internalRep.otherValuePtr))->refCount != 1)) {
		/*
		 * Force a copy of the List internal rep: we do need it unshared!
		 */
		
		Tcl_Obj *objPtr = resultPtrPtr[idx];

		TclListObjSetElement(NULL, lastPtr, idx, objPtr);
		TclListObjGetElements(interp, lastPtr, &len, &resultPtrPtr);
	    }
	    if (write && (((List *)(lastPtr->internalRep.otherValuePtr))->refCount != 1)) {
		Tcl_Panic("internal rep refCount?\n");
	    }
	    resultPtrPtr = &(resultPtrPtr[idx]);
	}

	if (write) {
	    Tcl_InvalidateStringRep(currValuePtr);
	    Tcl_InvalidateStringRep(lastPtr);
	}
	
	currValuePtr = *resultPtrPtr;
	if (!currValuePtr) {
	    goto autoErr;
	}
	if (write) {
	    if (Tcl_IsShared(currValuePtr)  && (i != numLevels-1)) {
		Tcl_DecrRefCount(currValuePtr);
		currValuePtr = Tcl_DuplicateObj(currValuePtr);
		Tcl_IncrRefCount(currValuePtr);
		*resultPtrPtr = currValuePtr;
	    }
	}
	
	idxPtr += idxCount;
	levelCountPtr++;
	typeIsHash = !typeIsHash;
    }
    
    if (write && (valuePtr->refCount != 1)) {
	fprintf(stderr, "valuePtr %p:'%s', currValuePtr %p:'%s'\n", valuePtr,
		TclGetString(valuePtr), currValuePtr, TclGetString(currValuePtr));
	Tcl_Panic(
	    "L_DeepDiveIntoStruct called for writing, exiting with obj with refCount = %i != 1!",
	    valuePtr->refCount);
	
    }

    done:
    Tcl_DecrRefCount(countPtr);
    return resultPtrPtr;

    listErr:
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "index not present in array", NULL);
    resultPtrPtr = NULL;
    goto done;

    dictErr:
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "key not known in dictionary", NULL);
    resultPtrPtr = NULL;
    goto done;

    autoErr:
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "autoextending nested arrays not implemented yet", NULL);
    resultPtrPtr = NULL;
    goto done;
}


/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */

