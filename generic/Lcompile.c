/*
 * Copyright (c) 2006-2007 BitMover, Inc.
 */
#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"

/*
 * To implement the defined() operator, we have an L-specific type to
 * represent the undefined value of array, hash, or struct members
 * when they dynamically are brought into life by an array
 * auto-extend.  We create one object of this type and dup it as the
 * value of all undefined objects.
 */

private void
undef_freeInternalRep(Tcl_Obj *o)
{
	o->bytes  = NULL;
	o->length = 0;
}

/*
 * Return an error if someone tries to convert a value of undef type
 * to anything else.
 */
private int
undef_setFromAny(Tcl_Interp *interp, Tcl_Obj *o)
{
	Tcl_SetObjResult(interp,
			 Tcl_NewStringObj("cannot read undefined value", -1));
	return (TCL_ERROR);
}

/*
 * Get a pointer to the "undefined" object pointer, allocating it the
 * first time it is needed.  It is OK to bump the ref count each time;
 * we want the one-and-only undef object to never be freed.
 */
Tcl_Obj **
L_undefObjPtrPtr()
{
	static Tcl_Obj *undef_obj = NULL;

	unless (undef_obj) {
		undef_obj = Tcl_NewObj();
		Tcl_InvalidateStringRep(undef_obj);
		undef_obj->bytes = tclEmptyStringRep;
		undef_obj->typePtr = &L_undefType;
		Tcl_IncrRefCount(undef_obj);
	}
	Tcl_IncrRefCount(undef_obj);
	return (&undef_obj);
}

Tcl_ObjType L_undefType = {
	"undef",
	undef_freeInternalRep,
	NULL,
	NULL,
	undef_setFromAny
};

/* Enum for sym_lookup() and sym_store(). */
enum lookup {
	NOUSED	= 0x01,  // do not update used_p
	NOWARN	= 0x02,  // issue no error message if symbol undefined
};

/* The next two functions are generated by flex. */
extern void	*L__scan_bytes (const char *bytes, int len);
extern void	L__delete_buffer(void *buf);

private int	L_ParseScript(Tcl_Interp *interp, CONST char *str, Ast **L_ast);
private int	L_CompileScript(Tcl_Interp *interp, CompileEnv *envPtr,
			       void *ast, int opts);
private void	ast_free(Ast *ast_list);
private Expr	*ast_mkInitializer(VarDecl *decl);
private void	compile_assignment(Expr *expr);
private void	compile_binOp(Expr *expr, L_Expr_f flags);
private void	compile_block(Block *block);
private void	compile_break(Stmt *stmt);
private void	compile_classDecl(ClsDecl *class);
private void	compile_condition(Expr *cond);
private void	compile_continue(Stmt *stmt);
private void	compile_idxOp(Expr *expr, L_Expr_f flags);
private void	compile_expr(Expr *expr, L_Expr_f flags);
private int	compile_exprs(Expr *expr, L_Expr_f flags);
private void	compile_fnCall(Expr *expr);
private void	compile_fnDecl(FnDecl *fun);
private void	compile_fnDecls(FnDecl *fun);
private void	compile_foreach(ForEach *loop);
private void	compile_foreachArray(ForEach *loop);
private void	compile_foreachHash(ForEach *loop);
private void	compile_ifUnless(Cond *cond);
private void	compile_incdec(Expr *expr);
private void	compile_join(Expr *expr);
private void	compile_keys(Expr *expr);
private void	compile_length(Expr *expr);
private void	compile_loop(Loop *loop);
private void	compile_fnParms(VarDecl *decl);
private void	compile_push(Expr *expr);
private void	compile_return(Stmt *stmt);
private void	compile_shortCircuit(Expr *expr);
private void	compile_sort(Expr *expr);
private void	compile_split(Expr *expr);
private void	compile_stmt(Stmt *stmt);
private void	compile_stmts(Stmt *stmt);
private void	compile_trinOp(Expr *expr);
private void	compile_twiddle(Expr *expr);
private void	compile_twiddleSubst(Expr *expr);
private void	compile_unOp(Expr *expr);
private void	compile_varDecl(VarDecl *decl);
private void	compile_varDecls(VarDecl *decls);
private void	emit_globalUpvar(Sym *sym, Expr *id);
private void	emit_instrForLOp(Expr *expr);
private Jmp	*emit_jmp(int op);
private void	fixup_jmps(Jmp *jumps);
private Frame	*frame_enclosingLoop();
private Frame	*frame_outer(Frame *frame);
private void	frame_pop(void);
private void	frame_push(Tcl_Interp *interp, CompileEnv *envPtr,
			   void *block, Frame_f flags);
private int	ispatternfn(char *name, Expr **Foo_star, Expr **bar);
private char	*mk_uniqSym(char *name);
private Proc	*proc_begin(Frame_f flags);
private void	proc_finish(Proc *procPtr, char *name);
private int	push_index(Expr *expr);
private void	push_lit(Expr *expr);
private int	push_parms(Expr *parameters);
private void	push_pointer(Expr *lval);
private int	push_regexpModifiers(Expr *regexp);
private void	push_var(Expr *expr);
private void	re_gatherTxt(Expr *e, Tcl_Obj *s);
private int	re_submatchCnt(Expr *re);
private VarDecl	*struct_lookupMember(Type *t, Expr *idx, int *offset);
private Sym	*sym_lookup(Expr *id, enum lookup flags);
private Sym	*sym_store(VarDecl *decl);
private void	track_cmd(int codeOffset, void *node);
private void	type_free(Type *type_list);

Lglobal	*L;		// per-interp global state
Type	*L_int;		// pre-defined types
Type	*L_float;
Type	*L_string;
Type	*L_void;
Type	*L_var;
Type	*L_poly;

/*
 * L built-in functions.
 */
static struct {
	char	*name;
	void	(*fn)(Expr *);
} builtins[] = {
	{ "join",	compile_join },
	{ "keys",	compile_keys },
	{ "length",	compile_length },
	{ "push",	compile_push },
	{ "sort",	compile_sort },
	{ "split",	compile_split },
};

/*
 * L compiler entry point.
 */
int
Tcl_LObjCmd(ClientData clientData, Tcl_Interp *interp, int objc,
	    Tcl_Obj *CONST objv[])
{
	int	i, index, len;
	int	opts = 0;
	char	*str;
	Ast	*ast;
	static	CONST char *options[] = { "-poly", "-nowarn", NULL };
	enum	options { L_POLY, L_NOWARN };

	/* Extract the L global state from the interp. */
	L = Tcl_GetAssocData(interp, "L", NULL);

	if (objc < 2) {
		Tcl_WrongNumArgs(interp, 1, objv, "?options? l-program");
		return (TCL_ERROR);
	}

	/* option parsing -- add flags to :opts */
	for (i = 1; i < objc - 1; i++) {
		if (Tcl_GetIndexFromObj(interp, objv[i],
			options, "option", 0, &index) != TCL_OK) {
			return (TCL_ERROR);
		}
		switch((enum options)index) {
		    case L_POLY:
			opts |= L_OPT_POLY;
			break;
		    case L_NOWARN:
			opts |= L_OPT_NOWARN;
			break;
		    default:
			L_bomb("bad opt Tcl_GetIndexFromObj should've caught");
		}
	}
	str = Tcl_GetStringFromObj(objv[objc - 1], &len);
	if (L_ParseScript(interp, str, &ast) != TCL_OK) {
		return (TCL_ERROR);
	}
	unless (ast) return (TCL_OK);	// empty script
	return (L_CompileScript(interp, NULL, ast, opts));
}

/*
 * Parse an L script into an AST.  Parsing and compiling are broken into two
 * stages in order to support an interactive mode that parses many times
 * before finally compiling.
 */
private int
L_ParseScript(Tcl_Interp *interp, CONST char *str, Ast **ast_p)
{
	int	len = strlen(str);
	void	*lex_buffer;

	L_typeck_init();

	if (((Interp *)interp)->scriptFile) {
		char *f = Tcl_GetString(((Interp *)interp)->scriptFile);
		L->file = ckstrdup(f);
	} else {
		L->file = ckstrdup("<stdin>");
	}

	L->line		= 1;
	L->token_offset = L->prev_token_len = 0;
	L->script       = ckstrdup(str);
	L->script_len   = len;
	L->errs		= NULL;
	L_lex_start();
	lex_buffer      = (void *)L__scan_bytes(str, len);

	L_parse();
	ASSERT(ast_p);
	*ast_p = L->ast;

	L__delete_buffer(lex_buffer);

	if (L->errs) {
		Tcl_SetObjResult(interp, L->errs);
		return (TCL_ERROR);
	}
	return (TCL_OK);
}

/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
private int
L_CompileScript(Tcl_Interp *interp, CompileEnv *envPtr, void *ast, int opts)
{
	int	ret = TCL_OK;
	char	*name = mk_uniqSym("%%l_toplevel");
	TopLev	*toplev;
	Proc	*top_proc;

	ASSERT(((Ast *)ast)->type == L_NODE_TOPLEVEL);

	top_proc = proc_begin(TOPLEV|SKIP);
	L->frame->options = opts;

	for (toplev = (TopLev *)ast; toplev; toplev = toplev->next) {
		switch (toplev->kind) {
		    case L_TOPLEVEL_CLASS:
			compile_classDecl(toplev->u.class);
			break;
		    case L_TOPLEVEL_FUN:
			compile_fnDecl(toplev->u.fun);
			break;
		    case L_TOPLEVEL_GLOBAL:
			compile_varDecls(toplev->u.global);
			break;
		    case L_TOPLEVEL_STMT:
			compile_stmts(toplev->u.stmt);
			break;
		    default:
			L_bomb("Unexpected toplevel stmt type %d", toplev->kind);
		}
	}

	push_str("");
	TclEmitOpcode(INST_DONE, L->frame->envPtr);
	proc_finish(top_proc, name);

	if (L->errs) {
		ckfree(name);
		Tcl_SetObjResult(interp, L->errs);
		return (TCL_ERROR);
	}

	/* Invoke the top-level code that was just compiled. */
	if (L->frame->envPtr) {
		push_str(name);
		emit_invoke(1);
	} else {
		ret = Tcl_Eval(L->frame->interp, name);
	}
	ckfree(name);
	return (ret);
}

private void
compile_classDecl(ClsDecl *class)
{
	char	*cls_name = class->decl->id->u.string;

	unless (class->constructor) {
		L_errf(class, "no constructor declared for class %s", cls_name);
	}
	unless (class->destructor) {
		L_errf(class, "no destructor declared for class %s", cls_name);
	}

	/*
	 * A class creates two scopes, one for the class symbols and
	 * the other for its top-level code (class variable
	 * initializers).  See the comments in sym_store().
	 */
	frame_push(L->frame->interp, L->frame->envPtr, NULL, CLS_OUTER|SEARCH);
	frame_push(L->frame->interp, L->frame->envPtr, NULL, CLS_TOPLEV|SKIP);

	push_str("::namespace");
	push_str("eval");
	push_str("::L::_class_%s", cls_name);
	push_str("variable __num 0");
	emit_invoke(4);

	compile_varDecls(class->clsvars);

	if (class->constructor) compile_fnDecl(class->constructor);
	if (class->destructor)  compile_fnDecl(class->destructor);

	compile_fnDecls(class->fns);

	frame_pop();
	frame_pop();
}

private void
compile_fnDecls(FnDecl *fun)
{
	for (; fun; fun = fun->next) {
		compile_fnDecl(fun);
	}
}

private void
compile_fnDecl(FnDecl *fun)
{
	int	i;
	Expr	*self_id;
	VarDecl	*self_decl;
	VarDecl	*decl = fun->decl;
	char	*name = decl->id->u.string;
	char	*clsname = NULL;
	Proc	*procPtr;
	ClsDecl	*clsdecl = NULL;
	Sym	*self_sym, *sym;

	ASSERT(fun && decl);
	ASSERT(!(decl->flags & SCOPE_LOCAL));
	ASSERT(decl->flags & (SCOPE_CLASS | SCOPE_GLOBAL));
	ASSERT(decl->flags & (DECL_FN|DECL_CLASS_PRIV_FN|DECL_CLASS_PUB_FN));

	/*
	 * Sort out the possible error cases:
	 *
	 * - name illegal
	 * - name already declared as a variable
	 * - proto already declared and doesn't match this decl
	 * - this decl declares function body but body already declared
	 *
	 * with the exception that "main" is allowed to be re-declared.
	 */
	if (name[0] == '_') {
		L_errf(decl->id, "function names cannot begin with _");
	}
	if (!strcmp(name, "END")) {
		L_errf(decl->id, "cannot use END for function name");
	}
	for (i = 0; i < sizeof(builtins)/sizeof(builtins[0]); ++i) {
		if (!strcmp(builtins[i].name, name)) {
			L_errf(decl->id,
			       "function '%s' conflicts with built-in",
			       name);
		}
	}
	sym = sym_lookup(decl->id, NOWARN|NOUSED);
	if (sym && strcmp(name, "main")) {
		unless (sym->kind & L_SYM_FN) {
			L_errf(fun, "%s already declared as a variable",name);
			return;
		} else if ((sym->kind & L_SYM_FNBODY) && fun->body) {
			L_errf(fun, "function %s already declared", name);
			return;
		} else unless (L_typeck_same(decl->type, sym->type)) {
			L_errf(fun, "does not match prior declaration of %s",
			       name);
			return;
		}
	} else {
		sym = sym_store(decl);
		unless (sym) return;
	}

	/* Check arg and return types for legality. */
	L_typeck_declType(decl);

	unless (fun->body) return;

	procPtr = proc_begin(SEARCH);
	sym->kind |= L_SYM_FNBODY;
	L->frame->block = (Ast *)fun;

	compile_fnParms(decl);

	/*
	 * Extra code for for class member functions.  First, always
	 * declare the local variable "self".
	 */
	if (decl->flags & (DECL_CLASS_PUB_FN | DECL_CLASS_PRIV_FN)) {
		self_id   = ast_mkId("self", 0, 0);
		self_decl = ast_mkVarDecl(L_string, self_id, 0, 0);
		self_decl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
		self_sym  = sym_store(self_decl);
		self_sym->used_p = TRUE;
		clsdecl = fun->decl->clsdecl;
		clsname = clsdecl->decl->id->u.string;
	}

	/*
	 * For the constructor, before compiling the user's
	 * constructor body, emit code to increment the class instance
	 * #, set "self" to the namespace name of the class instance,
	 * create the namespace, then compile the instance-variable
	 * initializers.  Basically this:
	 *
	 *     incrStkImm ::L::_class_<cls_name>::__num
	 *     set self ::L::_instance_<cls_name>${__num}
	 *     namespace eval $self {}
	 *     ...instance variable initializers...
	 *     ...user's constructor body...
	 */
	if (decl->flags & DECL_CLASS_CONSTRUCTOR) {
		ASSERT(clsdecl && clsname && self_sym);
		push_str("::L::_class_%s::__num", clsname);
		TclEmitInstInt1(INST_INCR_STK_IMM, 1, L->frame->envPtr);
		push_str("::namespace");
		push_str("eval");
		push_str("::L::_instance_%s", clsname);
		push_str("::L::_class_%s::__num", clsname);
		TclEmitOpcode(INST_LOAD_STK, L->frame->envPtr);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		emit_store_scalar(self_sym->idx);
		push_str("");
		emit_invoke(4);
		compile_varDecls(clsdecl->instvars);
	}

	/*
	 * For private member functions, upvar "self" to the "self" in
	 * the calling frame.  This works because only other class member
	 * functions can call private member functions, and they have "self".
	 */
	if (decl->flags & DECL_CLASS_PRIV_FN) {
		push_str("1");
		push_str("self");
		TclEmitInstInt4(INST_UPVAR, self_sym->idx, L->frame->envPtr);
		emit_pop();
	}

	/*
	 * For public member functions (except the constructor), upvar
	 * "self" to the first formal which is guaranteed to be the
	 * object.
	 */
	if ((decl->flags & DECL_CLASS_PUB_FN) &&
	    !(decl->flags & DECL_CLASS_CONSTRUCTOR)) {
		push_str("0");
		/* Name of 1st formal (must check in case it was omitted). */
		if (decl->type->u.func.formals) {
			push_str(decl->type->u.func.formals->id->u.string);
		}
		TclEmitInstInt4(INST_UPVAR, self_sym->idx, L->frame->envPtr);
		emit_pop();
	}

	L->enclosing_func = fun;
	compile_block(fun->body);
	L->enclosing_func = NULL;

	/*
	 * For class destructor, delete the instance namespace.
	 */
	if (decl->flags & DECL_CLASS_DESTRUCTOR) {
		ASSERT(self_sym);
		push_str("::namespace");
		push_str("delete");
		emit_load_scalar(self_sym->idx);
		emit_invoke(3);
	}

	/*
	 * Emit a "fall of the end" implicit return, except for class
	 * constructors which return the value of "self".
	 */
	if (decl->flags & DECL_CLASS_CONSTRUCTOR) {
		emit_load_scalar(self_sym->idx);
	} else {
		push_str("");
	}
	TclEmitOpcode(INST_DONE, L->frame->envPtr);

	/*
	 * The proc name is the L function name prepended by the tclprefix
	 * in the decl.  The prefix is used for private class member
	 * functions where it holds the class namespace.
	 */
	if (decl->tclprefix) {
		char *tclname = cksprintf("%s%s", decl->tclprefix, name);
		proc_finish(procPtr, tclname);
		ckfree(tclname);
	} else {
		proc_finish(procPtr, name);
	}
}

private Proc *
proc_begin(Frame_f flags)
{
	Proc	*procPtr;
	CompileEnv *envPtr;

	envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
	frame_push(L->frame->interp, envPtr, NULL, flags);

	procPtr = (Proc *)ckalloc(sizeof(Proc));
	procPtr->iPtr              = (struct Interp *)L->frame->interp;
	procPtr->refCount          = 1;
	procPtr->numArgs           = 0;
	procPtr->numCompiledLocals = 0;
	procPtr->firstLocalPtr     = NULL;
	procPtr->lastLocalPtr      = NULL;
	procPtr->bodyPtr           = Tcl_NewObj();
	Tcl_IncrRefCount(procPtr->bodyPtr);
	TclInitCompileEnv(L->frame->interp, envPtr, L->script, L->script_len,
			  NULL, 0);
	envPtr->procPtr = procPtr;

	return (procPtr);
}

private void
proc_finish(Proc *procPtr, char *name)
{
	Tcl_Command cmd;

	TclInitByteCodeObj(procPtr->bodyPtr, L->frame->envPtr);
#ifdef TCL_COMPILE_DEBUG
	if (getenv("L_DISASSEMBLE")) {
		printf("Bytecode for %s:\n", name);
		TclPrintByteCodeObj(L->frame->interp, procPtr->bodyPtr);
	}
#endif
	cmd = Tcl_CreateObjCommand(L->frame->interp, name, TclObjInterpProc,
				   (ClientData) procPtr, TclProcDeleteProc);
	procPtr->cmdPtr = (Command *)cmd;
	TclFreeCompileEnv(L->frame->envPtr);
	ckfree((char *)L->frame->envPtr);
	frame_pop();
}

private void
compile_varDecl(VarDecl *decl)
{
	int	start_off = currOffset(L->frame->envPtr);
	char	*name;
	Sym	*sym;

	ASSERT(decl->id && decl->type);

	name = decl->id->u.string;

	unless (L_typeck_declType(decl)) return;

	if ((name[0] == '_') && (decl->flags & DECL_LOCAL_VAR)) {
		L_errf(decl, "local variable names cannot begin with _");
	}
	if (!strcmp(name, "END")) {
		L_errf(decl, "cannot use END for variable name");
	}

	sym = sym_store(decl);
	unless (sym) return;  // bail if multiply declared

	if (decl->flags & DECL_EXTERN) {
		if (decl->initializer) {
			L_errf(decl, "extern initializers illegal");
		}
		unless (L->frame->flags & TOPLEV) {
			L_errf(decl, "externs illegal in local scopes");
		}
		sym->used_p = TRUE;  // to suppress extraneous warning
		return;
	}

	unless (decl->initializer) {
		decl->initializer = ast_mkInitializer(decl);
	}
	compile_expr(decl->initializer, L_DISCARD);
	track_cmd(start_off, decl);
}

private void
compile_varDecls(VarDecl *decls)
{
	for (; decls; decls = decls->next) {
		compile_varDecl(decls);
	}
}

/*
 * Make an assignment node to initialize a variable with an initial
 * "blank" value appropriate for its type.
 */
private Expr *
ast_mkInitializer(VarDecl *decl)
{
	Expr	*assign, *val;

	switch (decl->type->kind) {
	    case L_ARRAY:
	    case L_STRUCT:
	    case L_HASH:
		val = ast_mkUnOp(L_OP_LIST, NULL, decl->node.beg,
				 decl->node.end);
		break;
	    case L_INT:
		val = ast_mkConst(L_int, decl->node.beg, decl->node.end);
		val->u.integer = 0;
		break;
	    case L_FLOAT:
		val = ast_mkConst(L_float, decl->node.beg, decl->node.end);
		val->u.flote = 0.0;
		break;
	    default:
		val = ast_mkConst(L_poly, decl->node.beg, decl->node.end);
		val->u.string = ckstrdup("");
		break;
	}
	assign = ast_mkBinOp(L_OP_EQUALS, decl->id, val, decl->node.beg,
			     decl->node.end);
	return (assign);
}

private void
compile_stmt(Stmt *stmt)
{
	int	start_off = currOffset(L->frame->envPtr);

	unless (stmt) return;
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
		frame_push(L->frame->interp, L->frame->envPtr, stmt, SEARCH);
		compile_block(stmt->u.block);
		frame_pop();
		break;
	    case L_STMT_EXPR:
		compile_exprs(stmt->u.expr, L_DISCARD);
		break;
	    case L_STMT_COND:
		compile_ifUnless(stmt->u.cond);
		break;
	    case L_STMT_LOOP:
		compile_loop(stmt->u.loop);
		break;
	    case L_STMT_FOREACH:
		compile_foreach(stmt->u.foreach);
		break;
	    case L_STMT_RETURN:
		compile_return(stmt);
		break;
	    case L_STMT_BREAK:
		compile_break(stmt);
		break;
	    case L_STMT_CONTINUE:
		compile_continue(stmt);
		break;
	    default:
		L_bomb("Malformed AST in compile_stmt");
	}
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
	    case L_STMT_COND:
	    case L_STMT_EXPR:
		break;
	    default:
		track_cmd(start_off, stmt);
		break;
	}
}

private void
compile_stmts(Stmt *stmts)
{
	for (; stmts; stmts = stmts->next) {
		compile_stmt(stmts);
	}
}

private void
compile_block(Block *block)
{
	compile_varDecls(block->decls);
	compile_stmts(block->body);
}

private void
compile_return(Stmt *stmt)
{
	Type	*ret_type;

	unless (L->enclosing_func) {
		L_errf(stmt, "return from global scope illegal");
		return;
	}

	ret_type = L->enclosing_func->decl->type->base_type;
	if (isvoidtype(ret_type) && (stmt->u.expr)) {
		L_errf(stmt, "void function cannot return value");
	} else if (stmt->u.expr) {
		compile_expr(stmt->u.expr, L_PUSH_VAL);  // return value
		unless (L_typeck_compat(ret_type, stmt->u.expr->type)) {
			L_errf(stmt, "incompatible return type");
		}
	} else {
		push_str("");  // no return value -- push a ""
	}

	TclEmitOpcode(INST_DONE, L->frame->envPtr);
}

private void
compile_fnParms(VarDecl *decl)
{
	int	i, by_name;
	int	name_parms = 0;
	char	*name;
	Proc	*proc = L->frame->envPtr->procPtr;
	VarDecl	*p;
	VarDecl	*new_decl = NULL;
	Sym	*new_sym, *sym;
	Expr	*new_id;
	VarDecl	*param = decl->type->u.func.formals;
	CompiledLocal	*local;

	/*
	 * Public class member fns (except constructor) must have
	 * object as first arg.
	 */
	if (decl->flags & DECL_CLASS_PUB_FN) {
		unless ((param && (param->type == decl->clsdecl->decl->type)) ||
			(decl->flags & DECL_CLASS_CONSTRUCTOR)) {
			L_errf(decl->id, "class public member function must "
			       "have class object as first arg");
		}
	}

	for (p = param, i = 0; p; p = p->next, i++) {
		/*
		 * For prototypes, the grammar lets you declare a
		 * function arg with a type but no name, but in a
		 * declaration it's an error to omit the name.  Handle
		 * that by making up a name so we can keep compiling.
		 */
		unless (p->id) {
			L_errf(p, "formal parameter #%d lacks a name", i+1);
			name = ckalloc(32);
			snprintf(name, 32, "unnamed-arg-%d", i+1);
			p->id = ast_mkId(name, 0, 0);
		}
		/* Class member fns cannot use "self" as a parameter. */
		if (decl->flags & (DECL_CLASS_PUB_FN | DECL_CLASS_PRIV_FN)) {
			if (!strcmp(p->id->u.string, "self")) {
				L_errf(p, "'self' reserved in class member "
				       "functions");
				continue;
			}
		}
		/*
		 * For a pass-by-name formal, mangle the formal name
		 * to "&name" and create a new local variable "name"
		 * that's an upvar to the variable whose name is
		 * passed in the formal.  Note that the formal will have
		 * type "name-of <t>" and the local gets type <t>.
		 */
		by_name = ((p->type->kind == L_NAMEOF) &&
			   (p->type->base_type->kind != L_FUNCTION));
		if (by_name) {
			new_id = ast_mkId(p->id->u.string, p->id->node.beg,
					  p->id->node.end);
			new_decl = ast_mkVarDecl(p->type->base_type, new_id,
						 p->node.beg, p->node.end);
			new_decl->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
			name = ckalloc(strlen(p->id->u.string) + 2);
			sprintf(name, "&%s", p->id->u.string);
			ckfree(p->id->u.string);
			p->id->u.string = name;
		}
		name = p->id->u.string;
		/* Formal parameters are stored in local variable slots. */
		proc->numArgs = i + 1;
		proc->numCompiledLocals = i + 1;
		local = (CompiledLocal *)ckalloc(sizeof(CompiledLocal) -
						 sizeof(local->name) +
						 strlen(name) + 1);
		if (proc->firstLocalPtr == NULL) {
			proc->firstLocalPtr = local;
			proc->lastLocalPtr  = local;
		} else {
			proc->lastLocalPtr->nextPtr = local;
			proc->lastLocalPtr = local;
		}
		local->nextPtr = NULL;
		local->nameLength = strlen(name);
		local->frameIndex = i;
		local->flags = VAR_ARGUMENT;
		if (p->flags & DECL_REST_ARG) {
			local->flags |= VAR_IS_ARGS;
			if (p->next) L_errf(p, "Rest parameter must be last");
		}
		local->resolveInfo = NULL;
		local->defValuePtr = NULL;
		strcpy(local->name, name);
		sym = sym_store(p);
		sym->idx = i;
		if (by_name) {
			/* Push a 1 the first time (arg to INST_UPVAR). */
			unless (name_parms++) push_str("1");
			/* Suppress any unused warning for &name. */
			sym->used_p = TRUE;
			new_sym = sym_store(new_decl);
			emit_load_scalar(sym->idx);
			TclEmitInstInt4(INST_UPVAR, new_sym->idx,
					L->frame->envPtr);
		}
		/* Suppress unused warning for obj arg in class member fns. */
		if ((p == param) &&
		    (decl->flags & DECL_CLASS_PUB_FN) &&
		    !(decl->flags & DECL_CLASS_CONSTRUCTOR)) {
			sym->used_p = TRUE;
		}
	}
	/* Pop the 1 pushed for INST_UPVAR. */
	if (name_parms) emit_pop();
}

private void
compile_split(Expr *expr)
{
	int n = compile_exprs(expr->b, L_PUSH_VAL);
	if ((n < 1) || (n > 3)) {
		L_errf(expr, "incorrect # args for split");
	}
	TclEmitInstInt1(INST_L_SPLIT, n, L->frame->envPtr);
	expr->type = type_mkArray(0, L_string, PER_INTERP);
}

private void
compile_push(Expr *expr)
{
	int	idx, n;
	Expr	*arg, *array;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 2) {
		L_errf(expr, "incorrect # arguments to push");
		goto done;
	}
	array = expr->b->a;
	arg   = expr->b->next;
	unless (isnameof(expr->b) && array && (isarray(array)||ispoly(array))) {
		L_errf(expr, "first arg to push not an array reference (&)");
		goto done;
	}
	unless (L_typeck_compat(array->type->base_type, arg->type)) {
		L_errf(expr, "pushing incompatible type onto array");
		goto done;
	}

	idx = array->sym->idx;  // local slot # for array
	if (idx <= 255) {
		TclEmitInstInt1(INST_LAPPEND_SCALAR1, idx, L->frame->envPtr);
	} else {
		TclEmitInstInt4(INST_LAPPEND_SCALAR4, idx, L->frame->envPtr);
	}
	emit_pop();
 done:
	expr->type = L_void;
}

private void
compile_keys(Expr *expr)
{
	int	n;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 1) {
		L_errf(expr, "incorrect # args to keys");
		expr->type = L_poly;
		return;
	}
	unless (ishash(expr->b) || ispoly(expr->b)) {
		L_errf(expr, "arg to keys is not a hash");
		expr->type = L_poly;
		return;
	}
	push_str("::dict");
	push_str("keys");
	TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
	emit_invoke(3);
	if (ispoly(expr->b)) {
		expr->type = L_poly;
	} else {
		expr->type = type_mkArray(0,
					  expr->b->type->u.hash.idx_type,
					  PER_INTERP);
	}
}

private void
compile_length(Expr *expr)
{
	int	n;

	expr->type = L_int;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n == 1) {
		L_errf(expr, "incorrect # args to length");
		return;
	}
	if (isstring(expr->b)) {
		push_str("::string");
		push_str("length");
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		emit_invoke(3);
	} else if (isarray(expr->b) || islist(expr->b) || ispoly(expr->b)) {
		push_str("::llength");
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		emit_invoke(2);
	} else if (ishash(expr->b)) {
		push_str("::dict");
		push_str("size");
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		emit_invoke(3);
	} else {
		L_errf(expr, "arg to length has illegal type");
	}
}

private void
compile_sort(Expr *expr)
{
	int	i, n;
	Expr	*l;
	Type	*t;

	/*
	 * Do some gymnastics to get this on the run-time stack:
	 * ::lsort
	 * <all args except last one>
	 * -integer, -real, or -ascii depending on list type
	 * <last arg (the thing to be sorted)>
	 */

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless (n >= 1) {
		L_errf(expr, "incorrect # args to sort");
		return;
	}
	/* Last argument to sort must be an array, list, or poly. */
	for (i = 0, l = expr->b; i < (n-1); ++i) l = l->next;
	if (isarray(l) || islist(l)) {
		t = l->type->base_type;
	} else if (ispoly(l)) {
		t = L_poly;
	} else {
		L_errf(expr, "last arg to sort not an array or list");
		return;
	}
	switch (t->kind) {
	    case L_INT:
		push_str("-integer");
		break;
	    case L_FLOAT:
		push_str("-real");
		break;
	    default:
		push_str("-ascii");
		break;
	}
	TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
	if (n > 255) L_errf(expr, "sort cannot have >255 args");
	push_str("::lsort");
	TclEmitInstInt1(INST_ROT, -(n+1), L->frame->envPtr);
	emit_invoke(n+2);
	expr->type = type_mkArray(0, t, PER_INTERP);
}

private void
compile_join(Expr *expr)
{
	int	n;
	Expr	*array;
	Expr	*sep = NULL;

	expr->type = L_string;

	n = compile_exprs(expr->b, L_PUSH_VAL);
	unless ((n == 1) || (n == 2)) {
		L_errf(expr, "incorrect # args to join");
		return;
	}
	array = expr->b;
	if (n == 2) sep = expr->b->next;
	unless (isarray(array) || islist(array) || ispoly(array)) {
		L_errf(expr, "first arg to join not an array or list");
		return;
	}
	unless (!sep || (isstring(sep) || ispoly(sep))) {
		L_errf(expr, "second arg to join not a string");
		return;
	}
	push_str("::join");
	TclEmitInstInt1(INST_ROT, -n, L->frame->envPtr);
	emit_invoke(n+1);
}

private void
compile_expr(Expr *expr, L_Expr_f flags)
{
	int	start_off = currOffset(L->frame->envPtr);

	unless (expr) return;
	switch (expr->kind) {
	    case L_EXPR_FUNCALL:
		compile_fnCall(expr);
		break;
	    case L_EXPR_CONST:
	    case L_EXPR_RE:
		push_lit(expr);
		break;
	    case L_EXPR_ID:
		push_var(expr);
		break;
	    case L_EXPR_UNOP:
		compile_unOp(expr);
		break;
	    case L_EXPR_BINOP:
		compile_binOp(expr, flags);
		break;
	    case L_EXPR_TRINOP:
		compile_trinOp(expr);
		break;
	    default:
		L_bomb("Unknown expression type %d", expr->kind);
	}

	/*
	 * Throw away the value if requested by the caller. This is done
	 * for expressions that are statements, and in for-loop pre and
	 * post expressions.
	 */
	if (flags & L_DISCARD) emit_pop();

	if ((expr->kind == L_EXPR_UNOP)   || (expr->kind == L_EXPR_BINOP) ||
	    (expr->kind == L_EXPR_TRINOP) || (expr->kind == L_EXPR_FUNCALL)) {
		track_cmd(start_off, expr);
	}
}

/*
 * If a function-call name begins with a cap and has an _ inside, it
 * looks like a pattern call.  From a name like "Foo_Bar" create these
 * strings: "Foo_*" "bar".  Return them as Expr's since that's what
 * the caller needs.  The Expr's need not be freed explicitly since
 * all AST nodes are deallocated upon exit.
 */
private int
ispatternfn(char *name, Expr **Foo_star, Expr **bar)
{
	char	*buf, *p;

	unless ((name[0] >= 'A') && (name[0] <= 'Z') &&
		(p = strchr(name, '_')) && p[1]) {  // _ cannot be last
		return (FALSE);
	}

	*p = '\0';

	/* Build Foo_* from Foo_bar. */
	buf = ckalloc(strlen(name) + 3);
	strcpy(buf, name);
	strcat(buf, "_*");
	*Foo_star = ast_mkId(buf, 0, 0);
	ckfree(buf);

	/* Build bar from Foo_bar. */
	buf = ckalloc(strlen(p+1) + 1);
	strcpy(buf, p+1);
	*bar = ast_mkConst(L_string, 0, 0);
	(*bar)->u.string = buf;

	*p = '_';

	return (TRUE);
}

/*
 * Rules for compiling a function call like "foo(arg)":
 *
 * - Call foo.  If foo isn't declared, that's OK, we just won't
 *   have a prototype to type-check against.
 *
 * For a function call like "Foo_bar(a,b,c)", where the name starts with
 * [A-Z] and has an _ in it (except at the end), we have what's called
 * a "pattern function":
 *
 * - If Foo_bar happens to be a declared function, handle as above.
 *
 * - If the function Foo_* is defined, change the call to Foo_*(bar,a,b,c).
 *
 * - Else change the call to *a(bar,b,c) where *a means that the value
 *   of the argument "a" becomes the function name.  It is an error for
 *   "a" to not exist (no args) or to not be of type string.
 */
private void
compile_fnCall(Expr *expr)
{
	int	i, num_parms;
	char	*name;
	Expr	*Foo_star, *bar;
	Sym	*sym;

	ASSERT(expr->a->kind == L_EXPR_ID);
	name = expr->a->u.string;

	/* Check for an L built-in function. */
	for (i = 0; i < sizeof(builtins)/sizeof(builtins[0]); ++i) {
		if (!strcmp(builtins[i].name, name)) {
			builtins[i].fn(expr);
			return;
		}
	}

	sym = sym_lookup(expr->a, NOWARN);

	if (sym && isfntype(sym->type)) {
		/* A regular call -- the name is the fn name. */
		if (sym->decl->tclprefix) {
			push_str("%s%s", sym->decl->tclprefix, name);
		} else {
			push_str(name);
		}
		expr->type = sym->type->base_type;
	} else if (sym && (sym->type->kind == L_NAMEOF) &&
		   (sym->type->base_type->kind == L_FUNCTION)) {
		/*
		 * Name is a function "pointer".  It holds the function
		 * name and its type is the function proto.
		 */
		emit_load_scalar(sym->idx);
		expr->type = sym->type->base_type->base_type;
	} else if (sym) {
		/* Name is declared but isn't a function or fn pointer. */
		L_errf(expr, "'%s' is declared but not as a function", name);
		expr->type = L_poly;
	} else if (ispatternfn(name, &Foo_star, &bar)) {
		/* Pattern function.  Figure out which kind. */
		if ((sym = sym_lookup(Foo_star, NOWARN))) {
			/* Foo_* is defined -- compile Foo_*(bar,a,b,c). */
			push_str(Foo_star->u.string);
			bar->next = expr->b;
			expr->b = bar;
			expr->type = sym->type;
		} else {
			/* Compile as *a(bar,b,c). */
			expr->type = L_poly;
			unless (expr->b) {
				L_errf(expr,
				       "pattern function call has no args");
				return;
			}
			compile_expr(expr->b, L_PUSH_VAL);
			unless (isstring(expr->b)) {
				L_errf(expr->b,
				       "first arg to pattern function is "
				       "not string");
			}
			bar->next = expr->b->next;
			expr->b = bar;
		}
	} else {
		/* Call to an undeclared function. */
		push_str(name);
		expr->type = L_poly;
	}
	num_parms = push_parms(expr->b);
	emit_invoke(num_parms+1);
	if (sym && isfntype(sym->type)) {
		L_typeck_fncall(sym->type->u.func.formals, expr);
	} else if (sym && (sym->type->kind == L_NAMEOF) &&
		   (sym->type->base_type->kind == L_FUNCTION)) {
		L_typeck_fncall(sym->type->base_type->u.func.formals, expr);
	}
}

private void
push_var(Expr *expr)
{
	Sym	*sym;

	ASSERT(expr->op == L_EXPR_ID);

	/*
	 * Special case for the pre-defined identifier END which gets
	 * the last index of the most recent string or array/list
	 * being indexed.
	 */
	if (!strcmp(expr->u.string, "END")) {
		if (L->idx_nesting) {
			TclEmitOpcode(INST_L_READ_SIZE, L->frame->envPtr);
		} else {
			L_errf(expr,
			       "END illegal outside of a string or array index");
		}
		expr->type = L_int;
	} else if ((sym = sym_lookup(expr, 0))) {
		emit_load_scalar(sym->idx);
	} else {
		// Undeclared variable.
		expr->type = L_poly;
	}
}

private int
compile_exprs(Expr *expr, L_Expr_f flags)
{
	int	num_exprs;

	for (num_exprs = 0; expr; expr = expr->next, ++num_exprs) {
		compile_expr(expr, flags);
	}
	return (num_exprs);
}

/*
 * Emit code to push the parameters to a function call and return the
 * # pushed.  If we see two parms like "-foovariable, &foo", then push an
 * L pointer.
 */
private int
push_parms(Expr *parms)
{
	int	i = 0;
	int	widget_flag = FALSE;
	char	*s;
	Expr	*p;

	for (i = 0, p = parms; p; p = p->next, i++) {
		if (widget_flag && (p->kind == L_EXPR_UNOP) &&
		    (p->op == L_OP_ADDROF)) {
			push_pointer(p->a);     // L pointer
		} else {
			compile_expr(p, L_PUSH_VAL);  // regular parm
		}
		s = p->u.string;
		widget_flag = ((p->kind == L_EXPR_CONST) && isstring(p) &&
		    /* has at least the minimum length */
		    (strlen(s) >= strlen("-variable")) &&
		    /* starts with '-' */
		    (s[0] == '-') &&
		    /* ends with "variable" */
		    !strcmp("variable", s + (strlen(s) - strlen("variable"))));
	}
	return (i);
}

private void
push_pointer(Expr *expr)
{
	push_str("::pointer");
	push_str("new");
	push_str(expr->u.string);
	if (expr->kind == L_EXPR_ID) {
		emit_invoke(3);
	} else if (expr->op == L_OP_HASH_INDEX) {
		L_errf(expr, "hash keys are not yet supported by pointers");
	} else if ((expr->op == L_OP_ARRAY_INDEX) ||
		   (expr->op == L_OP_STRUCT_INDEX)) {
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "more than one index is unsupported");
		}
		push_index(expr);
		emit_invoke(4);
	}
}

private void
push_lit(Expr *expr)
{
	switch (expr->type->kind) {
	    case L_STRING:
	    case L_POLY:
	    case L_CLASS:
		push_str("%s", expr->u.string);
		break;
	    case L_INT:
		push_str("%lu", expr->u.integer);
		break;
	    case L_FLOAT:
		push_str("%f", expr->u.flote);
		break;
	    default:
		ASSERT(0);
		break;
	}
}

private void
compile_unOp(Expr *expr)
{
	Sym	*sym;

	switch (expr->op) {
	    case L_OP_BANG:
	    case L_OP_BITNOT:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->a, "in unary ! or ~");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_UPLUS:
	    case L_OP_UMINUS:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_expect(L_INT|L_FLOAT, expr->a, "in unary +/-");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_DEFINED:
		compile_expr(expr->a, L_PUSH_VAL);
		L_typeck_deny(L_VOID, expr->a);
		TclEmitOpcode(INST_L_DEFINED, L->frame->envPtr);
		expr->type = L_int;
		break;
	    case L_OP_ADDROF:
		/* &id -- push the tcl name of the id. */
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "invalid argument to &");
		}
		if ((sym = sym_lookup(expr->a, 0))) {
			push_str(sym->tclname);
			expr->type = type_mkNameOf(expr->a->type, PER_INTERP);
		} else {
			// Undeclared variable.
			expr->type = L_poly;
		}
		return;
	    case L_OP_PLUSPLUS_PRE:
	    case L_OP_PLUSPLUS_POST:
	    case L_OP_MINUSMINUS_PRE:
	    case L_OP_MINUSMINUS_POST:
		compile_incdec(expr);
		expr->type = expr->a->type;
		return;
	    case L_OP_LIST:
		push_str("::list");
		if (expr->a) {
			compile_expr(expr->a, L_PUSH_VAL);
			emit_invoke(2);
			expr->type = type_mkList(expr->a->type, PER_INTERP);
		} else {
			/* Empty list {}. */
			emit_invoke(1);
			expr->type = L_poly;
		}
		return;
	    default:
		L_bomb("Unknown unary operator %d", expr->op);
		break;
	}
}

private void
compile_binOp(Expr *expr, L_Expr_f flags)
{
	Type	*type;

	switch (expr->op) {
	    case L_OP_EQUALS:
	    case L_OP_EQPLUS:
	    case L_OP_EQMINUS:
	    case L_OP_EQSTAR:
	    case L_OP_EQSLASH:
	    case L_OP_EQPERC:
	    case L_OP_EQBITAND:
	    case L_OP_EQBITOR:
	    case L_OP_EQBITXOR:
	    case L_OP_EQLSHIFT:
	    case L_OP_EQRSHIFT:
		compile_assignment(expr);
		expr->type = expr->a->type; // type of assignment is type of lhs
		break;
	    case L_OP_ANDAND:
	    case L_OP_OROR:
		compile_shortCircuit(expr);
		expr->type = L_int;
		break;
	    case L_OP_STR_EQ:
	    case L_OP_STR_NE:
	    case L_OP_STR_GT:
	    case L_OP_STR_GE:
	    case L_OP_STR_LT:
	    case L_OP_STR_LE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_STRING, expr->a, "in string comparison");
		L_typeck_expect(L_STRING, expr->b, "in string comparison");
		emit_instrForLOp(expr);
		expr->type = L_int;
		break;
	    case L_OP_EQUALEQUAL:
	    case L_OP_NOTEQUAL:
	    case L_OP_GREATER:
	    case L_OP_GREATEREQ:
	    case L_OP_LESSTHAN:
	    case L_OP_LESSTHANEQ:
	    case L_OP_PLUS:
	    case L_OP_MINUS:
	    case L_OP_STAR:
	    case L_OP_SLASH:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT|L_FLOAT, expr->a,
				"in arithmetic operator");
		L_typeck_expect(L_INT|L_FLOAT, expr->b,
				"in arithmetic operator");
		emit_instrForLOp(expr);
		if (isfloat(expr->a) || isfloat(expr->b)) {
			expr->type = L_float;
		} else {
			expr->type = L_int;
		}
		break;
	    case L_OP_PERC:
	    case L_OP_BITAND:
	    case L_OP_BITOR:
	    case L_OP_BITXOR:
	    case L_OP_LSHIFT:
	    case L_OP_RSHIFT:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->a, "in arithmetic operator");
		L_typeck_expect(L_INT, expr->b, "in arithmetic operator");
		emit_instrForLOp(expr);
		expr->type = L_int;
		break;
	    case L_OP_ARRAY_INDEX:
	    case L_OP_HASH_INDEX:
	    case L_OP_STRUCT_INDEX:
		compile_idxOp(expr, flags);
		break;
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		expr->type = L_string;
		break;
	    case L_OP_CONS:
		push_str("::concat");
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		emit_invoke(3);
		ASSERT(islist(expr->a) || ishash(expr->a));
		ASSERT(islist(expr->b) || ishash(expr->b));
		if (ishash(expr->a) && ishash(expr->b)) {
			unless (L_typeck_same(expr->a->type, expr->b->type)) {
				L_errf(expr,
				     "hash elements must all be of same type");
			}
			expr->type = expr->a->type;
		} else if (islist(expr->a) && islist(expr->b)) {
			/*
			 * The list type is literally a list of all the
			 * individual element types linked together.
			 */
			APPEND(Type, next, expr->a->type, expr->b->type);
			expr->type = expr->a->type;
		} else {
			L_errf(expr, "cannot mix hash and non-hash elements");
			expr->type = L_poly;
		}
		break;
	    case L_OP_KV:
		push_str("::list");
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		emit_invoke(3);
		unless (isscalar(expr->a)) {
			L_errf(expr->a, "hash keys must be scalar");
		}
		expr->type = type_mkHash(expr->a->type, expr->b->type,
					 PER_INTERP);
		break;
	    case L_OP_EQTWID:
		compile_twiddle(expr);
		expr->type = L_int;
		break;
	    case L_OP_COMMA:
		compile_expr(expr->a, L_DISCARD);
		compile_expr(expr->b, L_PUSH_VAL);
		expr->type = expr->b->type;
		break;
	    case L_OP_CAST:
		type = (Type *)expr->a;
		if (type == L_int) {
			push_str("::tcl::mathfunc::int");
			compile_expr(expr->b, L_PUSH_VAL);
			emit_invoke(2);
		} else if (type == L_float) {
			push_str("::tcl::mathfunc::double");
			compile_expr(expr->b, L_PUSH_VAL);
			emit_invoke(2);
		} else {
			compile_expr(expr->b, L_PUSH_VAL);
		}
		L_typeck_deny(L_VOID|L_FUNCTION, expr->b);
		expr->type = type;
		break;
	    default:
		L_bomb("compile_binOp: malformed AST");
	}
}

private void
compile_trinOp(Expr *expr)
{
	switch (expr->op) {
	    case L_OP_EQTWID:
		compile_twiddleSubst(expr);
		expr->type = L_int;
		break;
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, L_PUSH_VAL);
		compile_expr(expr->b, L_PUSH_VAL);
		compile_expr(expr->c, L_PUSH_VAL);
		TclEmitInstInt1(INST_CONCAT1, 3, L->frame->envPtr);
		expr->type = L_string;
		break;
	    case L_OP_ARRAY_SLICE: {
		int	n = 0;
		compile_expr(expr->a, L_PUSH_VAL);
		if (isstring(expr->a)) {
			push_str("::string");
			push_str("range");
			TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
			expr->type = L_string;
			n = 5;
		} else if (isarray(expr->a) || islist(expr->a)) {
			push_str("::lrange");
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
			expr->type = expr->a->type;
			n = 4;
		} else {
			L_errf(expr->a, "illegal type for slice");
			expr->type = L_poly;
		}
		compile_expr(expr->b, L_PUSH_VAL);
		unless (isint(expr->b)) {
			L_errf(expr->b, "first slice index not an int");
		}
		compile_expr(expr->c, L_PUSH_VAL);
		unless (isint(expr->c)) {
			L_errf(expr->c, "second slice index not an int");
		}
		emit_invoke(n);
		break;
	    }
	    default:
		L_bomb("compile_trinOp: malformed AST");
	}
}

/*
 * Gather all the non-interpolated parts of a string or regexp
 * expression and concat them into a Tcl_Obj.  Used by
 * re_submatchCnt() below.
 */
private void
re_gatherTxt(Expr *e, Tcl_Obj *s)
{
	switch (e->kind) {
	    case L_EXPR_RE:
	    case L_EXPR_CONST:
		if (isstring(e)) Tcl_AppendToObj(s, e->u.string, -1);
		break;
	    case L_EXPR_BINOP:
	    case L_EXPR_TRINOP:
		if ((e->op == L_OP_INTERP_RE) || (e->op == L_OP_INTERP_STRING)){
			re_gatherTxt(e->a, s);
			re_gatherTxt(e->b, s);
			if (e->c) re_gatherTxt(e->c, s);
		}
		break;
	    default:
		break;
	}
}

/*
 * Estimate how many submatches are in the given regexp.  These are
 * the sub-expressions within parens.  Since regexp's can be
 * interpolated, we can't always get this exact, so just look at the
 * non-interpolated parts of the string.
 */
private int
re_submatchCnt(Expr *re)
{
	int		n = 0;
	Tcl_Obj		*const_regexp;
	Tcl_RegExp	compiled;

	const_regexp = Tcl_NewObj();
	Tcl_IncrRefCount(const_regexp);

	re_gatherTxt(re, const_regexp);

	compiled = Tcl_GetRegExpFromObj(L->frame->interp, const_regexp,
					TCL_REG_ADVANCED);
	unless (compiled) {
		L_warnf(re, "cannot get submatch count in"
			    " interpolated regular expression");
	} else {
		n = ((TclRegexp *)compiled)->re.re_nsub;
	}

	Tcl_DecrRefCount(const_regexp);
	return (n);
}

private void
compile_twiddle(Expr *expr)
{
	int	i, mod_cnt, nocase, submatch_cnt;
	int	exact = 0;
	Expr	*regexp = expr->b;
	Sym	*s;
	Expr	*id;
	VarDecl	*v;
	Tcl_DString ds;

	submatch_cnt = re_submatchCnt(regexp);

	/*
	 * Check if the regexp can be compiled (like Tcl's) to a string
	 * comparison, string match, or regexp instruction.  Otherwise
	 * have to call the ::regexp command.
	 */
	unless (submatch_cnt || (regexp->flags & L_EXPR_RE_G)) {
		/*
		 * Can compile it: no match vars, no options (or just -nocase).
		 * If possible, convert regexp to glob so the faster
		 * string comparison or match instructions can be used.
		 * Otherwise, compile to a regexp instruction.
		 */
		nocase = (regexp->flags & L_EXPR_RE_I);
		if (isstring(regexp) &&
		    (TclReToGlob(NULL, regexp->u.string,
				 strlen(regexp->u.string), &ds,
				 &exact) == TCL_OK)) {
			push_cstr(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds));
			Tcl_DStringFree(&ds);
			compile_exprs(expr->a, L_PUSH_VAL);
			if (exact && !nocase) {
				TclEmitOpcode(INST_STR_EQ, L->frame->envPtr);
			} else {
				TclEmitInstInt1(INST_STR_MATCH, nocase,
						L->frame->envPtr);
			}
		} else {
			/*
			 * Pass correct RE compile flags. We use only Int1
			 * (8-bit), but that handles all the flags we want to
			 * pass.
			 * Don't use TCL_REG_NOSUB as we may have backrefs.
			 */
			int cflags = TCL_REG_ADVANCED
			    | (nocase ? TCL_REG_NOCASE : 0);
			compile_exprs(regexp, L_PUSH_VAL);
			compile_exprs(expr->a, L_PUSH_VAL);
			TclEmitInstInt1(INST_REGEXP, cflags, L->frame->envPtr);
		}
	} else {
		/*
		 * Has submatches or /g modifier -- must call ::regexp cmd.
		 */
		push_str("::regexp");
		mod_cnt = push_regexpModifiers(regexp);
		push_str("--");
		compile_exprs(regexp, L_PUSH_VAL);
		compile_exprs(expr->a, L_PUSH_VAL);
		/* Submatch vars.  This loop always iterates at least once. */
		for (i = 0; i <= submatch_cnt; i++) {
			char	buf[32];
			snprintf(buf, 32, "$%d", i);
			id = ast_mkId(buf, 0, 0);
			unless (sym_lookup(id, NOWARN)) {
				v = ast_mkVarDecl(L_string, id, 0, 0);
				v->flags = SCOPE_LOCAL | DECL_LOCAL_VAR;
				s = sym_store(v);
				s->used_p = TRUE; // suppress unused var warning
			}
			push_str(buf);
		}
		emit_invoke(5 + submatch_cnt + mod_cnt);
	}
	L_typeck_expect(L_STRING, expr->a, "in =~");
	// Note: the match boolean is left on the stack.
}

private void
compile_twiddleSubst(Expr *expr)
{
	Expr	*lhs = expr->a;
	int	modCount, tmpIndex = 0;
	char	*tmpNm;

	push_str("::regsub");
	modCount = push_regexpModifiers(expr->b);
	push_str("-line");
	push_str("--");
	compile_expr(expr->b, L_PUSH_VAL);
	// ::regsub <mods> -line -- <re>
	compile_expr(expr->c, L_PUSH_VAL);
	// ::regsub <mods> -line -- <re> <subst>
	if (isindexop(lhs)) {
		compile_idxOp(lhs, L_PUSH_VALPTR|L_LVALUE);
	} else {
		compile_expr(lhs, L_PUSH_VAL);
	}
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in =~");
		return;
	}
	if (isindexop(lhs)) {
		tmpIndex = mk_singleTemp(&tmpNm);
		// ::regsub <mods> -line -- <re> <subst> <lhs-val> <lhs-ptr>
		TclEmitInstInt1(INST_ROT, -(6+modCount), L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str("%s", tmpNm);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst> <tmp-name>
	} else {
		// ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str(lhs->u.string);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst> <lhs-name>
	}
	emit_invoke(modCount + 7);
	if (isindexop(lhs)) {
		// <lhs-ptr> <match>
		emit_load_scalar(tmpIndex);
		// <lhs-ptr> <match> <new-val>
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		// <match> <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(L_PUSH_NEW, L->frame->envPtr);
		// <match> <new-val>
		emit_pop();
	}
	L_typeck_expect(L_STRING, lhs, "in =~");
	// <match>
}

private void
compile_shortCircuit(Expr *expr)
{
	Jmp	*jmp;
	unsigned char op;

	/*
	 * In case the operator "a op b" short-circuits, we need one
	 * value of "a" on the stack for the test and one for the value of
	 * the expression.  If the operator doesn't short-circuit, we
	 * pop one of these off and move on to evaluating "b".
	 */
	ASSERT((expr->op == L_OP_ANDAND) || (expr->op == L_OP_OROR));
	op = (expr->op == L_OP_ANDAND) ? INST_JUMP_FALSE4 : INST_JUMP_TRUE4;
	compile_condition(expr->a);
	// <a-val>
	TclEmitOpcode(INST_DUP, L->frame->envPtr);
	// <a-val> <a-val>
	jmp = emit_jmp(op);
	// <a-val>   if short-circuit and we jumped out
	// <a-val>   if did not short-circuit and we're still going
	emit_pop();
	compile_condition(expr->b);
	fixup_jmps(jmp);
	// <a-val>   if short-circuit
	// <b-val>   if did not short-circuit
}

/*
 * Compile an expression that is used as a conditional test.
 * This is compiled like a normal expression except that if it's
 * of string type its value is compared against the string "0".
 */
private void
compile_condition(Expr *cond)
{
	compile_expr(cond, L_PUSH_VAL);
	if (isvoid(cond)) {
		L_errf(cond, "void type illegal in predicate");
	} else if (isstring(cond)) {
		push_str("0");
		TclEmitOpcode(INST_NEQ, L->frame->envPtr);
	} else unless (isscalar(cond)) {
		L_errf(cond, "predicate must be scalar");
	}
	cond->type = L_int;
}

/*
 * Compile if-unless as follows.
 *
 * No "else" leg:          "Else" leg present:
 *    <eval cond>              <eval cond>
 *    jmpFalse 1               jmpFalse 1
 *    <if leg>                 <if leg>
 * 1:                          jmp 2
 *                          1: <else leg>
 *                          2:
 */
private void
compile_ifUnless(Cond *cond)
{
	Jmp	*endjmp, *falsejmp;

	/* Test the condition and jmp if false. */
	compile_condition(cond->cond);
	falsejmp = emit_jmp(INST_JUMP_FALSE4);

	/* Compile the "if" leg. */
	frame_push(L->frame->interp, L->frame->envPtr, cond, SEARCH);
	compile_stmts(cond->if_body);

	if (cond->else_body) {
		/* "Else" leg present. */
		frame_pop();
		frame_push(L->frame->interp, L->frame->envPtr, cond, SEARCH);
		endjmp = emit_jmp(INST_JUMP4);
		fixup_jmps(falsejmp);
		compile_stmts(cond->else_body);
		fixup_jmps(endjmp);
	} else {
		/* No "else" leg. */
		fixup_jmps(falsejmp);
	}
	frame_pop();
}

/*
 * Compile for, do, and while loops.
 *
 * For & while loop:    Do loop:
 *    <pre>
 *    jmp 1
 * 2: <body>            1: <body>
 *    <post>
 * 1: <cond>               <cond>
 *    jmpTrue 2            jmpTrue 1
 */
private void
compile_loop(Loop *loop)
{
	int	body_off, jmp_dist;
	Jmp	*break_jumps, *continue_jumps;
	Jmp	*condjmp = 0;

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->pre, L_DISCARD);
	unless (loop->kind == L_LOOP_DO) condjmp = emit_jmp(INST_JUMP4);

	/*
	 * Compile loop body.  Note that we must grab the jump fix-ups
	 * out of the frame before popping it.
	 */
	frame_push(L->frame->interp, L->frame->envPtr, loop, SEARCH);
	body_off = currOffset(L->frame->envPtr);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->post, L_DISCARD);
	unless (loop->kind == L_LOOP_DO) fixup_jmps(condjmp);

	compile_condition(loop->cond);

	jmp_dist = currOffset(L->frame->envPtr) - body_off;
	if (jmp_dist > 127) {
		TclEmitInstInt4(INST_JUMP_TRUE4, -jmp_dist, L->frame->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP_TRUE1, -jmp_dist, L->frame->envPtr);
	}
	fixup_jmps(break_jumps);
}

/*
 * Emit a jump instruction with an unknown target offset and return a
 * structure that can be passed in to fixup_jmps() to later fix-up the
 * target to any desired bytecode offset.  Caller must free the
 * returned structure.
 */
private Jmp *
emit_jmp(int op)
{
	Jmp	*ret = (Jmp *)ckalloc(sizeof(Jmp));

	ret->op     = op;
	ret->offset = currOffset(L->frame->envPtr);
	ret->next   = NULL;
	switch (op) {
	    case INST_JUMP1:
	    case INST_JUMP_TRUE1:
	    case INST_JUMP_FALSE1:
		ret->size = 1;
		TclEmitInstInt1(op, 0, L->frame->envPtr);
		break;
	    case INST_JUMP4:
	    case INST_JUMP_TRUE4:
	    case INST_JUMP_FALSE4:
		ret->size = 4;
		TclEmitInstInt4(op, 0, L->frame->envPtr);
		break;
	    default:
		L_bomb("unexpected jump instruction");
		break;
	}
	return (ret);
}

/*
 * Fix up jump targets to point to the current PC, and free the
 * passed-in fix-ups list.
 */
private void
fixup_jmps(Jmp *j)
{
	int	target;
	Jmp	*t;
	unsigned char *jmp_pc;

	while (j) {
		target = currOffset(L->frame->envPtr) - j->offset;
		jmp_pc = L->frame->envPtr->codeStart + j->offset;
		switch (j->size) {
		    case 1:
			TclUpdateInstInt1AtPc(j->op, target, jmp_pc);
			break;
		    case 4:
			TclUpdateInstInt4AtPc(j->op, target, jmp_pc);
			break;
		    default:
			L_bomb("unexpected jump fixup");
			break;
		}
		t = j->next;
		ckfree((char *)j);
		j = t;
	}
}

private void
compile_foreach(ForEach *loop)
{
	compile_expr(loop->expr, L_PUSH_VAL);

	switch (loop->expr->type->kind) {
	    case L_ARRAY:
		compile_foreachArray(loop);
		break;
	    case L_HASH:
		compile_foreachHash(loop);
		break;
	    case L_STRING:
		L_errf(loop->expr, "Foreach over string not yet implemented");
		break;
	    case L_POLY:
		L_errf(loop->expr, "Foreach over poly not yet implemented");
		break;
	    default:
		L_errf(loop->expr, "Illegal foreach expression"
		       " (must be array or hash)");
		break;
	}
}

/*
 * Most of the following function came from tclCompCmds.c
 * TclCompileForEachCmd(), modified in various ways for L.
 */
private void
compile_foreachArray(ForEach *loop)
{
	int		i, continue_off, loopctr_idx, num_vars, val_idx;
	Expr		*var;
	ForeachInfo	*info;
	ForeachVarList	*varlist;
	unsigned char	*jumpPc;
	JumpFixup	jumpFalseFixup;
	Jmp		*break_jumps, *continue_jumps;
	int		jumpBackDist, jumpBackOffset, infoIndex;

	/*
	 * Type-check the value variables.  In "foreach (v1,v2,v3 in
	 * a)", v* are the value variables or variable list, and a is
	 * the value list, in tcl terminology.
	 */
	for (var = loop->key, num_vars = 0; var; var = var->next, ++num_vars) {
		unless (sym_lookup(var, NOUSED)) return;  // undeclared var
		unless (L_typeck_compat(var->type,
					loop->expr->type->base_type)) {
			L_errf(var, "loop index type incompatible with"
				    " array element type");
		}
	}

	/* Temps for value list value and loop counter. */
	val_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);
	loopctr_idx = TclFindCompiledLocal(NULL, 0, 1,
					   L->frame->envPtr);

	/*
	 * ForeachInfo and ForeachVarList are structures required by
	 * the bytecode interpreter for foreach bytecodes.  In our
	 * case, we have only one value and one variable list
	 * consisting of num_vars variables.
	 */
	info = (ForeachInfo *)ckalloc(sizeof(ForeachInfo) +
	    sizeof(ForeachVarList *));
	info->numLists       = 1;
	info->firstValueTemp = val_idx;
	info->loopCtTemp     = loopctr_idx;
	varlist = (ForeachVarList *)ckalloc(sizeof(ForeachVarList) +
	    num_vars * sizeof(int));
	varlist->numVars = num_vars;
	for (i = 0, var = loop->key; var; var = var->next, ++i) {
		Sym *s = sym_lookup(var, 0);
		varlist->varIndexes[i] = s->idx;
	}
	info->varLists[0] = varlist;
	infoIndex = TclCreateAuxData(info, &tclForeachInfoType,
				     L->frame->envPtr);

	/* The values to iterate through are already on the stack (the
	 * caller evaluated loop->expr).  Assign to the value temp. */
	emit_store_scalar(val_idx);
	emit_pop();

	/* Initialize the loop state. */
	TclEmitInstInt4(INST_FOREACH_START4, infoIndex, L->frame->envPtr);

	/* Top of the loop.  Step, and jump out if done. */
	continue_off = currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_FOREACH_STEP4, infoIndex, L->frame->envPtr);
	TclEmitForwardJump(L->frame->envPtr, TCL_FALSE_JUMP, &jumpFalseFixup);

	/* Loop body. */
	frame_push(L->frame->interp, L->frame->envPtr, loop, SEARCH);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* End of loop -- jump back to top. */
	jumpBackOffset = currOffset(L->frame->envPtr);
	jumpBackDist   = jumpBackOffset - continue_off;
	if (jumpBackDist > 120) {
		TclEmitInstInt4(INST_JUMP4, -jumpBackDist, L->frame->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP1, -jumpBackDist, L->frame->envPtr);
	}

	/* Fixup jumps. */
	if (TclFixupForwardJumpToHere(L->frame->envPtr, &jumpFalseFixup, 127)) {
		/* Update the jump back to the loop top since it also
		   moved down. */
		jumpBackOffset += 3;
		jumpPc = (L->frame->envPtr->codeStart + jumpBackOffset);
		jumpBackDist += 3;
		if (jumpBackDist > 120) {
			TclUpdateInstInt4AtPc(INST_JUMP4, -jumpBackDist,jumpPc);
		} else {
			TclUpdateInstInt1AtPc(INST_JUMP1, -jumpBackDist,jumpPc);
		}
	}
	fixup_jmps(break_jumps);
}

private void
compile_foreachHash(ForEach *loop)
{
	Sym	*key;
	Sym	*val = NULL;
	int	body_off, disp, it_idx;
	Jmp	*break_jumps, *continue_jumps, *out_jmp;

	/* Check types and ensure variables are declared etc. */
	unless ((key = sym_lookup(loop->key, NOUSED))) return;
	if (loop->value) {
		unless ((val = sym_lookup(loop->value, NOUSED))) return;
		unless (L_typeck_compat(val->type,
					loop->expr->type->base_type)) {
			L_errf(loop->value, "loop index value type "
			       "incompatible with hash element type");
		}
	}
	unless (L_typeck_compat(key->type, loop->expr->type->u.hash.idx_type)) {
		L_errf(loop->key,
		       "loop index key type incompatible with hash index type");
	}
	if (loop->key->next) {
		L_errf(loop, "multiple variables illegal in foreach over hash");
	}

	/* A temp to hold the iterator state.*/
	it_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr);

	/*
	 * Both DICT_FIRST and DICT_NEXT leave value, key, and done-p
	 * on the stack.  Check done-p and jump out of the loop if
	 * it's true. (We fixup the jump target once we know the size
	 * of the loop body.)
	 */
	TclEmitInstInt4(INST_DICT_FIRST, it_idx, L->frame->envPtr);
	out_jmp = emit_jmp(INST_JUMP_TRUE4);

	/*
	 * Update the key and value variables. We save the offset of
	 * this code so we can jump back to it after DICT_NEXT.
	 * Note: the caller already pushed loop->expr.
	 */
	body_off = currOffset(L->frame->envPtr);
	emit_store_scalar(key->idx);
	emit_pop();
	if (loop->value) emit_store_scalar(val->idx);
	emit_pop();

	/*
	 * Compile loop body.  Note that we must grab the jump fix-ups
	 * out of the frame before popping it.
	 */
	frame_push(L->frame->interp, L->frame->envPtr, loop, SEARCH);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* If there's another entry in the hash, go around again. */
	TclEmitInstInt4(INST_DICT_NEXT, it_idx, L->frame->envPtr);
	disp = body_off - currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_JUMP_FALSE4, disp, L->frame->envPtr);

	/* End of the loop.  Point the jump after the DICT_FIRST to here. */
	fixup_jmps(out_jmp);

	/* All done.  Cleanup the values that DICT_FIRST/DICT_NEXT left. */
	emit_pop();
	emit_pop();
	fixup_jmps(break_jumps);
	/* XXX We need to ensure that DICT_DONE happens in the face of
	   exceptions, so that the refcount on the dict will be
	   decremented, and the iterator freed.  See the
	   implementation of "dict for" in tclCompCmds.c.  --timjr
	   2006.11.3 */
	TclEmitInstInt4(INST_DICT_DONE, it_idx, L->frame->envPtr);
}

private VarDecl *
struct_lookupMember(Type *t, Expr *idx, int *offset)
{
	VarDecl *m;

	ASSERT(idx->op == L_OP_STRUCT_INDEX);

	unless (t->u.struc.members) {
		L_errf(idx, "incomplete struct type %s", t->u.struc.tag);
		return (NULL);
	}
	for (*offset = 0, m = t->u.struc.members; m; m = m->next, ++*offset) {
		if (!strcmp(idx->u.string, m->id->u.string)) {
			return (m);
		}
	}
	return (NULL);
}

/*
 * Generate code to push an array/hash/struct/string index onto the stack.
 * Return flags suitable for the INST_L_INDEX instruction which indicate
 * whether the operator is an array, hash, struct, or string index.
 */
private int
push_index(Expr *expr)
{
	int	ret;
	Type	*type;
	VarDecl *member;
	int	offset;
	char	buf[16];

	/* Error-path return values. */
	ret  = 0;
	type = L_poly;

	ASSERT(type);
	switch (expr->op) {
	    case L_OP_STRUCT_INDEX:
		unless (isstruct(expr->a)) {
			L_errf(expr, "not a struct");
			goto out;
		}
		member = struct_lookupMember(expr->a->type,
					     expr,
					     &offset);
		if (member) {
			snprintf(buf, sizeof(buf), "%i", offset);
			push_str(buf);
			type = member->type;
		} else {
			L_errf(expr, "struct field %s not found",
			       expr->u.string);
		}
		ret = L_IDX_ARRAY;
		break;
	    case L_OP_ARRAY_INDEX:
		compile_expr(expr->b, L_PUSH_VAL);
		L_typeck_expect(L_INT, expr->b, "in array/string index");
		if (isarray(expr->a) || islist(expr->a)) {
			type = expr->a->type->base_type;
			ret  = L_IDX_ARRAY;
		} else if (isstring(expr->a)) {
			type = L_string;
			ret  = L_IDX_STRING;
		} else if (ispoly(expr->a)) {
			type = L_poly;
			ret  = L_IDX_ARRAY;
		} else {
			L_errf(expr, "not an array or string");
		}
		break;
	    case L_OP_HASH_INDEX: {
		compile_expr(expr->b, L_PUSH_VAL);
		if (ishash(expr->a)) {
			L_typeck_expect(expr->a->type->u.hash.idx_type->kind,
					expr->b,
					"in hash index");
			type = expr->a->type->base_type;
		} else {
			L_errf(expr, "not a hash");
		}
		ret = L_IDX_HASH;
		break;
	    }
	    default:
		L_bomb("Invalid index op, %d", expr->op);
		break;
	}
 out:
	expr->type = type;
	return (ret);
}

/*
 * Compile a hash/array/struct or string index.  These are the
 * L_OP_HASH_INDEX, L_OP_ARRAY_INDEX, and L_OP_STRUCT_INDEX nodes.
 *
 * The resulting stack depends on the flags which specify whether the
 * indexed element's value, pointer, or both (and in what order) are
 * wanted.  We get one of
 *
 * <elem-obj>                  if flags & L_PUSH_VAL
 * <elem-obj  <deep-ptr>       if flags & L_PUSH_PTR
 * <elem-obj> <deep-ptr>       if flags & L_PUSH_VAL_PTR
 * <deep-ptr> <elem-obj>       if flags & L_PUSH_PTR_VAL
 */
private void
compile_idxOp(Expr *expr, L_Expr_f flags)
{
	compile_expr(expr->a, L_PUSH_PTR | (flags & L_LVALUE));
	expr->sym = expr->a->sym;  // propagate sym table ptr up the tree

	if (isstring(expr->a)) {
		TclEmitOpcode(INST_L_PUSH_STR_SIZE, L->frame->envPtr);
	} else if (isarray(expr->a) || islist(expr->a) || ispoly(expr->a)) {
		TclEmitOpcode(INST_L_PUSH_LIST_SIZE, L->frame->envPtr);
	}

	++L->idx_nesting;
	flags |= push_index(expr);
	--L->idx_nesting;

	if (isstring(expr->a) || isarray(expr->a) || islist(expr->a) ||
	    ispoly(expr->a)) {
		TclEmitOpcode(INST_L_POP_SIZE, L->frame->envPtr);
	}

	TclEmitInstInt4(INST_L_INDEX, flags, L->frame->envPtr);

	/*
	 * Adjust the stack depth that Tcl tracks (debug build) to
	 * reflect when two objs are left on the stack instead of one
	 * as indicated by the entry in the tclInstructionTable in
	 * tclCompile.c
	 */
	if (flags & (L_PUSH_PTRVAL | L_PUSH_VALPTR)) {
		TclAdjustStackDepth(1, L->frame->envPtr);
	}
}

private void
compile_assignment(Expr *expr)
{
	Expr	*lhs = expr->a;
	Expr	*rhs = expr->b;
	/* Whether it's an arithmetic assignment (lhs op= rhs). */
	int	arith = (expr->op != L_OP_EQUALS);

	compile_expr(rhs, L_PUSH_VAL);
	// <rval>
	if (isindexop(lhs)) {
		compile_idxOp(lhs, (arith?L_PUSH_VALPTR:L_PUSH_PTR) | L_LVALUE);
		// <rval> <lhs-ptr>               if !arith
		// <rval> <lhs-val> <lhs-ptr>     if arith
	} else {
		sym_lookup(lhs, 0);
	}
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in assignment");
		return;
	}

	L_typeck_assign(lhs, rhs);

	if (isindexop(lhs)) {
		if (arith) {
			// <rval> <lhs-val> <lhs-ptr>
			TclEmitInstInt4(INST_REVERSE, 3, L->frame->envPtr);
			// <lhs-ptr> <lhs-val> <rval>
			emit_instrForLOp(expr);
			// <lhs-ptr> <new-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		}
		// <rval> <lhs-ptr>   or   <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(L_PUSH_NEW, L->frame->envPtr);
	} else {
		if (arith) {
			emit_load_scalar(lhs->sym->idx);
			// <rval> <old-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
			// <old-val> <rval>
			emit_instrForLOp(expr);
			// <new-val>
		}
		// <rval>   or   <new-val>
		emit_store_scalar(lhs->sym->idx);
	}
	// <rval>
}

private void
compile_incdec(Expr *expr)
{
	Expr	*lhs = expr->a;
	/* Whether expr is a postfix operator. */
	int	post = ((expr->op == L_OP_PLUSPLUS_POST) ||
			(expr->op == L_OP_MINUSMINUS_POST));
	/* Whether expr is a ++ operator. */
	int	inc = ((expr->op == L_OP_PLUSPLUS_PRE) ||
		       (expr->op == L_OP_PLUSPLUS_POST));

	if (isindexop(lhs)) {
		compile_idxOp(lhs, L_PUSH_PTRVAL|L_LVALUE);
		// <lhs-ptr> <lhs-val>
	} else {
		sym_lookup(lhs, 0);
	}
	unless (lhs->sym) {
		L_errf(expr, "invalid l-value in inc/dec");
		return;
	}

	L_typeck_expect(L_INT|L_FLOAT, lhs, "in ++/--");

	if (isindexop(lhs)) {
		// <lhs-ptr> <lhs-val>
		push_str("1");
		// <hs-ptr> <lhs-val> 1
		TclEmitOpcode(inc?INST_ADD:INST_SUB, L->frame->envPtr);
		// <lhs-ptr> <new-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt4(post?L_PUSH_OLD:L_PUSH_NEW, L->frame->envPtr);
	} else {
		if (post) compile_expr(lhs, L_PUSH_VAL);
		// <old-val>   if post
		TclEmitInstInt1(INST_INCR_SCALAR1_IMM, lhs->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(inc? 1 : -1, L->frame->envPtr);
		// <old-val> <new-val>   if post
		// <new-val>             if !post
		if (post) emit_pop();
	}
	// <old-val>   if post
	// <new-val>   if !post
}

private int
push_regexpModifiers(Expr *regexp)
{
	int	n = 0;

	if (regexp->flags & L_EXPR_RE_I) {
		push_str("-nocase");
		n++;
	}
	if (regexp->flags & L_EXPR_RE_G) {
		push_str("-all");
		n++;
	}
	return (n);
}

private void
emit_instrForLOp(Expr *expr)
{
	int	op = 0;

	switch (expr->op) {
	    case L_OP_STR_EQ:
	    case L_OP_EQUALEQUAL:
		op = INST_EQ;
		break;
	    case L_OP_STR_NE:
	    case L_OP_NOTEQUAL:
		op = INST_NEQ;
		break;
	    case L_OP_STR_GT:
	    case L_OP_GREATER:
		op = INST_GT;
		break;
	    case L_OP_STR_GE:
	    case L_OP_GREATEREQ:
		op = INST_GE;
		break;
	    case L_OP_STR_LT:
	    case L_OP_LESSTHAN:
		op = INST_LT;
		break;
	    case L_OP_STR_LE:
	    case L_OP_LESSTHANEQ:
		op = INST_LE;
		break;
	    case L_OP_PLUS:
	    case L_OP_EQPLUS:
		op = INST_ADD;
		break;
	    case L_OP_MINUS:
	    case L_OP_EQMINUS:
		op = INST_SUB;
		break;
	    case L_OP_STAR:
	    case L_OP_EQSTAR:
		op = INST_MULT;
		break;
	    case L_OP_SLASH:
	    case L_OP_EQSLASH:
		op = INST_DIV;
		break;
	    case L_OP_PERC:
	    case L_OP_EQPERC:
		op = INST_MOD;
		break;
	    case L_OP_BITAND:
	    case L_OP_EQBITAND:
		op = INST_BITAND;
		break;
	    case L_OP_BITOR:
	    case L_OP_EQBITOR:
		op = INST_BITOR;
		break;
	    case L_OP_BITXOR:
	    case L_OP_EQBITXOR:
		op = INST_BITXOR;
		break;
	    case L_OP_LSHIFT:
	    case L_OP_EQLSHIFT:
		op = INST_LSHIFT;
		break;
	    case L_OP_RSHIFT:
	    case L_OP_EQRSHIFT:
		op = INST_RSHIFT;
		break;
	    case L_OP_UMINUS:
		op = INST_UMINUS;
		break;
	    case L_OP_UPLUS:
		op = INST_UPLUS;
		break;
	    case L_OP_BANG:
		op = INST_LNOT;
		break;
	    case L_OP_BITNOT:
		op = INST_BITNOT;
		break;
	    default:
		L_bomb("Unable to map operator %d to an instruction", expr->op);
		break;
	}
	TclEmitOpcode(op, L->frame->envPtr);
}

private void
compile_continue(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_enclosingLoop();

	unless (loop_frame) {
		L_errf(stmt, "continue allowed only inside loops");
		return;
	}
	j = emit_jmp(INST_JUMP4);
	j->next = loop_frame->continue_jumps;
	loop_frame->continue_jumps = j;
}

private void
compile_break(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_enclosingLoop();

	unless (loop_frame) {
		L_errf(stmt, "break allowed only inside loops");
		return;
	}
	j = emit_jmp(INST_JUMP4);
	j->next = loop_frame->break_jumps;
	loop_frame->break_jumps = j;
}

/*
 * Walk up the semantic stack and return the first frame that
 * corresponds to a loop.
 */
private Frame *
frame_enclosingLoop()
{
	Frame *f;

	for (f = L->frame; f; f = f->prevFrame) {
		Ast *node = (Ast *)f->block;
		if (node && ((node->type == L_NODE_LOOP) ||
			     (node->type == L_NODE_FOREACH_LOOP))) {
			break;
		}
	}
	return (f);
}

private Frame *
frame_outer(Frame *frame)
{
	ASSERT(frame);
	while (frame->prevFrame) frame = frame->prevFrame;
	ASSERT(frame->flags & OUTER);
	return (frame);
}

private void
emit_globalUpvar(Sym *sym, Expr *id)
{
	/*
	 * Tim comment: We attempt to detect whether L global
	 * variables should be true globals, or should be shared with
	 * the calling proc, by checking if the current variable frame
	 * pointer in interp is the same as the global frame pointer.
	 * (Sharing variables with the calling proc is useful if you
	 * want to use L as an expr replacement).
	 */
	if (((Interp *)L->frame->interp)->rootFramePtr !=
	    ((Interp *)L->frame->interp)->varFramePtr) {
		ASSERT(!(sym->decl->flags & (DECL_CLASS_VAR |
					     DECL_CLASS_INST_VAR)));
		push_str("1");
		push_str(id->u.string);
		TclEmitInstInt4(INST_UPVAR, sym->idx, L->frame->envPtr);
		emit_pop();
		return;
	}

	/*
	 * The namespace of the var we're creating an upvar alias to is
	 * either ::, an L class namespace, or an L class instance namespace
	 * (and in this case the local "self" holds the namespace name).
	 */
	switch (sym->decl->flags &
		(DECL_GLOBAL_VAR | DECL_CLASS_VAR | DECL_CLASS_INST_VAR)) {
	    case DECL_GLOBAL_VAR:
		push_str("::");
		break;
	    case DECL_CLASS_VAR:
		push_str("::L::_class_%s", sym->decl->clsdecl->decl->id->u.string);
		break;
	    case DECL_CLASS_INST_VAR: {
		Sym *self = sym_lookup(ast_mkId("self", 0, 0), NOWARN);
		ASSERT(!self || (self->idx >= 0));
		if (self) emit_load_scalar(self->idx);
		break;
	    }
	}
	push_str(id->u.string);
	TclEmitInstInt4(INST_NSUPVAR, sym->idx, L->frame->envPtr);
	emit_pop();
}

/*
 * Add a variable or function name to the symbol table.  If it's a
 * local variable, allocate a slot for it in the current proc.
 *
 * Print an error if the symbol is already defined.  The rules are
 *
 * - Multiply defined globals are illegal, with the exception that
 *   main() can be re-defined.
 * - A local cannot shadow any other local in the proc.
 * - A local can shadow a global.
 * - A local can shadow a global upvar shadow (which is a local
 *   with special status).
 *
 * Scopes are created as follows.  The complexity stems from Tcl
 * requiring local upvar shadows as the only way to access globals.
 * So we have a scope in which the global symbol is stored and a
 * nested scope for the proc in which the local upvar shadow is
 * stored.
 *
 * There is one scope hierarchy per Tcl Interp in which L code
 * appears, as illustrated next.  OUTER,TOPLEV,SKIP etc are frame
 * flags (Frame_f); SKIP means that the scope is skipped when
 * searching enclosing scopes.
 *
 * [ outer-most scope (OUTER): globals go in this frame's symtab
 *     [ * (%%n_toplevel proc) (TOPLEV|SKIP)
 *         global initializers get compiled in this scope, causing the local
 *         upvar shadows to go in this scope's symtab
 *         [ class outer-most (CLS_OUTER): class/instance vars & private
 *             member fns go in this frame's symtab
 *             [ * class top-level (CLS_TOPLEV|SKIP)
 *                 class variable initializers get compiled in this scope
 *                 (note that this is still in the %%n_toplevel proc)
 *                 [ (constructor proc)
 *                     instance var initializers get compiled here
 *                 ]
 *                 [ (destructor proc)
 *                 ]
 *                 [ (member fn proc): public fn names go in outer-most scope's
 *                     symtable, private fn names go in class outer-most scope,
 *                     fn locals go in this frame's symtab
 *                     [ block
 *                         [ nested blocks...
 *                         ]
 *                     ]
 *                 ]
 *             ]
 *         ]
 *         [ regular function (proc): fn name goes in outer-most scope's symtab,
 *           fn locals go in this frame's symtab
 *             [ block
 *                 [ nested blocks...
 *                 ]
 *             ]
 *         ]
 *     ]
 * ]
 */
private Sym *
sym_store(VarDecl *decl)
{
	int	new;
	char	*name = decl->id->u.string;
	Sym	*sym;
	Frame	*frame;
	Tcl_HashEntry *hPtr;

	/* Check for multiple declaration. */
	switch (decl->flags & (SCOPE_LOCAL | SCOPE_GLOBAL | SCOPE_CLASS)) {
	    case SCOPE_GLOBAL:
		/* Declaring a global -- search outer-most frame. */
		frame = frame_outer(L->frame);
		hPtr = Tcl_FindHashEntry(frame->symtab, name);
		/*
		 * Special case for main: don't allow redeclaration within
		 * the same script, determined by whether the current AST
		 * root is the same one as when main was last declared.
		 */
		if (!strcmp(name, "main")) {
			if (hPtr && (L->mains_ast == L->ast)) {
				L_errf(decl->id, "redeclaration of main");
				return (NULL);
			}
			if (hPtr) Tcl_DeleteHashEntry(hPtr);
			L->mains_ast = L->ast;
		} else if (hPtr) {
			L_errf(decl, "multiple declaration of global %s", name);
			return (NULL);
		}
		break;
	    case SCOPE_CLASS:
		/* Declaring class var -- search up thru class outer scope. */
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) {
				L_errf(decl, "multiple declaration of %s",
				       name);
				return (NULL);
			}
			if (frame->flags & CLS_OUTER) break;
		}
		break;
	    case SCOPE_LOCAL:
		/* Declaring a local -- search current proc's local scopes. */
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			unless (frame->envPtr == L->frame->envPtr) break;
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) {
				sym = (Sym *)Tcl_GetHashValue(hPtr);
				ASSERT(sym->kind & L_SYM_LVAR);
				unless (sym->kind & L_SYM_LSHADOW) {
					L_errf(decl, "multiple declaration "
					       "of local %s", name);
					return (NULL);
				}
			}
		}
		break;
	    default:
		ASSERT(0);
		break;
	}

	/* Select the frame to add the symbol to. */
	switch (decl->flags & (SCOPE_LOCAL | SCOPE_GLOBAL | SCOPE_CLASS)) {
	    case SCOPE_GLOBAL:
		frame = frame_outer(L->frame);
		break;
	    case SCOPE_CLASS:
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			if (frame->flags & CLS_OUTER) break;
		}
		ASSERT(frame->flags & CLS_OUTER);
		break;
	    case SCOPE_LOCAL:
		frame = L->frame;
		break;
	    default:
		ASSERT(0);
		break;
	}
	hPtr = Tcl_CreateHashEntry(frame->symtab, name, &new);
	/* If it's not new, it must be shadowing a global. */
	ASSERT(new || ((sym->kind & L_SYM_LSHADOW) &&
		       (decl->flags & (DECL_LOCAL_VAR | DECL_CLASS_INST_VAR))));
	sym = (Sym *)ckalloc(sizeof(Sym));
	memset(sym, 0, sizeof(*sym));
	sym->name = ckstrdup(name);
	sym->type = decl->type;
	sym->decl = decl;

	/*
	 * The decl also says whether variables are local or global.
	 * Vars in the outer-most scope (which includes all externs),
	 * are globals.  Mangle the tcl name for a global "g" to "_g"
	 * so that we can always create a local upvar shadow for it.
	 * Locals and function names are not allowed to begin with "_".
	 */
	if (isfntype(decl->type)) {
		ASSERT(decl->flags &
		       (DECL_FN | DECL_CLASS_PRIV_FN | DECL_CLASS_PUB_FN));
		sym->kind    = L_SYM_FN;
		sym->tclname = ckstrdup(name);
	} else if (decl->flags &
		   (DECL_GLOBAL_VAR | DECL_CLASS_VAR | DECL_CLASS_INST_VAR)) {
		sym->kind    = L_SYM_GVAR;
		sym->tclname = ckalloc(strlen(name)+2);
		sprintf(sym->tclname, "_%s", name);
	} else {
		ASSERT(decl->flags & DECL_LOCAL_VAR);
		sym->kind    = L_SYM_LVAR;
		sym->tclname = ckstrdup(name);
	}

	/* If a local, allocate a slot for it. */
	if (sym->kind & L_SYM_LVAR) {
		sym->idx = TclFindCompiledLocal(name, strlen(name),
						1, L->frame->envPtr);
	} else {
		sym->idx = -1;
	}

	decl->id->sym  = sym;
	decl->id->type = decl->type;
	Tcl_SetHashValue(hPtr, sym);

	return (sym);
}

/*
 * Lookup id in the symbol table.
 *
 * flags & NOUSED ==> don't mark the id as having been referenced
 * (used for warning which variables are unused).
 *
 * flags & NOWARN ==> don't print error message if id not found.
 *
 * The first time a global is referenced within a scope, an upvar is
 * created for it.
 */
private Sym *
sym_lookup(Expr *id, enum lookup flags)
{
	int	new;
	char	*name;
	Sym	*shw;
	Sym	*sym = NULL;
	Frame	*frame;
	Tcl_HashEntry *hPtr = NULL;

	unless (id->kind == L_EXPR_ID) return (NULL);
	name = id->u.string;

	for (frame = L->frame; frame; frame = frame->prevFrame) {
		if ((frame->envPtr == L->frame->envPtr) ||
		    (frame->flags & SEARCH)) {
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) break;
		}
	}
	if (hPtr) sym = (Sym *)Tcl_GetHashValue(hPtr);
	if (sym) {
		/*
		 * If a global is being referenced for the first time
		 * in this scope, create a local upvar to shadow it.
		 */
		if ((sym->kind & L_SYM_GVAR) && (sym->idx == -1)) {
			// assert global => in outer-most frame
			ASSERT(!(sym->decl->flags & DECL_GLOBAL_VAR) ||
			       (frame->flags & OUTER));
			// assert class var => in class outer-most frame
			ASSERT(!(sym->decl->flags & DECL_CLASS_VAR) ||
			       (frame->flags & CLS_OUTER));
			// assert class instance var => class outer-most frame
			ASSERT(!(sym->decl->flags & DECL_CLASS_INST_VAR) ||
			       (frame->flags & CLS_OUTER));
			hPtr = Tcl_CreateHashEntry(L->frame->symtab, name,
						   &new);
			ASSERT(new);
			shw = (Sym *)ckalloc(sizeof(Sym));
			memset(shw, 0, sizeof(*shw));
			shw->kind    = L_SYM_LVAR | L_SYM_LSHADOW;
			shw->name    = ckstrdup(name);
			shw->tclname = ckstrdup(sym->tclname);
			shw->type    = sym->decl->type;
			shw->decl    = sym->decl;
			shw->used_p  = TRUE;
			shw->idx     = TclFindCompiledLocal(shw->tclname,
						strlen(shw->tclname),
						1,
						L->frame->envPtr);
			emit_globalUpvar(shw, id);
			Tcl_SetHashValue(hPtr, shw);
			sym = shw;
		}
		unless (flags & NOUSED) sym->used_p = TRUE;
		id->sym  = sym;
		id->type = sym->type;
		return (sym);
	} else {
		unless (flags & NOWARN) {
			L_errf(id, "undeclared variable: %s", name);
		}
		ASSERT(id->sym == NULL);
		id->type = L_poly;  // to minimize cascading errors
		return (NULL);
	}
}

/* Make a new unique name. */
private char *
mk_uniqSym(char *name)
{
	static int ctr = 0;

	char *s = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
	sprintf(s, "%d%s", ctr++, name);
	return (s);
}

private void
frame_push(Tcl_Interp *interp, CompileEnv *envPtr, void *block, Frame_f flags)
{
	Frame *new_frame = (Frame *)ckalloc(sizeof(Frame));
	memset(new_frame, 0, sizeof(*new_frame));

	new_frame->interp = interp;
	new_frame->envPtr = envPtr;
	new_frame->block  = block;
	new_frame->flags  = flags;
	new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
	new_frame->prevFrame = L->frame;
	/* Inherit options from the previous frame. */
	if (L->frame) new_frame->options = L->frame->options;
	L->frame = new_frame;
}

private void
frame_pop(void)
{
	Frame	*prev = L->frame->prevFrame;
	Sym	*sym;
	Tcl_HashEntry *hPtr;
	Tcl_HashSearch hSearch;

	/*
	 * Check for unused local symbols, and free the frame's symbol
	 * table and the frame itself.
	 */
	for (hPtr = Tcl_FirstHashEntry(L->frame->symtab, &hSearch);
	     hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		sym = (Sym *)Tcl_GetHashValue(hPtr);
		unless (sym->used_p || !(sym->kind & L_SYM_LVAR)) {
			L_warnf(sym->decl, "%s unused", sym->name);
		}
		ckfree(sym->name);
		ckfree(sym->tclname);
		ckfree((char *)sym);
	}
	Tcl_DeleteHashTable(L->frame->symtab);
	ckfree((char *)L->frame->symtab);
	ckfree((char *)L->frame);

	L->frame = prev;
}

void
L_bomb(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	fprintf(stderr, "L Internal Error: ");
	vfprintf(stderr, format, ap);
	va_end(ap);
	fprintf(stderr, "\n");
	exit(1);
}

/* This is scheduled for a major make-over. */
void
L_trace(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	if (getenv("LTRACE")) {
		fprintf(stderr, "***: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
	}
	va_end(ap);
	fflush(stderr);
}

void
L_warn(char *s)
{
	unless (L->frame && (L->frame->options & L_OPT_NOWARN)) {
		fprintf(stderr, "L Warning: %s\n", s);
	}
}

void
L_warnf(void *node, const char *format, ...)
{
	va_list	ap;

	unless (L->frame && (L->frame->options & L_OPT_NOWARN)) {
		va_start(ap, format);
		if (node) {
			fprintf(stderr, "%s:%d: ",
				((Ast *)node)->file, ((Ast *)node)->line);
		}
		fprintf(stderr, "L Warning: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
		va_end(ap);
	}
}

/* L_err is yyerror and is called by the parser for syntax errs. */
void
L_err(const char *format, ...)
{
	va_list ap;
	char	*buf;

	va_start(ap, format);
	buf = ckvsprintf(format, ap);
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	Tcl_AppendPrintfToObj(L->errs, "%s:%d: L Error: %s\n",
			      L->file, L->line, buf);
	ckfree(buf);
}

void
L_errf(void *node, const char *format, ...)
{
	va_list ap;
	char	*buf;

	va_start(ap, format);
	buf = ckvsprintf(format, ap);
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	if (node) {
		Tcl_AppendPrintfToObj(L->errs, "%s:%d: ",
				      ((Ast *)node)->file, ((Ast *)node)->line);
	}
	Tcl_AppendPrintfToObj(L->errs, "L Error: %s\n", buf);
	ckfree(buf);
}

private void
ast_free(Ast *ast_list)
{
	while (ast_list) {
		Ast	*node = ast_list;
		ast_list = ast_list->next;
		switch (node->type) {
		    case L_NODE_EXPR:
			switch (((Expr *)node)->kind) {
			    case L_EXPR_CONST:
				if (((Expr *)node)->type == L_string) {
					ckfree(((Expr *)node)->u.string);
				}
				break;
			    case L_EXPR_BINOP:
				if (((Expr *)node)->op == L_OP_STRUCT_INDEX) {
					ckfree(((Expr *)node)->u.string);
				}
				break;
			    case L_EXPR_ID:
			    case L_EXPR_RE:
				ckfree(((Expr *)node)->u.string);
				break;
			    default:
				break;
			}
			break;
		    case L_NODE_VAR_DECL:
			ckfree(((VarDecl *)node)->tclprefix);
			break;
		    default:
			break;
		}
		ckfree((char *)node);
	}
}

private void
type_free(Type *type_list)
{
	while (type_list) {
		Type	*type = type_list;
		type_list = type_list->list;
		if (type->kind == L_STRUCT) ckfree(type->u.struc.tag);
		ckfree((char *)type);
	}
}

/*
 * This is basically a whacked version of EnterCmdStartData and
 * EnterCmdWordData from tclCompile.c.
 */
private void
track_cmd(int codeOffset, void *node)
{
	int	cmdIndex = L->frame->envPtr->numCommands++;
	Ast	*ast = (Ast *)node;
	int	len = ast->end - ast->beg;
	int	srcOffset = ast->beg;
	int	*wwlines;
	ECL	*ePtr;
	CmdLocation *cmdLocPtr;
	CompileEnv *envPtr = L->frame->envPtr;
	ExtCmdLoc *eclPtr = envPtr->extCmdMapPtr;

	if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
		Tcl_Panic("track_cmd: bad command index %d", cmdIndex);
	}
	if (cmdIndex >= envPtr->cmdMapEnd) {
		/*
		 * Expand the command location array by allocating
		 * more storage from the heap. The currently allocated
		 * CmdLocation entries are stored from cmdMapPtr[0] up
		 * to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
		 */
		size_t currElems = envPtr->cmdMapEnd;
		size_t newElems  = 2*currElems;
		size_t currBytes = currElems * sizeof(CmdLocation);
		size_t newBytes  = newElems * sizeof(CmdLocation);
		CmdLocation *newPtr = (CmdLocation *)ckalloc((int)newBytes);

		/*
		 * Copy from old command location array to new, free
		 * old command location array if needed, and mark new
		 * array as malloced.
		 */
		memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
		if (envPtr->mallocedCmdMap) ckfree((char *)envPtr->cmdMapPtr);
		envPtr->cmdMapPtr      = (CmdLocation *)newPtr;
		envPtr->cmdMapEnd      = newElems;
		envPtr->mallocedCmdMap = 1;
	}

	cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
	cmdLocPtr->codeOffset   = codeOffset;
	cmdLocPtr->srcOffset    = srcOffset;
	cmdLocPtr->numSrcBytes  = len;
	cmdLocPtr->numCodeBytes = currOffset(envPtr) - codeOffset;

	/*
	 * The command locations have to be sorted in ascending order
	 * by codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(),
	 * if nothing else). However, when L compiles nested function
	 * calls, the outer one will get tracked second, even though
	 * it begins first.  So we walk the new CmdLocation entry back
	 * from the end until it lands where it belongs.
	 */
	while ((cmdIndex > 0) && (envPtr->cmdMapPtr[cmdIndex-1].codeOffset >
				  envPtr->cmdMapPtr[cmdIndex].codeOffset)) {
		CmdLocation cmdLoc = envPtr->cmdMapPtr[cmdIndex];
		envPtr->cmdMapPtr[cmdIndex]   = envPtr->cmdMapPtr[cmdIndex-1];
		envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
		cmdIndex--;
	}

	if (eclPtr->nuloc >= eclPtr->nloc) {
		/*
		 * Expand the ECL array by allocating more storage
		 * from the heap. The currently allocated ECL entries
		 * are stored from eclPtr->loc[0] up to
		 * eclPtr->loc[eclPtr->nuloc-1] (inclusive).
		 */
		size_t currElems = eclPtr->nloc;
		size_t newElems = (currElems ? 2*currElems : 1);
		size_t newBytes = newElems * sizeof(ECL);
		eclPtr->loc = (ECL *) ckrealloc((char *) eclPtr->loc, newBytes);
		eclPtr->nloc = newElems;
	}

	/* We enter only one word for the L command. */
	ePtr = &eclPtr->loc[eclPtr->nuloc];
	ePtr->srcOffset = srcOffset;
	ePtr->line = (int *) ckalloc(sizeof(int));
	ePtr->nline = 1;
	wwlines = (int *) ckalloc(sizeof(int));
	wwlines[0] = ast->line;
	eclPtr->nuloc ++;
}

char *
ckstrdup(const char *str)
{
	if (str) {
		return (ckstrndup(str, strlen(str)));
	} else {
		return (NULL);
	}
}

char *
ckstrndup(const char *str, int len)
{
	char	*newStr = ckalloc(len+1);

	strncpy(newStr, str, len);
	newStr[len] = '\0';
	return (newStr);
}

char *
cksprintf(const char *fmt, ...)
{
	va_list	ap;
	char	*buf;

	va_start(ap, fmt);
	buf = ckvsprintf(fmt, ap);
	va_end(ap);
	return (buf);
}

char *
ckvsprintf(const char *fmt, va_list ap)
{
	int	len;
	char	*buf;

	len = 64;
	buf = ckalloc(len);
	while (vsnprintf(buf, len, fmt, ap) >= len) {
		ckfree(buf);
		len *= 2;
		buf = ckalloc(len);
		ASSERT(len < 32768);  // sanity check
	}
	return (buf);
}

/*
 * Since we have C-like variable declarations in L, when hashes and
 * arrays are declared, the base type is parsed separately from the
 * array sizes or hash-element types.  The next two functions put them
 * back together.  E.g., in
 *
 *    string h{int};
 *
 * the main type passed in to these functions is a hash type
 * (w/index type of "int") but the hash type doesn't yet have its
 * base type set, which in this example is "string".
 *
 * For simple declarations (like "string s") where there is no
 * explicit array or hash, decl->type won't be set by the parser, so
 * the base type goes there.  For arrays/hashes, decl->type points to
 * the first level of array or hash, and the base type must go onto
 * the last nested hash or array type.
 */

void
L_set_baseType(Type *type, Type *base_type)
{
	while (type->base_type) {
		ASSERT((type->kind == L_ARRAY) ||
		       (type->kind == L_HASH) ||
		       (type->kind == L_NAMEOF));
		type = type->base_type;
	}
	type->base_type = base_type;
}

void
L_set_declBaseType(VarDecl *decl, Type *base_type)
{
	if (decl->type) {
		L_set_baseType(decl->type, base_type);
	} else {
		decl->type = base_type;
	}
}

/*
 * These are called before each Tcl interp is created (see
 * tclInterp.c) and after it is deleted.  Set up a top-level scope and
 * call frame in order to persist typedefs, struct types, and globals
 * across all the L programs compiled inside the interp.
 */
void
TclLInitCompiler(Tcl_Interp *interp)
{
//	putenv("MallocStackLogging=1");

	/* Associate the L global state with this interp. */
	L = (Lglobal *)ckalloc(sizeof(Lglobal));
	memset(L, 0, sizeof(Lglobal));
	Tcl_SetAssocData(interp, "L", TclLCleanupCompiler, L);

	L->interp = interp;
	frame_push(interp, NULL, NULL, OUTER|SEARCH);
	L_scope_enter();
}

void
TclLCleanupCompiler(ClientData clientData, Tcl_Interp *interp)
{
	char	buf[32];

	L = (Lglobal *)clientData;
	L_scope_leave();
	frame_pop();
	ast_free(L->ast_list);
	type_free(L->type_list);
	if (L->include_table) {
		Tcl_DeleteHashTable(L->include_table);
		ckfree((char *)L->include_table);
	}
	ckfree(L->script);
	ckfree(L->file);
	ckfree((char *)L);
	L = NULL;

	snprintf(buf, sizeof(buf), "/usr/bin/leaks %u", getpid());
//	system(buf);
}

void
L_scope_enter()
{
	Scope	*new_scope = (Scope *)ckalloc(sizeof(*new_scope));

	new_scope->structs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->structs, TCL_STRING_KEYS);

	new_scope->typedefs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->typedefs, TCL_STRING_KEYS);

	new_scope->prev = L->curr_scope;
	L->curr_scope = new_scope;
}

void
L_scope_leave()
{
	Scope	*prev = L->curr_scope->prev;

	Tcl_DeleteHashTable(L->curr_scope->structs);
	ckfree((char *)L->curr_scope->structs);

	Tcl_DeleteHashTable(L->curr_scope->typedefs);
	ckfree((char *)L->curr_scope->typedefs);

	ckfree((char *)L->curr_scope);

	L->curr_scope = prev;
}

/*
 * Called by parser to look up a reference to "struct tag".  If
 * "local" is true, check only the current scope.  If the struct
 * hasn't yet been declared, add an incomplete type to the current
 * scope's struct table whose members will get filled up later when
 * the struct is fully declared.
 */
Type *
L_struct_lookup(char *tag, int local)
{
	int		new;
	Type		*type;
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->structs, tag);
		if (local) break;
	}
	if (hPtr) {
		type = (Type *)Tcl_GetHashValue(hPtr);
	} else {
		hPtr = Tcl_CreateHashEntry(L->curr_scope->structs, tag, &new);
		type = type_mkStruct(tag, NULL, PER_INTERP);
		Tcl_SetHashValue(hPtr, type);
	}
	return (type);
}

/*
 * Called by parser to declare a new struct type.  If the struct
 * already has been declared but without any members, fill them in
 * now and return the existing type pointer.  If tag is NULL, just
 * sanity check the members' types (checking for void etc).
 */
Type *
L_struct_store(char *tag, VarDecl *m)
{
	Type	*type = NULL;

	ASSERT(m);

	if (tag) {
		type = L_struct_lookup(tag, TRUE);
		if (type->u.struc.members) {
			L_errf(m, "multiple declaration of struct %s", tag);
		} else {
			type->u.struc.members = m;
		}
	}

	/* Check member types for legality. */
	for (; m; m = m->next) {
		L_typeck_declType(m);
	}

	return (type);
}

/*
 * Called by parser to look up an ID in the typedef table to see if
 * it's been previously declared as a type name.
 */
Type *
L_typedef_lookup(char *name)
{
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->typedefs, name);
	}
	if (hPtr) {
		return ((Type *)Tcl_GetHashValue(hPtr));
	} else {
		return (NULL);
	}
}

/*
 * Called by parser to define a new type name.
 */
void
L_typedef_store(VarDecl *decl)
{
	int		new;
	Tcl_HashEntry	*hPtr;
	char		*name = decl->id->u.string;

	hPtr = Tcl_CreateHashEntry(L->curr_scope->typedefs, name, &new);
	if (new) {
		Tcl_SetHashValue(hPtr, decl->type);
	} else {
		Type *t = Tcl_GetHashValue(hPtr);
		unless (L_typeck_same(decl->type, t)) {
			L_errf(decl, "Cannot redefine type %s", name);
		}
	}
}

/*
 * This function executes the INST_L_SPLIT bytecode and is based on
 * pieces from tclCmdMZ.c.
 *
 * For edge cases, some of Perl's "split" semantics are obeyed:
 *
 * - A limit <= 0 means no limit.
 *
 * - If the regexp is ' ', we split on white space but leading
 *   white space does not produce a null first field.
 *
 * - No regexp means split on white space.
 */
Tcl_Obj *
L_split(Tcl_Interp *interp, Tcl_Obj *strobj, Tcl_Obj *reobj, Tcl_Obj *limobj)
{
	int		end, lim, matches, off, ret, start;
	int		ondefault=0, onspace=0;
	Tcl_RegExp	regExpr;
	Tcl_RegExpInfo	info;
	Tcl_Obj		*resultPtr, *objPtr, *listPtr;
	char		*str;
	int		len;

	if (limobj) {
		Tcl_GetIntFromObj(interp, limobj, &lim);
		if (lim <= 0) {
			lim = INT_MAX;
		} else {
			/* The lim is the max # fields to return,
			 * which is one less than the max # matches to
			 * allow. */
			--lim;
		}
	} else {
		lim = INT_MAX;
	}

	/*
	 * Check for the cases of no regexpr (split on white space) or
	 * splitting on ' ' (split on white space but don't return a
	 * null field for any leading white space).
	 */
	if (reobj) {
		unless (strcmp(" ", Tcl_GetString(reobj))) onspace = 1;
	} else {
		ondefault = 1;
	}

	/*
	 * Make sure to avoid problems where the objects are shared. This can
	 * cause RegExpObj <> UnicodeObj shimmering that causes data corruption.
	 * [Bug #461322]
	 */
	if (strobj == reobj) {
		objPtr = Tcl_DuplicateObj(strobj);
	} else {
		objPtr = strobj;
	}
	str = TclGetStringFromObj(objPtr, &len);

	listPtr = Tcl_NewObj();
	matches = 0;
	off     = 0;

	/*
	 * Split on white space if no regexp or ' ' was specified.  No
	 * need for the regexp engine here.
	 */
	if (ondefault || onspace) {
		int letters = 0, skip = 0;
		for (start = 0; (off < len) && (matches < lim); ++off) {
			if (skip) {
				unless (isspace(str[off])) {
					start   = off;
					letters = 1;
					skip    = 0;
					++matches;
				}
			} else {
				if (isspace(str[off])) {
					/* When regexp is ' ', create no null
					 * field for leading white space. */
					unless (onspace && !off && !start) {
						resultPtr = Tcl_NewStringObj(
								str+start,
								off-start);
						Tcl_ListObjAppendElement(
								NULL, listPtr,
								resultPtr);
					}
					skip = 1;
				} else letters = 1;
			}
		}
		unless (skip) {
			resultPtr = Tcl_NewStringObj(str+start, len-start);
			Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		}
		/* If input was all whitespace, return empty list. */
		unless (letters || !lim) listPtr = Tcl_NewObj();
		goto done;
	}

	/*
	 * Split on the specified regular expression.
	 */
	regExpr = Tcl_GetRegExpFromObj(interp, reobj,
				       TCL_REG_ADVANCED | TCL_REG_PCRE);
	unless (regExpr) {
		listPtr = Tcl_NewObj();
		goto done;
	}
	while ((off < len) && (matches < lim)) {
		ret = Tcl_RegExpExecObj(interp, regExpr, objPtr, off,
				10 /* matches */,
				((off > 0 && (str[off-1] != '\n'))
				? TCL_REG_NOTBOL : 0));
		if (ret < 0) goto done;
		if (ret == 0) break;

		Tcl_RegExpGetInfo(regExpr, &info);
		start = info.matches[0].start;
		end   = info.matches[0].end;
		matches++;

		/*
		 * Copy to the result list the portion of the source
		 * string before the match. If we matched the empty
		 * string, split after the current char.
		 */
		if (start == end) {
			ASSERT(start == 0);
			resultPtr = Tcl_NewStringObj(str+off, 1);
			++off;
		} else {
			resultPtr = Tcl_NewStringObj(str+off, start);
		}
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		off += end;
	}
	/*
	 * Copy to the result list the portion of the source string after
	 * the last match, unless we matched the last char.
	 */
	if (off < len) {
		resultPtr = Tcl_NewStringObj(str+off, len-off);
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
	}

 done:
	if (objPtr && (strobj == reobj)) {
		Tcl_DecrRefCount(objPtr);
	}
	return (listPtr);
}
