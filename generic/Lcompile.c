/*
 * Copyright (c) 2006-2007 BitMover, Inc.
 */
#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"

/*
 * Special obj type to store deep pointers. These CANNOT ever go out of the
 * engine (ie, stored in a var or returned), and they do not remain valid
 * after any command or expression that may access variables.
 *
 * These are generated by L_deepDive and are consumed immediately
 * after that.
 */
Tcl_ObjType L_deepPtrType = {
	"l-deepType",			/* name */
	NULL,				/* freeIntRepProc */
	NULL,				/* dupIntRepProc */
	NULL,				/* updateStringProc */
	NULL				/* setFromAnyProc */
};

/*
 * To implement the defined() operator, we have an L-specific type to
 * represent the undefined value of array, hash, or struct members
 * when they dynamically are brought into life by an array
 * auto-extend.  We create one object of this type and dup it as the
 * value of all undefined objects.
 */

private void
undef_freeInternalRep(Tcl_Obj *o)
{
	o->bytes  = NULL;
	o->length = 0;
}

/*
 * Return an error if someone tries to convert a value of undef type
 * to anything else.
 */
private int
undef_setFromAny(Tcl_Interp *interp, Tcl_Obj *o)
{
	Tcl_SetObjResult(interp,
			 Tcl_NewStringObj("cannot read undefined value", -1));
	return (TCL_ERROR);
}

/*
 * Get a pointer to the "undefined" object pointer, allocating it the
 * first time it is needed.
 */
private Tcl_Obj **
undef_obj()
{
	static Tcl_Obj *undef_obj = NULL;

	unless (undef_obj) {
		undef_obj = Tcl_NewObj();
		Tcl_InvalidateStringRep(undef_obj);
		undef_obj->bytes = "";
		undef_obj->typePtr = &L_undefType;
		Tcl_IncrRefCount(undef_obj);
	}
	return (&undef_obj);
}

Tcl_ObjType L_undefType = {
	"undef",
	undef_freeInternalRep,
	NULL,
	NULL,
	undef_setFromAny
};

/*
 * Duplicate part of struct Dict from tclDictObj.c; all we need is the
 * first member.  The deep-dive execution code uses it to traverse
 * hashes.  WARNING: this may break if dicts change their internal
 * rep!
 */
typedef struct Dict {
	Tcl_HashTable table;	/* Object hash table to store mapping in. */
} Dict;

/* Enum for sym_lookup() and sym_store(). */
enum lookup {
	NOUSED	= 0x01,  // do not update used_p
	NOWARN	= 0x02,  // issue no error message if symbol undefined
};

/* Enum for compile_expr[s](). */
enum compile_expr {
	PUSH,		// compile code to push expr's val onto stack
	DISCARD,	// compile expr but discard its value
};

/* The next two functions are generated by flex. */
extern void	*L__scan_bytes (const char *bytes, int len);
extern void	L__delete_buffer(void *buf);

private int	L_ParseScript(Tcl_Interp *interp, CONST char *str, Ast **L_ast);
private int	L_CompileScript(Tcl_Interp *interp, CompileEnv *envPtr,
			       void *ast, int opts);
private void	L_IncrListTail(Tcl_Obj *o);
private Tcl_Obj **L_LindexFlat(Tcl_Interp *interp, Tcl_Obj *listPtr,
			       int indexCount, Tcl_Obj *const indexArray[]);
private Tcl_Obj **L_LsetFlatExtend(Tcl_Interp *interp, Tcl_Obj *listPtr,
				   int indexCount, Tcl_Obj *const indexArray[]);
private void	ast_free(Ast *ast_list);
private Expr	*ast_mkInitializer(VarDecl *decl);
private void	compile_assignment(Expr *expr);
private void	compile_binOp(Expr *expr);
private void	compile_block(Block *block);
private void	compile_break(Stmt *stmt);
private void	compile_condition(Expr *cond);
private void	compile_continue(Stmt *stmt);
private void	compile_deepDive(Expr *expr, Deep_f flags);
private void	compile_expr(Expr *expr, enum compile_expr flags);
private int	compile_exprs(Expr *expr, enum compile_expr flags);
private void	compile_fnCall(Expr *expr);
private void	compile_fnDecl(FnDecl *fun);
private void	compile_foreach(ForEach *loop);
private void	compile_foreachArray(ForEach *loop);
private void	compile_foreachHash(ForEach *loop);
private void	compile_ifUnless(Cond *cond);
private void	compile_incdec(Expr *expr);
private void	compile_loop(Loop *loop);
private void	compile_fnParms(VarDecl *decl);
private void	compile_push(Expr *expr);
private void	compile_return(Stmt *stmt);
private void	compile_shortCircuit(Expr *expr);
private void	compile_split(Expr *expr);
private void	compile_stmt(Stmt *stmt);
private void	compile_stmts(Stmt *stmt);
private int	compile_topLevels(TopLev *stmt);
private void	compile_trinOp(Expr *expr);
private void	compile_twiddle(Expr *expr);
private void	compile_twiddleSubst(Expr *expr);
private void	compile_unOp(Expr *expr);
private void	compile_varDecl(VarDecl *decl);
private void	compile_varDecls(VarDecl *decls);
private Tcl_Obj	**deepdive_array(Tcl_Interp *interp, Tcl_Obj *obj,
				 Tcl_Obj **idxs, int num_idxs, Deep_f flags);
private Tcl_Obj	**deepdive_hash(Tcl_Interp *interp, Tcl_Obj *obj,
				Tcl_Obj **idxs, int num_idxs, Deep_f flags);
private void	emit_globalUpvar(Sym *sym, Expr *id);
private void	emit_instrForLOp(Expr *expr);
private Jmp	*emit_jmp(int op);
private void	fixup_jmps(Jmp *jumps);
private Frame	*frame_enclosingLoop();
private Frame	*frame_outer(Frame *frame);
private void	frame_pop(void);
private void	frame_push(Tcl_Interp *interp, CompileEnv *envPtr, void *block);
private int	ispatternfn(char *name, Expr **Foo_star, char **foo,
			    Expr **bar);
private char	*mk_uniqSym(char *name);
private Proc	*proc_begin(void);
private void	proc_finish(Proc *procPtr, char *name);
private int	push_deepDiveIdxs(Expr *expr, int *num_idx, Tcl_Obj **counts);
private Type	*push_index(Expr *expr);
private void	push_lit(Expr *expr);
private int	push_parms(Expr *parameters);
private void	push_pointer(Expr *lval);
private int	push_regexpModifiers(Expr *regexp);
private void	push_var(Expr *expr);
private void	re_gatherTxt(Expr *e, Tcl_Obj *s);
private int	re_submatchCnt(Expr *re);
private VarDecl	*struct_lookupMember(Type *t, Expr *idx, int *offset);
private Sym	*sym_lookup(Expr *id, enum lookup flags);
private Sym	*sym_store(VarDecl *decl);
private void	track_cmd(int codeOffset, void *node);
private void	type_free(Type *type_list);

Lglobal	*L;		// per-interp global state
Type	*L_int;		// pre-defined types
Type	*L_float;
Type	*L_string;
Type	*L_void;
Type	*L_var;
Type	*L_widget;
Type	*L_poly;

/*
 * Unlike the other isxxx type functions, this one doesn't require the
 * expression to have been compiled yet.  It peeks into it just far
 * enough to figure out if it's a widget.  This is needed since to
 * compile a pattern-function call we need to know if the first arg is
 * a widget *before* it is compiled.
 */
static inline int
iswidget(Expr *expr)
{
	Sym *sym;

	if (expr->type) return (expr->type->kind == L_WIDGET);
	/*
	 * Test these if the expression hasn't yet been compiled.
	 * These are the only expressions that can produce a widget.
	 */
	switch (expr->kind) {
	    case L_EXPR_UNOP:
		return ((expr->op == L_OP_CAST) &&
			(((Type *)expr->a)->kind == L_WIDGET));
	    case L_EXPR_ID:
		sym = sym_lookup(expr, NOWARN);
		return (sym && (sym->type->kind == L_WIDGET));
	    case L_EXPR_FUNCALL:
		sym = sym_lookup(expr->a, NOWARN);
		return (sym && (sym->type->kind == L_FUNCTION) &&
			(sym->type->base_type == L_widget));
	    default:
		return (0);
	}
}

/*
 * If TCL encounters an lang(L) directive while evaluating code directly,
 * e.g., from an upvar, it will enter the L compiler via this function.
 */
int
Tcl_LObjCmd(ClientData clientData, Tcl_Interp *interp, int objc,
	    Tcl_Obj *CONST objv[])
{
	int	i, index, len;
	int	opts = 0;
	char	*str;
	Ast	*ast;
	static	CONST char *options[] = { "-poly", "-nowarn", NULL };
	enum	options { L_POLY, L_NOWARN };

	/* Extract the L global state from the interp. */
	L = Tcl_GetAssocData(interp, "L", NULL);

	if (objc < 2) {
		Tcl_WrongNumArgs(interp, 1, objv, "?options? l-program");
		return (TCL_ERROR);
	}

	/* option parsing -- add flags to :opts */
	for (i = 1; i < objc - 1; i++) {
		if (Tcl_GetIndexFromObj(interp, objv[i],
			options, "option", 0, &index) != TCL_OK) {
			return (TCL_ERROR);
		}
		switch((enum options)index) {
		    case L_POLY:
			opts |= L_OPT_POLY;
			break;
		    case L_NOWARN:
			opts |= L_OPT_NOWARN;
			break;
		    default:
			L_bomb("bad opt Tcl_GetIndexFromObj should've caught");
		}
	}
	str = Tcl_GetStringFromObj(objv[objc - 1], &len);
	if (L_ParseScript(interp, str, &ast) != TCL_OK) {
		return (TCL_ERROR);
	}
	unless (ast) return (TCL_OK);	// empty script
	return (L_CompileScript(interp, NULL, ast, opts));
}

/*
 * If TCL encounters an L pragma while compiling TCL code, for example when
 * processing an entire file in TclCompileScript(), it will enter L via
 * TclCompileLCmd().  In that case, we get a pointer to the toplevel
 * compilation environment, so we have the option of emitting global code.
 *
 * If there is an error during L compilation, we return TCL_ERROR.  However,
 * the error only causes TCL to defer evaluation of the L pragma until
 * runtime, at which point Tcl_LObjCmd() will recompile the L code and hit the
 * same error.
 */
int
TclCompileLCmd(Tcl_Interp *interp, Tcl_Parse *parsePtr, Command *cmdPtr,
	       CompileEnv *envPtr)
{
	Ast	*ast;
	Tcl_Token *ltok;

	unless (parsePtr->numWords == 2) return (TCL_ERROR);

	/* Extract the L global state from the interp. */
	L = Tcl_GetAssocData(interp, "L", NULL);

	/* The first component of the second token contains the code. */
	ltok = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
	if (L_ParseScript(interp, ltok[1].start, &ast) != TCL_OK) {
		return (TCL_ERROR);
	}
	unless (ast) {
		/* Empty script -- leave a "" on the stack. */
		frame_push(interp, envPtr, NULL);
		push_str("");
		frame_pop();
		return (TCL_OK);
	}
	return (L_CompileScript(interp, envPtr, ast, 0));
}

/*
 * Parse an L script into an AST.  Parsing and compiling are broken into two
 * stages in order to support an interactive mode that parses many times
 * before finally compiling.
 */
private int
L_ParseScript(Tcl_Interp *interp, CONST char *str, Ast **ast_p)
{
	int	len = strlen(str);
	void	*lex_buffer;

	L_typeck_init();

	if (((Interp *)interp)->scriptFile) {
		char *f = Tcl_GetString(((Interp *)interp)->scriptFile);
		L->file = ckstrdup(f);
	} else {
		L->file = ckstrdup("<stdin>");
	}

	L->line		= 1;
	L->token_offset = L->prev_token_len = 0;
	L->script       = ckstrdup(str);
	L->script_len   = len;
	L->errs		= NULL;
	L_lex_start();
	lex_buffer      = (void *)L__scan_bytes(str, len);

	L_parse();
	ASSERT(ast_p);
	*ast_p = L->ast;

	L__delete_buffer(lex_buffer);

	if (L->errs) {
		Tcl_SetObjResult(interp, L->errs);
		return (TCL_ERROR);
	}
	return (TCL_OK);
}

/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
private int
L_CompileScript(Tcl_Interp *interp, CompileEnv *envPtr, void *ast, int opts)
{
	int	ret;

	ASSERT(((Ast *)ast)->type == L_NODE_TOPLEVEL);

	frame_push(interp, envPtr, ast);
	L->frame->options = opts;
	ret = compile_topLevels(ast);
	frame_pop();

	if (L->errs) {
		Tcl_SetObjResult(interp, L->errs);
		return (TCL_ERROR);
	}
	return (ret);
}

private int
compile_topLevels(TopLev *stmt)
{
	int	ret = TCL_OK;
	char	*name;
	Proc	*top_proc;

	name = mk_uniqSym("%%l_toplevel");
	top_proc = proc_begin();
	L->frame->toplevel_p = TRUE;

	for (; stmt; stmt = stmt->next) {
		switch (stmt->kind) {
		    case L_TOPLEVEL_FUN:
			compile_fnDecl(stmt->u.fun);
			break;
		    case L_TOPLEVEL_GLOBAL:
			compile_varDecls(stmt->u.global);
			break;
		    case L_TOPLEVEL_STMT:
			compile_stmts(stmt->u.stmt);
			break;
		    default:
			L_bomb("Unexpected toplevel stmt type %d", stmt->kind);
		}
	}

	push_str("");
	TclEmitOpcode(INST_DONE, L->frame->envPtr);
	proc_finish(top_proc, name);

	if (L->errs) {
		ret = TCL_ERROR;
		goto done;
	}

	/* Invoke the top-level code that was just compiled. */
	if (L->frame->envPtr) {
		push_str(name);
		emit_invoke(1);
		goto done;
	} else {
		ret = Tcl_Eval(L->frame->interp, name);
		goto done;
	}
 done:
	ckfree(name);
	return (ret);
}

private void
compile_fnDecl(FnDecl *fun)
{
	char	*name = fun->decl->id->u.string;
	Proc	*procPtr;
	Sym	*sym;

	ASSERT(fun);
	ASSERT(fun->decl->outer_p);

	if (name[0] == '_') {
		L_errf(fun->decl->id, "function names cannot begin with _");
	}

	/*
	 * Sort out the possible error cases:
	 *
	 * - name already declared as a variable
	 * - proto already declared and doesn't match this decl
	 * - this decl declares function body but body already declared
	 *
	 * with the exception that "main" is allowed to be re-declared.
	 */

	sym = sym_lookup(fun->decl->id, NOWARN|NOUSED);
	if (sym && strcmp(name, "main")) {
		unless (sym->kind & L_SYM_FN) {
			L_errf(fun, "%s already declared as a variable",name);
			return;
		} else if ((sym->kind & L_SYM_FNBODY) && fun->body) {
			L_errf(fun, "function %s already declared", name);
			return;
		} else unless (L_typeck_same(fun->decl->type, sym->type)) {
			L_errf(fun, "does not match prior declaration of %s",
			       name);
			return;
		}
	} else {
		sym = sym_store(fun->decl);
		unless (sym) return;
	}

	/* Check arg and return types for legality. */
	L_typeck_declType(fun->decl);

	unless (fun->body) return;

	procPtr = proc_begin();
	sym->kind |= L_SYM_FNBODY;
	L->frame->block = (Ast *)fun;

	compile_fnParms(fun->decl);

	L->enclosing_func = fun;
	compile_block(fun->body);
	L->enclosing_func = NULL;

	/* This is the "fall off the end" implicit return. We return "". */
	push_str("");
	TclEmitOpcode(INST_DONE, L->frame->envPtr);

	proc_finish(procPtr, fun->decl->id->u.string);
}

private Proc *
proc_begin(void)
{
	Proc	*procPtr;
	CompileEnv *envPtr;

	envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
	frame_push(L->frame->interp, envPtr, NULL);

	procPtr = (Proc *)ckalloc(sizeof(Proc));
	procPtr->iPtr              = (struct Interp *)L->frame->interp;
	procPtr->refCount          = 1;
	procPtr->numArgs           = 0;
	procPtr->numCompiledLocals = 0;
	procPtr->firstLocalPtr     = NULL;
	procPtr->lastLocalPtr      = NULL;
	procPtr->bodyPtr           = Tcl_NewObj();
	Tcl_IncrRefCount(procPtr->bodyPtr);
	TclInitCompileEnv(L->frame->interp, envPtr, L->script, L->script_len,
			  NULL, 0);
	envPtr->procPtr = procPtr;

	return (procPtr);
}

private void
proc_finish(Proc *procPtr, char *name)
{
	Tcl_Command cmd;

	TclInitByteCodeObj(procPtr->bodyPtr, L->frame->envPtr);
#ifdef TCL_COMPILE_DEBUG
	if (getenv("L_DISASSEMBLE")) {
		printf("Bytecode for %s:\n", name);
		TclPrintByteCodeObj(L->frame->interp, procPtr->bodyPtr);
	}
#endif
	cmd = Tcl_CreateObjCommand(L->frame->interp, name, TclObjInterpProc,
				   (ClientData) procPtr, TclProcDeleteProc);
	procPtr->cmdPtr = (Command *)cmd;
	TclFreeCompileEnv(L->frame->envPtr);
	ckfree((char *)L->frame->envPtr);
	frame_pop();
}

private void
compile_varDecl(VarDecl *decl)
{
	int	start_off = currOffset(L->frame->envPtr);
	char	*name;
	Sym	*sym;

	ASSERT(decl->id && decl->type);

	name = decl->id->u.string;

	unless (L_typeck_declType(decl)) return;

	if ((name[0] == '_') && !decl->outer_p) {
		L_errf(decl, "local variable names cannot begin with _");
	}

	sym = sym_store(decl);
	unless (sym) return;  // bail if multiply declared

	if (decl->extern_p) {
		if (decl->initializer) {
			L_errf(decl, "extern initializers illegal");
		}
		unless (L->frame->toplevel_p) {
			L_errf(decl, "externs illegal in local scopes");
		}
		sym->used_p = TRUE;  // to suppress extraneous warning
		return;
	}

	unless (decl->initializer) {
		decl->initializer = ast_mkInitializer(decl);
	}
	compile_expr(decl->initializer, DISCARD);
	track_cmd(start_off, decl);
}

private void
compile_varDecls(VarDecl *decls)
{
	for (; decls; decls = decls->next) {
		compile_varDecl(decls);
	}
}

/*
 * Make an assignment node to initialize a variable with an initial
 * "blank" value appropriate for its type.
 */
private Expr *
ast_mkInitializer(VarDecl *decl)
{
	Expr	*assign, *val;

	switch (decl->type->kind) {
	    case L_ARRAY:
	    case L_STRUCT:
	    case L_HASH:
		val = ast_mkUnOp(L_OP_LIST, NULL, decl->node.beg,
				 decl->node.end);
		break;
	    case L_INT:
		val = ast_mkConst(L_int, decl->node.beg, decl->node.end);
		val->u.integer = 0;
		break;
	    case L_FLOAT:
		val = ast_mkConst(L_float, decl->node.beg, decl->node.end);
		val->u.flote = 0.0;
		break;
	    default:
		val = ast_mkConst(L_string, decl->node.beg, decl->node.end);
		val->u.string = ckstrdup("");
		break;
	}
	assign = ast_mkBinOp(L_OP_EQUALS, decl->id, val, decl->node.beg,
			     decl->node.end);
	return (assign);
}

private void
compile_stmt(Stmt *stmt)
{
	int	start_off = currOffset(L->frame->envPtr);

	unless (stmt) return;
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
		frame_push(L->frame->interp, L->frame->envPtr, stmt);
		compile_block(stmt->u.block);
		frame_pop();
		break;
	    case L_STMT_EXPR:
		compile_exprs(stmt->u.expr, DISCARD);
		break;
	    case L_STMT_COND:
		compile_ifUnless(stmt->u.cond);
		break;
	    case L_STMT_LOOP:
		compile_loop(stmt->u.loop);
		break;
	    case L_STMT_FOREACH:
		compile_foreach(stmt->u.foreach);
		break;
	    case L_STMT_RETURN:
		compile_return(stmt);
		break;
	    case L_STMT_BREAK:
		compile_break(stmt);
		break;
	    case L_STMT_CONTINUE:
		compile_continue(stmt);
		break;
	    default:
		L_bomb("Malformed AST in compile_stmt");
	}
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
	    case L_STMT_COND:
	    case L_STMT_EXPR:
		break;
	    default:
		track_cmd(start_off, stmt);
		break;
	}
}

private void
compile_stmts(Stmt *stmts)
{
	for (; stmts; stmts = stmts->next) {
		compile_stmt(stmts);
	}
}

private void
compile_block(Block *block)
{
	compile_varDecls(block->decls);
	compile_stmts(block->body);
}

private void
compile_return(Stmt *stmt)
{
	Type	*ret_type;

	unless (L->enclosing_func) {
		L_errf(stmt, "return from global scope illegal");
		return;
	}

	ret_type = L->enclosing_func->decl->type->base_type;
	if (isvoidtype(ret_type) && (stmt->u.expr)) {
		L_errf(stmt, "void function cannot return value");
	} else if (stmt->u.expr) {
		compile_expr(stmt->u.expr, PUSH);  // return value
		unless (L_typeck_compat(ret_type, stmt->u.expr->type)) {
			L_errf(stmt, "incompatible return type");
		}
	} else {
		push_str("");  // no return value -- push a ""
	}

	TclEmitOpcode(INST_DONE, L->frame->envPtr);
}

private void
compile_fnParms(VarDecl *decl)
{
	int	i, by_name;
	int	name_parms = 0;
	char	*name;
	Proc	*proc = L->frame->envPtr->procPtr;
	VarDecl	*p;
	VarDecl	*new_decl = NULL;
	Sym	*new_sym, *sym;
	Expr	*new_id;
	VarDecl	*param = decl->type->u.func.formals;
	CompiledLocal	*local;

	for (p = param, i = 0; p; p = p->next, i++) {
		/*
		 * For prototypes, the grammar lets you declare a
		 * function arg with a type but no name, but in a
		 * declaration it's an error to omit the name.  Handle
		 * that by making up a name so we can keep compiling.
		 */
		unless (p->id) {
			L_errf(p, "formal parameter #%d lacks a name", i+1);
			name = ckalloc(32);
			snprintf(name, 32, "unnamed-arg-%d", i+1);
			p->id = ast_mkId(name, 0, 0);
		}
		/*
		 * For a pass-by-name formal, mangle the formal name
		 * to "&name" and create a new local variable "name"
		 * that's an upvar to the variable whose name is
		 * passed in the formal.  Note that the formal will have
		 * type "name-of <t>" and the local gets type <t>.
		 */
		by_name = ((p->type->kind == L_NAMEOF) &&
			   (p->type->base_type->kind != L_FUNCTION));
		if (by_name) {
			new_id = ast_mkId(p->id->u.string, p->id->node.beg,
					  p->id->node.end);
			new_decl = ast_mkVarDecl(p->type->base_type, new_id,
						 p->node.beg, p->node.end);
			name = ckalloc(strlen(p->id->u.string) + 2);
			sprintf(name, "&%s", p->id->u.string);
			ckfree(p->id->u.string);
			p->id->u.string = name;
		}
		name = p->id->u.string;
		/* Formal parameters are stored in local variable slots. */
		proc->numArgs = i + 1;
		proc->numCompiledLocals = i + 1;
		local = (CompiledLocal *)ckalloc(sizeof(CompiledLocal) -
						 sizeof(local->name) +
						 strlen(name) + 1);
		if (proc->firstLocalPtr == NULL) {
			proc->firstLocalPtr = local;
			proc->lastLocalPtr  = local;
		} else {
			proc->lastLocalPtr->nextPtr = local;
			proc->lastLocalPtr = local;
		}
		local->nextPtr = NULL;
		local->nameLength = strlen(name);
		local->frameIndex = i;
		local->flags = VAR_ARGUMENT;
		if (p->rest_p) {
			local->flags |= VAR_IS_ARGS;
			if (p->next) L_errf(p, "Rest parameter must be last");
		}
		local->resolveInfo = NULL;
		local->defValuePtr = NULL;
		strcpy(local->name, name);
		sym = sym_store(p);
		sym->idx = i;
		if (by_name) {
			/* Push a 1 the first time (arg to INST_UPVAR). */
			unless (name_parms++) push_str("1");
			/* Suppress any unused warning for &name. */
			sym->used_p = TRUE;
			new_sym = sym_store(new_decl);
			emit_load_scalar(sym->idx);
			TclEmitInstInt4(INST_UPVAR, new_sym->idx,
					L->frame->envPtr);
		}
	}
	/* Pop the 1 pushed for INST_UPVAR. */
	if (name_parms) emit_pop();
}

private void
compile_split(Expr *expr)
{
	int n = compile_exprs(expr->b, PUSH);
	if ((n < 1) || (n > 3)) {
		L_errf(expr, "incorrect # args for split");
	}
	TclEmitInstInt1(INST_L_SPLIT, n, L->frame->envPtr);
	expr->type = type_mkArray(0, L_string, PER_INTERP);
}

private void
compile_push(Expr *expr)
{
	int	idx, n;
	Expr	*arg, *array;

	n = compile_exprs(expr->b, PUSH);
	unless (n == 2) {
		L_errf(expr, "incorrect # arguments to push");
		goto done;
	}
	array = expr->b->a;
	arg   = expr->b->next;
	unless (isnameof(expr->b) && array && (isarray(array)||ispoly(array))) {
		L_errf(expr, "first arg to push not an array reference (&)");
		goto done;
	}
	unless (L_typeck_compat(array->type->base_type, arg->type)) {
		L_errf(expr, "pushing incompatible type onto array");
		goto done;
	}

	idx = array->sym->idx;  // local slot # for array
	if (idx <= 255) {
		TclEmitInstInt1(INST_LAPPEND_SCALAR1, idx, L->frame->envPtr);
	} else {
		TclEmitInstInt4(INST_LAPPEND_SCALAR4, idx, L->frame->envPtr);
	}
	emit_pop();
 done:
	expr->type = L_void;
}

private void
compile_expr(Expr *expr, enum compile_expr flags)
{
	int	start_off = currOffset(L->frame->envPtr);

	unless (expr) return;
	switch (expr->kind) {
	    case L_EXPR_FUNCALL:
		compile_fnCall(expr);
		break;
	    case L_EXPR_CONST:
	    case L_EXPR_RE:
		push_lit(expr);
		break;
	    case L_EXPR_ID:
		push_var(expr);
		break;
	    case L_EXPR_UNOP:
		compile_unOp(expr);
		break;
	    case L_EXPR_BINOP:
		compile_binOp(expr);
		break;
	    case L_EXPR_TRINOP:
		compile_trinOp(expr);
		break;
	    default:
		L_bomb("Unknown expression type %d", expr->kind);
	}

	/*
	 * Throw away the value if requested by the caller. This is done
	 * for expressions that are statements, and in for-loop pre and
	 * post expressions.
	 */
	if (flags & DISCARD) emit_pop();

	if ((expr->kind == L_EXPR_UNOP)   || (expr->kind == L_EXPR_BINOP) ||
	    (expr->kind == L_EXPR_TRINOP) || (expr->kind == L_EXPR_FUNCALL)) {
		track_cmd(start_off, expr);
	}
}

/*
 * If a function-call name begins with a cap and has an _ inside, it
 * looks like a pattern call.  From a name like "Foo_Bar" create
 * these various strings: "Foo_*", "foo", "bar".  Except for "foo"
 * return them as Expr's since that's what the caller needs.
 *
 * Caller must free *foo but the Expr's need not be freed explicitly
 * since all AST nodes are deallocated upon exit.
 */
private int
ispatternfn(char *name, Expr **Foo_star, char **foo, Expr **bar)
{
	char	*buf, *p;

	unless ((name[0] >= 'A') && (name[0] <= 'Z') &&
		(p = strchr(name, '_')) && p[1]) {  // _ cannot be last
		return (FALSE);
	}

	*p = '\0';

	/* Build Foo_* from Foo_bar. */
	buf = ckalloc(strlen(name) + 3);
	strcpy(buf, name);
	strcat(buf, "_*");
	*Foo_star = ast_mkId(buf, 0, 0);
	ckfree(buf);

	/* Build foo from Foo_bar. */
	*foo = ckalloc(strlen(name) + 1);
	strcpy(*foo, name);
	Tcl_UtfToLower(*foo);

	/* Build bar from Foo_bar. */
	buf = ckalloc(strlen(p+1) + 1);
	strcpy(buf, p+1);
	*bar = ast_mkConst(L_string, 0, 0);
	(*bar)->u.string = buf;

	*p = '_';

	return (TRUE);
}

/*
 * Rules for compiling a function call like "foo(arg)":
 *
 * - If foo is as variable of type string, poly, or name-of function,
 *   assume it contains the name of the function to call.
 *
 * - Otherwise call foo.  If foo isn't declared, that's OK, we just won't
 *   have a prototype to type-check against.
 *
 * For a function call like "Foo_bar(a,b,c)", where the name starts with
 * [A-Z] and has an _ in it (except at the end), we have what's called
 * a "pattern function":
 *
 * - If Foo_bar happens to be a function or variable, handle as above.
 *
 * - If the function Foo_* is defined, change the call to Foo_*(bar,a,b,c).
 *
 * - If "a" is not of widget type, change the call to foo(bar,a,b,c)
 *   (note the change to lower case).
 *
 * - If "a" is of type widget, change the call to *a(bar,b,c) where *a
 *   means that the variable "a" contains the function name.
 */
private void
compile_fnCall(Expr *expr)
{
	int	num_parms;
	char	*foo, *name;
	Expr	*Foo_star, *bar;
	Sym	*sym;

	ASSERT(expr->a->kind == L_EXPR_ID);
	name = expr->a->u.string;

	/* Check for an L built-in function. */
	if (!strcmp(name, "split")) {
		compile_split(expr);
		return;
	} else if (!strcmp(name, "push")) {
		compile_push(expr);
		return;
	}

	sym = sym_lookup(expr->a, NOWARN);

	if (sym && isfntype(sym->type)) {
		/* A regular call -- the name is the fn name. */
		push_str(name);
		expr->type = sym->type->base_type;
	} else if (sym && (isstring(expr->a) || ispoly(expr->a))) {
		/*
		 * Name is a string variable that holds the fn name to
		 * call.  Name, formals, and return type are all
		 * unknown at compile-time.
		 */
		emit_load_scalar(sym->idx);
		expr->type = L_poly;
	} else if (sym && (sym->type->kind == L_NAMEOF) &&
		   (sym->type->base_type->kind == L_FUNCTION)) {
		/*
		 * Name is a function "pointer".  It holds the function
		 * name and its type is the function proto.
		 */
		emit_load_scalar(sym->idx);
		expr->type = sym->type->base_type->base_type;
	} else if (sym) {
		/* Name is a variable but not of string type. */
		L_errf(expr, "function name is a non-string variable");
		expr->type = L_poly;
	} else if (ispatternfn(name, &Foo_star, &foo, &bar)) {
		/* Pattern function.  Figure out which kind. */
		if ((sym = sym_lookup(Foo_star, NOWARN))) {
			/* Foo_* is defined -- compile Foo_*(bar,a,b,c). */
			push_str(Foo_star->u.string);
			bar->next = expr->b;
			expr->b = bar;
			expr->type = sym->type;
		} else if (iswidget(expr->b)) {
			/* First arg is widget -- compile *a(bar,b,c). */
			compile_expr(expr->b, PUSH);
			bar->next = expr->b->next;
			expr->b = bar;
			expr->type = L_poly;
		} else {
			/* First arg is not widget -- compile foo(bar,a,b,c). */
			push_str(foo);
			bar->next = expr->b;
			expr->b = bar;
			expr->type = L_poly;
		}
		ckfree(foo);
	} else {
		/* Call to an undeclared function. */
		push_str(name);
		expr->type = L_poly;
	}
	num_parms = push_parms(expr->b);
	emit_invoke(num_parms+1);
	if (sym && isfntype(sym->type)) {
		L_typeck_fncall(sym->type->u.func.formals, expr);
	} else if (sym && (sym->type->kind == L_NAMEOF) &&
		   (sym->type->base_type->kind == L_FUNCTION)) {
		L_typeck_fncall(sym->type->base_type->u.func.formals, expr);
	}
}

private void
push_var(Expr *expr)
{
	Sym	*sym;

	ASSERT(expr->op == L_EXPR_ID);

	if ((sym = sym_lookup(expr, 0))) {
		emit_load_scalar(sym->idx);
	} else {
		// Undeclared variable.
		expr->type = L_poly;
	}
}

private int
compile_exprs(Expr *expr, enum compile_expr flags)
{
	int	num_exprs;

	for (num_exprs = 0; expr; expr = expr->next, ++num_exprs) {
		compile_expr(expr, flags);
	}
	return (num_exprs);
}

/*
 * Emit code to push the parameters to a function call and return the
 * # pushed.  If we see two parms like "-foovariable, &foo", then push an
 * L pointer.
 */
private int
push_parms(Expr *parms)
{
	int	i = 0;
	int	widget_flag = FALSE;
	char	*s;
	Expr	*p;

	for (i = 0, p = parms; p; p = p->next, i++) {
		if (widget_flag && (p->kind == L_EXPR_UNOP) &&
		    (p->op == L_OP_ADDROF)) {
			push_pointer(p->a);     // L pointer
		} else {
			compile_expr(p, PUSH);  // regular parm
		}
		s = p->u.string;
		widget_flag = ((p->kind == L_EXPR_CONST) && isstring(p) &&
		    /* has at least the minimum length */
		    (strlen(s) >= strlen("-variable")) &&
		    /* starts with '-' */
		    (s[0] == '-') &&
		    /* ends with "variable" */
		    !strcmp("variable", s + (strlen(s) - strlen("variable"))));
	}
	return (i);
}

private void
push_pointer(Expr *expr)
{
	push_str("::pointer");
	push_str("new");
	push_str(expr->u.string);
	if (expr->kind == L_EXPR_ID) {
		emit_invoke(3);
	} else if (expr->op == L_OP_HASH_INDEX) {
		L_errf(expr, "hash keys are not yet supported by pointers");
	} else if ((expr->op == L_OP_ARRAY_INDEX) ||
		   (expr->op == L_OP_STRUCT_INDEX)) {
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "more than one index is unsupported");
		}
		push_index(expr);
		emit_invoke(4);
	}
}

private void
push_lit(Expr *expr)
{
	char	buf[64];

	switch (expr->type->kind) {
	    case L_STRING:
		push_str(expr->u.string);
		break;
	    case L_INT:
		snprintf(buf, sizeof(buf), "%lu", expr->u.integer);
		push_str(buf);
		break;
	    case L_FLOAT:
		snprintf(buf, sizeof(buf), "%f", expr->u.flote);
		push_str(buf);
		break;
	    default:
		ASSERT(0);
		break;
	}
}

private void
compile_unOp(Expr *expr)
{
	Sym	*sym;

	switch (expr->op) {
	    case L_OP_BANG:
	    case L_OP_BITNOT:
		compile_expr(expr->a, PUSH);
		L_typeck_expect(L_INT, expr->a, "in unary ! or ~");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_UPLUS:
	    case L_OP_UMINUS:
		compile_expr(expr->a, PUSH);
		L_typeck_expect(L_INT|L_FLOAT, expr->a, "in unary +/-");
		emit_instrForLOp(expr);
		expr->type = expr->a->type;
		break;
	    case L_OP_DEFINED:
		compile_expr(expr->a, PUSH);
		L_typeck_deny(L_VOID, expr->a);
		TclEmitOpcode(INST_L_DEFINED, L->frame->envPtr);
		expr->type = L_int;
		break;
	    case L_OP_ADDROF:
		/* &id -- push the tcl name of the id. */
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "invalid argument to &");
		}
		if ((sym = sym_lookup(expr->a, 0))) {
			push_str(sym->tclname);
			expr->type = type_mkNameOf(expr->a->type, PER_INTERP);
		} else {
			// Undeclared variable.
			expr->type = L_poly;
		}
		return;
	    case L_OP_PLUSPLUS_PRE:
	    case L_OP_PLUSPLUS_POST:
	    case L_OP_MINUSMINUS_PRE:
	    case L_OP_MINUSMINUS_POST:
		compile_incdec(expr);
		expr->type = expr->a->type;
		return;
	    case L_OP_LIST:
		push_str("::list");
		if (expr->a) {
			compile_expr(expr->a, PUSH);
			emit_invoke(2);
			expr->type = type_mkList(expr->a->type, PER_INTERP);
		} else {
			/* Empty list {}. */
			emit_invoke(1);
			expr->type = L_poly;
		}
		return;
	    default:
		L_bomb("Unknown unary operator %d", expr->op);
		break;
	}
}

private void
compile_binOp(Expr *expr)
{
	Type	*type;

	switch (expr->op) {
	    case L_OP_EQUALS:
	    case L_OP_EQPLUS:
	    case L_OP_EQMINUS:
	    case L_OP_EQSTAR:
	    case L_OP_EQSLASH:
	    case L_OP_EQPERC:
	    case L_OP_EQBITAND:
	    case L_OP_EQBITOR:
	    case L_OP_EQBITXOR:
	    case L_OP_EQLSHIFT:
	    case L_OP_EQRSHIFT:
		compile_assignment(expr);
		expr->type = expr->a->type; // type of assignment is type of lhs
		break;
	    case L_OP_ANDAND:
	    case L_OP_OROR:
		compile_shortCircuit(expr);
		expr->type = L_int;
		break;
	    case L_OP_STR_EQ:
	    case L_OP_STR_NE:
	    case L_OP_STR_GT:
	    case L_OP_STR_GE:
	    case L_OP_STR_LT:
	    case L_OP_STR_LE:
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		L_typeck_expect(L_STRING|L_WIDGET, expr->a,
				"in string comparison");
		L_typeck_expect(L_STRING|L_WIDGET, expr->b,
				"in string comparison");
		emit_instrForLOp(expr);
		expr->type = L_int;
		break;
	    case L_OP_EQUALEQUAL:
	    case L_OP_NOTEQUAL:
	    case L_OP_GREATER:
	    case L_OP_GREATEREQ:
	    case L_OP_LESSTHAN:
	    case L_OP_LESSTHANEQ:
	    case L_OP_PLUS:
	    case L_OP_MINUS:
	    case L_OP_STAR:
	    case L_OP_SLASH:
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		L_typeck_expect(L_INT|L_FLOAT, expr->a,
				"in arithmetic operator");
		L_typeck_expect(L_INT|L_FLOAT, expr->b,
				"in arithmetic operator");
		emit_instrForLOp(expr);
		if (isfloat(expr->a) || isfloat(expr->b)) {
			expr->type = L_float;
		} else {
			expr->type = L_int;
		}
		break;
	    case L_OP_PERC:
	    case L_OP_BITAND:
	    case L_OP_BITOR:
	    case L_OP_BITXOR:
	    case L_OP_LSHIFT:
	    case L_OP_RSHIFT:
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		L_typeck_expect(L_INT, expr->a, "in arithmetic operator");
		L_typeck_expect(L_INT, expr->b, "in arithmetic operator");
		emit_instrForLOp(expr);
		expr->type = L_int;
		break;
	    case L_OP_ARRAY_INDEX:
	    case L_OP_HASH_INDEX:
	    case L_OP_STRUCT_INDEX:
		compile_deepDive(expr, L_DEEP_VAL);
		break;
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		TclEmitInstInt1(INST_CONCAT1, 2, L->frame->envPtr);
		expr->type = L_string;
		break;
	    case L_OP_CONS:
		push_str("::concat");
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		emit_invoke(3);
		ASSERT(islist(expr->a) || ishash(expr->a));
		ASSERT(islist(expr->b) || ishash(expr->b));
		if (ishash(expr->a) && ishash(expr->b)) {
			unless (L_typeck_same(expr->a->type, expr->b->type)) {
				L_errf(expr,
				     "hash elements must all be of same type");
			}
			expr->type = expr->a->type;
		} else if (islist(expr->a) && islist(expr->b)) {
			/*
			 * The list type is literally a list of all the
			 * individual element types linked together.
			 */
			APPEND(Type, next, expr->a->type, expr->b->type);
			expr->type = expr->a->type;
		} else {
			L_errf(expr, "cannot mix hash and non-hash elements");
			expr->type = L_poly;
		}
		break;
	    case L_OP_KV:
		push_str("::list");
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		emit_invoke(3);
		unless (isscalar(expr->a)) {
			L_errf(expr->a, "hash keys must be scalar");
		}
		expr->type = type_mkHash(expr->a->type, expr->b->type,
					 PER_INTERP);
		break;
	    case L_OP_EQTWID:
		compile_twiddle(expr);
		expr->type = L_int;
		break;
	    case L_OP_COMMA:
		compile_expr(expr->a, DISCARD);
		compile_expr(expr->b, PUSH);
		expr->type = expr->b->type;
		break;
	    case L_OP_CAST:
		type = (Type *)expr->a;
		if (type == L_int) {
			push_str("::tcl::mathfunc::int");
			compile_expr(expr->b, PUSH);
			emit_invoke(2);
		} else if (type == L_float) {
			push_str("::tcl::mathfunc::double");
			compile_expr(expr->b, PUSH);
			emit_invoke(2);
		} else {
			compile_expr(expr->b, PUSH);
		}
		L_typeck_deny(L_VOID|L_FUNCTION, expr->b);
		expr->type = type;
		break;
	    default:
		L_bomb("compile_binOp: malformed AST");
	}
}

private void
compile_trinOp(Expr *expr)
{
	switch (expr->op) {
	    case L_OP_EQTWID:
		compile_twiddleSubst(expr);
		expr->type = L_int;
		break;
	    case L_OP_INTERP_STRING:
	    case L_OP_INTERP_RE:
		compile_expr(expr->a, PUSH);
		compile_expr(expr->b, PUSH);
		compile_expr(expr->c, PUSH);
		TclEmitInstInt1(INST_CONCAT1, 3, L->frame->envPtr);
		expr->type = L_string;
		break;
	    default:
		L_bomb("compile_trinOp: malformed AST");
	}
}

/*
 * Gather all the non-interpolated parts of a string or regexp
 * expression and concat them into a Tcl_Obj.  Used by
 * re_submatchCnt() below.
 */
private void
re_gatherTxt(Expr *e, Tcl_Obj *s)
{
	switch (e->kind) {
	    case L_EXPR_RE:
	    case L_EXPR_CONST:
		if (isstring(e)) Tcl_AppendToObj(s, e->u.string, -1);
		break;
	    case L_EXPR_BINOP:
	    case L_EXPR_TRINOP:
		if ((e->op == L_OP_INTERP_RE) || (e->op == L_OP_INTERP_STRING)){
			re_gatherTxt(e->a, s);
			re_gatherTxt(e->b, s);
			if (e->c) re_gatherTxt(e->c, s);
		}
		break;
	    default:
		break;
	}
}

/*
 * Estimate how many submatches are in the given regexp.  These are
 * the sub-expressions within parens.  Since regexp's can be
 * interpolated, we can't always get this exact, so just look at the
 * non-interpolated parts of the string.
 */
private int
re_submatchCnt(Expr *re)
{
	int		n = 0;
	Tcl_Obj		*const_regexp;
	Tcl_RegExp	compiled;

	const_regexp = Tcl_NewObj();
	Tcl_IncrRefCount(const_regexp);

	re_gatherTxt(re, const_regexp);

	compiled = Tcl_GetRegExpFromObj(L->frame->interp, const_regexp,
					TCL_REG_ADVANCED);
	unless (compiled) {
		L_warnf(re, "cannot get submatch count in"
			    " interpolated regular expression");
	} else {
		n = ((TclRegexp *)compiled)->re.re_nsub;
	}

	Tcl_DecrRefCount(const_regexp);
	return (n);
}

private void
compile_twiddle(Expr *expr)
{
	int	i, mod_cnt, nocase, submatch_cnt;
	int	exact = 0;
	Expr	*regexp = expr->b;
	Sym	*s;
	Expr	*id;
	VarDecl	*v;
	Tcl_DString ds;

	submatch_cnt = re_submatchCnt(regexp);

	/*
	 * Check if the regexp can be compiled (like Tcl's) to a string
	 * comparison, string match, or regexp instruction.  Otherwise
	 * have to call the ::regexp command.
	 */
	unless (submatch_cnt || (regexp->flags & L_EXPR_RE_G)) {
		/*
		 * Can compile it: no match vars, no options (or just -nocase).
		 * If possible, convert regexp to glob so the faster
		 * string comparison or match instructions can be used.
		 * Otherwise, compile to a regexp instruction.
		 */
		nocase = (regexp->flags & L_EXPR_RE_I);
		if (isstring(regexp) &&
		    (TclReToGlob(NULL, regexp->u.string,
				 strlen(regexp->u.string), &ds,
				 &exact) == TCL_OK)) {
			push_cstr(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds));
			Tcl_DStringFree(&ds);
			compile_exprs(expr->a, PUSH);
			if (exact && !nocase) {
				TclEmitOpcode(INST_STR_EQ, L->frame->envPtr);
			} else {
				TclEmitInstInt1(INST_STR_MATCH, nocase,
						L->frame->envPtr);
			}
		} else {
			compile_exprs(regexp, PUSH);
			compile_exprs(expr->a, PUSH);
			TclEmitInstInt1(INST_REGEXP, nocase, L->frame->envPtr);
		}
	} else {
		/*
		 * Has submatches or /g modifier -- must call ::regexp cmd.
		 */
		push_str("::regexp");
		mod_cnt = push_regexpModifiers(regexp);
		push_str("--");
		compile_exprs(regexp, PUSH);
		compile_exprs(expr->a, PUSH);
		/* Submatch vars.  This loop always iterates at least once. */
		for (i = 0; i <= submatch_cnt; i++) {
			char	buf[32];
			snprintf(buf, 32, "$%d", i);
			id = ast_mkId(buf, 0, 0);
			unless (sym_lookup(id, NOWARN)) {
				v = ast_mkVarDecl(L_string, id, 0, 0);
				s = sym_store(v);
				s->used_p = TRUE; // suppress unused var warning
			}
			push_str(buf);
		}
		emit_invoke(5 + submatch_cnt + mod_cnt);
	}
	L_typeck_expect(L_STRING, expr->a, "in =~");
	// Note: the match boolean is left on the stack.
}

private void
compile_twiddleSubst(Expr *expr)
{
	int	modCount, tmpIndex = 0;
	char	*tmpNm;
	/* Whether lhs is an array/hash/struct index (deep dive). */
	int	deep_dive = isdeepdive(expr->a);

	push_str("::regsub");
	modCount = push_regexpModifiers(expr->b);
	push_str("-line");
	push_str("--");
	compile_expr(expr->b, PUSH);
	// ::regsub <mods> -line -- <re>
	compile_expr(expr->c, PUSH);
	// ::regsub <mods> -line -- <re> <subst>
	if (deep_dive) {
		tmpIndex = mk_singleTemp(&tmpNm);
		compile_deepDive(expr->a, L_DEEP_VAL_PTR);
		// ::regsub <mods> -line -- <re> <subst> <lhs-val> <lhs-ptr>
		TclEmitInstInt1(INST_ROT, -(6+modCount), L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str(tmpNm);
		// <lhs-ptr> ::regsub <mods> -line -- <re> <lhs-val> <subst> <tmp-name>
	} else {
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "invalid l-value in =~");
			return;
		}
		compile_expr(expr->a, PUSH);
		// ::regsub <mods> -line -- <re> <subst> <lhs-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst>
		push_str(expr->a->u.string);
		// ::regsub <mods> -line -- <re> <lhs-val> <subst> <lhs-name>
	}
	unless (expr->a->sym) return;  // bail if lhs not declared
	emit_invoke(modCount + 7);
	if (deep_dive) {
		// <lhs-ptr> <match>
		emit_load_scalar(tmpIndex);
		// <lhs-ptr> <match> <new-val>
		TclEmitInstInt1(INST_ROT, 2, L->frame->envPtr);
		// <match> <new-val> <lhs-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				expr->a->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(L_DEEP_NEW, L->frame->envPtr);
		// <match> <new-val>
		emit_pop();
	}
	L_typeck_expect(L_STRING, expr->a, "in =~");
	// <match>
}

private void
compile_shortCircuit(Expr *expr)
{
	Jmp	*jmp;
	unsigned char op;

	/*
	 * In case the operator "a op b" short-circuits, we need one
	 * value of "a" on the stack for the test and one for the value of
	 * the expression.  If the operator doesn't short-circuit, we
	 * pop one of these off and move on to evaluating "b".
	 */
	ASSERT((expr->op == L_OP_ANDAND) || (expr->op == L_OP_OROR));
	op = (expr->op == L_OP_ANDAND) ? INST_JUMP_FALSE4 : INST_JUMP_TRUE4;
	compile_condition(expr->a);
	// <a-val>
	TclEmitOpcode(INST_DUP, L->frame->envPtr);
	// <a-val> <a-val>
	jmp = emit_jmp(op);
	// <a-val>   if short-circuit and we jumped out
	// <a-val>   if did not short-circuit and we're still going
	emit_pop();
	compile_condition(expr->b);
	fixup_jmps(jmp);
	// <a-val>   if short-circuit
	// <b-val>   if did not short-circuit
}

/*
 * Compile an expression that is used as a conditional test.
 * This is compiled like a normal expression except that if it's
 * of string type its value is compared against the string "0".
 */
private void
compile_condition(Expr *cond)
{
	compile_expr(cond, PUSH);
	if (isvoid(cond)) {
		L_errf(cond, "void type illegal in predicate");
	} else if (isstring(cond) || iswidget(cond)) {
		push_str("0");
		TclEmitOpcode(INST_NEQ, L->frame->envPtr);
	} else unless (isscalar(cond)) {
		L_errf(cond, "predicate must be scalar");
	}
	cond->type = L_int;
}

/*
 * Compile if-unless as follows.
 *
 * No "else" leg:          "Else" leg present:
 *    <eval cond>              <eval cond>
 *    jmpFalse 1               jmpFalse 1
 *    <if leg>                 <if leg>
 * 1:                          jmp 2
 *                          1: <else leg>
 *                          2:
 */
private void
compile_ifUnless(Cond *cond)
{
	Jmp	*endjmp, *falsejmp;

	/* Test the condition and jmp if false. */
	compile_condition(cond->cond);
	falsejmp = emit_jmp(INST_JUMP_FALSE4);

	/* Compile the "if" leg. */
	frame_push(L->frame->interp, L->frame->envPtr, cond);
	compile_stmts(cond->if_body);

	if (cond->else_body) {
		/* "Else" leg present. */
		frame_pop();
		frame_push(L->frame->interp, L->frame->envPtr, cond);
		endjmp = emit_jmp(INST_JUMP4);
		fixup_jmps(falsejmp);
		compile_stmts(cond->else_body);
		fixup_jmps(endjmp);
	} else {
		/* No "else" leg. */
		fixup_jmps(falsejmp);
	}
	frame_pop();
}

/*
 * Compile for, do, and while loops.
 *
 * For & while loop:    Do loop:
 *    <pre>
 *    jmp 1
 * 2: <body>            1: <body>
 *    <post>
 * 1: <cond>               <cond>
 *    jmpTrue 2            jmpTrue 1
 */
private void
compile_loop(Loop *loop)
{
	int	body_off, jmp_dist;
	Jmp	*break_jumps, *continue_jumps;
	Jmp	*condjmp = 0;

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->pre, DISCARD);
	unless (loop->kind == L_LOOP_DO) condjmp = emit_jmp(INST_JUMP4);

	/*
	 * Compile loop body.  Note that we must grab the jump fix-ups
	 * out of the frame before popping it.
	 */
	frame_push(L->frame->interp, L->frame->envPtr, loop);
	body_off = currOffset(L->frame->envPtr);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	if (loop->kind == L_LOOP_FOR) compile_exprs(loop->post, DISCARD);
	unless (loop->kind == L_LOOP_DO) fixup_jmps(condjmp);

	compile_condition(loop->cond);

	jmp_dist = currOffset(L->frame->envPtr) - body_off;
	if (jmp_dist > 127) {
		TclEmitInstInt4(INST_JUMP_TRUE4, -jmp_dist, L->frame->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP_TRUE1, -jmp_dist, L->frame->envPtr);
	}
	fixup_jmps(break_jumps);
}

/*
 * Emit a jump instruction with an unknown target offset and return a
 * structure that can be passed in to fixup_jmps() to later fix-up the
 * target to any desired bytecode offset.  Caller must free the
 * returned structure.
 */
private Jmp *
emit_jmp(int op)
{
	Jmp	*ret = (Jmp *)ckalloc(sizeof(Jmp));

	ret->op     = op;
	ret->offset = currOffset(L->frame->envPtr);
	ret->next   = NULL;
	switch (op) {
	    case INST_JUMP1:
	    case INST_JUMP_TRUE1:
	    case INST_JUMP_FALSE1:
		ret->size = 1;
		TclEmitInstInt1(op, 0, L->frame->envPtr);
		break;
	    case INST_JUMP4:
	    case INST_JUMP_TRUE4:
	    case INST_JUMP_FALSE4:
		ret->size = 4;
		TclEmitInstInt4(op, 0, L->frame->envPtr);
		break;
	    default:
		L_bomb("unexpected jump instruction");
		break;
	}
	return (ret);
}

/*
 * Fix up jump targets to point to the current PC, and free the
 * passed-in fix-ups list.
 */
private void
fixup_jmps(Jmp *j)
{
	int	target;
	Jmp	*t;
	unsigned char *jmp_pc;

	while (j) {
		target = currOffset(L->frame->envPtr) - j->offset;
		jmp_pc = L->frame->envPtr->codeStart + j->offset;
		switch (j->size) {
		    case 1:
			TclUpdateInstInt1AtPc(j->op, target, jmp_pc);
			break;
		    case 4:
			TclUpdateInstInt4AtPc(j->op, target, jmp_pc);
			break;
		    default:
			L_bomb("unexpected jump fixup");
			break;
		}
		t = j->next;
		ckfree((char *)j);
		j = t;
	}
}

private void
compile_foreach(ForEach *loop)
{
	compile_expr(loop->expr, PUSH);

	switch (loop->expr->type->kind) {
	    case L_ARRAY:
		compile_foreachArray(loop);
		break;
	    case L_HASH:
		compile_foreachHash(loop);
		break;
	    case L_STRING:
		L_errf(loop->expr, "Foreach over string not yet implemented");
		break;
	    case L_POLY:
		L_errf(loop->expr, "Foreach over poly not yet implemented");
		break;
	    default:
		L_errf(loop->expr, "Illegal foreach expression"
		       " (must be array or hash)");
		break;
	}
}

/*
 * Most of the following function came from tclCompCmds.c
 * TclCompileForEachCmd(), modified in various ways for L.
 */
private void
compile_foreachArray(ForEach *loop)
{
	int		i, continue_off, loopctr_idx, num_vars, val_idx;
	Expr		*var;
	ForeachInfo	*info;
	ForeachVarList	*varlist;
	unsigned char	*jumpPc;
	JumpFixup	jumpFalseFixup;
	Jmp		*break_jumps, *continue_jumps;
	int		jumpBackDist, jumpBackOffset, infoIndex;

	/*
	 * Type-check the value variables.  In "foreach (v1,v2,v3 in
	 * a)", v* are the value variables or variable list, and a is
	 * the value list, in tcl terminology.
	 */
	for (var = loop->key, num_vars = 0; var; var = var->next, ++num_vars) {
		unless (sym_lookup(var, NOUSED)) return;  // undeclared var
		unless (L_typeck_compat(var->type,
					loop->expr->type->base_type)) {
			L_errf(var, "loop index type incompatible with"
				    " array element type");
		}
	}

	/* Temps for value list value and loop counter. */
	val_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr->procPtr);
	loopctr_idx = TclFindCompiledLocal(NULL, 0, 1,
					   L->frame->envPtr->procPtr);

	/*
	 * ForeachInfo and ForeachVarList are structures required by
	 * the bytecode interpreter for foreach bytecodes.  In our
	 * case, we have only one value and one variable list
	 * consisting of num_vars variables.
	 */
	info = (ForeachInfo *)ckalloc(sizeof(ForeachInfo) +
	    sizeof(ForeachVarList *));
	info->numLists       = 1;
	info->firstValueTemp = val_idx;
	info->loopCtTemp     = loopctr_idx;
	varlist = (ForeachVarList *)ckalloc(sizeof(ForeachVarList) +
	    num_vars * sizeof(int));
	varlist->numVars = num_vars;
	for (i = 0, var = loop->key; var; var = var->next, ++i) {
		Sym *s = sym_lookup(var, 0);
		varlist->varIndexes[i] = s->idx;
	}
	info->varLists[0] = varlist;
	infoIndex = TclCreateAuxData(info, &tclForeachInfoType,
				     L->frame->envPtr);

	/* The values to iterate through are already on the stack (the
	 * caller evaluated loop->expr).  Assign to the value temp. */
	emit_store_scalar(val_idx);
	emit_pop();

	/* Initialize the loop state. */
	TclEmitInstInt4(INST_FOREACH_START4, infoIndex, L->frame->envPtr);

	/* Top of the loop.  Step, and jump out if done. */
	continue_off = currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_FOREACH_STEP4, infoIndex, L->frame->envPtr);
	TclEmitForwardJump(L->frame->envPtr, TCL_FALSE_JUMP, &jumpFalseFixup);

	/* Loop body. */
	frame_push(L->frame->interp, L->frame->envPtr, loop);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* End of loop -- jump back to top. */
	jumpBackOffset = currOffset(L->frame->envPtr);
	jumpBackDist   = jumpBackOffset - continue_off;
	if (jumpBackDist > 120) {
		TclEmitInstInt4(INST_JUMP4, -jumpBackDist, L->frame->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP1, -jumpBackDist, L->frame->envPtr);
	}

	/* Fixup jumps. */
	if (TclFixupForwardJumpToHere(L->frame->envPtr, &jumpFalseFixup, 127)) {
		/* Update the jump back to the loop top since it also
		   moved down. */
		jumpBackOffset += 3;
		jumpPc = (L->frame->envPtr->codeStart + jumpBackOffset);
		jumpBackDist += 3;
		if (jumpBackDist > 120) {
			TclUpdateInstInt4AtPc(INST_JUMP4, -jumpBackDist,jumpPc);
		} else {
			TclUpdateInstInt1AtPc(INST_JUMP1, -jumpBackDist,jumpPc);
		}
	}
	fixup_jmps(break_jumps);
}

private void
compile_foreachHash(ForEach *loop)
{
	Sym	*key;
	Sym	*val = NULL;
	int	body_off, disp, it_idx;
	Jmp	*break_jumps, *continue_jumps, *out_jmp;

	/* Check types and ensure variables are declared etc. */
	unless ((key = sym_lookup(loop->key, NOUSED))) return;
	if (loop->value) {
		unless ((val = sym_lookup(loop->value, NOUSED))) return;
		unless (L_typeck_compat(val->type,
					loop->expr->type->base_type)) {
			L_errf(loop->value, "loop index value type "
			       "incompatible with hash element type");
		}
	}
	unless (L_typeck_compat(key->type, loop->expr->type->u.hash.idx_type)) {
		L_errf(loop->key,
		       "loop index key type incompatible with hash index type");
	}
	if (loop->key->next) {
		L_errf(loop, "multiple variables illegal in foreach over hash");
	}

	/* A temp to hold the iterator state.*/
	it_idx = TclFindCompiledLocal(NULL, 0, 1, L->frame->envPtr->procPtr);

	/*
	 * Both DICT_FIRST and DICT_NEXT leave value, key, and done-p
	 * on the stack.  Check done-p and jump out of the loop if
	 * it's true. (We fixup the jump target once we know the size
	 * of the loop body.)
	 */
	TclEmitInstInt4(INST_DICT_FIRST, it_idx, L->frame->envPtr);
	out_jmp = emit_jmp(INST_JUMP_TRUE4);

	/*
	 * Update the key and value variables. We save the offset of
	 * this code so we can jump back to it after DICT_NEXT.
	 * Note: the caller already pushed loop->expr.
	 */
	body_off = currOffset(L->frame->envPtr);
	emit_store_scalar(key->idx);
	emit_pop();
	if (loop->value) emit_store_scalar(val->idx);
	emit_pop();

	/*
	 * Compile loop body.  Note that we must grab the jump fix-ups
	 * out of the frame before popping it.
	 */
	frame_push(L->frame->interp, L->frame->envPtr, loop);
	compile_stmts(loop->body);
	break_jumps    = L->frame->break_jumps;
	continue_jumps = L->frame->continue_jumps;
	frame_pop();
	fixup_jmps(continue_jumps);

	/* If there's another entry in the hash, go around again. */
	TclEmitInstInt4(INST_DICT_NEXT, it_idx, L->frame->envPtr);
	disp = body_off - currOffset(L->frame->envPtr);
	TclEmitInstInt4(INST_JUMP_FALSE4, disp, L->frame->envPtr);

	/* End of the loop.  Point the jump after the DICT_FIRST to here. */
	fixup_jmps(out_jmp);

	/* All done.  Cleanup the values that DICT_FIRST/DICT_NEXT left. */
	emit_pop();
	emit_pop();
	fixup_jmps(break_jumps);
	/* XXX We need to ensure that DICT_DONE happens in the face of
	   exceptions, so that the refcount on the dict will be
	   decremented, and the iterator freed.  See the
	   implementation of "dict for" in tclCompCmds.c.  --timjr
	   2006.11.3 */
	TclEmitInstInt4(INST_DICT_DONE, it_idx, L->frame->envPtr);
}

private VarDecl *
struct_lookupMember(Type *t, Expr *idx, int *offset)
{
	VarDecl *m;

	ASSERT(idx->op == L_OP_STRUCT_INDEX);

	unless (t->u.struc.members) {
		L_errf(idx, "incomplete struct type %s", t->u.struc.tag);
		return (NULL);
	}
	for (*offset = 0, m = t->u.struc.members; m; m = m->next, ++*offset) {
		if (!strcmp(idx->u.string, m->id->u.string)) {
			return (m);
		}
	}
	return (NULL);
}

/*
 * Generate code to push a deep-dive index onto the stack.  Return the
 * base type (this becomes the type of the expr node).
 */
private Type *
push_index(Expr *expr)
{
	VarDecl *member;
	int	offset;
	char	buf[16];

	switch (expr->op) {
	    case L_OP_STRUCT_INDEX:
		unless (isstruct(expr->a)) {
			L_errf(expr, "not a struct");
			return (L_poly);
		}
		member = struct_lookupMember(expr->a->type,
					     expr,
					     &offset);
		unless (member) {
			L_errf(expr, "struct field %s not found",
			       expr->u.string);
			return (L_poly);
		}
		snprintf(buf, sizeof(buf), "%i", offset);
		push_str(buf);
		return (member->type);
	    case L_OP_ARRAY_INDEX:
		unless (isarray(expr->a)) {
			L_errf(expr, "not an array");
			return (L_poly);
		}
		compile_expr(expr->b, PUSH);
		L_typeck_expect(L_INT, expr->b, "in array index");
		return (expr->a->type->base_type);
	    case L_OP_HASH_INDEX: {
		unless (ishash(expr->a)) {
			L_errf(expr, "not a hash");
			return (L_poly);
		}
		compile_expr(expr->b, PUSH);
		L_typeck_expect(expr->a->type->u.hash.idx_type->kind,
				expr->b,
				"in hash index");
		return (expr->a->type->base_type);
	    }
	    default:
		L_bomb("Invalid index op, %d", expr->op);
		return (NULL);
	}
}

/*
 * Increment the last element in the Tcl list "o".
 */
private void
L_IncrListTail(Tcl_Obj *o)
{
	int	oc, rc;
	Tcl_Obj	**ov;

	if (Tcl_ListObjGetElements(L->frame->interp, o, &oc, &ov) == TCL_OK) {
		if (oc) {
			rc = TclIncrObj(L->frame->interp, ov[oc-1],
					Tcl_NewIntObj(1));
			ASSERT(rc == TCL_OK);
		}
	}
}

/*
 * Push everything needed for an INST_L_DEEP_READ bytecode.  Namely,
 * the object being indexed followed by all the indices.
 *
 * Return value is L_DEEP_HASH_FIRST if the first index is for a hash, else 0.
 *
 * *num_idx gets the number of indices.
 *
 * *counts gets a Tcl_Obj with a list of the level counts (see the
 * deep-dive implementation in tclExecute.c for details).
 */
private int
push_deepDiveIdxs(Expr *expr, int *num_idx, Tcl_Obj **counts)
{
	int		flags;
	static int	ishash = 0;

	/* The recursion bottoms when we reach the thing being indexed. */
	unless (isdeepdive(expr)) {
		compile_expr(expr, PUSH);
		*num_idx = 0;
		*counts  = Tcl_NewObj();
		Tcl_IncrRefCount(*counts);
		return (0);
	}

	flags = push_deepDiveIdxs(expr->a, num_idx, counts);

	expr->type = push_index(expr);
	expr->sym  = expr->a->sym;  // propagate sym table ptr up the tree

	/*
	 * First time through, or when we reach another "level" which is
	 * a switch from a hash index last time to an array/struct index
	 * this time or vice-versa, append a 0 to the counts list.
	 */
	if (((expr->op == L_OP_HASH_INDEX) != ishash) || !*num_idx) {
		Tcl_ListObjAppendElement(NULL, *counts, Tcl_NewIntObj(0));
		ishash = (expr->op == L_OP_HASH_INDEX);
		/* Set flags first time through. */
		unless (*num_idx) flags = (ishash? L_DEEP_HASH_FIRST: 0);
	}

	++*num_idx;
	L_IncrListTail(*counts);  // inc last element of counts list

	return (flags);
}

/*
 * Compile a hash/array/struct reference, also known as a "deep dive".
 * These are the L_OP_HASH_INDEX, L_OP_ARRAY_INDEX, and L_OP_STRUCT_INDEX
 * nodes.
 *
 * The resulting stack depends on the flags which specify whether the
 * indexed element's value, pointer, or both (and in what order) are
 * wanted.  We get one of
 *
 * <elem-obj>                  if flags & L_DEEP_VAL
 * <elem-obj-ptr>              if flags & L_DEEP_PTR
 * <elem-obj> <elem-obj-ptr>   if flags & L_DEEP_VAL_PTR
 * <elem-obj-ptr> <elem-obj>   if flags & L_DEEP_PTR_VAL
 */
private void
compile_deepDive(Expr *expr, Deep_f flags)
{
	int	num_idx;
	Tcl_Obj	*counts;

	flags |= push_deepDiveIdxs(expr, &num_idx, &counts);
	unless ((flags & L_DEEP_VAL) || expr->sym) {
		L_errf(expr, "target of assignment is not an l-value");
	}

	// <obj> <idx1> ... <idxn>
	push_str(Tcl_GetString(counts));
	// <obj> <idx1> ... <idxn> <counts>
	Tcl_DecrRefCount(counts);
	TclEmitInstInt1(INST_L_DEEP_READ, num_idx+2, L->frame->envPtr);
	TclEmitInt1(flags, L->frame->envPtr);
	// Final stack config: see comment above.  Adjust the stack
	// depth that Tcl tracks if necessary, to reflect when two
	// objs are left on the stack instead of one.
	unless (flags & L_DEEP_VAL) TclAdjustStackDepth(1, L->frame->envPtr);
}

private void
compile_assignment(Expr *expr)
{
	/* Whether it's an arithmetic assignment (lhs op= rhs). */
	int	arith = (expr->op != L_OP_EQUALS);
	/* Whether lhs is an array/hash/struct index (deep dive). */
	int	deep_dive = isdeepdive(expr->a);

	compile_expr(expr->b, PUSH);
	// <rval>
	if (deep_dive) {
		compile_deepDive(expr->a, arith?L_DEEP_VAL_PTR:L_DEEP_PTR);
		// <rval> <lhs-deep-ptr>                  if !arith
		// <rval> <lhs-deep-val> <lhs-deep-ptr>   if arith
	} else {
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "invalid l-value in assignment");
		}
		sym_lookup(expr->a, 0);
	}
	unless (expr->a->sym) return;  // bail if lhs not declared

	L_typeck_assign(expr->a, expr->b);

	if (deep_dive) {
		if (arith) {
			// <rval> <lhs-deep-val> <lhs-deep-ptr>
			TclEmitInstInt4(INST_REVERSE, 3, L->frame->envPtr);
			// <lhs-deep-ptr> <lhs-deep-val> <rval>
			emit_instrForLOp(expr);
			// <lhs-deep-ptr> <new-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		}
		// <rval> <lhs-deep-ptr>   or   <new-val> <lhs-deep-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				expr->a->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(L_DEEP_NEW, L->frame->envPtr);
	} else {
		if (arith) {
			emit_load_scalar(expr->a->sym->idx);
			// <rval> <old-val>
			TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
			// <old-val> <rval>
			emit_instrForLOp(expr);
			// <new-val>
		}
		// <rval>   or   <new-val>
		emit_store_scalar(expr->a->sym->idx);
	}
	// <rval>
}

private void
compile_incdec(Expr *expr)
{
	/* Whether expr is a postfix operator. */
	int	post = ((expr->op == L_OP_PLUSPLUS_POST) ||
			(expr->op == L_OP_MINUSMINUS_POST));
	/* Whether expr is a ++ operator. */
	int	inc = ((expr->op == L_OP_PLUSPLUS_PRE) ||
		       (expr->op == L_OP_PLUSPLUS_POST));
	/* Whether lhs is an array/hash/struct index (deep dive). */
	int	deep_dive = isdeepdive(expr->a);

	if (deep_dive) {
		compile_deepDive(expr->a, L_DEEP_PTR_VAL);
		// <deep-ptr> <deep-val>
	} else {
		unless (expr->a->kind == L_EXPR_ID) {
			L_errf(expr, "invalid l-value in inc/dec");
		}
		sym_lookup(expr->a, 0);
	}
	unless (expr->a->sym) return;  // bail if operand undeclared

	L_typeck_expect(L_INT|L_FLOAT, expr->a, "in ++/--");

	if (deep_dive) {
		// <deep-ptr> <deep-val>
		push_str("1");
		// <deep-ptr> <deep-val> 1
		TclEmitOpcode(inc?INST_ADD:INST_SUB, L->frame->envPtr);
		// <deep-ptr> <new-val>
		TclEmitInstInt1(INST_ROT, 1, L->frame->envPtr);
		// <new-val> <deep-ptr>
		TclEmitInstInt4(INST_L_DEEP_WRITE,
				expr->a->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(post?L_DEEP_OLD:L_DEEP_NEW, L->frame->envPtr);
	} else {
		if (post) compile_expr(expr->a, PUSH);
		// <old-val>   if post
		TclEmitInstInt1(INST_INCR_SCALAR1_IMM, expr->a->sym->idx,
				L->frame->envPtr);
		TclEmitInt1(inc? 1 : -1, L->frame->envPtr);
		// <old-val> <new-val>   if post
		// <new-val>             if !post
		if (post) emit_pop();
	}
	// <old-val>   if post
	// <new-val>   if !post
}

private int
push_regexpModifiers(Expr *regexp)
{
	int	n = 0;

	if (regexp->flags & L_EXPR_RE_I) {
		push_str("-nocase");
		n++;
	}
	if (regexp->flags & L_EXPR_RE_G) {
		push_str("-all");
		n++;
	}
	return (n);
}

private void
emit_instrForLOp(Expr *expr)
{
	int	op = 0;

	switch (expr->op) {
	    case L_OP_STR_EQ:
	    case L_OP_EQUALEQUAL:
		op = INST_EQ;
		break;
	    case L_OP_STR_NE:
	    case L_OP_NOTEQUAL:
		op = INST_NEQ;
		break;
	    case L_OP_STR_GT:
	    case L_OP_GREATER:
		op = INST_GT;
		break;
	    case L_OP_STR_GE:
	    case L_OP_GREATEREQ:
		op = INST_GE;
		break;
	    case L_OP_STR_LT:
	    case L_OP_LESSTHAN:
		op = INST_LT;
		break;
	    case L_OP_STR_LE:
	    case L_OP_LESSTHANEQ:
		op = INST_LE;
		break;
	    case L_OP_PLUS:
	    case L_OP_EQPLUS:
		op = INST_ADD;
		break;
	    case L_OP_MINUS:
	    case L_OP_EQMINUS:
		op = INST_SUB;
		break;
	    case L_OP_STAR:
	    case L_OP_EQSTAR:
		op = INST_MULT;
		break;
	    case L_OP_SLASH:
	    case L_OP_EQSLASH:
		op = INST_DIV;
		break;
	    case L_OP_PERC:
	    case L_OP_EQPERC:
		op = INST_MOD;
		break;
	    case L_OP_BITAND:
	    case L_OP_EQBITAND:
		op = INST_BITAND;
		break;
	    case L_OP_BITOR:
	    case L_OP_EQBITOR:
		op = INST_BITOR;
		break;
	    case L_OP_BITXOR:
	    case L_OP_EQBITXOR:
		op = INST_BITXOR;
		break;
	    case L_OP_LSHIFT:
	    case L_OP_EQLSHIFT:
		op = INST_LSHIFT;
		break;
	    case L_OP_RSHIFT:
	    case L_OP_EQRSHIFT:
		op = INST_RSHIFT;
		break;
	    case L_OP_UMINUS:
		op = INST_UMINUS;
		break;
	    case L_OP_UPLUS:
		op = INST_UPLUS;
		break;
	    case L_OP_BANG:
		op = INST_LNOT;
		break;
	    case L_OP_BITNOT:
		op = INST_BITNOT;
		break;
	    default:
		L_bomb("Unable to map operator %d to an instruction", expr->op);
		break;
	}
	TclEmitOpcode(op, L->frame->envPtr);
}

private void
compile_continue(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_enclosingLoop();

	unless (loop_frame) {
		L_errf(stmt, "continue allowed only inside loops");
		return;
	}
	j = emit_jmp(INST_JUMP4);
	j->next = loop_frame->continue_jumps;
	loop_frame->continue_jumps = j;
}

private void
compile_break(Stmt *stmt)
{
	Jmp	*j;
	Frame	*loop_frame = frame_enclosingLoop();

	unless (loop_frame) {
		L_errf(stmt, "break allowed only inside loops");
		return;
	}
	j = emit_jmp(INST_JUMP4);
	j->next = loop_frame->break_jumps;
	loop_frame->break_jumps = j;
}

/*
 * Walk up the semantic stack and return the first frame that
 * corresponds to a loop.
 */
private Frame *
frame_enclosingLoop()
{
	Frame *f;

	for (f = L->frame; f; f = f->prevFrame) {
		Ast *node = (Ast *)f->block;
		if (node && ((node->type == L_NODE_LOOP) ||
			     (node->type == L_NODE_FOREACH_LOOP))) {
			break;
		}
	}
	return (f);
}

private Frame *
frame_outer(Frame *frame)
{
	ASSERT(frame);
	while (frame->prevFrame) frame = frame->prevFrame;
	ASSERT(frame->outer_p);
	return (frame);
}

private void
emit_globalUpvar(Sym *sym, Expr *id)
{
	/* Tim comment:
	   XXX: This might be bogus.  We attempt to detect
	   whether L global variables should be true globals,
	   or should be shared with the calling proc, by
	   checking if the current variable frame pointer in
	   interp is the same as the global frame pointer.
	   (Sharing variables with the calling proc is useful
	   if you want to use L as an expr replacement). */

	if (((Interp *)L->frame->interp)->rootFramePtr ==
	    ((Interp *)L->frame->interp)->varFramePtr) {
		push_str("::");
		push_str(id->u.string);
		TclEmitInstInt4(INST_NSUPVAR, sym->idx, L->frame->envPtr);
	} else {
		push_str("1");
		push_str(id->u.string);
		TclEmitInstInt4(INST_UPVAR, sym->idx, L->frame->envPtr);
	}
	emit_pop();
}

/*
 * Add a variable or function name to the current scope's symbol
 * table.  If it's a local variable, allocate a slot for it in the
 * current proc.
 *
 * Print an error if the symbol is already defined.  The rules are
 *
 * - Multiply defined globals are illegal, with the exception that
 *   main() can be re-defined.
 * - A local cannot shadow any other local in the proc.
 * - A local can shadow a global.
 * - A local can shadow a global upvar shadow (which is a local
 *   with special status).
 */
private Sym *
sym_store(VarDecl *decl)
{
	int	new;
	char	*name = decl->id->u.string;
	Sym	*sym;
	Frame	*frame;
	Tcl_HashEntry *hPtr;

	if (decl->outer_p) {
		/* Declaring a global -- search outer-most frame. */
		frame = frame_outer(L->frame);
		hPtr = Tcl_FindHashEntry(frame->symtab, name);
		/*
		 * Special case for main: don't allow redeclaration within
		 * the same script, determined by whether the current AST
		 * root is the same one as when main was last declared.
		 */
		if (!strcmp(name, "main")) {
			if (hPtr && (L->mains_ast == L->ast)) {
				L_errf(decl->id, "redeclaration of main");
				return (NULL);
			}
			if (hPtr) Tcl_DeleteHashEntry(hPtr);
			L->mains_ast = L->ast;
		} else if (hPtr) {
			L_errf(decl, "multiple declaration of global %s", name);
			return (NULL);
		}
	} else {
		/* Declaring a local -- search current proc's local scopes. */
		for (frame = L->frame; frame; frame = frame->prevFrame) {
			unless (frame->envPtr == L->frame->envPtr) break;
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) {
				sym = (Sym *)Tcl_GetHashValue(hPtr);
				ASSERT(sym->kind & L_SYM_LVAR);
				unless (sym->kind & L_SYM_LSHADOW) {
					L_errf(decl, "multiple declaration "
					       "of local %s", name);
					return (NULL);
				}
			}
		}
	}

	/*
	 * The decl says whether this sym goes in the outer-most scope
	 * so it persists across L files, or in the local scope.
	 */
	if (decl->outer_p) {
		frame = frame_outer(L->frame);
	} else {
		frame = L->frame;
	}
	hPtr = Tcl_CreateHashEntry(frame->symtab, name, &new);
	ASSERT(new || ((sym->kind & L_SYM_LSHADOW) && !decl->outer_p));

	sym = (Sym *)ckalloc(sizeof(Sym));
	memset(sym, 0, sizeof(*sym));
	sym->name    = ckstrdup(name);
	sym->type    = decl->type;
	sym->decl    = decl;

	/*
	 * The decl also says whether variables are local or global.
	 * Vars in the outer-most scope (which includes all externs),
	 * are globals.  Mangle the tcl name for a global "g" to "_g"
	 * so that we can always create a local upvar shadow for it.
	 * Locals and function names are not allowed to begin with "_".
	 */
	if (isfntype(decl->type)) {
		sym->kind    = L_SYM_FN;
		sym->tclname = ckstrdup(name);
	} else if (decl->outer_p) {
		sym->kind    = L_SYM_GVAR;
		sym->tclname = ckalloc(strlen(name)+2);
		sprintf(sym->tclname, "_%s", name);
	} else {
		sym->kind    = L_SYM_LVAR;
		sym->tclname = ckstrdup(name);
	}

	/* If a local, allocate a slot for it. */
	if (sym->kind & L_SYM_LVAR) {
		sym->idx = TclFindCompiledLocal(name, strlen(name),
						1, L->frame->envPtr->procPtr);
	} else {
		sym->idx = -1;
	}

	decl->id->sym  = sym;
	decl->id->type = decl->type;
	Tcl_SetHashValue(hPtr, sym);

	return (sym);
}

/*
 * Lookup id in the symbol table.
 *
 * flags & NOUSED ==> don't mark the id as having been referenced
 * (used for warning which variables are unused).
 *
 * flags & NOWARN ==> don't print error message if id not found.
 *
 * The first time a global is referenced within a scope, an upvar is
 * created for it.
 */
private Sym *
sym_lookup(Expr *id, enum lookup flags)
{
	int	new;
	char	*name;
	Sym	*shw;
	Sym	*sym = NULL;
	Frame	*frame;
	Tcl_HashEntry *hPtr = NULL;

	unless (id->kind == L_EXPR_ID) return (NULL);
	name = id->u.string;

	for (frame = L->frame; frame; frame = frame->prevFrame) {
		if ((frame->envPtr == L->frame->envPtr) || frame->outer_p) {
			hPtr = Tcl_FindHashEntry(frame->symtab, name);
			if (hPtr) break;
		}
	}
	if (hPtr) sym = (Sym *)Tcl_GetHashValue(hPtr);
	if (sym) {
		/*
		 * If a global is being referenced for the first time
		 * in this scope, create a local upvar to shadow it.
		 */
		if ((sym->kind & L_SYM_GVAR) && (sym->idx == -1)) {
			ASSERT(frame == frame_outer(L->frame));
			hPtr = Tcl_CreateHashEntry(L->frame->symtab, name,
						   &new);
			ASSERT(new);
			shw = (Sym *)ckalloc(sizeof(Sym));
			memset(shw, 0, sizeof(*shw));
			shw->kind    = L_SYM_LVAR | L_SYM_LSHADOW;
			shw->name    = ckstrdup(name);
			shw->tclname = ckstrdup(sym->tclname);
			shw->type    = sym->decl->type;
			shw->decl    = sym->decl;
			shw->used_p  = TRUE;
			shw->idx     = TclFindCompiledLocal(shw->tclname,
						strlen(shw->tclname),
						1,
						L->frame->envPtr->procPtr);
			emit_globalUpvar(shw, id);
			Tcl_SetHashValue(hPtr, shw);
			sym = shw;
		}
		unless (flags & NOUSED) sym->used_p = TRUE;
		id->sym  = sym;
		id->type = sym->type;
		return (sym);
	} else {
		unless (flags & NOWARN) {
			L_errf(id, "undeclared variable: %s", name);
		}
		ASSERT(id->sym == NULL);
		id->type = L_poly;  // to minimize cascading errors
		return (NULL);
	}
}

/* Make a new unique name. */
private char *
mk_uniqSym(char *name)
{
	static int ctr = 0;

	char *s = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);
	sprintf(s, "%d%s", ctr++, name);
	return (s);
}

private void
frame_push(Tcl_Interp *interp, CompileEnv *envPtr, void *block)
{
	Frame *new_frame = (Frame *)ckalloc(sizeof(Frame));
	memset(new_frame, 0, sizeof(*new_frame));

	new_frame->interp = interp;
	new_frame->envPtr = envPtr;
	new_frame->block  = block;
	new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
	new_frame->prevFrame = L->frame;
	/* Inherit options from the previous frame. */
	if (L->frame) new_frame->options = L->frame->options;
	L->frame = new_frame;
}

private void
frame_pop(void)
{
	Frame	*prev = L->frame->prevFrame;
	Sym	*sym;
	Tcl_HashEntry *hPtr;
	Tcl_HashSearch hSearch;

	/*
	 * Check for unused local symbols, and free the frame's symbol
	 * table and the frame itself.
	 */
	for (hPtr = Tcl_FirstHashEntry(L->frame->symtab, &hSearch);
	     hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		sym = (Sym *)Tcl_GetHashValue(hPtr);
		unless (sym->used_p || !(sym->kind & L_SYM_LVAR)) {
			L_warnf(sym->decl, "%s unused", sym->name);
		}
		ckfree(sym->name);
		ckfree(sym->tclname);
		ckfree((char *)sym);
	}
	Tcl_DeleteHashTable(L->frame->symtab);
	ckfree((char *)L->frame->symtab);
	ckfree((char *)L->frame);

	L->frame = prev;
}

void
L_bomb(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	fprintf(stderr, "L Internal Error: ");
	vfprintf(stderr, format, ap);
	va_end(ap);
	fprintf(stderr, "\n");
	exit(1);
}

/* This is scheduled for a major make-over. */
void
L_trace(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	if (getenv("LTRACE")) {
		fprintf(stderr, "***: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
	}
	va_end(ap);
	fflush(stderr);
}

void
L_warn(char *s)
{
	unless (L->frame && (L->frame->options & L_OPT_NOWARN)) {
		fprintf(stderr, "L Warning: %s\n", s);
	}
}

void
L_warnf(void *node, const char *format, ...)
{
	va_list	ap;

	unless (L->frame && (L->frame->options & L_OPT_NOWARN)) {
		va_start(ap, format);
		if (node) {
			fprintf(stderr, "%s:%d: ",
				((Ast *)node)->file, ((Ast *)node)->line);
		}
		fprintf(stderr, "L Warning: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
		va_end(ap);
	}
}

#define ERRBUF_SZ	1024

/* L_err is yyerror and is called by the parser for syntax errs. */
void
L_err(const char *format, ...)
{
	va_list ap;
	char	*buf;

	va_start(ap, format);
	buf = ckalloc(ERRBUF_SZ);
	vsnprintf(buf, ERRBUF_SZ, format, ap);
	va_end(ap);

	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	Tcl_AppendPrintfToObj(L->errs, "%s:%d: L Error: %s\n",
			      L->file, L->line, buf);
	ckfree(buf);
}

void
L_errf(void *node, const char *format, ...)
{
	va_list ap;
	char	*buf;

	va_start(ap, format);
	buf = ckalloc(ERRBUF_SZ);
	vsnprintf(buf, ERRBUF_SZ, format, ap);
	va_end(ap);
	unless (L->errs) {
		L->errs = Tcl_NewObj();
	}
	if (node) {
		Tcl_AppendPrintfToObj(L->errs, "%s:%d: ",
				      ((Ast *)node)->file, ((Ast *)node)->line);
	}
	Tcl_AppendPrintfToObj(L->errs, "L Error: %s\n", buf);
	ckfree(buf);
}

private void
ast_free(Ast *ast_list)
{
	while (ast_list) {
		Ast	*node = ast_list;
		ast_list = ast_list->next;
		if (node->type == L_NODE_EXPR) {
			switch (((Expr *)node)->kind) {
			    case L_EXPR_CONST:
				if (((Expr *)node)->type == L_string) {
					ckfree(((Expr *)node)->u.string);
				}
				break;
			    case L_EXPR_BINOP:
				if (((Expr *)node)->op == L_OP_STRUCT_INDEX) {
					ckfree(((Expr *)node)->u.string);
				}
				break;
			    case L_EXPR_ID:
			    case L_EXPR_RE:
				ckfree(((Expr *)node)->u.string);
				break;
			    default:
				break;
			}
		}
		ckfree((char *)node);
	}
}

private void
type_free(Type *type_list)
{
	while (type_list) {
		Type	*type = type_list;
		type_list = type_list->list;
		if (type->kind == L_STRUCT) ckfree(type->u.struc.tag);
		ckfree((char *)type);
	}
}

/* This is basically a whacked version of EnterCmdStartData in tclCompile.c. */
private void
track_cmd(int codeOffset, void *node)
{
	int	cmdIndex = L->frame->envPtr->numCommands++;
	Ast	*ast = (Ast *)node;
	int	len = ast->end - ast->beg;
	int	srcOffset = ast->beg;
	CmdLocation *cmdLocPtr;
	CompileEnv *envPtr = L->frame->envPtr;

	if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
		Tcl_Panic("track_cmd: bad command index %d", cmdIndex);
	}
	if (cmdIndex >= envPtr->cmdMapEnd) {
		/*
		 * Expand the command location array by allocating
		 * more storage from the heap. The currently allocated
		 * CmdLocation entries are stored from cmdMapPtr[0] up
		 * to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
		 */
		size_t currElems = envPtr->cmdMapEnd;
		size_t newElems  = 2*currElems;
		size_t currBytes = currElems * sizeof(CmdLocation);
		size_t newBytes  = newElems * sizeof(CmdLocation);
		CmdLocation *newPtr = (CmdLocation *)ckalloc((int)newBytes);

		/*
		 * Copy from old command location array to new, free
		 * old command location array if needed, and mark new
		 * array as malloced.
		 */
		memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
		if (envPtr->mallocedCmdMap) ckfree((char *)envPtr->cmdMapPtr);
		envPtr->cmdMapPtr      = (CmdLocation *)newPtr;
		envPtr->cmdMapEnd      = newElems;
		envPtr->mallocedCmdMap = 1;
	}

	cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
	cmdLocPtr->codeOffset   = codeOffset;
	cmdLocPtr->srcOffset    = srcOffset;
	cmdLocPtr->numSrcBytes  = len;
	cmdLocPtr->numCodeBytes = currOffset(envPtr) - codeOffset;

	/*
	 * The command locations have to be sorted in ascending order
	 * by codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(),
	 * if nothing else). However, when L compiles nested function
	 * calls, the outer one will get tracked second, even though
	 * it begins first.  So we walk the new CmdLocation entry back
	 * from the end until it lands where it belongs.
	 */
	while ((cmdIndex > 0) && (envPtr->cmdMapPtr[cmdIndex-1].codeOffset >
				  envPtr->cmdMapPtr[cmdIndex].codeOffset)) {
		CmdLocation cmdLoc = envPtr->cmdMapPtr[cmdIndex];
		envPtr->cmdMapPtr[cmdIndex]   = envPtr->cmdMapPtr[cmdIndex-1];
		envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
		cmdIndex--;
	}
}

char *
ckstrdup(const char *str)
{
	if (str) {
		return (ckstrndup(str, strlen(str)));
	} else {
		return (NULL);
	}
}

char *
ckstrndup(const char *str, int len)
{
	char	*newStr = ckalloc(len+1);

	strncpy(newStr, str, len);
	newStr[len] = '\0';
	return (newStr);
}

/*
 * Since we have C-like variable declarations in L, when hashes and
 * arrays are declared, the base type is parsed separately from the
 * array sizes or hash-element types.  The next two functions put them
 * back together.  E.g., in
 *
 *    string h{int};
 *
 * the main type passed in to these functions is a hash type
 * (w/index type of "int") but the hash type doesn't yet have its
 * base type set, which in this example is "string".
 *
 * For simple declarations (like "string s") where there is no
 * explicit array or hash, decl->type won't be set by the parser, so
 * the base type goes there.  For arrays/hashes, decl->type points to
 * the first level of array or hash, and the base type must go onto
 * the last nested hash or array type.
 */

void
L_set_baseType(Type *type, Type *base_type)
{
	while (type->base_type) {
		ASSERT((type->kind == L_ARRAY) ||
		       (type->kind == L_HASH) ||
		       (type->kind == L_NAMEOF));
		type = type->base_type;
	}
	type->base_type = base_type;
}

void
L_set_declBaseType(VarDecl *decl, Type *base_type)
{
	if (decl->type) {
		L_set_baseType(decl->type, base_type);
	} else {
		decl->type = base_type;
	}
}

/*
 * These are called before each Tcl interp is created (see
 * tclInterp.c) and after it is deleted.  Set up a top-level scope and
 * call frame in order to persist typedefs, struct types, and globals
 * across all the L programs compiled inside the interp.
 */
void
TclLInitCompiler(Tcl_Interp *interp)
{
//	putenv("MallocStackLogging=1");

	/* Associate the L global state with this interp. */
	L = (Lglobal *)ckalloc(sizeof(Lglobal));
	memset(L, 0, sizeof(Lglobal));
	Tcl_SetAssocData(interp, "L", TclLCleanupCompiler, L);

	L->interp = interp;
	frame_push(NULL, NULL, NULL);
	L->frame->outer_p = TRUE;
	L_scope_enter();
}

void
TclLCleanupCompiler(ClientData clientData, Tcl_Interp *interp)
{
	char	buf[32];

	L = (Lglobal *)clientData;
	L_scope_leave();
	frame_pop();
	ast_free(L->ast_list);
	type_free(L->type_list);
	if (L->include_table) {
		Tcl_DeleteHashTable(L->include_table);
		ckfree((char *)L->include_table);
	}
	ckfree(L->script);
	ckfree(L->file);
	ckfree((char *)L);
	L = NULL;

	snprintf(buf, sizeof(buf), "/usr/bin/leaks %u", getpid());
//	system(buf);
}

void
L_scope_enter()
{
	Scope	*new_scope = (Scope *)ckalloc(sizeof(*new_scope));

	new_scope->structs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->structs, TCL_STRING_KEYS);

	new_scope->typedefs = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_scope->typedefs, TCL_STRING_KEYS);

	new_scope->prev = L->curr_scope;
	L->curr_scope = new_scope;
}

void
L_scope_leave()
{
	Scope	*prev = L->curr_scope->prev;

	Tcl_DeleteHashTable(L->curr_scope->structs);
	ckfree((char *)L->curr_scope->structs);

	Tcl_DeleteHashTable(L->curr_scope->typedefs);
	ckfree((char *)L->curr_scope->typedefs);

	ckfree((char *)L->curr_scope);

	L->curr_scope = prev;
}

/*
 * Called by parser to look up a reference to "struct tag".  If
 * "local" is true, check only the current scope.  If the struct
 * hasn't yet been declared, add an incomplete type to the current
 * scope's struct table whose members will get filled up later when
 * the struct is fully declared.
 */
Type *
L_struct_lookup(char *tag, int local)
{
	int		new;
	Type		*type;
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->structs, tag);
		if (local) break;
	}
	if (hPtr) {
		type = (Type *)Tcl_GetHashValue(hPtr);
	} else {
		hPtr = Tcl_CreateHashEntry(L->curr_scope->structs, tag, &new);
		type = type_mkStruct(tag, NULL, PER_INTERP);
		Tcl_SetHashValue(hPtr, type);
	}
	return (type);
}

/*
 * Called by parser to declare a new struct type.  If the struct
 * already has been declared but without any members, fill them in
 * now and return the existing type pointer.  If tag is NULL, just
 * sanity check the members' types (checking for void etc).
 */
Type *
L_struct_store(char *tag, VarDecl *m)
{
	Type	*type = NULL;

	ASSERT(m);

	if (tag) {
		type = L_struct_lookup(tag, TRUE);
		if (type->u.struc.members) {
			L_errf(m, "multiple declaration of struct %s", tag);
		} else {
			type->u.struc.members = m;
		}
	}

	/* Check member types for legality. */
	for (; m; m = m->next) {
		L_typeck_declType(m);
	}

	return (type);
}

/*
 * Called by parser to look up an ID in the typedef table to see if
 * it's been previously declared as a type name.
 */
Type *
L_typedef_lookup(char *name)
{
	Tcl_HashEntry	*hPtr = NULL;
	Scope		*scope;

	for (scope = L->curr_scope; !hPtr && scope; scope = scope->prev) {
		hPtr = Tcl_FindHashEntry(scope->typedefs, name);
	}
	if (hPtr) {
		return ((Type *)Tcl_GetHashValue(hPtr));
	} else {
		return (NULL);
	}
}

/*
 * Called by parser to define a new type name.
 */
void
L_typedef_store(VarDecl *decl)
{
	int		new;
	Tcl_HashEntry	*hPtr;
	char		*name = decl->id->u.string;

	hPtr = Tcl_CreateHashEntry(L->curr_scope->typedefs, name, &new);
	if (new) {
		Tcl_SetHashValue(hPtr, decl->type);
	} else {
		Type *t = Tcl_GetHashValue(hPtr);
		unless (L_typeck_same(decl->type, t)) {
			L_errf(decl, "Cannot redefine type %s", name);
		}
	}
}

/*
 * This function is based on TclLindexFlat and is specialized for use
 * by the L deep-dive execution engine.  It returns a pointer to the
 * list element Tcl_Obj* referenced by the index, and returns NULL if
 * the index is out of range (TclLindexFlat returns a pointer to an
 * empty object).
 */
private Tcl_Obj **
L_LindexFlat(
    Tcl_Interp *interp,		/* Tcl interpreter. */
    Tcl_Obj *listPtr,		/* Tcl object representing the list. */
    int indexCount,		/* Count of indices. */
    Tcl_Obj *const indexArray[])/* Array of pointers to Tcl objects that
				 * represent the indices in the list. */
{
	int	i, index, listLen;
	Tcl_Obj	**elemPtrs;

	Tcl_IncrRefCount(listPtr);
	for (i=0 ; i<indexCount && listPtr ; i++) {
		if (TclGetIntFromObj(NULL, indexArray[i], &index) != TCL_OK) {
			Tcl_DecrRefCount(listPtr);
			return NULL;
		}
		TclListObjGetElements(NULL, listPtr, &listLen, &elemPtrs);
		if (index<0 || index>=listLen) {
			/* Index is out of range. */
			Tcl_DecrRefCount(listPtr);
			return NULL;
		} else {
			/* Extract the pointer to the appropriate element. */
			Tcl_DecrRefCount(listPtr);
			listPtr = elemPtrs[index];
			Tcl_IncrRefCount(listPtr);
		}
	}
	Tcl_DecrRefCount(listPtr);
	return (&elemPtrs[index]);
}

/*
 * This function is based on TclLsetFlat and is specialized for use by
 * the L deep-dive execution engine.  It returns a pointer to the list
 * element Tcl_Obj* referenced by the index, allowing it to be written
 * in place.  Unlike TclLsetFlat, it does not write to the element.
 * Also, any list in the dive that is shorter than the given index is
 * auto-extended up to the index value.
 */
private Tcl_Obj **
L_LsetFlatExtend(
    Tcl_Interp *interp,		/* Tcl interpreter. */
    Tcl_Obj *listPtr,		/* Pointer to the list being modified. */
    int indexCount,		/* Number of index args. */
    Tcl_Obj *const indexArray[])
				/* Index args. */
{
    int elemCount, i, index, result;
    int panic = 0;
    Tcl_Obj *parentList = NULL, *subListPtr, *chainPtr, **elemPtrs;

    /*
     * Error if there are no indices.
     */

    unless (indexCount) {
	L_bomb("L deep-dive internal error");
    }

    /*
     * If the list is shared, make a copy we can modify (copy-on-write).
     * We use Tcl_DuplicateObj() instead of TclListObjCopy() for a few
     * reasons: 1) we have not yet confirmed listPtr is actually a list;
     * 2) We make a verbatim copy of any existing string rep, and when
     * we combine that with the delayed invalidation of string reps of
     * modified Tcl_Obj's implemented below, the outcome is that any
     * error condition that causes this routine to return NULL, will
     * leave the string rep of listPtr and all elements to be unchanged.
     */

    subListPtr = Tcl_IsShared(listPtr) ? Tcl_DuplicateObj(listPtr) : listPtr;

    /*
     * Anchor the linked list of Tcl_Obj's whose string reps must be
     * invalidated if the operation succeeds.
     */

    chainPtr = NULL;

    /*
     * Loop through all the index arguments, and for each one dive
     * into the appropriate sublist.
     */

    do {
	/* Check for the possible error conditions... */
	result = TCL_ERROR;
	if (TclListObjGetElements(interp, subListPtr, &elemCount, &elemPtrs)
		!= TCL_OK) {
	    /* ...the sublist we're indexing into isn't a list at all. */
	    panic = 1;
	    break;
	}

	/*
	 * WARNING: the macro TclGetIntForIndexM is not safe for
	 * post-increments, avoid '*indexArray++' here.
	 */

	if (TclGetIntForIndexM(interp, *indexArray, elemCount - 1, &index)
		!= TCL_OK)  {
	    /* ...the index we're trying to use isn't an index at all. */
	    indexArray++;
	    panic = 1;
	    break;
	}
	indexArray++;

	if (index < 0) {
	    panic = 0;
	    break;
	}
	if (index >= elemCount) {
	    /* Auto extend. */
	    Tcl_Obj **pad;
	    int n = index - elemCount + 1;
	    pad = (Tcl_Obj **)ckalloc(n * sizeof(Tcl_Obj *));
	    for (i = 0; i < n; ++i) {
		    pad[i] = Tcl_DuplicateObj(*undef_obj());
	    }
	    result = Tcl_ListObjReplace(interp, subListPtr,
					elemCount, 0, n, pad);
	    ckfree((char *)pad);
	    if (result != TCL_OK) {
		panic = 1;
		break;
	    }
	    result = TclListObjGetElements(interp, subListPtr, &elemCount,
					   &elemPtrs);
	    if (result != TCL_OK) {
		panic = 1;
		break;
	    }
	}

	/*
	 * No error conditions. Determine the next sublist for the
	 * next pass through the loop, and take steps to make sure it
	 * is an unshared copy, as we intend to modify it.
	 */

	result = TCL_OK;
	--indexCount;
	parentList = subListPtr;
	subListPtr = elemPtrs[index];
	if (Tcl_IsShared(subListPtr)) {
		subListPtr = Tcl_DuplicateObj(subListPtr);
	}

	/*
	 * Replace the original elemPtr[index] in parentList with a copy
	 * we know to be unshared.  This call will also deal with the
	 * situation where parentList shares its intrep with other
	 * Tcl_Obj's.  Dealing with the shared intrep case can cause
	 * subListPtr to become shared again, so detect that case and
	 * make and store another copy.
	 */

	TclListObjSetElement(NULL, parentList, index, subListPtr);
	if (Tcl_IsShared(subListPtr)) {
		subListPtr = Tcl_DuplicateObj(subListPtr);
		TclListObjSetElement(NULL, parentList, index, subListPtr);
	}

	/*
	 * The TclListObjSetElement() calls do not spoil the string
	 * rep of parentList, and that's fine for now, since all we've
	 * done so far is replace a list element with an unshared copy.
	 * The list value remains the same, so the string rep. is still
	 * valid, and unchanged, which is good because if this whole
	 * routine returns NULL, we'd like to leave no change to the
	 * value of the lset variable.  Later on, when we set valuePtr
	 * in its proper place, then all containing lists will have
	 * their values changed, and will need their string reps spoiled.
	 * We maintain a list of all those Tcl_Obj's (via a little intrep
	 * surgery) so we can spoil them at that time.
	 */

	parentList->internalRep.twoPtrValue.ptr2 = (void *) chainPtr;
	chainPtr = parentList;
    } while (indexCount > 0);

    /*
     * Either we've detected and error condition, and exited the loop
     * with result == TCL_ERROR, or we've successfully reached the last
     * index, and we're ready to store valuePtr.  In either case, we
     * need to clean up our string spoiling list of Tcl_Obj's.
     */

    while (chainPtr) {
	Tcl_Obj *objPtr = chainPtr;

	if (result == TCL_OK) {

	    /*
	     * We're going to store valuePtr, so spoil string reps
	     * of all containing lists.
	     */

	    Tcl_InvalidateStringRep(objPtr);
	}

	/* Clear away our interp surgery mess */
	chainPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr2;
	objPtr->internalRep.twoPtrValue.ptr2 = NULL;
    }

    /*
     * We're bailing out either because of an internal error (bug), or
     * because of a negative array index.  Panic on the former, return
     * NULL on the latter.
     */
    if (result != TCL_OK) {
	if (panic) {
	    L_bomb("L deep-dive internal error");
	}
	return NULL;
    }

    if (TclListObjGetElements(interp, parentList, &elemCount, &elemPtrs)
		!= TCL_OK) {
	return NULL;
    }
    return (&elemPtrs[index]);
}

private Tcl_Obj **
deepdive_hash(Tcl_Interp *interp, Tcl_Obj *obj, Tcl_Obj **idxs, int num_idxs,
	      Deep_f flags)
{
	int	dflag, result, tmp;
	Dict	*dict;
	Tcl_Obj	**elt;		// ret value
	Tcl_Obj	*last;
	int	create = (flags & L_DEEP_PTR);
	int	write = !(flags & L_DEEP_VAL);
	Tcl_HashEntry *hPtr;

	/*
	 * Index into the passed-in object to get the penultimate
	 * element in the level, creating elements if necessary.
	 */
	if (write && Tcl_IsShared(obj)) {
		Tcl_Panic("A shared dict in the path");
	}
	if (num_idxs == 1) {
		last = obj;
	} else {
		unless (write) {
			dflag = DICT_PATH_READ;
		} else if (create) {
			dflag = DICT_PATH_CREATE;
		} else {
			dflag = DICT_PATH_UPDATE;
		}
		last = TclTraceDictPath(interp, obj, num_idxs-1, idxs, dflag);
		unless (last) goto undef;
		if (write && Tcl_IsShared(last)) {
			Tcl_Panic("Shared last of dict type");
		}
	}

	/*
	 * Now index into the penultimate element to reach the
	 * final element, creating it if necessary.
	 */
	unless (Tcl_DictObjSize(NULL, last, &tmp) == TCL_OK) {
		goto undef;  // last is not a dict
	}
	dict = (Dict *)last->internalRep.otherValuePtr;
	hPtr = Tcl_FindHashEntry(&dict->table, (char *)idxs[num_idxs-1]);
	unless (hPtr) {
		Tcl_Obj *objPtr;
		unless (create) goto undef;
		objPtr = Tcl_NewObj();
		Tcl_IncrRefCount(objPtr);
		result = Tcl_DictObjPut(interp, last, idxs[num_idxs-1], objPtr);
		Tcl_DecrRefCount(objPtr);
		ASSERT(result == TCL_OK);
		hPtr = Tcl_FindHashEntry(&dict->table,(char *)idxs[num_idxs-1]);
	}
	elt = (Tcl_Obj **)(void *)&Tcl_GetHashValue(hPtr);
	if (write && Tcl_IsShared(*elt)) {
		Tcl_DecrRefCount(*elt);
		*elt = Tcl_DuplicateObj(*elt);
		Tcl_IncrRefCount(*elt);
	}

	return (elt);
 undef:
	if (write) L_bomb("L deep-dive internal error");
	return (undef_obj());
}

private Tcl_Obj **
deepdive_array(Tcl_Interp *interp, Tcl_Obj *obj, Tcl_Obj **idxs, int num_idxs,
	       Deep_f flags)
{
	Tcl_Obj	**elt;

	if (flags & L_DEEP_VAL) {
		elt = L_LindexFlat(interp, obj, num_idxs, idxs);
		unless (elt) {
			elt = undef_obj();
		}
	} else {
		elt = L_LsetFlatExtend(interp, obj, num_idxs, idxs);
		unless (elt) {
			Tcl_ResetResult(interp);
			Tcl_AppendResult(interp,
					 "cannot write to negative array index",
					 NULL);
			elt = NULL;
		}
	}
	return (elt);
}

/*
 * "Deep dive" is L's mechanism for indexing into a (possibly nested)
 * array, hash, or struct.  What is unique is that all the indices
 * that comprise a variable reference are compiled into one bytecode,
 * INST_L_DEEP_READ.  This function is called as part of the execution
 * of INST_L_DEEP_READ (see tclExecute.c) to perform the actual
 * indexing.  It returns a pointer to the Tcl_Obj pointer to the
 * indexed element.
 *
 * obj points to the object being indexed in to; idxs is the array of
 * indices; countsObj is a list of "level" counts.  Each level represents
 * one or more consecutive array references (a[3][2]), or hash
 * references (h{3}{2}), and the level count is how many such
 * references there are in a row (struct references are really just
 * array references in disguise).  Levels alternate hash, array, hash,
 * ...; or array, hash, array, ...; hash is first if flags &
 * L_DEEP_HASH_FIRST.
 *
 * For example, for a[3][2]{9}[4] we have
 *
 *   a 3 2 9 4 {2 1 1}
 *
 * and L_DEEP_HASH_FIRST is not set in flags.  The 3 2 9 4 are the
 * idx's.  The {2 1 1} is the countsObj object.  There are three levels;
 * the first is [3][2] hence the first elt of countsObj is 2 (there are 2
 * consecutive array references); the second is {9}; the third is [4].
 *
 * flags also can have the L_DEEP_PTR bit set if the indexed element
 * is being created (e.g., a[2]{3} = 1), or the L_DEEP_VAL bit set
 * if the element is only being read (e.g., i = a[2]{3}).  Other bits
 * are possible (L_DEEP_PTR_VAL and L_DEEP_VAL_PTR) if the element
 * will be both read and written (e.g., a[2]{3} += 1) but those cases
 * are not dealt with here.
 */
Tcl_Obj **
L_deepDive(Tcl_Interp *interp, Tcl_Obj *obj, Tcl_Obj **idxs,
	   Tcl_Obj *countsObj, Deep_f flags)
{
	int	i, n, num_levs, result;
	Tcl_Obj	*curr = obj;
	Tcl_Obj **currPtr = NULL;
	Tcl_Obj **counts;
	int	ishash  =  (flags & L_DEEP_HASH_FIRST);
	int	iswrite = !(flags & L_DEEP_VAL);

 	if (iswrite && (obj->refCount != 1)) {
 		Tcl_Panic("L_deepDive on obj with refCount %i", obj->refCount);
 	}

	/* Get num_levels in countsObj and extract the counts array. */
	if (Tcl_IsShared(countsObj)) {
		countsObj = TclListObjCopy(interp, countsObj);
		unless (countsObj) return (NULL);
	}
	result = Tcl_ListObjGetElements(interp, countsObj, &num_levs, &counts);
	unless (result == TCL_OK) {
		result = TclGetIntFromObj(NULL, countsObj, &i);
		unless (result == TCL_OK) return (NULL);
		num_levs = 1;
		counts   = &countsObj;
	}
	unless (num_levs) return (NULL);
	Tcl_IncrRefCount(countsObj);

	/* Dive for each level. */
	for (i = 0; i < num_levs; i++) {
		/* n = # indices in this level. */
		result = Tcl_GetIntFromObj(interp, counts[i], &n);
		unless (result == TCL_OK) goto done;

		if (ishash) {
			currPtr = deepdive_hash(interp, curr, idxs, n, flags);
		} else {
			currPtr = deepdive_array(interp, curr, idxs, n, flags);
		}
		if (!currPtr || (currPtr == undef_obj())) goto done;

		if (iswrite) Tcl_InvalidateStringRep(curr);
		curr = *currPtr;
		if (iswrite && Tcl_IsShared(curr) && (i != (num_levs-1))) {
			Tcl_Panic("L deep-dive internal error 2");
		}
		idxs += n;
		ishash = !ishash;
	}
	if (iswrite && (obj->refCount != 1)) {
		Tcl_Panic("L_deepDive exit with refCount = %i", obj->refCount);
	}
 done:
	Tcl_DecrRefCount(countsObj);
	return (currPtr);
}

/*
 * This function executes the INST_L_SPLIT bytecode and is based on
 * pieces from tclCmdMZ.c.
 *
 * For edge cases, some of Perl's "split" semantics are obeyed:
 *
 * - A limit <= 0 means no limit.
 *
 * - If the regexp is ' ', we split on white space but leading
 *   white space does not produce a null first field.
 *
 * - No regexp means split on white space.
 */
Tcl_Obj *
L_split(Tcl_Interp *interp, Tcl_Obj *strobj, Tcl_Obj *reobj, Tcl_Obj *limobj)
{
	int		end, lim, matches, off, ret, start;
	int		ondefault=0, onspace=0;
	Tcl_RegExp	regExpr;
	Tcl_RegExpInfo	info;
	Tcl_Obj		*resultPtr, *objPtr, *listPtr;
	char		*str;
	int		len;

	if (limobj) {
		Tcl_GetIntFromObj(interp, limobj, &lim);
		if (lim <= 0) {
			lim = INT_MAX;
		} else {
			/* The lim is the max # fields to return,
			 * which is one less than the max # matches to
			 * allow. */
			--lim;
		}
	} else {
		lim = INT_MAX;
	}

	/*
	 * Check for the cases of no regexpr (split on white space) or
	 * splitting on ' ' (split on white space but don't return a
	 * null field for any leading white space).
	 */
	if (reobj) {
		unless (strcmp(" ", Tcl_GetString(reobj))) onspace = 1;
	} else {
		ondefault = 1;
	}

	/*
	 * Make sure to avoid problems where the objects are shared. This can
	 * cause RegExpObj <> UnicodeObj shimmering that causes data corruption.
	 * [Bug #461322]
	 */
	if (strobj == reobj) {
		objPtr = Tcl_DuplicateObj(strobj);
	} else {
		objPtr = strobj;
	}
	str = TclGetStringFromObj(objPtr, &len);

	listPtr = Tcl_NewObj();
	matches = 0;
	off     = 0;

	/*
	 * Split on white space if no regexp or ' ' was specified.  No
	 * need for the regexp engine here.
	 */
	if (ondefault || onspace) {
		int letters = 0, skip = 0;
		for (start = 0; (off < len) && (matches < lim); ++off) {
			if (skip) {
				unless (isspace(str[off])) {
					start   = off;
					letters = 1;
					skip    = 0;
					++matches;
				}
			} else {
				if (isspace(str[off])) {
					/* When regexp is ' ', create no null
					 * field for leading white space. */
					unless (onspace && !off && !start) {
						resultPtr = Tcl_NewStringObj(
								str+start,
								off-start);
						Tcl_ListObjAppendElement(
								NULL, listPtr,
								resultPtr);
					}
					skip = 1;
				} else letters = 1;
			}
		}
		unless (skip) {
			resultPtr = Tcl_NewStringObj(str+start, len-start);
			Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		}
		/* If input was all whitespace, return empty list. */
		unless (letters || !lim) listPtr = Tcl_NewObj();
		goto done;
	}

	/*
	 * Split on the specified regular expression.
	 */
	regExpr = Tcl_GetRegExpFromObj(interp, reobj,
				       TCL_REG_ADVANCED | TCL_REG_PCRE);
	unless (regExpr) {
		listPtr = Tcl_NewObj();
		goto done;
	}
	while ((off < len) && (matches < lim)) {
		ret = Tcl_RegExpExecObj(interp, regExpr, objPtr, off,
				10 /* matches */,
				((off > 0 && (str[off-1] != '\n'))
				? TCL_REG_NOTBOL : 0));
		if (ret < 0) goto done;
		if (ret == 0) break;

		Tcl_RegExpGetInfo(regExpr, &info);
		start = info.matches[0].start;
		end   = info.matches[0].end;
		matches++;

		/*
		 * Copy to the result list the portion of the source
		 * string before the match. If we matched the empty
		 * string, split after the current char.
		 */
		if (start == end) {
			ASSERT(start == 0);
			resultPtr = Tcl_NewStringObj(str+off, 1);
			++off;
		} else {
			resultPtr = Tcl_NewStringObj(str+off, start);
		}
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		off += end;
	}
	/*
	 * Copy to the result list the portion of the source string after
	 * the last match, unless we matched the last char.
	 */
	if (off < len) {
		resultPtr = Tcl_NewStringObj(str+off, len-off);
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
	}

 done:
	if (objPtr && (strobj == reobj)) {
		Tcl_DecrRefCount(objPtr);
	}
	return (listPtr);
}
