#ifndef L_COMPILE_H
#define L_COMPILE_H

#include "tclInt.h"
#include "tclCompile.h"
#include "Last.h"

#ifndef TRUE
#define TRUE 1
#endif /* TRUE */
#ifndef FALSE
#define FALSE 0
#endif /* FALSE */

typedef enum L_operator_name {
    L_OP_PLUS,
    L_OP_MINUS,
    L_OP_MULTIPLY,
    L_OP_DIVIDE,
    L_OP_MODULUS
} L_operator_name;

/**
 * An L_compile_frame is just a stack that lets the semantic actions
 * track state as the parser does its thing.
 */
typedef struct L_compile_frame {
    Tcl_Interp	*interp;
    CompileEnv	*envPtr;
    Tcl_HashTable *symtab;
    /* The "original code next" is where we save the compEnv->codeNext
     * pointer so we can check if any code was emitted in this frame.
     * Yikk.  --timjr 2006.2.23 */
    unsigned char *originalCodeNext;
    /* Jump fixups allow you to conveniently set the target of a jump that has
       been previously emitted. */
    JumpFixupArray *jumpFixupArrayPtr;
    struct L_compile_frame *prevFrame;
} L_compile_frame;

/* L_symbols are used to represent variables. */
typedef struct L_symbol {
    char *name;
    L_type *type;
    int localIndex;
} L_symbol;


void LCompileScript(Tcl_Interp *interp, CONST char *str, int numBytes, 
                    CompileEnv *envPtr, void *ast);
int LParseScript(Tcl_Interp *interp, CONST char *str, int numBytes, L_ast_node **ast);
/* void L_assignment(L_ast_node *lvalue, L_ast_node *rvalue); */
void L_begin_function_decl(L_ast_node *name);
void L_end_function_decl(L_ast_node *name);
void L_begin_function_call(L_ast_node *name);
void L_end_function_call(L_ast_node *name, int param_count);
void L_if_condition(int unless_p);
void L_if_end(int elseClause);
void L_if_alternative_end();
void L_if_consequent_end();
void L_op_post_incdec(L_ast_node *lvalue, char op);
void L_op_pre_incdec(L_ast_node *lvalue, char op);
/* void L_lhs_assignment(L_ast_node *rvalue); */
/* void L_rhs_assignment(L_ast_node *rvalue); */
void L_assignment(L_ast_node *rvalue);
void L_op_binop(L_operator_name op);
/* void L_push_str(L_ast_node *str); */
/* void L_push_int(L_ast_node *i); */
void L_push_literal(L_ast_node *literal);
void L_push_id(L_ast_node *id);
void L_return(int value_on_stack_p);
void maybeFixupEmptyCode(L_compile_frame *frame);
void L_frame_push(Tcl_Interp *interp, CompileEnv *compEnv);
void L_frame_pop();
void L_bomb(const char *format, ...);
void L_trace(const char *format, ...);
void L_errorf(const char *format, ...);
void L_declare_variable(L_ast_node *name, int base_type, int initialize_p);
void L_declare_parameter(L_ast_node *name, int base_type);
L_symbol *L_get_symbol(char *name, int error_p);
L_symbol *L_make_symbol(char *name, int base_type, L_ast_node *array_type, int localIndex);


/* L_error is yyerror (for parse errors) */
void L_error(char *s);

/* L_parse is generated by yacc... not sure where the prototype is
   actually meant to be found. --timjr 2006.2.23  */
int L_parse(void);

/* This is the type that Yacc will use for all semantic values. */ 
#define YYSTYPE void *

/* AST convenience macros */
#define MK_STRING_NODE(var,str) do {\
        var = mk_expression(L_EXPRESSION_STRING, -1, NULL, NULL, NULL, NULL);\
        ((L_expression *)var)->u.s = ckalloc(strlen(str) + 1);\
        strcpy(((L_expression *)var)->u.s, str);\
} while(0);

#define MK_INT_NODE(var,int) do {\
        var = mk_expression(L_EXPRESSION_INT, -1, NULL, NULL, NULL, NULL);\
        ((L_expression *)var)->u.i = int;\
} while(0);

#define MK_FLOAT_NODE(var,float) do {\
        var = mk_expression(L_EXPRESSION_FLOAT, -1, NULL, NULL, NULL, NULL);\
        ((L_expression *)var)->u.d = float;\
} while(0);

#define L_NODE_TYPE(node) ((L_ast_node*)node)->node_type

#endif /* L_COMPILE_H */

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
