=head1 NAME

L

=head1 SYNOPSIS

L [options] script.l [args]

=head1 DESCRIPTION

L is a little interpreted language that draws heavily from C and Perl.
From C, L gets C syntax, simple types (int, float, string), and
complex types (arrays, structs).
From Perl, L gets associative arrays and regular expressions (PCRE).
And from neither, L gets its own simplistic form of classes.

L stands for "little" as in little language.  The idea was to distill
the useful parts of other languages and combine them into a scripting
language, with type checking, classes (not full-blown OO but useful none
the less), and direct access to a cross-platform graphical toolkit.

L provides a set of built-in functions, drawn from Perl and the 
standard C library.

L is built on top of the Tcl/TK system.  The L compiler generates Tcl
byte codes and uses the Tcl calling convention.  This means that L and
Tcl code may be intermixed.  More importantly, it means that
L may use all of the TK widgets.  The net result is a type-checked
scripting language which may be used for cross-platform GUIs.

L is open source under the same license as Tcl/TK BSD like).

=head1 RUNNING L PROGRAMS

You can run an L program from the command line.

    L [options] progname.l [args]

Alternatively, put this as the first line of your script, but make
sure your script is executable (C<chmod 755 script.l> under Unix).

    #!/path/to/L [options]

Options:

=over 4

=item B<-n | --nowarn>

Disable compiler warnings.  This is useful when you know you have
unused variables or other warnings that you don't want to be
bothered with.

=item B<-P | --poly>

Treat all types as C<poly>.  This effectively disables type checking.

=back

The optional [args] is a white-space separated list of arguments that
are passed to the script's main() function as an argument count (argc)
and an array of strings (argv).

=head1 SYNTAX

An L script or program consists of one or more statements.  These may
be executable statements, variable or type declarations, or function
or class declarations.  Statements outside of functions are said
to be at the C<top level> and are executed in the order they appear,
although you can use a C<return> statement to bail out.
There is no need to have a C<main()> function, but if one is
present, it is executed after all of the top-level statements
(even if you did a C<return> from the top level).

    puts("This is printed first.");
    void main()
    {
        puts("This is printed last.");
    }
    puts("This is printed second.");

L statements end in a semi-colon.

    printf("Hello, world\n");

Comments start with a // or a hash symbol and run to the end of the line.
C-style comments also are allowed.

    # This is a comment
    // So is this
    /* And this too */

Whitespace usually is irrelevant.

    printf(
        "Hello, world\n")
        ;

... except inside quoted strings:

    # this would print with a linebreak in the middle
    print "Hello\
    world";

and around the string-concatenation operator " . " so it can
be distinguished from the struct-member selection operator ".".

Double quotes or single quotes may be used around literal strings:

    puts("Hello, world");
    puts('Hello, world');

However, only double quotes "interpolate" variables and handle
character escapes such as for newlines (C<\n>):

    printf("Hello, ${name}\n");     # works fine
    printf('Hello, ${name}\n');     # prints ${name}\n literally

Inside single quotes, you can still escape a line break, the
single quote character (C<\'>), and the escape character (C<\\>).

If you put a line break in the middle of a string but forget to escape
it, L will complain.

=head1 NAME SCOPING

Variables must be declared before use, or a compile-time error
will result.  However, functions need not be declared before use
although it is good practice to do so.

Declarations at the top-level code exist at the C<global> scope and
are visible across all scripts executed by a single run of L.  You can
qualify a global declaration with C<private> to restrict it to the
current file only; this is similar to a C<static> in C, except that
private globals are not allowed to shadow public globals.  Names
declared in a function, or in a block within a function, are C<local>
and are scoped to the block in which they are declared.

Functions and global variables share the same name space, so a
variable and function cannot have identical names.  Struct tags
have their own namespace, and type names have theirs.

Inside a function, two locals cannot share the same name, even if they
are in parallel scopes.  But a local can share the same name as a
global, in which case the local is said to C<shadow> the global.

Names declared inside of a class can be either local or global
depending on how they are qualified.  Classes are discussed later.

=head1 VARIABLES AND TYPES

L is a strongly typed language with both scalar and complex types.
All variables are typed and must be declared before use.

The scalar types are int, float, and string.  The complex types are
array, hash, struct, and list.  L also supports function pointers,
classes, and a special type called C<poly> which matches any type and
normally is used to disable type checking.  Finally, L has the concept
of an C<undefined> value which a variable of any type can possess.
These all are discussed next.

Strong typing means that you can assign something of one type only to
something else of a compatible type.  Normally, to be compatible the
types must be structurally the same, but there are exceptions such as
an int being compatible with float and a list sometimes being
compatible with an array or struct.  These special cases are discussed
further below.

An L variable is written as an identifier without any special prefix
characters like in Perl.  Variables begin with a letter and can
contains letters, numerals, and underscores, but they B<cannot> begin
with an underscore (_).  This is because the L compiler reserves names
starting with _ for internal use.

A variable declaration includes the
type, the variable name, and optionally an initial value which can
be any L expression:

    int i = 3*2;

    printf("i = %d\n", i);  // prints i = 6

If an initial value is omitted, the variable starts out with the
undefined value C<undef>, discussed more below.

=over 4

=item Scalars

A scalar represents a single value that is a string, integer, or
floating-point number:

    string animal = "camel";
    int answer = 42;
    float pi = 3.14159;

When one of these types is expected, supplying another one usually is
an error, except that an int always can be used as a float.  You can
override this behavior with a type cast, discussed below.

Strings have a special feature where they can be indexed like arrays,
to get a character or range of characters, or to change a character
(but you cannot change a range of characters):

    string s1, s2;

    s1 = "hello";
    s2 = s1[1];     // s2 gets "e"
    s2 = s1[1..3];  // s2 gets "ell"
    s1[1] = "x";    // changes s1 to "hxllo"
    s1[END+1] = "there";    // changes s1 to "hxllothere"

The pre-defined identifier C<END> is index of the last character,
or -1 is the string is empty.  You always can write to one past the end
of a string to append to it, but writing beyond END+1 is an error.

You delete a character within a string by indexing the string and
setting it to "" (the empty string), or by using the C<undef()> built-in:

    s[3] = "";    // deletes fourth character of s
    undef(s[3]);  // also deletes fourth character

=item Undef

Sometimes you want to signify that a variable has no legal value, such
as when returning an error from a function.  L has a pre-defined
constant called C<undef> which you can assign to anything.

    int_var = undef;
    array_var = undef;

This is different than the C<undef()> built-in I<function> which
deletes array, hash, or string elements and which is described
later.

You can test whether something has the value undef or a regular value
with the built-in function C<defined()>:

    if (defined(int_var)) {
        printf("int_var has the value %d\n", int_var);
    } else {
        printf("int_var is undefined\n");
    }

L itself sometimes uses undef to tell you that no value is available.
One case is when you assign to an array element that is more than one
past the end of an array.  L auto-extends the array and sets the
unassigned elements to undef.

Undef requires some care, because the underlying execution engine
I<does> let you read its value, which is the empty string ("").  In a
string operation this would be a legal value but would cause a
run-time error in an arithmetic operation.  So if you call a function
that can return undef, you should check the definedness of the return
value before using it.

=item Arrays

An array holds a list of values, all of the same type:

    string animals[] = { "camel", "llama", "owl" };
    int numbers[] = { 23, 42, 69 };

You do not specify a size when declaring an array, because
arrays grow dynamically.

Arrays are zero-indexed.  Here's how you get at elements in an array:

    puts(animals[0]);              # prints "camel"
    puts(animals[1]);              # prints "llama"

The pre-defined identifier C<END> is index of the last element
of an array, unless the array is empty and then END is -1:

    puts(animals[END]);       # last element, prints "owl"

END is valid only inside of an array subscript.

If you need the length of an array, use a built-in function:

    num_elems = length(animals);   # will get 3

If the array is empty, length() returns 0.

To get multiple values from an array, you use what's called an array
C<slice> which is a sub-array of the array being sliced.
Slices are for reading values only, you cannot write to a slice.

    animals[0..1];            # gives { "camel", "llama" }
    animals[1..END];          # gives all except the first element

In this last example where END is used, you must be careful, because if
the array is empty, END will be -1, and an array slice where the
second index is less than the first causes a run-time error.

You can add on to the end of an array no matter how many elements
it already has:

    push(&animals, "tiger");

The & means that animals is passed by reference, because it will
be changed.  This is discussed more later.

Another way to append:

    animals[END+1] = "tiger";

You can remove an element from the end of an array with C<pop>:

    string birds[] = { "robin", "dove", "cardinal" };
    string next = pop(&birds);   // next gets "cardinal"

Or you can remove from anywhere in an array with C<undef>:

    string dev_team[] = { "larry", "curly", "mo" };
    undef(dev_team[0]);  // delete "larry" from dev_team

When you delete an element, all subsequent elements slide down
by one index.  Note that undef() works only on a variable; it
cannot remove an element from a function return value, for example.

You also can directly assign to any array index even if the array
hasn't yet grown up to that index.  If you assign more than one past
the current end, the unassigned elements are assigned undef:

    string colors[] = { "blue, "red" };
    colors[3] = "green";   # colors[2] gets undef and colors[3] gets "green"

You can read from any non-negative array index as well.  You will simply
get undef if the element doesn't exist.  Reading from a negative index
causes a run-time error.

An array can hold elements of any type, including other arrays.
Although L does not have true multi-dimensional arrays, arrays of
arrays give you basically the same thing:

    int matrix[][] = {
        { 1, 2, 3 },
        { 4, 5, 6 },
        { 7, 8, 9 }
    };

When declaring an array, it is legal to put the brackets after the
type instead of the name.  This is useful in function prototypes that
omit the parameter name, and is required if a function returns an
array.  This example illustrates both cases:

    int[] mysort(int[]);

=item Hashes

A hash holds a set of key/value pairs:

    int grades{string} = { "Tom"=>85, "Rose"=>90 };

When you declare a hash, you specify both the key type (within the {})
and the value type.  The keys must be of scalar type but the values can
be of any type, allowing you to create hashes of arrays or other hashes.

To get at a hash element, you index the hash with the key:

    grades{"Rose"};           # gives 90

If the given key does not exist in the hash, you get back undef.
Using undef as a key causes a run-time error.

You get a list of all the keys in a hash with the C<keys()> built-in,
which returns an array:

    string students[] = keys(grades);

Because hashes have no particular internal order, the order in which
the keys ("Tom" and "Rose") appear is undefined.  However, you can
obtain a sorted array of keys like this:

    string students[] = sort(keys(grades));

The C<length> built-in works on hashes too and returns the number of
key/value pairs.

You remove an element from a hash with C<undef>:

    undef(grades{"Tom"});  // removes "Tom" from the hash

It is not an error to remove something that's not in the hash.  Note
that undef() works only on a variable; it cannot remove an element
from a function return value, for example.

When declaring a hash, it is legal to put the braces after the base
type instead of the name.  This is useful in function prototypes that
omit the parameter name, and is required is a function returns a
hash.  This example illustrates both cases:

    int{string} adjust_grades(int{string});

=item Structs

L structs are much like structs in C.  They contain a fixed number
of named things of various types:

    struct my_struct {
        int    i;
        int    j;
        string s;
    };
    struct my_struct st = { 1, 2, "hello" };

You index a struct with the "." operator except when it is a
call-by-reference parameter and then you use "->":

    void foo(struct my_struct &byref) {
        puts(byref->s);  // prints hello
    }
    puts(st.i);    // prints 1
    puts(st.j);    // prints 2
    puts(st.s);    // prints hello
    foo(&st);      // pass st by reference

It is an error to use "." when "->" is required and vice-versa.  Be
careful to not put any whitespace around the "." or else you will get
the string concatenation operator and not struct-member selection.

Structs can be named like C<my_struct> above or they can be anonymous:

    struct {
        int    i;
        int    j;
    } var1;

Struct names have their own name space, so they will never clash with
function, variable, or type names.

=item Lists

In the examples above, we have been initializing arrays, hashes, and
structs by putting values inside of {}:

    string nums[] = { "one", "two", "three" };

In L, the C<{}> is an operator that creates a C<list> and can be used
anywhere an expression is valid.  The array could instead be
initialized like this:

    string nums[];
    nums = { "one", "two", "three" };

We said before that you can assign a value to something only if it has
a compatible type.  Lists are special in that they can be compatible
with arrays, hashes, and structs.  A list where all the elements are
of the same type, say T, is compatible with an array of things of
type T.  The example above illustrates this.

A list also is compatible with a struct if the list elements agree
in type and number with the struct.  The assignment of the variable
C<st> above illustrates this.

A list is compatible with a hash if it has a sequence of key/value
pairs and they are all compatible with the key/value types of
the hash:

    int myhash{string} = { "one"=>1, "two"=>2, "three"=>3 };

Lists are very useful at times because you can use them to build up
larger complex structures.  To concatenate two arrays, you could do
this:

    { (expand)array1, (expand)array2 };

The (expand) operator takes an array (or struct or list) and moves its
elements out a level as if they were between the { and } separated by
commas.  This is discussed more later.

=item Poly

Sometimes you don't want L to do type checking.
In this case, you use the C<poly> type, which is compatible with
any type.  Poly effectively disables type checking, allowing you
to use or assign values without regard to their types.  Obviously,
care must be taken when using poly.

The B<-poly> option to L causes all variables to be treated as if they
were of type poly, regardless of how they are declared.

=item Type Casts

Something of one type can be converted into something of another
type with a type cast like in C:

    string_var = (string)13;

If the thing being cast cannot be converted to the requested type, you
may not receive an error until you later you use it and the run-time
engine discovers that conversion is impossible.

=item Typedefs

You can declare a type name to be a short hand for another type, as
you would in C:

    typedef int index_t;
    typedef string table_t{index_t};

And then use the short-hand as you would any other type name:

    table_t my_table;
    my_table{3} = "value";

You can typedef a function pointer too.  This declares compar_t
as type function that takes two ints and returns an int:

    typedef int compar_t(int a, int b);

Type names belong to their own name space, so you can define a typedef
with the same name as a variable, function, or struct name without
ambiguity.

=back

=head1 INTERPOLATION

Expressions can be interpolated into double-quoted strings, which
means that within a string you can write an expression and at run-time
its value will be inserted.  For example, this interpolates two
variables:

    int    a = 12;
    string b = "hello";

    /* This will print "A is 12 and b is hello". */

    printf("A is ${a} and b is ${b}\n");

Everything inside the ${} is evaluated like any other L expression, so
it is not limited to just variables:

    printf("The time is ${`date`}\n");

=head1 FUNCTIONS

L's functions are much like functions in C.  Like variable names,
function names B<cannot> begin with an underscore (_).

Each function must be declared with a return type and a
formal-parameter list:

    int sum(int a, int b)
    {
        return (a + b);
    }

C<void> is a legal return type for a function that returns no value.
Functions cannot be nested.

Function prototypes are allowed, where all but the function body is
declared.  In a prototype, you can omit any parameter names or use
C<void> for an empty parameter list:

    void no_op1(void);
    void no_op2();
    int sum(int, int);

Unlike Perl, when calling a function you must use parentheses around
the arguments:

    sum(a, b);

L does a special kind of call called a C<pattern function> call
when the function name is capitalized and contains an underscore;
these are useful for calling Tcl commands and are described later.
Normal function names should avoid being both capitalized and
with an underscore.

Parameters are passed by value by default.  To pass by reference,
you use a C<&> in the declaration and in the function call:

    void inc(int &arg)
    {
        ++arg;
    }

    inc(&x);

The C<&> only tells L to pass by reference; it is not a pointer and
cannot be used in any other context.

Only variables can be passed by reference, not elements of arrays,
hashes, or structs.  This is one significant difference from C.

When accessing a struct argument inside a function, if the struct was
passed by reference, the "->" operator must be used instead of ".".
This makes it clear to the reader that the struct variable is passed
by reference; it is intended to allude to a C pointer even though L
does not have pointers.

Functions can take a variable number of arguments, like printf does.
In the function declaration, you use the qualifier "..." in front
of the last formal parameter name and omit its type:

    void dump(...args)
    {
        string s;
        foreach(s in args) puts(s);
    }
    dump("just one");
    dump("but two", "or three", "or more is OK");

Inside the function, C<args> has type array of poly, allowing any
number of parameters of any type to be passed.

=head2 The main() Function

If main() is present, it is called after all of the top-level statements
have executed.  The main() function may defined in any of the following
ways:

   void main() {}
   void main(int argc, string argv[]) {}
   void main(int argc, string argv[], string env{string}) {}

The C<argv> array is populated from any arguments that appear after the
script name on the L command line:

   L script.l arg1 arg2 arg3

The C<env> hash is populated with the environment variables present
when L is invoked.  Although you can change this hash, writes to it
are not reflected back into the environment.  To do that use the
C<setenv> library function.

=head2 Function Pointers

Function pointers are supported, but only as arguments -- you cannot
otherwise assign a function pointer to a variable.  It is common to
first typedef the function-pointer type; here is one for a function
that compares two strings:

    typedef int str_compar_t(string a, string b);

You can then pass such a compare function as follows:

    string    a[];

    bubble_sort(a, &unary_compar);

Where the sort function looks like this:

    string[] bubble_sort(string a[], str_compar_t &compar)
    {
        do {
            ...
            if (compar(a[i], a[i+1] > 0) { ... }
            ...
        } ...
    }

And the compare function looks like this:

    int unary_compar(string a, string b)
    {
	int	al = length(a);
	int	bl = length(b);

	if (al < bl) {
		return -1;
	} else if (al > bl) {
		return 1;
	} else {
		return 0;
	}
    }

=head1 CONTROL TRANSFER STATEMENTS

L has most of the usual conditional and looping constructs except for
case/switch.

A conditional expression can be any L expression of type int or
string.  Any non-zero int value is TRUE, and zero is FALSE.  Any
non-empty string value is TRUE, and the empty string ("") is FALSE.

See the list of operators in the next section for information on
comparison and logic operators, which are commonly used in conditional
statements.

=over 2

=item if

The C<if> statement comes in the traditional form:

    if ( condition ) {
        ...
    } else if ( other condition ) {
        ...
    } else {
        ...
    }

And there's a negated version of it provided as a more readable
version of C<if (!I<condition>)>.

    unless ( condition ) {
        ...
    }

=item while

    while ( condition ) {
        ...
    }

    do {
        ...
    while ( condition )

=item for

    for (i = 0; i < max; ++i) {
        ...
    }

=item foreach

The C<foreach> statement lets you iterate through the elements of an
array:

    string element;
    string myarray[];

    foreach (element in myarray) {
        printf("This element is %s\n", element);
    }

... of a hash:

    string key;
    int value;
    int myhash{string};

    foreach (key=>value in myhash) {
        printf("Key %s has value %d\n", key, value);
    }

... or of a string:

    string char;

    foreach (char in mystring) {
        printf("This char is %s\n", char);
    }

If you want to stride through more than one array or character in
each iteration, just use a list of value variables instead of one:

    foreach (e1,e2,e3 in myarray) {
        printf("Next three are %s:%s:%s\n", e1, e2, e3);
    }

If the array or string length isn't a multiple of three, the
stragglers get the value undef on the last iteration.  Strides
work only for arrays and strings, not hashes.

=item goto

The C<goto> statement unconditionally transfers control to a label in
the same function, or to a label at the global scope if the goto is at
the global scope.  You cannot use a goto to transfer in to or out of
a function.  Labels have their own name space so they will not clash
with variable, function, or type names.

    /* A goto at the global scope. */
    goto L1;
    puts("this is not executed");
L1: puts("but this is");

    void foo()
    {
        goto L2;
        puts("this is not executed");
L2:     puts("but this is");
    }

Some caveats: do not jump into a foreach loop or a run-time error may
result due to bypassing the loop set-up.  Do not bypass a variable
declaration or else the variable will be inaccessible.

=back

=head1 INCLUDES

L has an C<include> statement like the one in the C pre-processor.
An include can appear anywhere a statement can appear as long as it begins
in the first column and is contained entirely on one line:

    include("types.l");
    include("globals.l);
    void main()
    {
        ...
    }

L remembers which files have been included and will not include a file
more than once, allowing you to have include files that include each
other.

=head1 HERE DOCUMENTS

Sometimes you need to assign a multi-line string to a variable.
C<Here documents> help with that:

    string s;

    s = <<END
    This is the first line in s.
    This is the second.
    And the last.
    END

Everything in the line starting after the initial <<END delimeter and
before the final END delimeter get put into the variable C<s>.  You
can use any identifier you want as the delimeter, it doesn't have
to be END.

The text inside the here document undergoes interpolation.  If you
don't want that, put the initial delimeter inside of single quotes:

    s = <<'END'
    None of this text is interpolated.
    So this ${xyz} appears literally as '${xyz}'.
    END

=head1 WORKING WITH TCL/TK

L is built on top of Tcl: L functions are compiled down to Tcl procs,
L local variables are just Tcl variables local to the proc, and L global
variables are Tcl globals.
Although L is designed to hide its Tcl underpinnings, sometimes it is
useful for L and Tcl to cooperate.

=head2 Mixing L and Tcl Code

When you invoke L with a script whose name ends in C<.l>, the script
must contain only L code.
If you run a C<.tcl> script, you can mix L and Tcl:

    puts "This is Tcl code"
    #lang L
    printf("This is L code\n");
    #lang tcl
    puts "Back to Tcl code"

You also can run L code from within Tcl by passing the L code to the
Tcl command named C<L>:

    puts "Tcl code again"
    L { printf("Called from the L Tcl command.\n"); }

=head2 Calling Tcl from L

You call a Tcl proc from L like you would an L function:

    string s = "hello world";
    puts(s);

In this example, C<puts> is the Tcl command that outputs its argument
to the C<stdout> channel.

If you want argument type checking, you can provide a prototype for the Tcl
functions you call.  Otherwise, no type checking is performed.

In Tcl, options usually are passed as strings like "-option1" or "-option2".
L has a feature to pass these options more pleasantly:

    func(option1:);            // passes "-option1"
    func(option2: value, arg); // passes "-option2", value, arg

Without this, you would have to say:

    func("-option1");
    func("-option2", value, arg);

A similar feature is for passing sub-commands to Tcl commands:

    String_length("xyzzy");   // like tcl's [string length xyzzy]
    String_isSpace(s);        // like tcl's [string is space $s]

Whenever the function name is capitalized and contains an underscore,
the sequence of capitalized names after the underscore are converted
to (lower case) arguments (although capitalizing the
first name after the underscore is optional).
This is called a C<pattern function> call.

If you need to execute arbitrary Tcl code rather than just call a proc,
you pass it to Tcl's C<eval> command:

    eval("puts {you guessed it, Tcl code again}");

=head2 Calling L from Tcl

L functions are easily called from Tcl, because an L function
C<foo> compiles down to a Tcl proc named C<foo> in the global
namespace.
Let's say this is run from a script named C<script.tcl>:

    #lang L
    int avg(...args)
    {
        int i, sum=0;
        unless (length(args)) return (0);
        foreach (i in args) sum += i;
        return (sum/length(args));
    }
    #lang tcl
    set x [avg 4 5 6]
    puts "The average is $x"

The L code defines a proc named C<avg> which the Tcl code then calls.

An exception is that C<private> L functions are not callable from Tcl.

=head2 Variables

Because L globals are just Tcl variables, you can access L variables
from Tcl code.  Here is an example from the L library:

    int size(string path)
    {
        int sz;

        if (catch("set sz [file size $path]")) {
            return (-1);
        } else {
            return (sz);
        }
    }

In the Tcl code, C<$path> refers to the L formal parameter C<path>,
and the L local C<sz> is set to the file size.  This example also
illustrates how you can use Tcl's exception-handling facility
to catch an exception raised within some Tcl code.

An exception is that L global names are mangled with a prepended
underscore (_), so to access the L global C<foo> from Tcl, you need
to refer to C<$_foo>.  Another exception is that private L global
names are mangled so much (to make them unique) that they are
not accessible from Tcl.

=head2 Namespaces

You can access Tcl procs and variables in namespaces other than
the global namespace by qualifying the name:

    extern string ::mynamespace::myvar;

    /* Print a bytecode disassembly of the proc "foo". */
    puts(::tcl::unsupported::disassemble("proc", "foo"));

    /* Print a variable in another namespace. */
    puts(::mynamespace::myvar);

=head2 Calling Tk

To help call Tk widgets, L has a C<widget> type that is used with the
pattern function calls described above.  A widget value behaves like
a string except in a pattern function call where it is the name
of the widget to call:

    widget w = Text_new();
    Text_insert(w, "end", "hi!");   // like tcl's $w insert end hi!

Another feature is useful for calling Tk widgets that take the I<name>
of a variable whose value is updated when the user changes a widget
field.  You can use an L variable like this:

    string msg;
    ttk::label(".foo", textvariable: &msg);

The ampersand (&) in front of C<msg> alludes to a C pointer but this
is actually a type of bridge between the L variable C<msg> and an
anonymous global variable created by L and passed to the widget.  This
mechanism lets you pass class or class instance variables,
structure members, and array elements in addition to local or global
variables.

L uses this special bridge whenever the option name ends in
"variable", as "textvariable" does in the example above (yes,
this is a hack).

=head1 OPERATORS

=over 4

=item Arithmetic

    +   addition
    -   subtraction
    *   multiplication
    /   division
    %   remainder

=item Numeric comparison

    ==  equality
    !=  inequality
    <   less than
    >   greater than
    <=  less than or equal
    >=  greater than or equal

=item String comparison

    eq  equality
    ne  inequality
    lt  less than
    gt  greater than
    le  less than or equal
    ge  greater than or equal
    =~  regexp match or substitute

=item Bit operations

    &   bit and
    |   bit or
    ^   bit exclusive or
    ~   bit complement
    <<  left shift
    >>  right shift

=item Boolean logic

    &&  and
    ||  or
    !   not

=item Conditional

    ?:  ternary conditional (as in C)

=item Indexing

    []  array index
    {}  hash index
    .   struct index (no whitespace around the dot)
    ->  struct index (call-by-reference parameters dereference)
    ->  class and instance variable access (object dereference)

=item Miscellaneous

    =   assignment
    ,   statement sequence
    .   string concatenation (must have whitespace around the dot)
    ``  command expansion

=item Assignment

    +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, .=

=item Operator precedence (highest to lowest) and associativity

    `` (non assoc)
    [] {} . (struct index) -> ++ -- (left)
    unary + unary - ! ~ & (right)
    * / % (left)
    + - . (string concatenation) (left)
    << >> (left)
    < <= > >= lt le gt ge (left)
    == != eq ne =~ (left)
    & (left)
    ^ (left)
    | (left)
    && (left)
    || (left)
    ?: (right)
    = += -= *= /= %= &= |= ^= <<= >>= .= (right)
    , (left)

=back

=head1 PRE-DEFINED IDENTIFIERS

=over 4

=item __FILE__

A string containing the name of the current source file, or "<stdin>"
if the script is read from stdin instead of from a file.
Read only.

=item __LINE__

An int containing the current line number within the script.
Read only.

=item END

An int containing the index of the last character of a non-empty
string or the last element of a non-empty array.  If the array or
string is empty, END is -1.  Valid only inside of a string or array
subscript.  Read only.

=item undef

A poly containing the undef value and defined(undef) is true.  The
undef value can be assigned to variables to make them not defined.
The value of undef is the empty string ("").  Read only.

=back

=head1 RESERVED WORDS

The following identifiers are reserved.  They cannot be used for
variable, function, or type names:

    break
    class
    constructor
    continue
    destructor
    do
    else
    eq
    expand
    extern
    float
    for
    foreach
    ge
    goto
    gt
    if
    instance
    int
    le
    lt
    ne
    poly
    private
    public
    return
    split
    string
    struct
    typedef
    unless
    void
    while

=head1 BUILT-IN AND LIBRARY FUNCTIONS

L has several built-in functions and a set of library functions
modeled after the standard C library and/or Perl.

=over 4

=item `command`

Execute the command (the string enclosed within back-ticks) and
substitute its output as the value of the expression.  The command is
executed using the Tcl C<exec> command which understands I/O
re-direction and pipes.

=proto int abs(int val)

Return the absolute value of the argument.

=proto void assert(int condition)

Print an error and exit with status 1 if C<condition> is false.
The filename, line number, and text of the condition are printed.

=proto string basename(string path)

Return the file portion of a path name.

=proto string caller(int frame)

Return the name of a calling function, or the caller's caller, etc.
To get the caller, use a frame of 0, to get the caller's caller, use
1, etc.

=proto int chdir(string dir)

Change directory to dir.
Return 0 on success, -1 on error.

=proto int chmod(string path, string permissions)

Change the mode of the file or directory named by path.  Permissions
can be the octal code that chmod(1) uses, or symbolic attributes that
chmod(1) uses of the form [ugo]?[[+-=][rwxst],[...]], where multiple
symbolic attributes can be separated by commas (example: u+s,go-rw add
sticky bit for user, remove read and write permissions for group and
other).  A simplified ls-style string, of the form rwxrwxrwx (must be 9
characters), is also supported (example: rwxr-xr-t is equivalent to
01755).
Return 0 on success, -1 on error.

=proto int chown(string owner, string group, string path)

Change the file ownership of the file or directory names by path.  If
either owner or group is an empty string, the attribute will not be
modified.
Return 0 on success, -1 on error.

=proto void die(string message)

Output the message to stderr and exit 1. If message does not have a
trailing newline, append " in <filename> at line <linenum>\n".

=proto string dirname(string path)

Return the directory portion of a pathname.

=proto int exists(string path)

Return 1 if the given path exists or 0 if it does not exist.

=proto int fclose(FILE f)

Close an open FILE handle.
Return 0 on success, -1 on error.

=proto string fgetline(FILE f)

Get the next line from a FILE handle and return it, or return undef
for EOF/errors.

=proto FILE fopen(string path, string mode)

Open a file.  The C<mode> string indicates how the file will be accessed.

=over 4

=item "r"

Open the file for reading only; the file must already exist. This is
the default value if access is not specified.

=item "r+"

Open the file for both reading and writing; the file must already exist.

=item "w"

Open the file for writing only. Truncate it if it exists. If it
doesn't exist, create a new file.

=item "w+"

Open the file for reading and writing. Truncate it if it exists. If it
doesn't exist, create a new file.

=item "a"

Open the file for writing only. The file must already exist, and the
file is positioned so that new data is appended to the file.

=item "a+"

Open the file for reading and writing. If the file doesn't exist,
create a new empty file. Set the initial access position to the end of
the file.

=item "v"

This mode can be added to any of the above and causes open errors to
be written to stderr.

=back

Return a FILE handle on success and undef on error.

=proto int fprintf(FILE f, string fmt, ...args)

Format and print a string to the given FILE handle.  The FILE handles
C<stdin>, C<stdout>, and C<stderr> are pre-defined.

Return 0 on success, -1 on error.

=proto string freadn(FILE f, int numBytes)

Read at most numBytes from the given FILE handle, or read the entire
file if numBytes == -1.
Return undef on error.

=proto string ftype(string path)

Return the type of file at the given path. Type can be C<directory>, C<file>,
C<character>, C<block>, C<fifo>, C<symlink> or C<socket>.
Return undef on error.

=proto string[] getdir(string dir, string pattern)

Return the files in the given directory, as a string array.  Filter
the list by C<pattern> which is a glob and may contain the following
special characters:

=over 4 

=item ?

Matches any single character.

=item *

Matches any sequence of zero or more characters.

=item [chars]

Matches any single character in chars. If chars contains a sequence of
the form a-b then any character between a and b (inclusive) will
match.

=item \x

Matches the character x.
=item {a,b,...}

Matches any of the strings a, b, etc.

=back

If the first character in a pattern is ``~'' then it refers to the
home directory for the user whose name follows the ``~''. If the ``~''
is followed immediately by ``/'' then the value of the HOME
environment variable is used.

=proto string getenv(string varname)

Return the value of an environment variable if it exists, or return ""
if the it does not exist.

=proto int isdir(string path)

Return 1 if the given path exists and is a directory, else return 0.

=proto int isdouble(poly n)

Return 1 if n is a double or can be converted to one, else return 0.
For example, both isdouble(3.14159) and isdouble("3.14159") return 1.

=proto int isinteger(poly n)

Return 1 if n is an integer or can be converted to one, else return 0.
For example, both isdouble(13) and isdouble("13") return 1.

=proto int islink(string path)

Return 1 if the given path exists and is a link, else return 0.

=proto int isreg(string path)

Return 1 if the given path exists and is a regular file, else return 0.

=proto int isspace(string buf)

Return 1 if all characters in the argument are space characters.

=proto string join(string sep, type array[])

Convert an array into a string by joining all of its elements by
inserting sep between each pair.

=proto keyType[] keys(valType hash{keyType})

Return an array containing the keys of a given hash.  Note that the
return type depends on the argument type.

=proto int length(type array[])

Return the number of elements the given array.

=proto int length(valType hash{keyType})

Return the number of key/value pairs the given hash.

=proto int link(string sourcePath, string targetPath)

Create a hard link from sourcePath to targetPath.
Return 0 on success, -1 on error.

=proto int lstat(string path, struct stat &buf)

Call lstat(2) on C<path> and place the information in C<buf>.
Return 0 on success, -1 on error.
The C<struct stat> type is defined as follows:

=over 4

    struct stat {
	int	st_dev;
	int	st_ino;
	int	st_mode;
	int	st_nlink;
	int	st_uid;
	int	st_gid;
	int	st_size;
	int	st_atime;
	int	st_mtime;
	int	st_ctime;
	string	st_type;
    };

=back

=proto int mkdir(string path)

Create a directory at the given path.  This creates all non-existing
parent directories.  The directories are created with mode 0775
(rwxrwxr-x).
Return 0 on success, -1 on error.

=proto int mtime(string path)

Return the modified time of path, or 0 to indicate error.

=proto string normalize(string path)

Return a normalized version of path. The pathname will be an absolute
path with all "../" and "./" removed.

=proto int pclose(FILE f)

Close an open pipe created by popen().
Return 0 on success, -1 on error.

=proto FILE popen(string cmd, string mode)

Open a pipe to the command C<cmd>.  The returned FILE handle may be
used to write to the command's input pipe or read from its output
pipe, depending on the value of C<mode>.  If write-only access is used
("w"), then standard output for the pipeline is directed to the
current standard output unless overridden by the command.  If
read-only access is used ("r"), standard input for the pipeline is
taken from the current standard input unless overridden by the
command.  Return the FILE handle on success, or undef on error.

=proto void printf(string fmt, ...args)

Format arguments and print to stdout, as in printf(3).
Return 0 on success, -1 on error.

=proto void push(type &array[], type element)

Push one or more elements onto the end of C<array>.  Equivalent to
saying array[length(array)] = element.

=proto type pop(type &array[])

Remove an element from the end of C<array>.
Return undef if the array is empty.

=proto int rename(string oldpath, string newpath)

Rename a file.
Return 0 on success, -1 on error.

=proto string require(string packageName)

Find and load the given package packageName.  Return the version
string of the package loaded on success, and undef on error.

=proto int rmdir(string dir)

Delete the given directory.
Return 0 on success, -1 on error.

=proto string setenv(string varname, string val)

Set an environment variable, overwriting any pre-existing value.
Return the new value.

=proto int size(string path)

Return the size, in bytes, of the named file path, or -1 on error.

=proto void sleep(int seconds)

Sleep for C<seconds> seconds.

=proto type[] sort(type[] array)

=proto type[] sort([decreasing: | increasing:], type[] array)

=proto type[] sort([integer: | real: | ascii:], type[] array)

=proto type[] sort(command: compar, type[] array)

Sort the array C<array> and return a new array of sorted elements.
The first variation sorts the elements into ascending order, and does
an integer, real, or ascii sort based on the type of C<array>.  The
second two variations show optional arguments that can be passed to
change this behavior.  The last variation shows how a custom compare
function can be specified.  The function must take two array elements
of type T as arguments and return -1 if the first comes before the
second in the sort order, +1 if the first comes after the second, and
0 if the two are equal.

=proto string sprintf(string fmt, ...args)

Format arguments and return a formatted string like sprintf(3).
Return undef on error.

=proto int stat(string path, struct stat &buf)

Call stat(2) on C<path> and place the information in C<buf>.
Return 0 on success, -1 on error.
See the lstat() command for the definition of C<struct stat>.

=proto string stdio_getLastError(void)

Return the last error from an fclose(), fopen(), popen(), or system() call.

=proto int strchr(string s, string c)

Return the first index of c into s, or -1 if c is not found.

=proto int streq(string a, string b)

Return 1 if the two strings are equal, else return 0.

=proto string[] split(string s)

=proto string[] split(string s, /regexp/)

=proto string[] split(string s, /regexp/, int limit)

=proto string[] split(string s, string sep)

=proto string[] split(string s, sep, int limit)

Split a string into substrings.
In the first variation, the string is split on whitespace.
In the second and third variations, the string is split on the given regular
expression, with at most C<limit> fields being split off (a limit less than
0 means no limit).
The last two variations split, where no regexp or separator is specified, split
on white space but any leading white space does not produce a null first field.

=proto int strlen(string s)

Return the string length.

=proto int strneq(string a, string b, int n)

Return 1 if the two strings are equal up to n characters, else return
0.

=proto int strrchr(string s, string c)

Return the last index of c into s, or -1 if c is not found.

=proto int symlink(string sourcePath, string targetPath)

Create a symbolic link from sourcePath to targetPath.
Return 0 on success, -1 on failure.

=proto string system(string cmd)

Execute the given command.  This is the same as the `` operator (see above)
but in a function-call form.

=proto string tolower(string s)

Return a copy of the string that is in all lower case.

=proto string toupper(string s)

Return a copy of the string that is in all upper case.

=proto string trim(string s)

Return a copy of the string that has been trimmed of any leading and
trailing whitespace.

=proto void undef(<array>[index])

=proto void undef(<string>[index])

=proto void undef(<hash>{index})

Remove an array, string, or hash element from the specified variable.

=proto int unlink(string path)

Delete the named file.
Return 0 on success, -1 on failure.

=proto void unsetenv(string varname)

Unset an environment variable.
Return 0 on success, -1 on failure.

=proto void warn(string message)

Output the message to stderr.  If message does not have a trailing
newline, append " in <filename> at line <linenum>\n".

=back

=head1 MANIPULATING COMPLEX STRUCTURES

L has built-in operators for turning complex data structures into
something else: (expand), (expand all), and (tcl).

(expand) takes an array of things and pushes them all onto the
run-time stack to call a function that expects such a list.
It is identical to tcl's {*}:

    void foo(string a, string b, string c);

    string v[] = { "one", "two", "three" };

    foo((expand)v);	// passes three string arguments to foo

It expands only one level, so if the array contains three hashes
instead of three strings, (expand)v passes three hashes to foo.
(expand) works with structs too.

Use (expand all) when you want to recursively expand a nested data
structure to a list of its elemental scalars.  If you have this
structure:

    struct {
        int   i[];
        int   h{string};
    } foo = {
        { 0, 1, 2, 3, },
        { "big" => 100, "medium" => 50, "small" => 10 }
    };

And you use (expand) to expand only one level:

    func((expand)foo);

You need a function definition like this:

    void func(int nums[], int sizes{string})
    {
    }

But if you use (expand all):

    func((expand all)foo);

You need this:

    void func(
        int      i,
        int      j,
        int      k,
        int      l,
        string   k1,
        int      v1,
        string   k2,
        int      v2,
        string   k3,
        int      v3)
    {
    }

(tcl) is used to pass a single string to a tcl proc for processing.
It puts in the tcl quotes.  So

    (tcl)foo

is

    0 1 2 3 { big 100 medium 50 small 10 }

Another example:

    string v[] = { "a b c", "d", "e" };

    string arg = (tcl)v;     // arg is "{a b c} d e"

=head1 REGULAR EXPRESSIONS

L's regular expression support is based on the PCRE (Perl Compatible
Regular Expressions) library L<http://www.pcre.org>.  The basics are
documented here but for more extensive documentation please see
L<http://www.pcre.org/pcre.txt>.

=over 4

=item Simple matching

    if (s =~ /foo/) { ... }  # true if s contains "foo"

The C<//> matching operator must be used in conjunction with C<=~> to
tell L what variable to look at.

=item Simple substitution

    x =~ s/foo/bar/;         # replaces foo with bar in x
    x =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in x
    x =~ s/foo/bar/i;        # does a case-insensitive search

=item More complex regular expressions

    .                   a single character
    \s                  a whitespace character (space, tab, newline, ...)
    \S                  non-whitespace character
    \d                  a digit (0-9)
    \D                  a non-digit
    \w                  a word character (a-z, A-Z, 0-9, _)
    \W                  a non-word character
    [aeiou]             matches a single character in the given set
    [^aeiou]            matches a single character outside the given set
    (foo|bar|baz)       matches any of the alternatives specified

    ^                   start of string
    $                   end of string

Quantifiers can be used to specify how many of the previous thing you
want to match on, where "thing" means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.

    *                   zero or more of the previous thing
    +                   one or more of the previous thing
    ?                   zero or one of the previous thing
    {3}                 matches exactly 3 of the previous thing
    {3,6}               matches between 3 and 6 of the previous thing
    {3,}                matches 3 or more of the previous thing

Some brief examples:

    /^\d+/              string starts with one or more digits
    /^$/                nothing in the string (start and end are adjacent)
    /(\d\s){3}/         a three digits, each followed by a whitespace
                        character (eg "3 4 5 ")
    /(a.)+/             matches a string in which every odd-numbered letter
                        is a (eg "abacadaf")

    // This loop reads from stdin, and prints non-blank lines.
    string buf;
    while (defined(buf = fgetline(stdin)) {
        unless (buf =~ /^$/) puts(buf);
    }

=item Parentheses for capturing

As well as grouping, parentheses serve a second purpose.  They can be
used to capture the results of parts of the regexp match for later use.
The results end up in C<$1>, C<$2> and so on (but note that if you want
to interpolate those in a string the syntax is a little convoluted: 
C<"matched ${$1} and ${$2}">).  

    // A cheap and nasty way to break an e-mail address into parts.
    if (email =~ /([^@]+)@(.+)/) {
        printf("Username is %s\n", $1);
        printf("Hostname is %s\n", $2);
    }

Capturing has a limitation.  If you have more than one regexp with
captures in an expression, the last one evaluated sets C<$1>, C<$2>,
etc.

    // This loses email1's captures.
    if ((email1 =~ /([^@]+)@(.+)/) && (email2 =~ /([^@]+)@(.+)/)) {
        printf("Username is %s\n", $1);
        printf("Hostname is %s\n", $2);
    }

In situations like this, care must be taken because the evaluation
order of sub-expressions generally is undefined.  But this example is
an exception because the && operator always evaluates its operands in
order.

=back

=head1 CLASSES

L has a C<class> abstraction for encapsulating data and
functions that operate on that data.  L classes are simpler than
full-blown object-oriented programming (there is no inheritance), but
they get you most of the way there.

You declare a class like this:

    class myclass
    {
        ....
    }

The name C<myclass> becomes a global type name, allowing you to
declare an C<object> of C<myclass>:

    myclass obj;

You can declare both variables and functions inside the class.  These
all must be declared inside one class declaration at the global scope.
You cannot have one class declaration that has some of the
declarations and another with the rest, and you cannot nest classes
inside of functions or other classes.

Inside the class, you can have C<class variables> and
C<instance variables>.  Class variables are associated with the class
and not the individual objects that you allocate, so there is only one
copy of each.  Instance variables get attached to each object.

    class myclass
    {
        /* Class variables. */
        public string pub_var;
        private int num = 0;

        /* Instance variables. */
        instance {
            public string inst_var;
            private int n;
        }
        ...
    }

All declarations (except the constructor and destructor) must be
qualified with either C<public> or C<private> to say whether the name
is visible at the global scope or only inside the class.

A class can have a constructor and a destructor but they are optional.
Inside the constructor, the variable C<self> is automatically declared
as the object being constructed.  The constructor should return
C<self>.  The destructor must be declared with C<self> as the first
parameter.

    constructor myclass_new()
    {
        n = num++;
        return (self);
    }
    destructor myclass_delete(myclass self) {}

If omitted, L creates a default constructor or destructor named
C<classname_new> and C<classname_delete>.  Although not shown in this
example, you can declare them with any number of parameters, just like
regular functions.

A C<public> class member function is visible at the global scope, so
its name must not clash with any other global function or variable.  A
private member function is local to the class.

The first parameter to each public function must be C<self>, the
object being operated on.  Private functions do not explicitly include
C<self> in the parameter list because it is implicitly passed by the
compiler.

    private void bump_num()
    {
        ++n;
    }
    public int myclass_getnum(myclass self)
    {
        bump_num();
        return (n);
    }

To create an object, you must call the constructor, because just
declaring the variable does not allocate anything:

    myclass obj;

    obj = myclass_new();

To operate on an object, you call one of its public member functions,
passing the object as the first argument:

    int n = myclass_getnum(obj);

L allows you to directly access public class and instance variables
from outside the class.  To get a class variable, you dereference the
class name (you must use ->):

    string s = myclass->pub_var;

To get a public instance variable, you dereference the object whose
data you want to access:

    string s = obj->inst_var;

Once you free an object

    myclass_delete(obj);

you must be careful to not use C<obj> again unless you assign a
new object to it, or else a run-time error will result.

=head1 EXAMPLE CODE

=head2 pod2html.l

This is an L implementation of pod2html.  Pretty stripped down but slightly
prettier than the Perl pod2html.

	#!../../unix/tclsh

	int
	main(int ac, string av[])
	{
		FILE	f;
		int	i, ul;
		int	space = 0, dd = 0, p = 0, pre = 0, table = 0;
		string	head, buf, tmp, title, trim, all[];

		// lint
		if (0) ac++;

		/*
		 * -t&lt;title&gt; or --title=&lt;title&gt;
		 */
		for (i = 1; defined(av[i]) && (av[i] =~ /^-/); i++) {
			if (av[i] eq "--") {
				i++;
				break;
			}
			if ((av[i] =~ /--title=(.*)/) || (av[i] =~ /-t(.*)/)) {
				title = $1;
			} else {
				die("usage: ${av[0]} [--title=whatever]");
			}
		}
		if (!defined(av[i]) ||
		    defined(av[i+1]) || !defined(f = fopen(av[i], "r"))) {
			die("usage: ${av[0]} filename");
		}
		unless (defined(title)) title = av[i];

		header(title);
		
		/*
		 * Load up the whole file in all[] and spit out the index.
		 */
		puts("&lt;ul&gt;");
		ul = 1;
		while (defined(buf = fgetline(f))) {
			push(&all, buf);
			if (buf =~ /^=head(\d+)\s+(.*)/) {
				i = (int)$1;
				while (ul &gt; i) {
					puts("&lt;/ul&gt;");
					ul--;
				}
				while (i &gt; ul) {
					puts("&lt;ul&gt;");
					ul++;
				}
				tmp = $2;
				tmp =~ s/\s+/_/g;
				buf =~ s/^=head(\d+)\s+//;
				puts("&lt;li&gt;&lt;a href=\"#${tmp}\"&gt;${buf}&lt;/a&gt;&lt;/li&gt;");
			}
		}
		while (ul--) puts("&lt;/ul&gt;");
		fclose(f);

		/*
		 * Now walk all[] and process the markup.  We currently handle:
		 * =head%d title
		 * =over 
		 * =item name
		 * =proto return_type func(args)
		 * =back
		 * &lt;blank line&gt;
		 * B&lt;bold this&gt;
		 * C&lt;some code&gt;
		 * I&lt;italics&gt;
		 */
		for (i = 0; i &lt;= length(all); i++) {
			buf = inline(all[i]);
			if (buf =~ /^=head(\d+)\s+(.*)/) {
				if ((int)$1 == 1) puts("&lt;HR&gt;");
				tmp = $2;
				tmp =~ s/\s+/_/g;
				printf("&lt;H%d&gt;&lt;a name=\"%s\"&gt;%s&lt;/a&gt;&lt;/H%d&gt;\n",
				    $1, tmp, $2, $1);
			} else if (buf =~ /^=over/) {
				puts("&lt;dl&gt;");
			} else if (buf =~ /^=item\s+(.*)/) {
				if (dd) {
					puts("&lt;/dd&gt;");
					dd--;
				}
				puts("&lt;dt&gt;&lt;strong&gt;${$1}&lt;/strong&gt;&lt;/dt&gt;&lt;dd&gt;");
				dd++;
			} else if (buf =~ /^=proto\s+([^ \t]+)\s+(.*)/) {
				if (dd) {
					puts("&lt;/dd&gt;");
					dd--;
				}
				puts("&lt;dt&gt;&lt;b&gt;${$1}&lt;br&gt;${$2}&lt;/b&gt;&lt;/dt&gt;&lt;dd&gt;");
				dd++;
			} else if (buf =~ /=table/) {
				
			} else if (buf =~ /^=back/) {
				if (dd) {
					puts("&lt;/dd&gt;");
					dd--;
				}
				puts("&lt;/dl&gt;");
			} else if (buf =~ /^\s*$/) {
				if (p) {
					puts("&lt;/p&gt;");
					p = 0;
				}
				if (pre) {
					/*
					 * If we see a blank line in a preformatted
					 * block, we don't want to stop the pre
					 * unless the next line is not indented.
					 * So peek ahead.
					 */
					if (defined(buf = all[i+1]) && (buf =~ /^\s/)) {
						puts("");
						continue;
					}
					puts("&lt;/pre&gt;");
					pre = 0;
					trim = undef;
				}
				space = 1;
			} else {
				if (space) {
					if (buf =~ /^(\s+)[^ \t]+/) {
						trim = $1;
						puts("&lt;pre&gt;");
						pre = 1;
					} else {
						puts("&lt;p&gt;");
						p = 1;
					}
					space = 0;
				}
				if (defined(trim)) buf =~ s/^${trim}//;
				puts(buf);
			}
		}
		puts("&lt;/body&gt;&lt;/html&gt;");
		return (0);
	}

	/*
	 * header and style sheet
	 */
	void
	header(string title)
	{
		string	head = &lt;&lt;EOF
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;${title}&lt;/title&gt;
	&lt;style&gt;
	pre {
		background: #eeeedd;
		border-width: 1px;
		border-style: solid solid solid solid;
		border-color: #ccc;
		padding: 5px 5px 5px 5px;
		font-family: monospace;
		font-weight: bolder;
	}
	body {
		padding-left: 10px;
	}
	dt {
		font-size: large;
	}
	&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
	EOF
		puts(head);
		puts("&lt;h1&gt;${title}&lt;/h1&gt;");
	}

	/*
	 * Process B&lt;bold&gt;, C&lt;code&gt;, I&lt;italic&gt;, F&lt;italic&gt;, L&lt;link&gt;, S&lt;non-breaking&gt;.
	 * This will handle nested stuff like C&lt;if (!I&lt;condition&gt;)&gt;
	 * but dies if there are nested ones of the same type, i.e.,
	 * C&lt;whatever C&lt;some more&gt;&gt;
	 */
	string
	inline(string buf)
	{
		string	c, prev, result, link, stack[];
		int	B = 0, C = 0, I = 0, L = 0, S = 0;

		unless (buf =~ /[BCFILS]&lt;.+&gt;/) {
			return (buf);
		}
		foreach (c in buf) {
			if ((c eq "&lt;") && defined(prev)) {
				if (prev eq "B") {
					if (B++) die("Nested B&lt;&gt; unsupported: ${buf}");
					result[END] = "";
					result .= "&lt;B&gt;";
					push(&stack, "B");
				} else if (prev eq "C") {
					if (C++) die("Nested C&lt;&gt; unsupported: ${buf}");
					result[END] = "";
					result .= "&lt;CODE&gt;";
					push(&stack, "CODE");
				} else if (prev eq "I" || prev eq "F") {
					if (I++) die("Nested I&lt;&gt; unsupported: ${buf}");
					result[END] = "";
					result .= "&lt;I&gt;";
					push(&stack, "I");
				} else if (prev eq "L") {
					if (L++) die("Nested L&lt;&gt; unsupported: ${buf}");
					result[END] = "";
					result .= "&lt;a href=\"";
					link = "";
					push(&stack, "L");
				} else if (prev eq "S") {
					if (S++) die("Nested S&lt;&gt; unsupported: ${buf}");
					result[END] = "";
					push(&stack, "S");
				} else {
					result .= c;
					prev = c;
				}
			} else if ((c eq "&gt;") && length(stack)) {
				c = pop(&stack);
				if (c eq "B") {
					B--;
				} else if (c eq "CODE") {
					C--;
				} else if (c eq "I") {
					I--;
				} else if (c eq "L") {
					L--;
					result .= "\"&gt;${link}&lt;/a&gt;";
					c = undef;
				} else {
					S--;
					c = undef;
				}
				if (defined(c)) {
					result .= "&lt;/" . c . "&gt;";
				}
				prev = undef;
			} else {
				if (S && isspace(c)) {
					result .= "&nbsp;";
				} else {
					result .= c;
				}
				if (L) link .= c;
				prev = c;
			}
		}
		return (result);
	}
